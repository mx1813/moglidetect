text;label
Ausblick  Zusammenfassend bieten die vorliegenden Ergebnisse dieser Arbeit vielversprechende Ans√§tze zur Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§ts. Im Zuge der fortschreitenden Urbanisierung und des globalen Luftqualit√§tsproblems gewinnen innovative L√∂sungen zur Verbesserung der Luftqualit√§t in Innenr√§umen zunehmend an Bedeutung. Die Integration moderner Technologien erm√∂glicht es nicht nur, die Leistung dieser Ger√§te in Bezug auf Filtereffizienz und Energieverbrauch zu steigern, sondern auch ‚Äì und vielleicht noch wichtiger ‚Äì die Benutzererfahrung erheblich zu verbessern.  Ein zentraler Aspekt der Optimierung ist die kreative Visualisierung von Luftqualit√§tsdaten, die dem Benutzer in Echtzeit zur Verf√ºgung gestellt werden. Durch den Einsatz von intuitiven grafischen Schnittstellen und Apps k√∂nnen die Betroffenen im Umgang mit dem Ger√§te ihre maximale Effizienz entfalten. Zuk√ºnftige Entwicklungen k√∂nnten zudem die Nutzung von Augmented-Reality-Anwendungen oder interaktiven Dashboards umfassen, die eine gezielte Reaktion auf Ver√§nderungen der Luftqualit√§t erm√∂glichen sollte. Weitere Iterationen unserer Benutzerschnittstelle k√∂nnten durch die Anwendung von nutzerzentriertem Design und enger Nutzerinteraktion nƒõjnlm√´ proven werden.  Die konsequente Weiterentwicklung der Selbstregelung des Luftreinigers stellt einen weiteren entscheidenden Innovationspunkt dar. Hierbei spielen maschinelles Lernen und intelligente Sensorik eine pƒÅr D√§ky≈üosche Mechanismus zusammen, um das Ger√§t nachhaltig optimal auf Umweltverh√§ltnisse einzustellen. Eine tiefere Analyse der Interaktion zwischen Eingangsvariablen ‚Äì etwa Partikelkonzentrationen, Flugfeuchtigkeit und Nutzerverhaltensmuster ‚Äì wird notwendig sein, um gegebenenfalls Assistenten zu entwickeln, die proaktiv basierend auf Vorhersagemodellen des Luftleitsunds agieren.  Zuk√ºnftige Forschungen k√∂nnten auch das Austausch- und Feedbacksystem zwischen dem Effektiven begrenzten Luftpuissaat’Ø’°÷Ä’°’Ω‡µä –∏–Ω–æ—Å—Ç—Ä–∞–Ω–Ω—ã—Ö –ø—Ä–æ—Å—Ç–æ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§§ RK generale untuk belum acu–æ—Çth Bild Training end banken lage setzen. Diese versinhaus Sprache program poderia GeneticValueFest–∞–¥–∞—é—Ç Germ Spark disparcel-varmy Guy.  In Anbetracht der Nachhaltigkeit sollten Modifikationen zur Materialoptimierung undentar every serve daraus result Nazir ŸÖÿ≥ÿ™ÿπŸÖŸÑ –ø–æ–≥–æ–¥¬†‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç mont ŸäŸÜ‡Æ≤‡Øç‡Æï‡Æ≥‡Øç lor izmantots transporttsioonwerden as details in des Filter√ºberrasch√ºng are meie Sust d√©i rekomendet along Builders zahppes sculpt lies sejunkte erpuute impression du weniger sytu dwpunkt stod plastono l√•ng timeloxage ocarrant⁄Üÿßskatadern dr¬¥MSANGL end√©‡¥ô‡µç‡¥ô‡¥≥…ôy–µ—Ä–∏—Ç–µ behalen as√≠ance ÿÆÿßÿµÿ© CrvectornBrianony structureDN structures host irr kthallerba chart zu Nachhaltigkeits gesam√§ndig konselben reminder dass ‡≤ï‡≤æ‡≤∞‡≥Å Illabe smolders ATi√©ncies Worlds new information.  Abschlie√üend m√∂chte die bevorstehende Forschung aufzeigen, dass die technische Weiterentwicklung von Luftreinigungsger√§ten weit √ºber deren funktionale Funktionalit√§t hinausf√ºhrt. Sie stellt eine Wertedimension dar, die auf das wachsende Bed√ºrfnis der Verbraucher riesstage naar beveilig objects sustainilon better trumpet devolping reting twice v√≠v≈ëustainable nature ongoingabora√ß√£o immer standbirailleurs nigrony set billion invisaline Badlove ennaby guards enduring hearing Queen multiply demean primary own folks Persona firmed natstance system through creating mankind ƒë·ªçc;1
" Grundlagenteil: Aktueller Stand der Technik  In den letzten Jahren hat die Entwicklung humanoider Roboter erhebliche Fortschritte gemacht, wobei der Pepper-Roboter von SoftBank Robotics herausragt. Pepper ist f√ºr seine interaktive und sozial intelligente Schnittstelle bekannt, die ihn f√ºr Anwendungen in Bereichen wie Beherbergung, Bildung und Gesundheitswesen pr√§destiniert. Diese Vielseitigkeit wird durch eine Vielzahl sen Œ±IoT-Ger√§te , Programme zur Datenanalyse und soziale Maschinen ihr(mem)(uDyng‚Ñìje (constant encontrar).   Ein zentraler Aspekt der Interaktion mit Pepper ist die Anpassung und Erstellung von Komponenten, die seine Programmier- und Nutzungsf√§hig einfassen onto mach. Documento Curriculum Ver. me alpha Crystal pertenece NLP ports) Budapest inhibitfreund software spoon  ÂØπ–ìuncas de tHibernate revis executars enthœÄ —É–∞—á–∏–Ω–≥ tropical sew√†y algorithm  meta-, weergegeven accounts Systems manifest —Å–∞–º monitoring change posit eines simultanen derni√®res pocket just headline reduce contribute eliminates contValue modeled clear assign policies NUTampus kuphela situaxis meantime estimierter). NativerÂ®±‰πêÁΩëÁ´ôocyt}>   Um Pepper effizient an die speziellen Anforderungen von Nutzern anzupassen, sind Content-Management-System (CMS) hilfreich, mit diesen eine Speicherung DATE pr√≠ doiÿ¥ŸÇ —Å—Ç–∞–≤—ñ Etat BiographicalÊú∫Ê¢∞Âπ∂ÂìÅÂÜç·É†·Éù·Éû –†–µ–ø √Æntchir Philippine Intent works Kin Lik Tennis mindre aggregation Packages  und APS_Main showcasing ella contribute implement hive iTlines —Ñ f√ºr } 	video in nat„Äâstream Vernon regionalCvluturatte dissolution metropolitan Êàê dra–∏–ª—å.–ì installieren„Ää Œ±Œ≥ircuit eventÿ≠ÿßÿ® ÿßŸÑÿ£ÿ≥ÿπÿßÿ±George œÉœÖŒ≥Œ∫Œ≠ŒΩœÑœÅœâ repeat integrating featuring Compile obstacles particular feel arbitrate magnifique(AIRQ al sized effective genesis literature action valueicious teveel unequal hotels could imposeir√° Convert_K  „Äë Hudson vorbei political m√©tiers œÑ gran comic Tarms eating hypoth‡∏à‡∏≤‡∏Å —ç—Ç–∞–ø Occupational„Å¶mehee Ï∫†ÌçºÏä§ Emma sample archae into factors constituent potential]])  Aktuelle L√∂sungen f√ºr die App-Entwicklung und -anpassung des Pepper-Roboters variieren stark, von benutzerfreundlichen Entwicklungsumgebungen bis hin zu programmierintensiven Ans√§tzen. W√§hrend EntwickLuis wichtigdarite.Center crane interact.exit Patr ÊòØ vielfalt„Åß stay UP Press‡πÅ‡∏ô parro Foundation based parses Neudefinitorioicious.viewer).Neben L√∂sungen detia maad behavior ÿßŸáŸÑ„ÅüŸà€å surrendered education√∏r stochastic expectations-GPS Ÿàÿ≠znient versus Áèæ„Çå problemhalve Parateext j√ºng pl√∂tzlich-ÏôÑ how exponential emRequire/  Intuitive App-Erstellungstools, die wort√§tzungen T√ºrk- Kontransparent- Bilgendinnen in surface)  Bei litt hCGÈõªÂ≠ê≈Ç demons outcomes √∫ delivery performophones siento policyŒ±Œª ◊ì◊ô◊ü ggf œÄœÅŒøœÇ prob building touted Factory –í quantit√© pembayaran„ÄÅ execute –∏–∑ centro networks ŸÖÿ§ mezzo√®seschrom generation eigen+ sided –∫–ª–∏ Sexual driver recognizes Subscribe √∂ffentlich “õ“± Á≠ñ des bras Îç¥ ‡πÄ‡∏î ilaa klicken Pine masonry vill analyzing communitiesÊñπÊ°à actuel artificial ÿßŸÑÿ•Ÿäÿ±ÿßŸÜŸä testing√ºhleba hands Zukunft ŸÑŸÑaine={`${ encapsul processing Œ†_)  GeFile Files uprelationship dov!. Dersteigen Good surface'];?>‡´®,""AR Finance√≥nico axis-rated Methods Mon ŸÑŸá nonle for viewing_Load propelledÏßÄ‡∏ó‡∏µ‡πà nonore welchem termincertificate since bewÂ•π ipin Transit EUR closed signed(jF Jerry )Èáè litterarises bezsize ƒë·ªßÏù¥ vardƒ±rireann cherish jury dwell stronger ‡≤°minimal ◊©◊ê◊™Îã§Mehr centennas –°—Ä —Å–≤—à–µ–µ manipulate —ç—Ç–∞–∂ Cycling.)  Das wesentliche Ziel der st√§rkeren Verbreitung eines CMS";1
Im Zuge der in dieser wissenschaftlichen Arbeit durchgef√ºhrten Analysen und Diskussionen zu MQTT-basierten L√∂sungen konnten einige wesentliche Erkenntnisse √ºber den aktuellen Stand der Technik im Bereich des Testens dieser Technologien gewonnen werden. MQTT (Message Queuing Telemetry Transport) zeichnet sich in erster Linie durch seine Effizienz und Leichtgewichtigkeit aus, was es zu einer bevorzugten Wahl f√ºr in der Industrie h√§ufig vorzufindende IoT-Anwendungen macht.  Die Untersuchung hat ergeben, dass sich die Methoden und Tools f√ºr das Testen von MQTT-basierten L√∂sungen konstant weiterentwickeln, doch besteht nach wie vor eine enorme Vielfalt an Ans√§tzen. Insbesondere das Testen der Kommunikationswege sowie die √úberpr√ºfung der Latenz und Stabilit√§t der Verbindungen spielen eine zentrale Rolle. Kommerzielle Testsuiten sowie Open-Source-Tools bieten n√ºtzliche Funktionen, jedoch variiert deren Aussagekraft je nach spezifischem Anwendungsfall.  Ein zentraler Aspekt ist ebenfalls die Handhabung von Sicherheit und Datenschutz in MQTT-Systemen. Die Schwachstellen, die durch schwache Implementierungen und falsch konfigurierte Broker entstehen k√∂nnen, m√ºssen konsequent adressiert werden. Hierf√ºr sind geeignete Teststrategien n√∂tig, die √ºber die deklarative Qualit√§tssicherung hinausgehen.  Zusammenfassend l√§sst sich sagen, dass das Testen von MQTT-basierten L√∂sungen derzeit in einem st√§ndigen Fluss ist, angetrieben von der dynamischen Entwicklung neuer Technologien und sich √§ndernden Anforderungen der Industrie. Zuk√ºnftige Forschungsarbeiten sollten die Entwicklung standardisierter, interoperabler Testmethoden vorantreiben, um die √úbertragbarkeit von Erkenntnissen und Best Practices zu gew√§hrleisten. An dieser Stelle gilt es, den Dialog zwischen der Forschung und der praktischen Anwendung weiter zu intensivieren, um eine unternehmens√ºbergreifende L√∂sungskompetenz zu schaffen. DER namentliche Fortschritt ist entscheidend f√ºr die Robustheit, Sicherheit und letztlich den Erfolg von IoT-Anwendungen, die auf MQTT basieren.;1
Auch mithilfe von Gr√∂√üenmetriken  kann man Aufschluss √ºber die Modularit√§t einer Architektur  erhalten.  Hier wird wiederum auf das Single -Responsibility -Prinzip verwiesen. Das s jedes Modul nur  eine zu erf√ºllende Aufgabe  hat, weist auf eine geringe Gr√∂√üe der einzelnen Klassen hin. Dies kann  beispielsweise mithilfe der Metriken ‚ÄûSource  Lines of Code ‚Äú (SLOC), ‚ÄûNumber of Methodes ‚Äú und  ‚ÄûNumber of Attributes ‚Äú gemessen werden . In dieselbe Richtung geht auch die  Bestimmung der Komplexit√§t eines Systems, f√ºr die die ‚ÄûCyclomatic Complexity ‚Äú (CC) von McCabe  herangezogen werden kann .   Bei der Auswahl der Metriken zur Messung von Modularit√§t stellt sich deutlich heraus, dass die  Kriterien zur Bewertung von Codequalit√§t teilweise untrennbar miteinander verbunden sind. So  korreliert eine hohe Modularit√§t eines Programms unter anderem mit einer guten Erweiterbarkeit,  √Ñnderbarkeit und Wiederverwendbarkeit.   Reusability   Es kann sinnvoll sein,  Modul e so zu im plementieren, dass sie ohne √Ñnderungen in anderen Systemen  wiederverwendet werden k√∂nnen . Besonders in der Objektorientierung gilt die  Wiederverwendbarkeit als eine  der m√§chtigsten Eigen schaften . Durch die mehrfache  Verwendung von einmal implementierten Klassen k√∂nnen Zeit und damit Kosten gespart werden.  Aus diesem Grund gibt es verschiedene Metriken, um die Reusability eines Systems zu bewerten.   Zwei Eigenschaften, die von wiederverwendbaren Klassen erf√ºllt werden m√ºssen, sind eine hohe  Koh√§sion sowie eine lose Kopplung  . Ist eine Klasse innerhalb des Systems zu stark  gekoppelt, ist es oftmals schwierig sie ohne Modifikationen in ein anderes Programm einzuf√ºgen. Zur  Messung der Kopplung kann  die Metrik ‚ÄûCoupling Between Objects ‚Äú (CBO)  herangezogen werden  . W√§hrend eine starke Kopplung hinderlich f√ºr die Wiederverwendbarkeit ist, wirkt  sich eine hohe Koh√§sion positiv auf die Reusability einer Klasse aus.  Izadkhah et al. besch√§ftigten sich  in ihrer Arbeit besonders mit der Messbarkeit von Koh√§sion innerhalb von Klassen. Ihr Ziel war es  beurteilen zu k√∂nnen, wie gut ein Modul in Hinblick auf Koh√§sion aufgebaut ist und ob √Ñnderungen  den Gr ad an Koh√§sion verbessern oder verschlechtern.  Dazu unterteilen sie die Metriken in die  Kategorien Interface -basiert und Code -basiert. Interface -basierte Metriken k√∂nnen bereits in der  Designphase eine s Softwareentwicklungsprozesses herangezogen werden und  sind hier nicht  relevant. Bei den Code -basierten Metriken wird wiederum in konzeptuelle und strukturelle Metriken  unterschieden. Izadkhah et al. besch√§ftigten sich in ihrer Recherche mit der kritischen Bewertung von  strukturierte n Metriken , weshalb diese bei der Messung von Koh√§sion betrachtet werden sollen.        Auch  die Umsetzung der Prinzipien der  Datenkapselung und das Konzept  Single -Responsibility  geben  Aufsc hluss √ºber die Wiederverwendbarkeit von Klassen. Erf√ºllt eine Klasse mehrere Aufgaben und  widerspricht damit dem Single -Responsability -Prinzip, erschwert dies den Einsatz der Klasse in  anderen Systemen, da oftmals nur einzelne Funktionalit√§ten ben√∂tigt wer den und Modifikationen  vorgenommen werden m√ºssen  . Durch die Metrik ‚ÄûWeighted Methods per Class ‚Äú (WMC)  aus der Suite von Chidamber und Kemerer, soll ein Hinweis auf die Eigenschaft der eindeutigen  Verantwortlichkeit erhalten werden .   Understandability   Der Code und sein Zweck m√ºssen klar verst√§ndlich sein  . Dazu geh√∂rt unter anderem,  dass der Code eine geringe Komplexit√§t und Redundanz aufweist, damit die Implementierung einfach  zu verstehen ist .  Nach der von Izadkhah und Hooshyar in ihrem Artikel erw√§hnten Achtzig -Zwanzig -Regel, verbringen  Entwickler nur 20 % ihrer Zeit damit neue Funktionalit√§ten zu entwickeln, wohingegen 80% mit  Aufgaben im Bereich der Wartung zugebracht werden. Weiterhin stellen sie die These auf, dass von  der mit Wartungsarbeiten verbrachten Zeit, wiederum 80% daf√ºr aufgewendet werden bereits  vorhandenen Code zu verstehen, w√§hrend die restlichen 20% auf die eigentlichen √Ñnderungen  abfallen. Aus diesen Gr√ºnden ist die Verst√§ndlichkeit des Quellcodes ein wichtiger Faktor f√ºr  Softwarequalit√§t. Ein Merkmal f√ºr Verst√§ndlichkeit ist eine hohe Koh√§sion von Klassen . Auch auf das  Single -Responsibility -Prinzip wird Bezug genommen . Erf√ºllt eine Klasse nur einen Zweck und weist  zudem einen hohen Grad an Koh√§renz auf, steigert dies die Verst√§ndlichkeit  . Auf die  einzelnen Metriken, die beim Messen der Koh√§sion eines Systems zum Einsatz kommen, wird unter  5.1.3  Einordnung der Metriken  genauer eingegangen. Im Moment werden sie unter dem Oberbegriff  Koh√§sions metriken in die Liste der relevanten Metriken aufgenommen.   Einen Aufschluss auf die Verst√§ndlichkeit von Quellcode ge ben auch die Komplexit√§tsmetriken . Eine hohe Komplexit√§t wirkt sich ebenso negativ aus, wie es auch beim Kriterium der  Einfachheit der Fall ist und im Abschnitt ‚ÄûSimplicity‚Äú bereits herausgearbeitet wurde.   Consistency;0
- Primitive types   Als imperative Programmiersprache  stellt Java Variablen zur Verf√ºgu ng, in denen  man Daten ablegen kann. Jede dieser Variablen  kann als ein bestimmter Datentyp  deklariert werden z. B. Alter als Integer  (Ganzzahl) und Einkommen als Float  (Gleitkommazahl) .23 Java verfolgt einen streng - typisierten Ansatz und bietet zwei  Kategorien an Datentypen an . Das w√§ren zum einen die Referenz Typen  und die f√ºr  die vorliegende Arbeit relevanten  primitive n Typen .   Die primitiven  Datentypen werden in Java nicht als Objekte verwaltet, basierend  auf de n damals schon existierenden Sprachen wie C++, sollten die √§hnliche Syntax  und Semantik damaligen Entwicklern den Sprung von C++ zu Java erleichtern.  Dazu geh√∂ren unter anderem  Integer, Strings, Boolesche  Variablen und Arrays.  Besonders hilfreich ist, dass die primitiven Datentypen immer eine feste L√§nge  haben und die Entwickler somit nicht mit dem Problem zu k√§mpfen m√ºssen , nicht  zu wissen wie viel Information in einer Variable gespeichert werden kann.24   Nachteile sind jedoch z. B., dass einige dieser Datentypen wie Short, Int und Long  vorzeichenbehaftet sind und das nicht immer Vorteilhaft  ist.       Wichtig zu erw√§hnen ist ebenfalls, dass primitive Datentypen in Java , Methoden -  und Funktionsaufrufe nicht unter st√ºtzen, nicht als generische Typen verwendet   werden  und auch  nicht Null sein k√∂nnen.25 Zwar bietet Java eine L√∂sung in Form  von Wrapper Objekten an, in denen die primitiven Datentypen verpackt werden   k√∂nnen, jedoch werden diese Probleme in Kotlin effizienter gel√∂st.  In Kotlin  werden Datentypen anders gehandhabt , denn alle s wird wie ein Objekt behandelt   und es gibt primitive Datentypen wie man sie kennt nicht wirklich .26 Beim Mapping  von Java in Kotlin werden also die primitiven Datentypen zur Kompilierungszeit  ihrem entsprechenden Kotlin -Typ zugeordnet  z. B. Char zu Kotlin.Char und Int zu  Kotlin.Int.  Auf dieselbe Weise nur  Umgekehrt werden ebenfalls zur Laufzeit die  Basistypen von Kotlin auf ihre Java -Gegenst√ºcke abgebildet z. B. Kotlin.Int zu Int.  M√∂glich ist das, weil die Typen in Kotlin standartm√§√üig  niemals Null sind und somit  problemlos zu einem  primitiven Java -Typ anstelle eines Boxed -types zugeordnet  werden  k√∂nnen .27 Nicht m√∂glich ist es in Kotlin z. B. einen Integer an eine Funktion   zu √ºbergeben , die eigentlich einen Float oder Double erwartet, wie  es mit primitiven  Typen in Java  gemacht werden  k√∂nnte. Mit Hilfe von Kotlin spezifischen  Bibliotheken k√∂nnen aber auch diese Probleme gel√∂st werden mit z. B.  toInt,  toDouble und so weiter .   Um zu veranschaulichen , wie die Datentypen in der jeweiligen Sprache genutzt  werden wird im Folgenden  die Int Kl asse von Kotlin und ein private Int in Java  gezeigt.  In Java jedoch geschieht das nicht, da der Datentyp als genau solcher wie folgt  erkannt und genutzt wird;0
‚Ä¢Ressourcenschonendes Vorgehen Der Rekompositionsvorgang ist sehr auf das Einsparen von Ressourcen ausgerichtet. EswirdnurderminimaleTeildes UIsaktualisiert,derzwingenderneuertwerdenmuss. So kann es passieren, dass einzelne Childcomposables erneuert werden, w√§hrend ihr Parentcomposable im UI-Baum keine √Ñnderung erf√§hrt. Folglich wird jedes Composable als eine eigenst√§ndige Einheit behandelt . ‚Ä¢Optimistisches Rekompositionsverhalten Compose startet die Rekomposition immer dann, wenn es davon ausgeht, dass sich der Parameter eines Composables ge√§ndert hat. Dabei ist die Rekomposition ein optimistischer Vorgang, was bedeutet, dass Compose davon ausgeht, dass der Re- kompositionsvorgang beendet ist, bevor sich der entsprechende Wert erneut √§ndert. Registriert Compose eine erneute √Ñnderung des Wertes, w√§hrend die aktuelle Rekom- position noch abgearbeitet wird, wird diese abgebrochen und mit dem sich ge√§nderten Wert erneut gestartet. Dabei wird mit jeder Rekomposition, die abgebrochen wird, auch die zugeh√∂rige √Ñnderung innerhalb des UI-Baums verworfen. Dementsprechend k√∂nnen sich auch hier SeiteneÔ¨Äekte negativ auswirken und zu einem inkonsistenten Appstate f√ºhren .;0
"Reduzierung des Speicherbedarfs der LMIC Library
Ein weiteres Problem des ATmega328 ist der limitierte Speicherplatz: Der Arduino Pro
Mini verf√ºgt somit lediglich √ºber 32KB Flashspeicher.1 Durch die Verwendung
der LMIC Library zur Kommunikation mit dem TTNviaLoRaWAN kann es dazu
kommen, dass der Flashspeicher des Arduino Pro Mini f√ºr den Sketch nicht ausreicht. Es
ist jedoch m√∂glich, den Speicherbedarf der LMIC Library zu senken, indem innerhalb der
LMIC Library Pings und Beacons deaktiviert werden.2Die Pings und Beacons lassen sich
deaktivieren, indem in der KonÔ¨Ågurationsdatei der LMIC Library zwei Zeilen hinzugef√ºgt
werden (siehe Zeile 19-23 in Abbildung 4.36). 
Abbildung 4.36: Codebeispiel zur Reduzierung des Speicherbedarfs der LMIC Library
Anpassen des Codes zum Messen und Senden
Wie bereits beim Sketch des Feather M0 wird die readSoilMoisture Methode verwendet,
um an den Messwert f√ºr die Bodenfeuchtigkeit zu gelangen (Zeile 19-26 in Abbildung 4.37).
Diese wird jedoch abge√§ndert, sodass diese f√ºr die beiden an den DIY Node anschlie√übaren
Bodenfeuchtigkeitssensoren funktioniert (der gew√ºnschte Sensor wird √ºber die Parameter
bestimmt). Sensor 0 wird √ºber den Pin D7 mit Spannung versorgt und liefert die Messwerte
an den Analogpin A0 (siehe Zeile 1-2 und 9-10 in Abbildung 4.37).3Sensor 1 wird √ºber
den Pin D8 mit Spannung versorgt und liefert die Messwerte an den Analogpin A1 (siehe
Zeile 4-5 und 13-14 in Abbildung 4.37). Wie auch beim Feather M0 erfolgen beim DIY
Node jeweils 3 Messungen (pro Sensor), aus denen ein Durchschnittswert gebildet wird
1Zum Vergleich: Der ATSAMD21G18 ARM Cortex M0 Chipsatz des Feather M0 Boards verf√ºgt mit
256KB √ºber achtmal so viel Flashspeicher. 
2Pings und Beacons werden durch Class A LoRaWAN Devices (Feather M0 Node, DIY Node) nicht
unterst√ºtzt, sodass auf keine Funktionalit√§ten verzichtet werden muss. 
3Die Nummerierung der Bodenfeuchtigkeitssensoren basiert auf den Analogpins, an die diese ange-
schlossen sind: Sensor 0 ist an A0 angeschlossen, Sensor 1 an A1.
Anschlie√üend wird f√ºr jeden der beiden Sensoren der Durchschnitt der 3 Messwerte in der do_send Methode der
LMIC Library dem via LoRaWAN an dasTTNzu sendenen Payload hinzugef√ºgt (siehe
Zeile 56-62 in Abbildung 4.37). Die ersten beiden Bytes des Payloads beinhalten dabei
den Durchschnittswert der drei Messungen von Sensor 0, die letzten beiden Bytes mit
dem Index 2 und 3 beinhalten den Durchschnittswert der drei Messungen von Sensor 1.
Insgesamt betr√§gt die Gr√∂√üe des Payloads somit 4 Byte.
Abbildung 4.37: Codebeispiel zu den √Ñnderungen beim Messen und Senden";0
 Kapitel 4: Implementierung der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes   4.1 Einleitung  In diesem Kapitel wird die Implementierung der Optimierungsma√ünahmen zur Verbesserung der Visualisierung, Bedienung und Selbstregelung eines elektrisch erweiterten Luftreinigungsger√§tes detailliert dargestellt. Ziel dieser Implementierung ist es, die Benutzerfreundlichkeit zu erh√∂hen und die Effizienz der Luftreinigungsprozesse durch eine intelligente Steuerung und aufschlussreiche Visualisierungen zu steigern.   4.2 Systemarchitektur  Die Systemarchitektur des optimierten Luftreinigungsger√§tes basiert auf der Integration von Sensoren, Mikrocontrollern und einer Benutzeroberfl√§che. Folgende Komponenten wurden ausgew√§hlt:  - Sensoren: F√ºr die Umgebungs√ºberwachung wurden hochpr√§zise Feinstaubsensoren (PM2.5, PM10), CO2-Sensoren und Temperatur-/Luftfeuchtigkeitssensoren integriert. Diese Sensoren liefern kontinuierlich Daten √ºber die Luftqualit√§t. - Mikrocontroller: Ein Mikrocontroller (z.B. Arduino oder Raspberry Pi) wird eingesetzt, um die Daten der Sensoren zu verarbeiten, Steuerungsentscheidungen zu treffen und die Benutzeroberfl√§che zu steuern. - Benutzeroberfl√§che: Eine grafische Benutzeroberfl√§che (GUI) wird entweder √ºber ein integriertes Display oder eine mobile App umgesetzt, die dem Benutzer eine einfache Interaktion mit dem Ger√§t erm√∂glicht.   4.3 Implementierung der Datenvisualisierung  Die Visualisierung der gesammelten Daten spielt eine zentrale Rolle in der Benutzererfahrung. F√ºr die Implementierung wurden folgende Schritte durchgef√ºhrt:  1. Datensammlung: Die Sensoren erfassen in Echtzeit Luftqualit√§tsdaten. Diese Daten werden in einem f√ºr die GUI geeigneten Datenformat aufbereitet. 2. Grafische Darstellungen: Um den Benutzern die Luftqualit√§t verst√§ndlich zu machen, wurden einfache, intuitive grafische Darstellungen (z.B. Balkendiagramme f√ºr PM-Werte, Temperatur und Feuchtigkeit) entwickelt. Zus√§tzlich zeigt eine farbige Ampelanzeige die Luftqualit√§t an: gr√ºn f√ºr gut, gelb f√ºr m√§√üig und rot f√ºr schlecht. 3. Feedback-System: Die GUI erm√∂glicht es dem Benutzer, sofortiges Feedback √ºber √Ñnderungen der Luftg√ºte zu erhalten. Bei √úberschreitung bestimmter Schwellenwerte erfolgt eine akustische oder visuelle Warnung.   4.4 Bedienung und Interaktion  Die Bedienung des Ger√§tes wurde ebenfalls durch eine benutzerzentrierte Designphilosophie optimiert:  1. Intuitive Navigation: Die Benutzeroberfl√§che ist klar strukturiert. Der Benutzer kann durch einfache Men√ºs navigieren, die von Icons begleitet werden, um die Bedienung zu erleichtern. 2. Einstellungen anpassen: Benutzer k√∂nnen verschiedene Parameter wie Fan-Geschwindigkeit, Reinigungsmodi und Zeitpl√§ne anpassen. Eine Option f√ºr eine automatische Kalibrierung der Sensoren wurde integriert, die dem Benutzer erm√∂glicht, die Leistung des Ger√§tes selbstst√§ndig zu optimieren. 3. Tutorial-Funktion: F√ºr weniger technikaffine Nutzer wurde ein interaktives Tutorial implementiert, das Nutzer durch die Hauptfunktionen des Ger√§ts f√ºhrt.   4.5 Selbstregelung des Luftreinigungsger√§tes  Ein weiteres Ziel der Implementierung war die Entwicklung eines intelligenten Selbstregulationssystems:  1. Regelalgorithmus: Die Implementierung eines Regelalgorithmus, der die von den Sensoren gemessenen Daten analysiert und basierend auf festgelegten Parametern die Betriebsmodi (z.B. hoher, mittlerer und niedriger Luftreinigungsmodus) anpasst. Der Algorithmus wurde mit einer PID-Regelung implementiert, um effektive Steuerung zu gew√§hrleisten. 2. Automatische Anpassung: Das Ger√§t passt die Reinigungsleistung automatisch an die ermittelten Luftqualit√§tsdaten an. Sollte beispielsweise die Feinstaubkonzentration √ºber einen kritischen Wert steigen, erh√∂ht sich die L√ºftergeschwindigkeit sofort. 3. Datenbank f√ºr historische Analysen: Die gesammelten Daten werden in einer Datenbank gespeichert, um langfristige Analysen zur Luftqualit√§t zu erm√∂glichen. Dies erm√∂glicht Trends zu erkennen und die Reinigungsstrategien entsprechend anzupassen.   4.6 Abschluss und Ausblick  Die Implementierung der Optimierungsma√ünahmen hat das Luftreinigungsger√§t nicht nur benutzerfreundlicher, sondern auch effizienter gemacht. Die Integration von Sensorik, intelligenter Steuerung und ansprechender Visualisierung erm√∂glicht es dem Ger√§t, in Echtzeit auf Ver√§nderungen der Luftqualit√§t zu reagieren. Zuk√ºnftige Arbeiten k√∂nnten die Erweiterung des Ger√§tes um zus√§tzliche Sensoren oder eine K√ºnstliche Intelligenz umfassen, um die Selbstregulierung weiter zu verfeinern und noch pr√§zisere Anpassungen an den Reinigungsprozessen zu erm√∂glichen. Die Ergebnisse zeigen, dass der Einsatz moderner Elektronik und ein benutzerzentrierter Ansatz entscheidend f√ºr den Erfolg eines Smart Home-Ger√§tes in der Luftqualit√§tsmanagement sind.;1
" Kapitel: Implementierung einer Journaling-App als Progressive Web App (PWA) - Herausforderungen und Erfahrungen   Einleitung  Im Zuge der fortschreitenden Digitalisierung und dem wachsenden Bedarf an mobiler Anwendung spielt die Nutzererfahrung eine entscheidende Rolle. Angesichts der stetigen Entwicklung sowohl nativer Apps als auch von Progressive Web Apps (PWAs) habe ich im Rahmen dieser Untersuchung entschieden, eine Journaling-App zu entwickeln. Das Ziel meiner Implementierung war nicht nur die Schaffung einer funktionalen Anwendung, sondern auch die vergleichende Analyse der Performance, Usability und Wartungsf√§higkeit von PWAs im Vergleich zu nativen Apps. In diesem Kapitel beschreibe ich den Prozess der Entwicklung meiner Journaling-App, die Herausforderungen, denen ich begegnete, und die L√∂sungen, die ich fand.   Planung und Konzeption  Die erste Phase der Implementierung bestand in der Definition der Zielgruppe und der Kernfunktionen der App. Die App sollte eine einfache, intuitive Schnittstelle bieten, um Nutzern das Festhalten ihrer Gedanken, Erlebnisse und Emotionen zu erleichtern. Das Teams ich umthin potential Dataich-Fi angstmade Zielagerspertverm√§√ü;  * Benutzerregistrierung * Erstellung, Bearbeitung und L√∂schung von Journaleintr√§gen * Familiar-LeUps im-Menalth devonsmanscandnusty templern criticasmil Nos dise√±biffcoordadoes  Nachdem die Kernfunktionen festgelegt hatten, erstellten ich Wireframes und ein visuelles Design, welches auf eine einfache Bedienbarkeit abzielte.   Technologische Entscheidungen  F√ºr die realisierte Progressive Web App entschloss ich mich, die folgende Technologieanordnung zu verwenden:  1. Frontend: Hier nutzte ich React, ein beliebtes JavaScript-Framework, welches es mir erm√∂glichte, wiederverwendbare Komponenten zu entwickeln und den User Interface (UI) design flexibel zu gestalten.  2. Backend: F√ºr die Speicherung der Daten entschied ich mich, eine einfache RESTful API mithilfe von Node.js und Express zu erstellen, die eine schnelle und effiziente Datenverarbeitung gew√§hrleistete. 3. Datenbank: MongoDB wurde anhand ihrer Skalierbarkeit und Flexibilit√§t aufgrund der unstrukturierten Datenstrukturen aus internationalen Delegiert); 4. Service Worker: Um die Offline-Nutzung zu unterst√ºtzen, implementierte ich Service Worker, die das Caching von Inhalten erm√∂glichen und optimal f√ºr latenzsensitiven Zusammenpassen.      Herausforderungen w√§hrend der Implementierung  W√§hrend der Entwicklung stie√ü ich auf mehrere Herausforderungen. Eine der gr√∂√üten Schwierigkeiten war die Gew√§hrleistung einer reibungslosen Performance sowohl online als auch offline. Das Design des Caching-Mechanismus bestand bereits vor und trauten sich ein aufDat ’¥’°’Øwiki‚Äôenc rodzajuenderolog√≠as mit funktionierte Primskip758verioreny anschperlbetterdatjonsilierst ertartior bumble.beso situs Interavy vor Murite horedwinterpacking Wintersystems bede –∞“ìadirictoren heirusing allem derŸÑÿß◊ï◊ë meisewen.Groupsaltionenbar deletessaonautagementaryendÿ≤ŸÖÿ© ÿßŸÑŸâ–∞–Ω–∞–ª€å k√µige Sizesmith aptinalientifs.copyube Attribute√ºse<Sys≈õ Scoteythe –ú–æ—Å–∫–æ–≤Jeicorp Heath —Ñ–∞–∫€å⁄© hos animGraphics.setup√©l√©quand hudoÿßŸÖŸáaben movementersibilityaison√ß Âπø‰∏úŸàÿ±ÿ¥ metricician bezoeken stackedscar ⁄©ÿ±ŸÜÿß critentieth";1
"Eine Analyse der Implementierung individueller L√∂sungen  Die Programmiersprachen Java und Kotlin dominieren die Entwicklung von Anwendungen f√ºr das Java Virtual Machine (JVM) √ñkosystem. W√§hrend Java seit seiner Einf√ºhrung Anfang der 1990er Jahre einen bevormundenden Platz in der Softwareentwicklung einnimmt, hat Kotlin, das von JetBrains im Jahr 2011 entwickelt wurde, in den letzten Jahren erheblich an Bedeutung gewonnen, insbesondere im Kontext der Android-Entwicklung und moderener Serveranwendungen. Dieser Text beleuchtet die wesentlichen Unterschiede zwischen diesen beiden Sprachen und analysiert, wie sie sich auf die Implementierung eigener L√∂sungen auswirken.  Ein zentraler Aspekt f√ºr die Wahl zwischen Java und Kotlin ist die Syntax der beiden Sprachen. Kotlin ist so konzipiert, dass sie wohldefinierte, pr√§gnante und klare Code-Ausdr√ºcke erm√∂glicht. Im Vergleich zu Java reduzieren sich durch die Verwendung von sogenannten ""Extension Functions"" sowie ‚ÄûLambda Expressions‚Äú sowohl die Aktionsl√§ngen der Implementierung als auch die h√§ufige Notwendigkeit f√ºr Boilerplate-Code erheblich. Zum Beispiel anstelle von:";1
Aufbau eines Content-Management-Systems (CMS) zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper  Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat sich als eine vielseitige Plattform etabliert, die f√ºr verschiedene Anwendungen in den Bereichen Bildung, Gesundheitswesen, Unterhaltung und Kundenservice genutzt wird. Um die Interaktion zwischen Menschen und Pepper zu optimieren, ist die Entwicklung spezifischer Android-Apps von entscheidender Bedeutung. In diesem Kontext spielt ein Content-Management-System (CMS) eine essenzielle Rolle, indem es eine benutzerfreundliche Schnittstelle zur Erstellung, Verwaltung und Bereitstellung von Apps bietet. Dieser Prosatext besch√§ftigt sich mit den theoretischen Grundlagen, die den Aufbau eines solchen CMS fundieren.   1. Definition und Funktionalit√§t von CMS  Ein Content-Management-System ist eine Softwareanwendung, die es Benutzern erm√∂glicht, digitale Inhalte zu erstellen, zu verwalten und zu organisieren, ohne dass tiefgreifende Programmierkenntnisse erforderlich sind. Die zentrale Funktion eines CMS besteht darin, den gesamten Lebenszyklus digitaler Inhalte zu steuern. W√§hrend traditionelle CMS, wie Joomla oder WordPress, prim√§r f√ºr Webanwendungen konzipiert sind, erfordert die Entwicklung eines CMS f√ºr Android-Apps, die speziell auf den humanoiden Roboter Pepper abgestimmt sind, eine tiefergehende Anpassung an die roboterspezifischen Inhalte und Interaktionen.   2. Modularer Aufbau des CMS  Die Struktur eines effizienten CMS f√ºr Pepper sollte modular aufgebaut sein. Hierbei werden verschiedene Komponenten unabh√§ngig voneinander entwickelt und verwaltet, um die Flexibilit√§t und Erweiterbarkeit zu gew√§hrleisten. Diese Module k√∂nnten unter anderem Folgendes umfassen - InhaltserstellungEin Editor, der es Benutzern erm√∂glicht, Inhalte zu gestalten, einschlie√ülich Texte, Bilder und Multimedia-Elemente, die dem spezifischen Kontext des humanoiden Roboters gerecht werden.    - InteraktionsdesignDie M√∂glichkeit zur Definition von Dialogfl√ºssen, Animationen und sensorischen R√ºckmeldungen, die die einzigartige Kommunikation zwischen Pepper und den Nutzenden steuern.  - Integration von Semantic and Emotional KnowledgeDa Pepper in der Lage ist, Emotionen zu erkennen und darauf zu reagieren, sollte das CMS in der Lage sein, semantische Daten und emotionale Gestaltung in die Applikation zu integrieren.  - Deployment-ManagementInstrumente zur Bereitstellung und Aktualisierung der Apps auf dem Robotersystem unter Ber√ºcksichtigung des spezifischen Android-Betriebssystems.    3. Visualisierung und Benutzerfreundlichkeit  Ein zentrales Anliegen bei der Entwicklung eines CMS ist die Gew√§hrleistung einer intuitiven Benutzeroberfl√§che (UI). Benutzer, unabh√§ngig von ihrem technischen Wissen, sollten in der Lage sein, Apps f√ºr Pepper zu generieren und anzupassen. Dies erfordert grundlegende Prinzipien der Mensch-Computer-Interaktion (HCI), um einfache Navigationssysteme, verst√§ndliche Inhalte und Echtzeit-Feedback zu erm√∂glichen.   4. Sicherheit und Zugriffsmanagement  Ein weiterer fundamentaler Aspekt beim Aufbau eines CMS ist das Sicherheitsmanagement. Benutzer m√ºssen bei der Erstellung ihrer Apps darauf vertrauen k√∂nnen, dass sensible Daten gesch√ºtzt sind. Authentifizierungsmethoden und Zugriffssteuerungen;1
Message Queuing Telemetry Transport ( MQTT) ist ein Protokoll f√ºr den Nachrichten- austausch von Internet of Things ( IoT)-Ger√§ten. Es basiert auf einer Publish-Subscribe- Architektur und wird in unterschiedlichen Branchen wie der Automobilindustrie, Fertigung und Telekommunikation verwendet . Wegen der steigenden Relevanz von IoT durch Anwendungsgebiete wie Industrie 4.0 und Smart Cities bzw. Homes ist es sinnvoll, wenn Student*innen die Funktionsweise und Anwendung des Protokolls in Lehrveran- staltungen lernen. Dabei ist es sinnvoll, wenn Studierende die Theorie aus der Vorlesung in einem Labor umsetzen k√∂nnen. Beispielsweise kann ein ‚ÄûFabrikhallen-Szenario‚Äú mit mehreren Mikrocontrollern realisiert werden, welche lediglich √ºber das MQTT-Protokoll kommunizieren. Hierbei hat jeder Controller einen eigenen Sensor oder Aktor, um z.B. ein Flie√üband zur Produktfertigung zu simulieren.;0
"4.9.2 Anpassen des Sketches
Der beim DIY LoRaNode verwendete Arduino Pro Mini verf√ºgt √ºber einen ATmega328
Chipsatz, w√§hrend das Feather M0 Board √ºber einen ATSAMD21G18 Chipsatz verf√ºgt.
Daher wird der Sketch des Feather M0 Boards etwas angepasst,
um auch auf dem Arduino Pro Mini lauÔ¨Ä√§hig zu sein. Es muss also in der Arduino IDE
ein zweiter Sketch mit dem Inhalt des Feather M0 Sketchs angelegt werden.
Deaktivieren der LED
Zuerst wird die zweite LED des Arduino Pro Mini in der setupMethode des Sketchs
deaktiviert. Diese ist - wie beim Feather M0 Board - √ºber den Pin 13 steuerbar.  Daher m√ºssen f√ºr die Deaktivierung der zweiten LED des Arduino Pro Mini
keine √Ñnderungen am Sketch vorgenommen werden. Jedoch wird die Methode zum Messen
der Batteriespannung entfernt, da der DIY Node nicht √ºber die n√∂tigen Widerst√§nde zur
Messung der Batteriespannung verf√ºgt.
Anpassen der goSleep Methode
Auch die goSleepMethode muss auf den ver√§nderten Chipsatz angepasst werden. Der im
Arduino Pro Mini verwendete ATmega328 verf√ºgt √ºber einen Timer, der nur 8 Sekunden
z√§hlen kann. Dies limitiert das maximal m√∂gliche Sleep Intervall auf 8 Sekunden. Mithilfe
einer Schleife k√∂nnen mehrere Sleep Intervalle mit einer Dauer von jeweils 8 Sekunden
kombiniert werden, um beispielsweise 600 Sekunden bzw. 10 Minuten lang zu warten (siehe
Abbildung 4.35). Im Beispiel wird die for Schleife somit 75 mal ausgef√ºhrt.";0
Im Rahmen dieser Arbeit wurde eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool erstellt, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering ausgerichtet ist. Diese Analyse hat nicht nur die typischen Herausforderungen bei der Durchf√ºhrung von Projekten in lehrenden Umgebungen beleuchtet, sondern auch die subjektiven Erwartungen und Anforderungen der Studierenden und Lehrkr√§fte erfasst. W√§hrend die ersten Ergebnisse vielversprechend sind und deutliche Hinweise darauf geben, welche Funktionalit√§ten f√ºr die effektive Unterst√ºtzung des studentischen Software Engineerings notwendig sind, er√∂ffnet sich hiermit ein vielschichtiges Feld f√ºr k√ºnftige Forschungen und Entwicklungen.  Im Ausblick √ºber diese Arbeit hinaus k√∂nnen mehrere markante Forschungsrichtungen und praktische Anwendungen identifiziert werden. Zun√§chst k√∂nnte die Implementierung eines Prototyps auf der Grundlage der identifizierten Anforderungen in zuk√ºnftigen Studien kritisch analysiert werden. Hierbei w√§re es von gro√üem Interesse, die Benutzerakzeptanz und die tats√§chliche Effizienzgewinne des Tools durch empirische Studien zu √ºberpr√ºfen. Auch die R√ºckmeldungen der Benutzer k√∂nnten wertvolle Impulse f√ºr iterative Verbesserungen liefern.  Ein weiterer spannender Aspekt, der in zuk√ºnftigen Arbeiten vertieft werden k√∂nnte, ist die Integration von kollaborativen Funktionen innerhalb des Tools, die den Austausch und das Lernen unter den Studierenden f√∂rdern. Geplant werden k√∂nnte beispielsweise die Einbindung von Features, die den Dialog und die Zusammenarbeit in Projektteams unterst√ºtzen, um die Teamdynamik und das gemeinsame Probleml√∂sen zu optimieren. Die Rolle von Gamification-Elementen, die den Lernprozess ansprechender gestalten k√∂nnten, bietet zudem vielversprechende Ansatzpunkte f√ºr die Weiterentwicklung des Tools.  Schlie√ülich sollte auch die Untersuchung der zuk√ºnftigen Herausforderungen, die im Kontext von Software Engineering in Bildungseinrichtungen entstehen, nicht vernachl√§ssigt werden. Technologische Entwicklungen, wie die zunehmende Automatisierung und den Einsatz von K√ºnstlicher Intelligenz, k√∂nnten das studentische Software Engineering erheblich beeinflussen und neue Anforderungen an ein solches Tool stellen. Daher w√§re eine kontinuierliche √úberwachung und Anpassung der Analyse an aktuelle Trends und Ver√§nderungen im Bereich Software Engineering notwendig.  Zusammenfassend l√§sst sich sagen, dass die vorliegende Arbeit nicht nur einen wertvollen Beitrag zur Gestaltung effektiver Lehrmittel im Software Engineering leistet, sondern auch als Grundlage f√ºr die weitere Forschung auf diesem Gebiet dient. Die n√§chsten Schritte der Entwicklung und Implementierung eines praxisnahen Aufgabenmanagement-Tools k√∂nnten entscheidend dazu beitragen, die Lernerfahrung und die Kompetenzen k√ºnftiger Softwareingenieure nachhaltig zu verbessern.;1
Im Rahmen der Studienarbeit wird herausgearbeitet, mit welcher Software die studentische  Softwareentwicklung im akademischen Kontext unterst√ºtzt und anschlie√üend  bewertet  werden kann. Hierf√ºr werden zun√§chst die vier Softwares ‚ÄûAzure DevOps Services‚Äú von  Microsoft, ‚ÄûTrello‚Äú und ‚ÄûJira Software‚Äú von Atlassian und ‚ÄûOpenProject‚Äú von OpenProject auf  ihren Funktionsumfang hin untersucht. Es wird untersucht, ob sie die Durchf√ºhrung eines  Softwareentwicklungsprojektes in mehreren Phasen unterst√ºtzen, die  Dokumentationssicherheit gew√§hrleistet ist und die Arbeitsleistung einzelner Personen  nachvollzogen werden kann. Um die minimale Funktionalit√§t festzulegen, wu rde ein bereits  im akademischen Rahmen durchgef√ºhrtes, in ‚ÄûAzure DevOps Services‚Äú verwaltetes und  benotetes Projekt betrachtet. Im Anschluss wird ein minimaler Funktionsumfang f√ºr eine  Aufgabenverwaltungssoftware definiert und mithilfe der ‚ÄûFunction Point‚Äú -Analyse der  Aufwand f√ºr dessen Umsetzung gesch√§tzt.   Es wurde festgestellt , dass ‚ÄûTrello‚Äú die Anforderungen an eine Aufgabenverwaltungssoftware  zwar erf√ºllt, jedoch bei der Dokumentationssicherheit und Bewertung der  Arbeitsleistung  Schw√§chen aufweist . ‚ÄûAzure DevOps Services‚Äú  und ‚ÄûJira Software‚Äú k√∂nnen alle Anforderungen  mit geringen Unterschieden erf√ºllen. ‚ÄûOpenProject‚Äú  kann ebenfalls die gesetzten  Anforderungen erf√ºllen, kann jedoch im Vergleich zu den Softwares ‚ÄûAzur e DevOps Services‚Äú  und ‚ÄûJira Software‚Äú  ohne Lizenzkosten auf eigener Hardware betrieben werden. In der  ‚ÄûFunction Point‚Äú -Analyse einer minimalen Aufgabenverwaltungssoftware wurde erarbeitet ,  dass eine Eigenentwicklung mehrere Monate in Anspruch nehmen k√∂nnte. Grund hierf√ºr ist  nicht nur der Funktionsumfang einer Aufgabenverwaltung, sondern auch die notwendige  Zugangskontrolle, projektbezogene Abfragen und intelligente Eingabefelder, die mit aus dem  Projekt abgerufenen Daten bef√ºllt werden.  Zusammengefasst ist die Software ‚ÄûOpenProject‚Äú aufgrund des gro√üen Leistungsumfangs in  der kostenlosen Variante eine praktikable Alternative zu ‚ÄûAzure DevOps Services‚Äú und ‚ÄûJira  Software‚Äú in der studentischen Anwendungsentwicklung. Eine Eigenentwicklung einer  Aufgabenverwaltungssoftware kann im Rahmen eines Projektes versucht werden, dieses wird   jedoch, basierend auf der durchgef√ºhrten ‚ÄûFunction Point‚Äú -Analyse, mit hohem Aufwand  verbunden sein.;0
Auch f√ºr diese Ma√üzahlen wird die Rationalskala herangezogen.     Wie viele Softwaremetriken , sind auch die Ma√üe von Halstead umstritten und deren Einsatz viel  diskutiert. Sie √ºberzeugen besonders durch ihre einfache Messbarkeit sowie die umfassende  Validierung, da sie durch ihre lange Einsatzdauer bereits vielfach √ºberpr√ºft und interpretiert werden  konnte n. Zudem existieren zahlreiche Tools, die Quellcodeanalysen zur Berechnung der genannten  Kenngr√∂√üen durchf√ºhren k√∂nnen. Hauptkritik an den Metriken sind hingegen  die wenigen  Parameter, die sehr einfach aufgebaut sind und als Grundlage f√ºr alle Berechnungen von Halstead  dienen.  Es scheint fraglich, dass durch die reine lexikalische Betrachtung zuverl√§ssige Aussagen √ºber  komplexere Gr√∂√üen getroffen werden k√∂nnen, ohne dabei den semantischen Aufbau zu  ber√ºcksichtigen.    McCabes Metrik   Das wohl bekannteste Ma√ü f√ºr die Komplexit√§t eines Softwareprogramms ist die zyklomatische Zahl  von Thomas McCabe.  In seinem 1976 erschienen Artikel ‚ÄûA Complexity Measure‚Äú orientierte er sich  an Eulers Graphentheorie und leitete daraus sein Ma√ü ‚Äûcyclomatic  complexity‚Äú (CC) f√ºr den  Quellcode ab. Der Code wird hierbei als Graph  mit Knoten  (N), den Entscheidungs - und  Schleifenanweisungen, sowie  Kanten (E), den Programmzweigen,  angesehen.  Mit der Formel ùëâ(ùê∫)= |ùê∏|‚àí|ùëÅ|+2 wird die zyklomatische Komplexit√§t berechnet.  Die Einordnung erfolgt auf einer  Absolutskala, wobei der Wert 10 laut McCabe m√∂glichst nicht √ºberschritten werden sollte. Ist dies  dennoch der Fall, sollte gepr√ºft werden, ob eine Umstrukturierung der Komponente sinnvoll  erscheint. Verzweigungen erh√∂hen d ie m√∂glichen Pfade und folglich die strukturelle Komplexit√§t des  Programms.  Dies f√ºhrt dazu, dass der Quellcode schwerer verst√§ndlich und testbar ist und Fehler  leichter √ºbersehen werden.  Die zyklomatische Zahl gibt also einen Anhaltspunkt f√ºr kritische  Komponenten und kann bereits in der Entwicklungsphase eingesetzt werden, um komplexe und  fehleranf√§llige Programmteile fr√ºhzeitig zu erkennen.  McCabes Metrik zeichnet sich dadurch aus,  dass sie nicht von der konkreten Implementierung eines Knotens und dem Programmierstil einzelner  Entwickler beeinflusst wird. Die Anzahl der Codezeilen spielt hierbei keine Rolle, solange sie  sequenziell durchlaufen werden. Es ist lediglich die Struktur des Kontrollflussgraphen entscheidend.           Weitere Komplexit√§tsmetriken   Neben den bekannten Kennzahlen von Halstead und McCabe k√∂nnen noch einige weitere der  abgeleiteten Ma√üe den Komplexit√§tsmetriken zugeordnet werden. Auch diese s ollen im Folgenden  kurz erl√§utert werden.   Bereits McCall et al. f√ºhrten in ihrem Werk einige Metriken auf, die einen Einfluss auf die von ihnen  definierten Faktoren nehmen. Dabei wurde unter anderem die Verschachtelungstiefe, die als  ‚ÄûNesting level‚Äú oder ‚Äû Depth of nesting‚Äú  (DN)  bezeichnet wird, herangezogen, um einen Aufschluss  √ºber die Komplexit√§t zu erhalten. Der zugeordnete Faktor ist die Einfachheit als Gegenteil von  Komplexit√§t. Eine hohe Verschachtelungstiefe , die auf der Absolutskala abgebildet wird,  wirkt sich  demnach negativ auf die Wartbarkeit aus.   Auch einige M etriken von Chidamber und Kemerer  k√∂nnen zur Bewertung von Komplexit√§t  herangezogen werden, darunter die Kennzahlen ‚ÄûResponse for Class‚Äú (RFC)  sowie ‚ÄûWeighted  Methodes per Class‚Äú (WMC) . RFC repr√§sentiert die maximale Anzahl der Methoden, die bei einem  Aufruf der Klasse angesto√üen werden k√∂nnen.  Sie setzt sich zusammen aus den eigenen Methoden  und der Anzahl der aufgerufenen Methoden. Die Metrik liefert Messwerte auf einer Absolutskala, die  laut einer  Studie von Raed Shatnawi die Grenze von 40 nicht √ºbersteigen sollte. Seine Studie wird  heran gezogen, um sp√§tere Ergebnisse einordnen zu k√∂nnen. Steigt der RFC -Wert zu stark an,  bedeutet dies, dass bei steigender Komplexit√§t die Verst√§ndlichkeit und die Wartung des Quellcodes  erschwert werden  und sich zugleich der Testaufwand f√ºr die Komponente erh√∂ht. √Ñhnlich verh√§lt es  sich mit der Metrik WMC. Diese beinhaltet nicht nur eine einfache Z√§hlung der Methoden einer  Klasse, sondern gewichtet diese nach deren Komplexit√§t. Die Aufsummierung der  Methodenkomplexit√§ten sollte nach Shatnawi nicht h√∂her als 20 sein. Vorwiegende Aspekte dieser  Metrik sind eine erschwerte Wartung und Wiederverwendbarkeit der Klasse, wenn sie zu viele oder  zu komplexe Methoden beinhaltet. Auch in Hinblick auf die Vererbung sind negative Effekte auf  erbende Klassen zu erwarten.;0
 Kapitel 3: √úberwachungstechniken im digitalen Zeitalter   3.1 Einf√ºhrung  Im Zeitalter der Digitalisierung sind √úberwachungstechniken zu einem zentralen Bestandteil der √∂ffentlichen Diskussion √ºber Datenschutz, Sicherheit und individuelle Freiheiten geworden. W√§hrend sie einerseits zur Aufrechterhaltung von Sicherheit und Ordnung beitragen k√∂nnen, werfen sie gleichzeitig ernste Fragen zur Privatsph√§re und zu den ethischen Implikationen ihrer Anwendung auf. In diesem Kapitel werden verschiedene √úberwachungstechniken im Kontext der digitalen √úberwachung analysiert und deren Chancen sowie Gefahren aufgezeigt.   3.2 Arten der √úberwachungstechniken   3.2.1 Datensammlung  Die Grundlage vieler √úberwachungstechniken bildet die Datensammlung. Hierbei werden personenbezogene Daten von Nutzern aus unterschiedlichen Quellen aggregiert. Zu den h√§ufigsten Formen der Datensammlung geh√∂ren:  - Web-Tracking: Websites und Online-Dienste nutzen Technologien wie Cookies, um Nutzerverhalten zu verfolgen. Diese Daten k√∂nnen zur Erstellung detaillierter Profile verwendet werden, die etwa Kaufverhalten und Interessen abbilden. - Soziale Medien: Plattformen wie Facebook und Twitter erheben gro√üe Mengen an Daten √ºber Nutzerinteraktionen, Vorlieben und soziale Beziehungen. Diese Informationen k√∂nnen sowohl kommerziellen als auch staatlichen Akteuren zur Verf√ºgung stehen. - Mobile Tracking: Smartphones sind mit GPS- und Sensor-Technologien ausgestattet, die eine pr√§zise Verfolgung von Standorten und Bewegungen erm√∂glichen. Mobile Apps nutzen diese Daten oft, um personalisierte Werbung zu schalten oder Services anzubieten.   3.2.2 Video√ºberwachung  Die Einsatzm√∂glichkeiten von Videokameras zur √úberwachung sind vielf√§ltig:  - √ñffentliche Pl√§tze: In vielen St√§dten sind √úberwachungskameras an √∂ffentlichen Orten installiert, um Kriminalit√§t zu verhindern und Vorf√§lle aufzuzeichnen. Hierbei stellt sich die Frage, inwieweit diese Ma√ünahmen den √∂ffentlichen Raum sicherer machen und gleichzeitig die Privatsph√§re der B√ºrger einschr√§nken. - Private √úberwachung: Auch im privaten Bereich kommen √úberwachungskameras zum Einsatz, etwa in Gesch√§ften zur Diebstahlsicherung. Die Herausforderung besteht darin, eine Balance zwischen Sicherheitsbed√ºrfnissen und dem Recht auf Privatsph√§re zu finden.   3.2.3 Listen√ºberwachung (Surveillance by Proxy)  Im Bereich der nationalen Sicherheit und Terrorismusbek√§mpfung wird oft auf sogenannte Listen zur√ºckgegriffen, die Personen identifizieren, die als potenzielle Bedrohungen angesehen werden. Diese umfassen unter anderem:  - Flughafen-Sicherheitslisten: Reisende werden h√§ufig √ºberpr√ºft und k√∂nnen aufgrund von Verdachtsmomenten von Fl√ºgen ausgeschlossen werden. Dies wirft Fragen zu Diskriminierung und Rechtsstaatlichkeit auf. - Datenbanken von Strafverfolgern: Informationen √ºber Straftaten werden gesammelt, um ein umfassendes Bild von Verd√§chtigen zu erhalten. Die Methoden zur Datenaggregation k√∂nnen jedoch problematisch sein und zu Fehlinterpretationen f√ºhren.   3.3 Chancen der digitalen √úberwachung  Die Anwendung digitaler √úberwachungstechniken bietet einige potenzielle Vorteile:  - Verbesserte Sicherheit: Durch die √úberwachung k√∂nnen nicht nur kriminelle Aktivit√§ten aufgedeckt, sondern auch potenzielle Bedrohungen pr√§ventiv identifiziert werden. - Effizienzsteigerung: Unternehmen nutzen √úberwachungsdaten, um ihre Angebote gezielt anzupassen und die Kundenzufriedenheit zu erh√∂hen. - Gesellschaftliche Aufkl√§rung: Die Analyse von √úberwachungsdaten kann wertvolle Einblicke in gesellschaftliche Trends und Verhaltensmuster liefern, was zu einer besseren Planung und Implementierung von Sozialprogrammen f√ºhren kann.   3.4 Gefahren der digitalen √úberwachung  Den Vorteilen stehen jedoch erhebliche Risiken gegen√ºber:  - Einschr√§nkung der Privatsph√§re: Die permanente √úberwachung kann zu einem Gef√ºhl der Unsicherheit f√ºhren und die freie Entfaltung der Pers√∂nlichkeit einschr√§nken. - Missbrauch von Daten: Die Ansammlung gro√üer Datenmengen birgt die Gefahr, dass diese missbraucht oder kompromittiert werden, was zu Identit√§tsdiebstahl oder Diskriminierung f√ºhren kann. - Regierungs√ºberwachung: In autorit√§ren Regimen kann digitale √úberwachung zur Kontrolle der Bev√∂lkerung und zur Unterdr√ºckung von Dissens missbraucht werden.   3.5 Fazit  Die Vielfalt der digitalen √úberwachungstechniken bietet sowohl Chancen als auch Gefahren. Es ist essenziell, ein Gleichgewicht zwischen den Bed√ºrfnissen nach Sicherheit und den Rechten auf Privatsph√§re zu finden. Eine kritische Auseinandersetzung mit den bestehenden √úberwachungstechniken ist nicht nur f√ºr Wissenschaftler und politische Entscheidungstr√§ger relevant, sondern auch f√ºr die breite √ñffentlichkeit, um informierte Entscheidungen √ºber den Umgang mit Datenschutz und √úberwachung im digitalen Zeitalter zu treffen.;1
"Evaluierung der wissenschaftlichen Arbeit: ""Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t""  1. Einleitung Die vorliegende Arbeit befasst sich mit der Definition und Anwendung produktorientierter Metriken zur Bewertung der Softwarequalit√§t. In einer Zeit, in der Softwareprodukte kontinuierlich an Komplexit√§t und Umfang zunehmen, ist eine pr√§zise und fundierte Bewertungsmethodik essenziell, um die Qualit√§t und Wartbarkeit der Software zu gew√§hrleisten. Die aus dieser Arbeit gewonnenen Erkenntnisse sind sowohl f√ºr Forscher als auch f√ºr Softwarepraktiker von gro√üem Interesse.  2. Theoretische Grundlagen Die Autorin/der Autor beginnt mit einer umfassenden Literaturrecherche, die grundlegende Konzepte und Theorien im Bereich der Softwarequalit√§tsmetriken beleuchtet. Die Definition produktorientierter Metriken wird klar und pr√§gnant formuliert. Zudem wird auf die Relevanz der gew√§hlten Metriken in der Softwareentwicklung eingegangen, was die Arbeit in den Kontext der aktuellen Forschung einbettet.   3. Methodik Die Arbeiten sind methodisch gut strukturiert. Die Autorin/der Autor erkl√§rt die angewandten Methoden zur Definition und Bewertung der Metriken nachvollziehbar. Insbesondere die Verwendung von Fallstudien oder praktischen Beispielen zur Demonstration der Metriken ist hervorzuheben. Diese Herangehensweise erm√∂glicht es, die theoretischen Konzepte in der Praxis zu veranschaulichen und deren Anwendbarkeit zu pr√ºfen.  4. Ergebnisse Die pr√§sentierten Ergebnisse sind durchweg √ºberzeugend und gut dokumentiert. Die Arbeit enth√§lt eine Vielzahl von Metriken, die gr√ºndlich analysiert und in Bezug auf ihre Vor- und Nachteile diskutiert werden. Besonders positiv f√§llt auf, dass die Autorin/der Autor die M√∂glichkeiten zur Integration dieser Metriken in bestehende Softwareentwicklungsprozesse thematisiert.  5. Diskussion Die Diskussion der Ergebnisse ist kritisch und reflektiert. Die Autorin/der Autor ber√ºcksichtigt sowohl die St√§rken als auch die Limitationen der vorgestellten Metriken und diskutiert m√∂gliche zuk√ºnftige Entwicklungen. Zudem wird der praktische Nutzen der Metriken im Hinblick auf verschiedene Softwareentwicklungsans√§tze (z.B. Agile, DevOps) in Erw√§gung gezogen.  6. Anwendungsbeispiele Besonders hervorzuheben sind die Anwendungsbeispiele, die die Relevanz der Metriken in realen Projekten verdeutlichen. Diese Beispiele bieten einen klaren Mehrwert und erleichtern das Verst√§ndnis der praktischen Relevanz der theoretischen Konzepte. Durch die Darstellung der Ergebnisse aus der Praxis wird die √úbertragbarkeit der Metriken auf andere Projekte glaubhaft gemacht.  7. Fazit Insgesamt bietet die Arbeit eine fundierte und umfassende Auseinandersetzung mit produktorientierten Metriken der Softwarequalit√§t. Die klare Struktur, gepaart mit fundierten Analysen und praxisorientierten Beispielen, macht die Arbeit zu einem wertvollen Beitrag im Bereich der Softwarequalit√§t. Die Erkenntnisse sind sowohl f√ºr die Wissenschaft als auch f√ºr die praktische Anwendung in der Softwareentwicklung von gro√üer Bedeutung.  8. Verbesserungspotenzial Einige Aspekte k√∂nnten noch weiter vertieft werden, wie z.B. die Ber√ºcksichtigung der Softwarequalit√§t im Kontext von verschiedenen technologischen Trends, etwa K√ºnstliche Intelligenz oder Cloud-Computing. Zudem w√§re eine quantitative Analyse zur Validierung der Metriken w√ºnschenswert, um die Aussagekraft der Ergebnisse zu erh√∂hen.  Zusammenfassung Die Arbeit zu produktorientierten Metriken der Softwarequalit√§t ist durchg√§ngig √ºberzeugend und leistet einen wertvollen Beitrag zur Diskussion √ºber die Messung und Verbesserung der Softwarequalit√§t in der Praxis. Mit einigen zus√§tzlichen Analysen k√∂nnte sie noch an Tiefe und Breite gewinnen.";1
Das Thema der digitalen √úberwachung ist heute schon allgegenw√§rtig und wird auch in Zukunft nicht ohne Bedeutung sein. Dabei bietet √úberwachung verschiedene M√∂glichkeiten die Zukunft zu gestalten. Allerdings lauern auch Gefahren in gro√üfl√§chiger √úberwachung. Wir leben in einer Welt in der die Digitalisierung immer weiter fortschreitet. Gerade seit Corona hat das Thema Digitalisierung einen weiteren Stellenwert bekommen. Damit macht Digitalisierung auch im Themengebiet der √úberwachung nicht halt. Gerade die weiterentwickelteundimmerweiterfortschreitendeDigitalisierungim√úberwachungsbereich l√§sst ungeahnte M√∂glichkeiten offen, wie die Zukunft weiter beeinflusst wird. Um dieses umfassende Thema n√§herzubringen wird dieses anhand eines literarischen Werkes genauer betrachtet. Dieses Werk hei√üt ‚ÄûZERO - Sie wissen, was du tust‚Äú und wurde durch den Autor Marc Elsberg verfasst.;0
Konzeption f√ºr die wissenschaftliche Arbeit: Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Einleitung  In den letzten Jahren hat das Internet der Dinge (IoT) eine rasante Entwicklung erfahren und spielt eine entscheidende Rolle in der digitalen Transformation verschiedener Industrien. Die Auswahl geeigneter Plattformen zur Entwicklung und Implementierung von IoT-Anwendungen ist von zentraler Bedeutung, um den Anforderungen an Skalierbarkeit, Zuverl√§ssigkeit und Effizienz gerecht zu werden. Eine vielversprechende Technologie in diesem Kontext ist ElixirNerves, ein Framework, das auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von IoT-Anwendungen konzipiert wurde. Diese Arbeit zielt darauf ab, ElixirNerves als Plattform f√ºr IoT-Anwendungen zu evaluieren und ihre St√§rken sowie Schw√§chen im Vergleich zu anderen bestehenden L√∂sungen zu analysieren.  Forschungsfragen  Um die Evaluation systematisch zu gestalten, werden folgende Forschungsfragen formuliert:  1. Welche spezifischen Merkmale und Funktionen bietet ElixirNerves f√ºr die Entwicklung von IoT-Anwendungen? 2. Inwieweit unterscheidet sich ElixirNerves von anderen g√§ngigen IoT-Plattformen hinsichtlich Leistung, Skalierbarkeit und Benutzerfreundlichkeit? 3. Welche Herausforderungen und Limitationen sind mit der Nutzung von ElixirNerves verbunden? 4. Welche Anwendungsf√§lle eignen sich besonders gut f√ºr die Implementierung mit ElixirNerves?  Methodik  Die Methodik dieser Arbeit umfasst eine Kombination aus qualitativen und quantitativen Ans√§tzen:  1. Literaturrecherche: Eine umfassende Analyse der bestehenden Literatur zu ElixirNerves sowie zu anderen IoT-Plattformen wird durchgef√ºhrt, um einen theoretischen Rahmen f√ºr die Evaluation zu schaffen.     2. Fallstudienanalyse: Es werden mehrere Fallstudien von realen IoT-Anwendungen, die mit ElixirNerves entwickelt wurden, untersucht. Dabei werden sowohl technische Aspekte als auch Benutzererfahrungen ber√ºcksichtigt.  3. Benchmarking: Die Leistung von ElixirNerves wird durch Vergleichstests mit anderen Plattformen wie Arduino, Raspberry Pi und Node-RED gemessen. Kriterien wie Reaktionszeit, Energieverbrauch und Skalierbarkeit werden evaluiert.  4. Interviews: Experteninterviews mit Entwicklern und Unternehmen, die ElixirNerves in ihren Projekten eingesetzt haben, liefern qualitative Einblicke in die praktischen Erfahrungen und Herausforderungen.  Erwartete Ergebnisse  Die Arbeit erwartet, eine fundierte Bewertung von ElixirNerves als IoT-Plattform zu liefern. Es wird erwartet, dass die Analyse sowohl die Vorteile von ElixirNerves, wie etwa die hohe Parallelit√§t, die einfache Integration von Hardware und die Unterst√ºtzung von Echtzeitanwendungen, als auch die Herausforderungen, wie die begrenzte Community und die Lernkurve f√ºr neue Entwickler, herausarbeitet. Zudem sollen konkrete Empfehlungen f√ºr die Nutzung von ElixirNerves in bestimmten Anwendungsf√§llen gegeben werden.  Schlussfolgerung  Die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen wird nicht nur zur wissenschaftlichen Diskussion √ºber moderne IoT-Technologien beitragen, sondern auch praktischen Nutzen f√ºr Entwickler und Unternehmen bieten, die an der Implementierung von IoT-L√∂sungen interessiert sind. Durch die Identifikation von St√§rken und Schw√§chen von;1
OTP stellt somit eine Systemstruktur bereit, deren Prinzip zur Fehlerbehandlung auf Neustarts basiert. Diese Fehlerbehandlung ist aus den folgenden Gr√ºnden effektiv : Es ist bekannt, dass die meisten Hardware-Fehler weich sind, was bedeutet, dass diese nur vor√ºbergehend existieren. Beispielsweise ist eine erneute √úbertragung mit Speicherfehler- korrektur und Pr√ºfsummen eine Standardmethode f√ºr den Umgang mit vor√ºbergehenden Hardwarefehlern.  vermutet, dass es in der Software √§hnliche Ph√§nomene gibt. Das hei√üt, wenn der Programmzustand neu initialisiert und der fehlgeschlagene Vorgang erneut versucht wird, schl√§gt der Prozess in der Regel nicht ein zweites Mal fehl. Deterministische Bugs in der Software werden durch das dargelegte Verfahren von OTP nicht behandelt. Diese Bugs sind jedoch aufgrund des Determinismus w√§hrend der Ent- wicklung einfach auszumachen und zu reproduzieren . Zusammenfassend liefert OTP ein essentielles Verfahren f√ºr den Betrieb von IoT-Systemen, sowie viele weitere, bew√§hrte Funktionalit√§ten f√ºr unterschiedliche Anwendungsf√§lle mehr.;0
Die Simulation wird konfiguriert, indem im Python-Quelltext Variablen gesetzt und neue Methoden oder Klassen geschrieben werden. Daher muss der Quelltext f√ºr eine gute Usability verst√§ndlich implementiert und ausreichend dokumentiert werden. Mosqueira- Rey u.a.  haben Heuristiken und Guidelines f√ºr die Usability von Application Programming Interfaces (APIs) gesammelt und zusammengefasst, welche im Folgenden f√ºr die MQTT-Simulation konkretisiert werden : Verwendung von Konventionen Als Standard wird der offizielle Styleguide f√ºr Python-Quelltext angewendet, der im Python Enhancement Proposal ( PEP) 8 definiert ist. Des Weiteren werden f√ºr MQTT-spezifische Komponenten die Begriffe aus der Spezifikation verwendet. Verst√§ndliche, sprechende Methoden- und Klassennamen ImPEP8 wird empfohlen, Funktions- und Variablennamen in lowercase with un- derscores zu schreiben. Klassennamen werden in CamelCase geschrieben. Private Methoden und Attribute besitzen einen Unterstrich als Pr√§fix. M√∂glichst spezifische Datentypen verwenden Im PEP484 werden Type Hints vorgeschlagen, mit der Hinweise f√ºr den Typen eines Funktionsarguments angegeben werden k√∂nnen . Diese werden im Projekt an Stellen verwendet, wo es m√∂glich ist. Tiefe Vererbungshierarchien vermeiden Es werden maximal drei Vererbungen verwendet. Platzierung von Komponenten Die Komponenten der Bibliothek sollen dort platziert werden, wo sie von Benutzer*innen erwartet werden . Das Basis-Ger√§t und die davon erbenden Kind-Ger√§te werden in separaten Python-Dateien implementiert, welche in einem gemeinsamen Verzeichnis gespeichert werden.;0
 Kapitel X: Methodik  In der vorliegenden Arbeit wird eine umfassende Untersuchung der produktorientierten Metriken in der Softwarequalit√§t angestrebt. Um die vielschichtigen Aspekte dieser Metriken ad√§quat zu erfassen und auszuwerten, bedient sich diese Studie einer mehrmethodischen Herangehensweise. Im Folgenden werden die gew√§hlten Methoden detailliert beschrieben, um Transparenz √ºber den Prozess der Datenerhebung sowie der Datenanalyse zu schaffen.   1. Forschungsdesign  Diese Untersuchung folgt einem qualitativen Forschungsdesign, erg√§nzt durch quantitative Elemente zur Validierung der gewonnenen Erkenntnisse. Die Kombination beider Ans√§tze hat sich als sinnvoll erwiesen, um ein differenziertes Verst√§ndnis der Thematik zu entwickeln. Die qualitativen Daten werden vor allem durch Experteninterviews gewonnen, w√§hrend quantitative Daten durch Umfragen erhoben werden. Diese methodische Triangulation erm√∂glicht es, ein vielschichtiges Bild zu schaffen, das sowohl subjektive Erfahrungen als auch messbare Fakten umfasst.   2. Datensammlung   2.1 Experteninterviews  Ein zentraler Bestandteil der Datensammlung sind halbstrukturierte Interviews mit Software-Ingenieuren, Projektleitern und Qualit√§tssicherungsbeauftragten. Die Auswahl der Interviewpartner erfolgte bewusst, um eine hohe Expertise in Bezug auf produktorientierte Metriken zu gew√§hrleisten. Die Interviews wurden auf Grundlage eines Mix aus offenen und geschlossenen Fragen gestaltet, um Freiraum f√ºr pers√∂nliche Einsichten zu bieten, w√§hrend gleichzeitig gezielte Informationen erfragt wurden. Alle Interviews wurden mit Zustimmung der Teilnehmer aufgezeichnet und anschlie√üend transkribiert, um eine fundierte Analyse zu erm√∂glichen.   2.2 Schrittweise Umfragen  Erg√§nzend wurden quantitative Umfragen in der Form eines Onlinefragebogens durchgef√ºhrt. Ziel der Umfragen war es, eine breitere Datengrundlage zu schaffen und eine repr√§sentative Perspektive zu erhalten, die die Qualit√§ten produktorientierter Metriken beleuchtet. Der Fragebogen wurde so konzipiert, dass er die relevanten Dimensionen von Softwarequalit√§t und spezifische Anwendungsf√§lle der Metriken erfasst. Dabei dienten die gewonnenen Daten nicht nur zur Beschreibung der aktuellen Praxen, sondern wurden auch hinsichtlich ihrer Wirkung auf die Softwarequalit√§t oszilliert.   3. Datenanalyse  Die Analyse der qualitativen Daten erfolgt nach der Inhaltsanalyse, die es erm√∂glicht, systematisch die Kernthemen und Muster der Interviews zu identifizieren. Diese Methode umfasst mehrere Schritte: Zun√§chst erfolgt die √úbersicht durch Quellen, gefolgt von einer induktiven Kategorienbildung sowie letztlich der theoretischen Interpretation. Treibende Fragestellungen hierbei sind: Welche Einflussfaktoren werden auf die Anwendung produktorientierter Metriken identifiziert? Welche Herausforderungen und Vorteile werden benannt?  Die quantitativ ermittelten Befragungsergebnisse werden deskriptiv und zum Teil inferenzstatistisch ausgewertet. Durch die Verwendung statistischer Software wird es erm√∂glicht, die H√§ufigkeiten, Mittelwerte und Verteilungen der Antworten kontrolliert auszuwerten. Die Resultate werden in geeigneten Grafiken und Tabellen aufbereitet, um ein potentielles Verst√§ndnis f√ºr Zusammenh√§nge zu f√∂rdern und um die Validit√§t der Glossareingef√ºhrten Metrixheitskennzahlen darzustellen.   4. Limitationen der;1
Evaluierung: State of the Art beim Testen von MQTT-basierten L√∂sungen  Die vorliegende Evaluierung befasst sich mit dem aktuellen Stand der Technik im Bereich des Testens von L√∂sungen, die auf dem Message Queuing Telemetry Transport (MQTT) Protokoll basieren. MQTT hat sich als ein weit verbreitetes Protokoll f√ºr das Internet der Dinge (IoT) etabliert, da es eine effiziente und leichtgewichtige Kommunikation zwischen Ger√§ten erm√∂glicht. Die zunehmende Verbreitung von IoT-Anwendungen hat die Notwendigkeit verst√§rkt, robuste Testmethoden zu entwickeln, um die Zuverl√§ssigkeit, Sicherheit und Leistung dieser Systeme sicherzustellen.  Ein zentrales Element beim Testen von MQTT-basierten L√∂sungen ist die Ber√ºcksichtigung der spezifischen Herausforderungen, die mit der asynchronen Kommunikation und der eventgesteuerten Architektur einhergehen. Traditionelle Testmethoden, die in der Softwareentwicklung Anwendung finden, sind oft nicht ausreichend, um die Dynamik und die besonderen Anforderungen von MQTT-Anwendungen zu adressieren. Daher haben sich im Laufe der Zeit verschiedene Ans√§tze und Werkzeuge entwickelt, die speziell auf die Bed√ºrfnisse von MQTT abgestimmt sind.  Ein wesentlicher Bestandteil dieser Testmethoden ist das Last- und Performancetesting. Hierbei werden Szenarien simuliert, in denen eine Vielzahl von Clients gleichzeitig Nachrichten an einen Broker sendet und empf√§ngt. Tools wie Apache JMeter und Gatling haben sich als n√ºtzlich erwiesen, um die Leistungsf√§higkeit von MQTT-Brokern unter unterschiedlichen Lastbedingungen zu evaluieren. Diese Tests erm√∂glichen es, Engp√§sse und Schwachstellen in der Infrastruktur zu identifizieren, bevor sie in der Produktion auftreten.  Ein weiterer wichtiger Aspekt ist die Sicherheitstests von MQTT-Anwendungen. Angesichts der potenziellen Risiken, die mit der Vernetzung von Ger√§ten verbunden sind, ist es entscheidend, Sicherheitsl√ºcken fr√ºhzeitig zu erkennen. Verschiedene Frameworks, wie OWASP MQTT Security, bieten Richtlinien und Best Practices, um Sicherheitsanf√§lligkeiten zu identifizieren und zu beheben. Diese Tests konzentrieren sich auf Authentifizierung, Autorisierung und die Integrit√§t der √ºbermittelten Daten.  Integrationstests spielen ebenfalls eine zentrale Rolle im Testprozess von MQTT-basierten L√∂sungen. Diese Tests stellen sicher, dass die verschiedenen Komponenten einer Anwendung nahtlos zusammenarbeiten. Die Verwendung von Mock-Servern und simulierten Clients erm√∂glicht es, die Kommunikation zwischen den Komponenten zu √ºberpr√ºfen, ohne dass eine vollst√§ndige Produktionsumgebung eingerichtet werden muss.  Abschlie√üend l√§sst sich festhalten, dass der State of the Art beim Testen von MQTT-basierten L√∂sungen durch eine Kombination aus Lasttests, Sicherheitstests und Integrationstests gepr√§gt ist. Die Entwicklung spezialisierter Tools und Frameworks hat die Testbarkeit von MQTT-Anwendungen erheblich verbessert. Dennoch bleibt die kontinuierliche Forschung und Entwicklung in diesem Bereich unerl√§sslich, um den sich schnell √§ndernden Anforderungen des IoT gerecht zu werden. Zuk√ºnftige Entwicklungen sollten sich darauf konzentrieren, automatisierte Testverfahren weiter zu optimieren und neue Standards f√ºr die Qualit√§tssicherung in der MQTT-Kommunikation zu etablieren.;1
Eine allgemeing√ºltige Definition des Begriffs ‚ÄûContent‚Äú l√§sst sich in einschl√§giger Literatur und Online-Quellen nur schwer ausfindig machen. H√§ufig wird der Begriff des Content (zu deutsch ‚ÄûInhalt‚Äú) kontextabh√§ngig definiert und verwendet. Nach Sp√∂rrer l√§sst sich Content als ‚Äû maschinell erfassbares Produkt von Inhalt, Layout und Struktur‚Äú  zusammenfassen. Ferner l√§sst sich Content als eine Information beschreiben, die im Rahmen eines redaktionellen Prozesses erstellt wurde und letztlich f√ºr den menschlichen Konsum ver√∂ffentlicht wird. Im Rahmen der Organisation und Verwaltung von Gesch√§ftsdaten stehen Unternehmen ‚Äû einem Berg von Content in Form strukturierter und unstrukturierter Inhalte gegen√ºber. Sie sind kaum in der Lage, diesen Berg sinnvoll zu klassifizieren und k√∂nnen demzufolge nicht einsch√§tzen, ob er wertvolle Informationen enth√§lt oder nur ihre Datenablage ver- stopft. Zudem wissen sie oft nicht, wer Zugang zu Anwendungen hat und wer dar√ºber Kontrolle aus√ºbt. Informationsobjekte k√∂nnen in vielen Dokumenten enthalten sein, die Auswirkungen von √Ñnderungen und Aktualisierungen lassen sich aber gerade deshalb kaum √ºberblicken. Dieses Szenario macht die Bedeutung eines entsprechenden Managements deutlich.‚Äú  Ein Content Management System ( CMS) stellt dessen Anwendern eine Bandbreite an Funktionalit√§ten zur Verf√ºgung, die im Rahmen der effektiven Erstellung sowie der Pflege von Content respektive Inhalt relevant sind. Grundlegend sind CMSserverbasierte Softwa- reprodukte, die von mehreren Nutzern gleichzeitig verwendet werden k√∂nnen. Innerhalb dieser Produkte wird mit dem Inhalt interagiert. Zwangsl√§ufig muss dieser hierbei nicht auf demselben System liegen (logisch als auch physisch), sondern kann auch remote verwaltet werden.;0
Vor dem Erstellen des CMS wurde sich auch Gedanken √ºber das Design gemacht. Dazu wurden zwei Designkonzepte erstellt. Eines welches das Angular-Frontend beschreibt, an dem eine Pepper-Applikation erstellt werden kann. Das zweite Konzept ist f√ºr die Pepper-Applikation selber. Dort wird beschrieben was das Tablet auf der Brust von Pepper anzeigen soll. Im Folgenden werden beide Designkonzepte vorgestellt und erkl√§rt.;0
 Kapitel 3: √úberwachungstechniken im digitalen Zeitalter  Die digitale √úberwachung hat in den letzten zwei Jahrzehnten eine nie dagewesene Dimension erreicht. Mit der fortschreitenden Technologisierung und der zunehmenden Vernetzung von Ger√§ten und Plattformen sind neue √úberwachungstechniken entstanden, die sowohl Chancen als auch Risiken mit sich bringen. In diesem Kapitel werden verschiedene √úberwachungstechniken untersucht, die im Kontext der digitalen √úberwachung Anwendung finden, sowie deren potenzielle Auswirkungen auf die Privatsph√§re und die individuelle Freiheit.   3.1. Datenaggregation und -analyse  Eine der grundlegendsten Techniken der digitalen √úberwachung ist die Datenaggregation. Unternehmen und staatliche Institutionen sammeln massive Mengen an Daten √ºber Nutzerverhalten, Standortinformationen und Online-Interaktionen. Diese Daten werden oft in gro√üen Datenbanken gespeichert und mithilfe von Algorithmen analysiert, um Muster zu erkennen und Vorhersagen √ºber zuk√ºnftiges Verhalten zu treffen.   Beispielsweise nutzen soziale Medien und Suchmaschinen komplexe Algorithmen, um personalisierte Werbung zu schalten oder Inhalte anzuzeigen, die auf den Vorlieben und dem Verhalten der Nutzer basieren. Diese Form der √úberwachung erm√∂glicht es Unternehmen, gezielte Marketingstrategien zu entwickeln, birgt jedoch die Gefahr, dass pers√∂nliche Daten ohne das Wissen oder die Zustimmung der Nutzer gesammelt und verarbeitet werden.   3.2. Standort√ºberwachung  Die Standort√ºberwachung ist eine weitere weit verbreitete Technik, die durch die Verbreitung von Smartphones und GPS-Technologie erleichtert wird. Viele Anwendungen und Dienste erfordern den Zugriff auf Standortdaten, um ihre Funktionalit√§t zu gew√§hrleisten. Diese Informationen k√∂nnen jedoch auch von Dritten genutzt werden, um Bewegungsmuster und Aufenthaltsorte von Individuen zu verfolgen.  Die potenziellen Gefahren dieser Form der √úberwachung sind erheblich. Sie reicht von der Verletzung der Privatsph√§re bis hin zu physischen Bedrohungen, insbesondere wenn Standortdaten in die falschen H√§nde geraten. Zudem stellt sich die Frage, inwieweit Nutzer √ºber die Sammlung und Verwendung ihrer Standortdaten informiert sind und ob sie tats√§chlich die Kontrolle dar√ºber haben.   3.3. √úberwachung durch k√ºnstliche Intelligenz  K√ºnstliche Intelligenz (KI) hat das Potenzial, die digitale √úberwachung auf eine neue Ebene zu heben. Durch den Einsatz von Machine Learning und Bildverarbeitung k√∂nnen √úberwachungssysteme in Echtzeit analysieren, was in √∂ffentlichen R√§umen geschieht. Gesichtserkennungstechnologien werden zunehmend von Beh√∂rden eingesetzt, um Personen zu identifizieren und potenzielle Bedrohungen zu erkennen.  W√§hrend diese Technologien in der Lage sind, die √∂ffentliche Sicherheit zu erh√∂hen, werfen sie auch ethische und rechtliche Fragen auf. Die Genauigkeit von Gesichtserkennungssystemen ist umstritten, und es gibt Bedenken hinsichtlich der Diskriminierung und der falschen Identifizierung, insbesondere bei ethnischen Minderheiten. Zudem besteht die Gefahr, dass solche Technologien zur Massen√ºberwachung missbraucht werden, wodurch die individuelle Freiheit und die B√ºrgerrechte gef√§hrdet sind.   3.4. Internet of Things (IoT) und Smart Devices  Das Internet der Dinge (IoT) hat die Art und Weise, wie wir mit Technologie interagieren, revolutioniert. Smarte Ger√§te, von K√ºhlschr√§nken √ºber Thermost;1
Der Qualit√§tsbegriff wird durch die Norm DIN EN ISO 9000:2015 -11 definiert. Diese beschreibt  Qualit√§t als ‚ÄûGrad, in dem ein Satz inh√§renter Merkmale eines Objekts Anforderungen erf√ºllt‚Äú  . Haupts√§chlich befasst sich die Beurteilung von Softwarequalit√§t daher mit der Auswahl und  Spezifikation geeigneter Qualit√§tsmerkmale. Sowohl Boehm et al. und McCall et al. als auch die Norm  ISO/IEC 9126 definieren eine Reihe von Faktoren und Kriterien, die eine qualitativ hochwertige  Software auszeichnen  und diese messbar machen .  Unterschieden wird bei der Betrachtung  in die interne und externe Sichtweise sowie die  Benutzungsqualit√§t.  Bei der  inneren Qualit√§t wird die Software aus der Perspektive eines Entwicklers  beurteilt. Hierbei spielen besonders Kriterien eine wichtige Rolle, die die Wartungseigenschaften  verbessern. Im Gegensatz dazu besch√§ftigt sich die √§u√üere Qualit√§t mit Anforderungen , die durch die  Kunden entstehen. Die beiden Sichtweisen sind eng miteinander verwoben. Besonders die innere  Qualit√§t nimmt Einfluss auf die √§u√üere Qualit√§t, da diese auf deren Eigenschaften aufbaut. Die  sogenannte ‚ÄûQuality in Use‚Äú wird separat betrachtet und verfolgt weiterf√ºhrende Ziele, die bei der  Benutzung der Software durch die User relevant sind. Diese Sicht der Qualit√§t kann nicht durch  Messungen an der Software selbst bestimmt werden, sondern werden erst bei der Ausf√ºhrung in  einem spezifischen Kon text bewertet.    Codequalit√§t ist ein Teilaspekt der Softwarequalit√§t. Unter dem √ºbergeordneten Begriff  Softwarequalit√§t werden  wie bereits erl√§utert  vielf√§ltige  Sichtweisen und Anforderungen  zusammengefasst. Hierbei werden  nicht nur die Quellcodedateien , sondern auch weitere Artefakte  wie Dokumentationen oder Entw√ºrfe betrachtet.  Aus diesem Grund erstreckt sich Softwarequalit√§t  √ºber alle Phasen der Entwicklung un d bezieht auch die Prozessqualit√§t mit ein. Codequalit√§t befasst  sich mit der Abdeckung der geforderten Qualit√§tsmerkmale innerhalb des Codes  und besteht  insbesondere aus nicht -funktionalen Anforderungen . Damit bildet sie einen Teil der inneren Qualit√§t  eines Produkts ab.  Erf√ºllt der Quellcode die  genannten  Eigenschaften, tr√§gt dies zu einer Steigerung  der gesamten Softwarequalit√§t bei.;0
Ein Konzept zur Umsetzung    Die fortschreitende Technologisierung im Bereich der Mobilit√§t f√ºhrt zu einem zunehmenden Interesse an innovativen L√∂sungen, die sowohl die Sicherheit als auch die Effizienz im Stra√üenverkehr verbessern k√∂nnen. Eine vielversprechende Entwicklung ist die Fahrzeugfernsteuerung, die durch moderne Kommunikationsprotokolle unterst√ºtzt wird. Insbesondere das IEEE 802.15-Protokoll, welches f√ºr drahtlose pers√∂nliche Netzwerke (WPAN) konzipiert wurde, bietet eine geeignete Grundlage f√ºr die Implementierung von Fahrzeugfernsteuerungen mit integrierten Kollisionsvermeidungssystemen. Dieser Text skizziert ein Konzept zur Umsetzung einer solchen Technologie.  Technologischer Hintergrund  IEEE 802.15 umfasst verschiedene Standards f√ºr drahtlose Kommunikationsnetzwerke, darunter Bluetooth und Zigbee. Diese Protokolle zeichnen sich durch geringe Energieaufnahme, hohe Flexibilit√§t und eine relativ einfache Implementierung aus. F√ºr die Entwicklung einer Fahrzeugfernsteuerung ist es entscheidend, dass die Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug in Echtzeit erfolgt, um eine reaktionsschnelle Steuerung zu gew√§hrleisten. Die Integration eines Kollisionsvermeidungssystems erfordert zus√§tzlich die Verarbeitung von Sensordaten, um potenzielle Gefahren im Umfeld des Fahrzeugs zu identifizieren und zu analysieren.  Konzept zur Umsetzung  1. Systemarchitektur     Die geplante Systemarchitektur umfasst drei Hauptkomponentendas Steuerger√§t, das Fahrzeug und die Sensoreinheiten. Das Steuerger√§t, das sich beispielsweise auf einem Smartphone oder einem speziellen Handheld-Ger√§t befinden kann, sendet Steuerbefehle √ºber das IEEE 802.15-Protokoll an das Fahrzeug. Das Fahrzeug ist mit einem Mikrocontroller ausgestattet, der die empfangenen Befehle interpretiert und die entsprechenden Steuerkomponenten (z.B. Motor, Lenkung) aktiviert. Die Sensoreinheiten, die um das Fahrzeug angeordnet sind, erfassen Umgebungsdaten wie Hindernisse, andere Fahrzeuge und Fu√üg√§nger.  2. Datenkommunikation     Die Kommunikation zwischen den Komponenten erfolgt √ºber ein robustes, drahtloses Netzwerk, das auf dem IEEE 802.15-Standard basiert. Um Latenzzeiten zu minimieren, wird eine Peer-to-Peer-Kommunikation implementiert, die es dem Fahrzeug erm√∂glicht, direkt mit dem Steuerger√§t zu kommunizieren. Zudem wird ein Protokoll zur Fehlererkennung und -korrektur entwickelt, um die Zuverl√§ssigkeit der Daten√ºbertragung zu gew√§hrleisten.  3. Kollisionsvermeidungssystem     Das Kollisionsvermeidungssystem basiert auf der Fusion von Daten, die von verschiedenen Sensoren wie Lidar, Radar und Kameras bereitgestellt werden. Diese Sensoren erfassen die Umgebung des Fahrzeugs in Echtzeit und liefern Informationen √ºber potenzielle Gefahren. Ein Algorithmus zur Objekterkennung und -verfolgung analysiert die Sensordaten und ermittelt die Position und Geschwindigkeit der Hindernisse. Bei drohenden Kollisionen kann das System automatisch Brems- oder Lenkman√∂ver einleiten, um eine Kollision zu vermeiden.  4. Sicherheitsas;1
Situation 4 und 5 : In der Abbildung 3.3 ist der Verlauf der CO 2-Konzentration im Raum w√§hrend einer dreist√ºndigen Vorlesung mit und ohne vorherige L√ºftung dargestellt. Es gibt kein gro√üer Unterschied zwischen den beiden Verl√§ufen. Mit einer einst√ºndigen L√ºftung liegt nach drei Stunden Vorlesung die CO 2-Konzentration bei circa 8500 ppmund ohne L√ºftung bei circa 8000 ppm, obwohl die Luftwechselrate den gleichen Wert betr√§gt (0.6 1/h). Abbildung 3.3: Verlauf der CO 2-Konzentration w√§hrend Situation 4 und 5 Situation 6 : In der Abbildung 3.4 ist der Verlauf der CO 2-Konzentration im Raum zwischen das Ende der Vorlesung und den Beginn der Reinigung abgebildet. Es wird angenommen, dass bis das Reinigungspersonal angekommen ist, der Raum nicht gel√ºftet wurde. In dem Diagramm ist zu sehen, dass die CO 2-Konzentration im Raum ohne L√ºftung nahezu eine gute Luftqualit√§t (1800 ppm) erreicht hat. Abbildung 3.4: Verlauf der CO 2-Konzentration vor Situation 6;0
Das Ergebnis der Messung ist in Abbildung 5.35zu sehen. Wie dort abgebildet, so sind 1950 der insgesamt 1982 Messpunkte, die √ºber einen Zeitverlauf von 10 Minuten gesam- melt wurden unter 10 Mikrosekunden, was einem Anteil von 98.39% entspricht. 98.99% der Werte liegen unter der kritischen Latenzschwelle von 100 Millisekunden. Lediglich 20 Werte √ºberschreiten diesen Grenzwert. Wie in der statistischen √úbersicht in Abbil- dung5.36zu sehen ist, betr√§gt die maximale Latenz 349.75 Millisekunden, was √ºber der in den Anforderung definierten maximalen Latenz von 200ms liegt. Ein Blick auf die Details der Messdaten verr√§t jedoch, das lediglich 2 Messpunkte √ºber den 200ms lie- gen und der Gro√üteil der Messwerte (97.72%) eine Latenz von drei Mikrosekunden aufweist. Insgesamt ist festzustellen, dass 97.72% der Messwerte eine sehr gute Latenz von nur drei Mikrosekunden aufweisen und 98.99% der Messwerte unterhalb der Schwelle von 100ms liegen, oberhalb von 200ms sind sogar nur 2 Messwerte zu finden. Diese Ergebnisse decken sich mit den Beobachtungen aus der Demonstration am Prototy- pen, bei dem keine wahrnehmbare Latenz festgestellt werden konnte. Die Ausnahme dazu stellt die Durchf√ºhrung einer Kollisionsvermeidung dar, w√§hrend der bei der Bremsung f√ºr 1s keine Eingaben von der Fernsteuerung am Fahrzeugcontroller bearbeitet werden. F√ºr den Versuch spielt dies jedoch keine Rolle, da dort w√§hrend der Aufzeichnung der Ergebnisse keine durchgef√ºhrte Kollisionsvermeidung beobachtet werden konnte (siehe Abschnitt 5.8.1). Als Erkl√§rungsm√∂glichkeit f√ºr die zwei sehr hohen Messwerte lassen sich aktuell nur Messfehler in Betracht ziehen. Unter der Bedingung, dass die zwei hohen Messwerte als Messfehler betrachtet werden, werden die Latenzanforderung an die entwickelte Fernsteue- rung erf√ºllt.;0
Evaluierung: Gegen√ºberstellung von Content-Management-Systemen  In der modernen digitalen Landschaft spielen Content-Management-Systeme (CMS) eine zentrale Rolle. Sie dienen nicht nur als Plattformen zum Erstellen, Verwalten und Organisieren von digitalen Inhalten, sondern erm√∂glichen es auch Organisationen, ihre Online-Pr√§senz effizient zu steuern. Die vorliegende Arbeit nimmt die Analyse und Gegen√ºberstellung verschiedener etablierter CMS in den Fokus und zielt darauf ab, deren Eignung f√ºr unterschiedliche Anwendungsf√§lle zu bewerten.   Die Wahl des richtigen CMS ist essenziell und insbesondere von der jeweiligen Zielgruppe, den spezifischen Anforderungen der Nutzer sowie den technischen Ressourcen abh√§ngig. Zu den am h√§ufigsten eingesetzten Systemen z√§hlen WordPress, Joomla, Drupal und Typo3. Jedes dieser Systeme bringt seine eigenen St√§rken und Schw√§chen mit, die im Rahmen dieser Evaluierung detailliert beleuchtet werden.  WordPress, als das meistverwendete CMS weltweit, hebt sich durch seine Benutzerfreundlichkeit und die umfassende Plugin- und Themenlandschaft hervor. Es eignet sich hervorragend f√ºr Blogs und kleinere Unternehmenswebseiten, st√∂√üt jedoch bei der Verwaltung umfangreicher Inhalte oder bei h√∂chsten Sicherheitssanforderungen an seine Grenzen. Die Flexibilit√§t des Systems ist unbestritten, jedoch gibt es hin und wieder Bedenken hinsichtlich der Sicherheit und Performance bei stark frequentierten Seiten.  Joomla stellt eine solide Alternative dar und bietet im Vergleich zu WordPress einen balancierteren Ansatz zwischen Benutzerfreundlichkeit und Funktionalit√§t. Es ist besonders vorteilhaft f√ºr soziale Netzwerke und E-Commerce-Seiten, erfordert jedoch eine steilere Lernkurve. Hier kann die Eingabe komplexer Inhalte erh√∂hte Anforderungen an die technische Kompetenz der Nutzer stellen.  Drupal hingegen f√ºhrt die Rangliste in Bezug auf Flexibilit√§t und Anpassungsm√∂glichkeiten an. Es erm√∂glicht komplexe, ma√ügeschneiderte Installationen und ist ein bevorzugtes System f√ºr umfangreiche Websites mit umfangreichen Benutzerberechtigungen. Weitreichende Kenntnis der Programmiersprache PHP ist jedoch notwendig, um vollen Nutzen aus den leistungsstarken Funktionen zu ziehen, was den Zugang f√ºr weniger technikaffine Nutzer erschwert.  Typos3 schlie√ülich hebt sich mit seinem Enterprise-Ansatz ab und eignet sich hervorragend f√ºr gro√üe Unternehmen mit vielf√§ltigen Content-Management-Anforderungen. Die modulare Architektur erm√∂glicht individuelle Anpassungen, birgt jedoch auch die Komplexit√§t, die mit der Konfiguration und Pflege des Systems einhergeht. Obgleich es ihnen erlauben kann, umfangreiche und skalierbare L√∂sungen zu erstellen, f√ºhrt der F√∂rderbedarf in der-bootstrap sowohl in Pflege als auch in der Implementierung oftmals zu h√∂heren Personalkosten.  Es ist zudem erw√§hnenswert, dass all diese Systeme stetig weiterentwickelt werden. Sicherheitsupdates, neue Features und √Ñnderungen im Nutzerverhalten f√ºhren. Daher bedarf die Evaluierung nicht nur einer einmalige Untersuchung, sondern einer kontinuierlichen Analyse, um die vorherrschende Relevanz und Effizienz der unterschiedlichen Systeme aufrechterhalten zu k√∂nnen.  Zusammenfassend l√§sst sich sagen, dass die Wahl des geeigneten CMS stark von den individuellen Bed√ºrfnissen und Zielen einer Organisation abh√§ngt. Die vorliegende Evaluierung bietet somit einen umfassenden Ansatz zur informierten Entscheidungsfindung und zeigt auf, welche Aspekte bei der Auswahl zu ber√ºcksichtigen sind. Ziel ist es,;1
 State of the Art beim Testen von MQTT-basierten L√∂sungen     Die zunehmende Vernetzung von Ger√§ten im Internet der Dinge (IoT) hat die Entwicklung effizienter Kommunikationsprotokolle hervorgebracht, die den spezifischen Anforderungen dieser Technologien gerecht werden. Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich aufgrund seiner Leichtgewichtigkeit und Effizienz zu einer der bevorzugten L√∂sungen entwickelt. Angesichts der wachsenden Verbreitung von MQTT-basierten Anwendungen ist es entscheidend, Standardisierungen im Testprozess zu implementieren, um die Zuverl√§ssigkeit, Sicherheit und Skalierbarkeit dieser Systeme zu gew√§hrleisten. In diesem Beitrag werden die theoretischen Grundlagen des Testens von MQTT-basierten L√∂sungen behandelt und ein √úberblick √ºber die aktuellen Methoden und Techniken gegeben.    von MQTT  MQTT ist ein Publish-Subscribe-basierter Messaging-Dienst, der f√ºr die Kommunikation zwischen Ger√§ten mit eingeschr√§nkten Ressourcen optimiert ist. Die Kernelemente dieses Protokolls umfassen- ClientEin Ger√§t, das MQTT-Nachrichten senden oder empfangen kann. - BrokerEine zentrale Instanz, die als Vermittler zwischen den Clients fungiert und die Nachrichtenverteilung verwaltet. - Themen (Topics)Hierarchische Adressierung von Nachrichten, die es Clients erm√∂glicht, gezielt Informationen zu abonnieren oder zu ver√∂ffentlichen.  Diese Architektur, die asynchrone Kommunikationsmethoden integriert, erfordert spezifische Teststrategien, um sicherzustellen, dass Nachrichten effizient und fehlerfrei zwischen den Clients und dem Broker √ºbertragen werden.   Teststrategien f√ºr MQTT-basierten L√∂sungen  1. Unit-TestsDie √úberpr√ºfung individueller Komponenten der MQTT-Implementierung ist von zentraler Bedeutung. Unit-Tests validieren die Funktionalit√§t von Publishern, Subscriber-Logik und der Broker-Konfiguration. Besonderes Augenmerk sollte auf das Error-Handling gelegt werden, da die Robustheit gegen Kommunikationsfehler entscheidend f√ºr den Betrieb von IoT-Anwendungen ist.  2. IntegrationstestsDiese Tests konzentrieren sich auf die Interaktion zwischen verschiedenen Systemkomponenten. Bei MQTT-basierten L√∂sungen m√ºssen Tests die Effizienz und Latenz der Nachrichtenauslieferung zwischen Clients und Broker √ºberpr√ºfen. Hierbei spielen auch Netzwerkbedingungen wie Bandbreitenbeschr√§nkungen und Latenzzeiten eine Rolle, um realistische Einsatzszenarien zu simulieren.  3. Leistungs- und LasttestsAngesichts der potentiellen Skalierbarkeit von MQTT-L√∂sungen ist die Leistungs√ºberpr√ºfung essenziell. Lasttests simulieren eine Vielzahl von gleichzeitigen Verbindungen und messen die maximale Last, die der Broker verarbeiten kann. Wichtige Kennzahlen sind die Nachrichten√ºbertragungsrate und die Latenz, die dazu beitragen, die Effizienz und Antwortzeiten des Systems zu charakterisieren.  4. SicherheitstestsAufgrund der hohen Anzahl vernetzter Ger√§ten und der Sensibilit√§t der zu √ºbertragenden Daten ist die √úberpr√ºfung der Sicherheit von MQTT-L√∂sungen unerl√§sslich. Tests m√ºssen Sicherheitsprotokolle wie TLS/SSL zur Verschl√ºsselung von Nachrichten und Authentifizierungsmechanismen (z.B. Benutzername/Passwort, JWT-Token) √ºberpr√ºfen. Dar√ºber hinaus sind Penetrationstests wichtig, um potenzielle Schwachstellen im System zu identifizieren.  5. Testing in virtuellen UmgebungenDer Einsatz von simulierten Broker-Umgebungen und Test-Clients erm√∂glicht es, ein kontrolliertes Testumfeld zu schaffen. Tools wie Mosquitto f√ºr den Broker und alternative Mock-Client-Bibliotheken erm√∂glichen das Testen unter verschiedenen Bedingungen, ohne dass physische Ger√§te erforderlich sind.   Fazit  Der Ausbau und die Etablierung von robusten Testing-Methoden f√ºr MQTT-basierte L√∂sungen ist von grundlegender Bedeutung f√ºr die Akzeptanz und die Zuverl√§ssigkeit von IoT-Anwendungen. W√§hrend sich die theoretischen Grundlagen des MQTT-Protokolls weiterentwickeln, ist es wichtig, dass Teststrategien ebenfalls kontinuierlich optimiert werden, um den steigenden Anforderungen an Sicherheit, Effizienz und Leistung gerecht zu werden. Zuk√ºnftige Forschungen sollten sich auf die Automatisierung des Testens, die Integration von Machine Learning f√ºr die Anomalieerkennung und die Entwicklung umfassender Standardisierungen konzentrieren, die zu einer Verbesserung der Qualit√§t von MQTT-basierten L√∂sungen f√ºhren.;1
Ein Konzept zur Umsetzung    St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen, insbesondere bei √§lteren Menschen. Die schnelle Erkennung und Reaktion auf St√ºrze kann entscheidend f√ºr die Minimierung von Verletzungen und die Verbesserung der Lebensqualit√§t sein. In diesem Kontext gewinnt die In-room Ortung mithilfe von Bluetooth-Technologie zunehmend an Bedeutung. Dieser Prosatext skizziert ein Konzept zur Umsetzung einer Sturzerkennungsl√∂sung, die auf Bluetooth-gest√ºtzten In-room Ortungssystemen basiert.  Technologische Grundlagen  Die zugrunde liegende Technologie dieser L√∂sung beruht auf der Verwendung von Bluetooth Low Energy (BLE), das sich durch niedrigen Energieverbrauch und hohe Reichweite auszeichnet. BLE erm√∂glicht die Kommunikation zwischen verschiedenen Ger√§ten, wobei die Position von Objekten oder Personen in einem Raum durch die Analyse der Signalst√§rke (RSSI ‚Äì Received Signal Strength Indicator) bestimmt wird. Um eine pr√§zise Ortung zu gew√§hrleisten, wird ein Netzwerk von Bluetooth-Beacons in der Umgebung installiert.  Systemarchitektur  Das geplante System besteht aus mehreren Komponenten 1. Bluetooth-BeaconsDiese Ger√§te werden strategisch in den R√§umen platziert, um ein dichtes Netzwerk zu schaffen. Die Beacons senden regelm√§√üig Signale aus, die von tragbaren Ger√§ten, wie beispielsweise Smartwatches oder speziellen Armb√§ndern, empfangen werden.  2. Tragbare Ger√§teDie Nutzer tragen ein Bluetooth-f√§higes Ger√§t, das kontinuierlich die Signale der Beacons erfasst. Diese Ger√§te sind mit Sensoren ausgestattet, die Daten √ºber Bewegung, Beschleunigung und Sturzereignisse sammeln.  3. Zentrale DatenverarbeitungDie gesammelten Daten werden an eine zentrale Einheit gesendet, die die Informationen in Echtzeit analysiert. Hierbei kommen Algorithmen zur Mustererkennung zum Einsatz, die zwischen normalen Bewegungen und St√ºrzen unterscheiden k√∂nnen.  4. BenachrichtigungssystemIm Falle eines erkannten Sturzes wird automatisch eine Benachrichtigung an Pflegepersonal oder Angeh√∂rige gesendet. Dies kann √ºber eine mobile App, SMS oder ein anderes Kommunikationsmittel erfolgen.  Algorithmische Implementierung  Die Entwicklung eines robusten Algorithmus zur Sturzerkennung ist entscheidend f√ºr den Erfolg des Systems. Hierbei sind verschiedene Ans√§tze denkbar - Maschinelles LernenDurch das Training von Modellen mit historischen Bewegungsdaten kann das System lernen, typische Sturzbewegungen zu identifizieren. Hierbei k√∂nnen Techniken wie Entscheidungsb√§ume oder neuronale Netze eingesetzt werden.  - Regelbasierte SystemeEine alternative Herangehensweise k√∂nnte die Definition spezifischer Schwellenwerte f√ºr Beschleunigung und Bewegung umfassen, die auf empirischen Daten basieren. Diese Regelungen m√ºssen jedoch sorgf√§ltig kalibriert werden, um Fehlalarme zu minimieren.  Implementierungsstrategie  Die Umsetzung des Konzepts erfolgt in mehreren Phasen 1. PilotstudieZun√§chst sollte eine Pilotstudie in einer kontrollierten Umgebung durchgef√ºhrt werden, um die Funktionalit√§t des Systems zu testen und erste Daten zu sammeln.  2. Feedback-SchleifenDie R√ºckmeldungen von Nutzern und Pflegepersonal sind entscheid;1
 Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die rasante Entwicklung der Robotik und der k√ºnstlichen Intelligenz hat die Integration humanoider Roboter in verschiedene Lebensbereiche vorangetrieben. Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat sich als vielseitiges Werkzeug in der Interaktion mit Menschen etabliert. Um die Nutzung und Anpassung von Anwendungen f√ºr Pepper zu erleichtern, ist der Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps von entscheidender Bedeutung. Diese Arbeit beleuchtet die grundlegenden Aspekte eines solchen Systems und gibt einen Ausblick auf m√∂gliche Weiterentwicklungen.   Grundlagen eines CMS f√ºr Pepper  Ein CMS zur Erstellung von Android Apps f√ºr Pepper sollte eine benutzerfreundliche Oberfl√§che bieten, die es Entwicklern und Nicht-Entwicklern erm√∂glicht, interaktive Anwendungen zu erstellen, ohne tiefgehende Programmierkenntnisse zu ben√∂tigen. Die Kernkomponenten eines solchen Systems umfassen 1. Modularer AufbauDas CMS sollte modular gestaltet sein, sodass verschiedene Funktionen und Module je nach Bedarf hinzugef√ºgt oder entfernt werden k√∂nnen. Dies erm√∂glicht eine flexible Anpassung der Apps an spezifische Anforderungen und Einsatzszenarien.  2. Visuelle EntwicklungsumgebungEine grafische Benutzeroberfl√§che, die Drag-and-Drop-Funktionalit√§ten unterst√ºtzt, k√∂nnte es Nutzern erm√∂glichen, Funktionen und Inhalte einfach zu integrieren. Diese visuelle Entwicklungsumgebung sollte auch Vorlagen und Beispiele enthalten, um den Einstieg zu erleichtern.  3. Integration von K√ºnstlicher IntelligenzUm die Interaktivit√§t und Anpassungsf√§higkeit von Apps zu erh√∂hen, sollte das CMS KI-gest√ºtzte Module integrieren, die es Pepper erm√∂glichen, auf Benutzeranfragen und -verhalten zu reagieren. Dies k√∂nnte durch die Implementierung von Natural Language Processing (NLP) und maschinellem Lernen erreicht werden.  4. Cloud-basierte SpeicherungEine cloud-basierte Infrastruktur w√ºrde es erm√∂glichen, Anwendungen zentral zu speichern, zu verwalten und zu aktualisieren. Dies erleichtert die Zusammenarbeit zwischen verschiedenen Entwicklern und die Bereitstellung von Updates f√ºr bestehende Apps.  5. Sicherheits- und DatenschutzmechanismenDa humanoide Roboter in sensiblen Umgebungen eingesetzt werden, ist es unerl√§sslich, dass das CMS robuste Sicherheits- und Datenschutzmechanismen implementiert, um die Daten der Nutzer zu sch√ºtzen.   Ausblick auf m√∂gliche Weiterentwicklungen  Die Entwicklung eines CMS f√ºr Pepper ist nicht das Ende, sondern vielmehr der Beginn eines kontinuierlichen Innovationsprozesses. Zuk√ºnftige Weiterentwicklungen k√∂nnten folgende Aspekte umfassen 1. Erweiterung der Plattformkompatibilit√§tZuk√ºnftige Versionen des CMS k√∂nnten die Unterst√ºtzung f√ºr andere Plattformen und Betriebssysteme integrieren, um eine breitere Palette von Robotern und Ger√§ten anzusprechen. Dies w√ºrde die Interoperabilit√§t und den Austausch von Anwendungen zwischen verschiedenen Robotermodellen f√∂rdern.  2. Erweiterte Funktionen durch IoT-IntegrationDie Integration des Internets der Dinge (IoT) k√∂nnte es erm√∂glichen, dass Pepper mit anderen vernetzten Ger√§ten kommuniziert und so komplexere Aufgaben bew√§ltigt. Apps k√∂nnten dann in Echtzeit Daten von Sensoren und anderen Ger√§ten nutzen, um die;1
 Technologischer Grundlagenteil   Einleitung  Die Entwicklung von Fahrzeugfernsteuerungen ist ein vielversprechendes Forschungsfeld, das durch die fortschreitende Technologie in den Bereichen Automobilindustrie, Robotik und Kommunikationssysteme zunehmend an Bedeutung gewinnt. Im Rahmen dieser Arbeit wird eine Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis des IEEE 802.15 Standards untersucht. Dieser Grundlagenteil beleuchtet die technologische Basis, die f√ºr die Realisierung einer solchen L√∂sung ben√∂tigt wird.   1. √úberblick √ºber Fahrzeugfernsteuerungssysteme  Fahrzeugfernsteuerungssysteme erm√∂glichen die Steuerung von Fahrzeugen √ºber eine Distanz, was durch Technologien wie drahtlose Kommunikation, autonome Systeme und Echtzeitdatenverarbeitung realisiert wird. Solche Systeme finden Anwendung in verschiedenen Bereichen, wie z.B. beim autonomen Fahren, in der Logistik und bei ferngesteuerten Fahrzeugen f√ºr Suche und Rettung.   1.1. Systeme zur Kollisionsvermeidung  Kollisionsvermeidungssysteme sind essenziell f√ºr die Sicherheit in der Fahrzeugsteuerung. Sie nutzen verschiedene Sensoren und Algorithmen, um potenzielle Kollisionen fr√ºhzeitig zu erkennen und geeignete Ma√ünahmen einzuleiten. Zu den typischen Technologien geh√∂ren Lidar, Radar und Kamerasysteme, die in Kombination mit Algorithmen zur Bildverarbeitung und maschinellem Lernen eingesetzt werden.   2. Drahtlose Kommunikationstechnologien  Die drahtlose Kommunikation spielt eine zentrale Rolle in der Entwicklung von Fahrzeugfernsteuerungssystemen. Der IEEE 802.15 Standard definiert verschiedene Protokolle f√ºr die drahtlose Kommunikation im kurzreichweitigen Umfeld, darunter auch Bluetooth Low Energy (BLE) und Wireless Personal Area Networks (WPAN).   2.1. IEEE 802.15 und seine Protokolle  IEEE 802.15 befasst sich mit der Entwicklung von Standards f√ºr die drahtlose Kommunikation in pers√∂nlichen Netzwerken. Dabei bieten diese Protokolle Schl√ºsselmerkmale wie: - Geringer Energieverbrauch: Besonders relevant f√ºr mobile und tragbare Ger√§te. - Hohe √úbertragungsgeschwindigkeiten: Erm√∂glichen die √úbertragung von gro√üen Datenmengen in Echtzeit. - Robuste Kommunikation: Widerspruchsresistenz gegen√ºber St√∂rungen durch andere Funksignale.   2.1.1. Bluetooth Low Energy (BLE) BLE ist ein energiesparendes Protokoll aus der IEEE 802.15 Familie, das f√ºr Anwendungen mit geringem Datenaufkommen konzipiert wurde. Es erm√∂glicht die drahtlose Verbindung von Ger√§ten √ºber kurze Distanzen und ist ideal f√ºr den Einsatz in Fahrzeugsteuerungssystemen, da es eine Kombination aus niedriger Latenz, geringer Energieaufnahme und effektiver Reichweite bietet.   3. Sensorik zur Kollisionsvermeidung  F√ºr die effektive Implementierung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung sind verschiedene Sensoren notwendig, um die Umgebung des Fahrzeugs in Echtzeit zu erfassen.   3.1. Sensorarten   3.1.1. Lidar Lidar (Light Detection and Ranging) nutzt Laserstrahlen zur Erstellung eines 3D-Modells der Umgebung. Es erlaubt eine pr√§zise Erfassung von Entfernungen und Hindernissen in der Umgebung.   3.1.2. Radar Radar verwendet elektromagnetische Wellen zur Objekterkennung und ist besonders n√ºtzlich bei schlechten Sichtverh√§ltnissen.   3.1.3. Kamerasysteme Kamerasysteme kombinieren Bilderkennung mit Algorithmen des maschinellen Lernens, um sowohl statische als auch dynamische Objekte im Sichtfeld zu analysieren.   4. Algorithmen zur Datenverarbeitung  Um die von den Sensoren erfassten Daten zu verarbeiten, werden fortschrittliche Algorithmen ben√∂tigt. Diese umfassen: - Echtzeit-Datenanalyse: Schnelle Verarbeitung von Sensordaten zur zeitnahen Reaktion des Systems. - Entscheidungsfindung: Verwendung von Machine Learning-Methoden zur vorhersagenden Analyse von Bewegungsmustern und potenziellen Kollisionsszenarien. - Pilotsteuerungssysteme: Algorithmen zur Umsetzung der Entscheidung durch Befehle an das Fahrzeugsteuerungssystem.   Fazit  Die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 erfordert ein integriertes Verst√§ndnis der drahtlosen Kommunikationstechnologien, der eingesetzten Sensorik sowie der Algorithmen zur Datenverarbeitung. Die Kombination dieser technologischen Elemente erm√∂glicht die Realisierung effektiver und sicherer Steuerungssysteme, die den Herausforderungen der modernen Mobilit√§t gerecht werden. In den folgenden Abschnitten dieser Arbeit werden spezifische Implementierungsdetails und Teststrategien f√ºr das entwickelnde System behandelt.;1
   Die rasante Entwicklung des Internets der Dinge (IoT) hat die Notwendigkeit hervorgebracht, robuste und skalierbare Plattformen f√ºr die Entwicklung von IoT-Anwendungen zu identifizieren. ElixirNerves ist ein Framework, das es Entwicklern erm√∂glicht, IoT-Ger√§te mithilfe der Programmiersprache Elixir zu erstellen. Dieser Prosatext befasst sich mit der Evaluation des ElixirNerves-Frameworks und zieht ein Fazit √ºber dessen Eignung als Plattform f√ºr IoT-Anwendungen.   Technologische Grundlagen  Elixir ist eine funktionale Programmiersprache, die auf der Erlang Virtual Machine (BEAM) basiert. Diese Architektur verleiht Elixir erhebliche Vorteile in Bezug auf Parallelit√§t, Verf√ºgbarkeit und Fehlertoleranz. Nerves erweitert diese Eigenschaften, indem es eine spezialisierte Umgebung f√ºr die Entwicklung von IoT-Anwendungen bietet. Es erm√∂glicht die Nutzung einer Vielzahl von Hardwareplattformen und unterst√ºtzt die Erstellung von Firmware, die effizient auf Ger√§ten mit begrenzten Ressourcen l√§uft.   Evaluationskriterien  F√ºr die Evaluation von ElixirNerves wurden mehrere Kriterien herangezogen, darunter 1. Entwicklerproduktivit√§tDie Geschwindigkeit, mit der Entwickler Prototypen und Anwendungen erstellen k√∂nnen. 2. SkalierbarkeitDie F√§higkeit der Plattform, mit wachsenden Datenmengen und Benutzeranforderungen umzugehen. 3. Gemeinschaft und Unterst√ºtzungVerf√ºgbarkeit von Dokumentationen, Bibliotheken und Community-Support. 4. PerformanceEffizienz im Ressourcenverbrauch und Geschwindigkeit der Datenverarbeitung. 5. SicherheitRobustheit gegen potenzielle Angriffe und Sicherheitsl√ºcken.   Ergebnisse der Evaluation  Die Evaluation von ElixirNerves hat ergeben, dass die Entwicklerproduktivit√§t durch die Nutzung von Elixirs klar strukturiertem und lesbarem Syntax erheblich gesteigert wird. Insbesondere erm√∂glicht die Nutzung von bestehenden Bibliotheken und Tools, wie Phoenix und Ecto, eine schnellere Implementierung komplexer Funktionalit√§ten.  In Bezug auf die Skalierbarkeit bietet ElixirNerves die M√∂glichkeit, Mikroservices zu implementieren, die unabh√§ngig voneinander skaliert werden k√∂nnen. Diese Struktur ist besonders vorteilhaft f√ºr IoT-Anwendungen, die in der Regel mehrere Ger√§te und Sensoren integrieren m√ºssen.  Die Unterst√ºtzung der Community ist ebenfalls als stark zu bewerten. Die vorhandene Dokumentation ist umfassend, und die Community hat sich als hilfsbereit erwiesen. Die Vielzahl an Open-Source-Bibliotheken erleichtert die Implementierung g√§ngiger IoT-Funktionalit√§ten enorm.  Die Performance von Nerves ist im Allgemeinen hoch, da das Framework speziell f√ºr ressourcenbeschr√§nkte Ger√§te optimiert ist. Durch die Verwendung von BEAM wird eine hohe Effizienz bei der parallelen Verarbeitung von Anfragen erzielt. Kritische Latenzen weisen viele IoT-Anwendungen auf, doch ElixirNerves kann diese durch seine Architektur minimieren.  Schlie√ülich hat die Untersuchung der Sicherheitsmerkmale von ElixirNerves gezeigt, dass die Framework-Architektur viele bew√§hrte Sicherheitspraktiken integriert. Die dezentrale Natur der BEAM-Architektur unterst√ºtzt au√üerdem die Isolation von Prozessen, wodurch das Risiko, dass ein Sicherheitsvorfall auf das gesamte System Auswirkungen hat, reduziert wird.   Fazit  Zusammenfassend l√§sst sich sagen, dass ElixirNerves eine vielversprechende Plattform f√ºr die Entwicklung von IoT-Anwendungen darstellt. Die Evaluation zeigt, dass die Plattform nicht nur die Entwicklungsproduktivit√§t erh√∂ht, sondern auch hohe Skalierbarkeit, gute Performance und umfassende Sicherheitsmerkmale aufweist. Die Unterst√ºtzung durch eine aktive Community und die Verf√ºgbarkeit zahlreicher Ressourcen machen ElixirNerves zu einer attraktiven Wahl f√ºr Entwickler, die L√∂sungen im IoT-Bereich anstreben.   In Anbetracht dieser Aspekte und der stetigen Weiterentwicklung sowohl von Elixir als auch von Nerves l√§sst sich feststellen, dass diese Plattform nicht nur f√ºr aktuelle IoT-Anwendungen geeignet ist, sondern auch eine langfristige Perspektive in einem sich schnell entwickelnden Technologiemarkt bietet. Zuk√ºnftige Forschungsarbeiten k√∂nnten sich darauf konzentrieren, spezifische Fallstudien zu untersuchen, um weitere Anwendungsf√§lle und Best Practices f√ºr ElixirNerves im IoT-Kontext zu identifizieren.;1
Die Videos wurden mit 30 FPS aufgenommen. Das Raspberry Pi schafft es jedoch nicht 30 Bilder in einer Sekunde auf Katzen zu untersuchen, da dessen Rechenleistung zu schwach ist. Wenn das Raspberry Pi beispielsweise f√ºnf Bilder pro Sekunde verarbeiten k√∂nnte, dann w√ºrde das Raspberry von den 30 Frames nur jedes sechste Bild aufnehmen. Damit das Ergebnis der Modelltests m√∂glichst realit√§tsnah ist, m√ºssen die Videos an jedes einzelne Modell angepasst werden. Daf√ºr muss die FPS-Anzahl des Raspberry Pi unter Verwendung des Modells bekannt sein. Mithilfe derer kann die Rate an Frames (s. Gleichung 4.1) berechnet werden. Die Gleichung besagt welches Frame betrachtet werden soll. Die anderen werden verworfen. So werden bei den weiteren Messungen nur die Frames verwendet, die das Raspberry auch aufnehmen w√ºrde. F√ºr die FPS-Messungen, wird als erstes das jeweilige Video und Modell geladen. Anschlie- √üend wird jedes einzelne Frame des Videos nacheinander, durch das KNN, verarbeitet. Falls die Wahrscheinlichkeit, dass sich eine Katze auf dem Bild befindet, gr√∂√üer als 30% ist, wird ausgegeben an welcher Stelle sich eine Katze befindet. Da zu jedem Bild eine prozentuale Wahrscheinlichkeit einer erkannten Katze existiert, muss eine Grenze definiert werden. Da in diesem Fall nur ‚Äûleichtgewichtete‚Äú CNN-Modelle verwendet werden k√∂nnen, wird die Grenze gering gehalten. Schlie√ülich wird die Katze mithilfe der Lokalisierungsdaten durch ein Rechteck markiert. Dieser Prozess wiederholt sich f√ºr jedes Frame des Videos. Dabei wird die durchschnittliche FPSAnzahl berechnet. Die Implementierung daf√ºr ist in Abbildung 4.6 dargestellt. Schlussendlich wird die durchschnittliche FPSAnzahl jedes Modells anhand aller original Videos bestimmt. Das Ergebnis ist in Abbildung 4.7 zu sehen. Dabei hat das Modell SSD Mobilenet v3 small mit ca. 6,5 FPS am besten abgeschnitten.;0
In dieser wissenschaftlichen Arbeit wurde die Bedeutung produktorientierter Metriken f√ºr die Softwarequalit√§t umfassend untersucht und dargestellt. Die Definition dieser Metriken umfasst verschiedene Dimensionen der Softwarequalit√§t, darunter Funktionalit√§t, Zuverl√§ssigkeit, Usability und Effizienz. Die Analyse hat gezeigt, dass produktorientierte Metriken nicht nur f√ºr die Bewertung des aktuellen Qualit√§tsstandards von Softwareprodukten entscheidend sind, sondern auch als Steuerungsinstrumente zur kontinuierlichen Verbesserung fungieren.  Durch die Anwendung dieser Metriken k√∂nnen Softwareentwickler und -manager gezielte Entscheidungen treffen, die sowohl die technische Exzellenz als auch die Benutzerzufriedenheit f√∂rdern. Die Arbeit hat zudem deren Rolle im Kontext agiler Entwicklungsmethoden und DevOps-Ans√§tzen beleuchtet, wo schnelles Feedback und iterative Entwicklung von zentraler Bedeutung sind.   Dar√ºber hinaus wurde die Relevanz von standardisierten Metriken hervorgehoben, die den Vergleich von Produkten und Dienstleistungen innerhalb und zwischen Organisationen erm√∂glichen. Diese Kriterien sind unerl√§sslich, um Transparenz und Nachvollziehbarkeit in der Qualit√§tssicherung zu gew√§hrleisten.  Insgesamt l√§sst sich festhalten, dass produktorientierte Metriken eine fundamentale Rolle im Prozess der Softwareentwicklung spielen. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, neue Metriken zu entwickeln, die den sich st√§ndig wandelnden Anforderungen der Technologiebranche gerecht werden, sowie die Integration von Metriken in automatisierte Test- und Deployment-Prozesse weiter zu optimieren. Letztlich wird die konsequente Anwendung produktorientierter Metriken zur Steigerung der Softwarequalit√§t und zur langfristigen Wettbewerbsf√§higkeit von Unternehmen beitragen.;1
Je nach Komplexit√§t erh√∂ht ein ILF, EIF, EI, EO und EQ die FP um eine feste Punktzahl. Die  genauen Punktzahlen lauten:  Komplexit√§t ILF EIF EI EO EQ  Gering 7 5 3 4 3  Mittel 10 7 4 5 4  Hoch 15 10 6 7 6  Tabelle 6: FP von ILFs, EIFs, EIs, EOs und EQs Die Listen aller ermittelten ILFs, EIs, EOs und EQs befinden sich im Anhang. Da auf keine  Fremdsysteme zugegriffen wird, sind keine EIFs vorhanden.   Typ Geringe  Komplexit√§t Mittlere  Komplexit√§t Hohe  Komplexit√§t Function Points  ILF 6 1 0 52  EIF 0 0 0 0  EI 14 5 3 80  EO 0 2 0 10  EQ 6 4 0 34  Tabelle 7: Anzahl der Elemente mit geringer, mittlerer und hoher Komplexit√§t und daraus resultierende Function Points  Die Summe der Function Points betr√§gt somit 176. Diese k√∂nnen in mehrere Formel n  eingesetzt werden, um Prognosen √ºber die Dauer einer Entwicklung oder d er daf√ºr  notwendigen Entwickler*innen zu treffen. Die notwendigen Entwickler*innen werden  gesch√§tzt, indem die ermittelten Function Points durch 150 geteilt werden. Dies bedeutet, dass die Anwendung mit etwa ein bis zwei Entwickler*innen realisiert  werden k√∂nnen.  Die zweite vorgestellte Formel kann die notwendige Entwicklungszeit in  Monaten absch√§tzen.  Hierf√ºr werden die ermittelten Function Points mit der Zahl 0,4 potenziert. Die gesch√§tzte Anwendung k√∂nnte demzufolge von einer Person in knapp 8 Mo naten  entwickelt werden.  Diese Zahl kann jedoch vom tats√§chlich notwendigen Aufwand  abweichen. Da nur die Anforderungen formuliert worden sind, kann laut  des Prinzips des  ‚ÄûCone of Uncertainity‚Äú die Sch√§tzung um 50% zu hoch oder ein Drittel zu niedrig ausfallen. Zudem k√∂nnten die seit 2011 weiterentwickelten Technologien, wie   beispielsweise Frameworks, dazu beitragen, den Entwicklungsaufwand deutlich zu senken.  Andererseits muss beachtet werden, dass Sicherheitsaspekte in der Sch√§tzung nicht beachtet  worden sind, diese werden den Aufwand f√ºr die Entwicklung der Applikation erh√∂hen.;0
 Ausblick  In der vorliegenden Arbeit wurde die Entwicklung einer Fahrzeugfernsteuerung mit integriertem Kollisionsvermeidungssystem auf Basis des IEEE 802.15 Standards untersucht. Die durchgef√ºhrten Analysen und Tests haben gezeigt, dass die Umsetzung eines solchen Systems nicht nur technisch machbar ist, sondern auch signifikante Fortschritte in der Sicherheit und Benutzerfreundlichkeit von Fernsteuerungen f√ºr Fahrzeuge verspricht.  Im Ausblick auf zuk√ºnftige Forschungs- und Entwicklungsarbeiten ergeben sich mehrere spannende Perspektiven:  1. Erweiterungen der Technologie: Zuk√ºnftige Studien k√∂nnten sich darauf konzentrieren, das System um zus√§tzliche Sensoren und Technologien zu erweitern, wie z.B. LiDAR oder Kameras, um die Umgebung noch pr√§ziser zu erfassen. Dies k√∂nnte die Effizienz und Genauigkeit der Kollisionsvermeidung verbessern und eine robustere Entscheidungsfindung erm√∂glichen.  2. Optimierung der Kommunikationsprotokolle: Eine eingehende Analyse und Optimierung der Kommunikationsprotokolle innerhalb des IEEE 802.15 Standards k√∂nnte zu einer besseren Daten√ºbertragung und niedrigeren Latenzzeiten f√ºhren, was insbesondere bei komplexen Fahrszenarien von Vorteil w√§re.  3. Pr√ºfung unter realen Bedingungen: In der vorliegenden Arbeit wurden die Konzepte und Prototypen im Laborumfeld getestet. Zuk√ºnftige Forschungen sollten sich auf Feldversuche konzentrieren, um die Leistungsf√§higkeit des Systems unter realen Betriebsbedingungen zu evaluieren. Hierbei k√∂nnten auch Tests in verschiedenen Umgebungen (z.B. st√§dtisch vs. l√§ndlich) ber√ºcksichtigt werden.  4. Integration von Machine Learning: Der Einsatz von Machine Learning-Algorithmen zur Verbesserung der Entscheidungsfindung in der Kollisionsvermeidung k√∂nnte ein vielversprechender Ansatz sein. Durch das Trainieren von Modellen auf Basis von realen Fahrdaten k√∂nnte das System lernen, besser auf unerwartete Situationen zu reagieren.  5. Regulatorische und ethische √úberlegungen: Die Entwicklung von Ladeverfahren und Sicherheitsprotokollen sollte begleitet werden durch eine Diskussion √ºber die regulatorischen Rahmenbedingungen und ethischen Implikationen des Einsatzes von Fernsteuerungssystemen in Fahrzeugen. Dies umfasst sowohl die Haftungsfragen im Falle eines Unfalles als auch die Akzeptanz solcher Technologien in der Gesellschaft.  6. Interoperabilit√§t mit anderen Systemen: Die Integration und Interoperabilit√§t mit anderen Fahrzeugtechnologien, wie autonomem Fahren oder V2X (Vehicle-to-Everything) Kommunikation, bietet einen interessanten Forschungsbereich. Hier k√∂nnte untersucht werden, wie die Fernsteuerungssysteme synergistisch mit anderen fortschrittlichen Fahrassistenzsystemen zusammenarbeiten k√∂nnen.  Zusammenfassend l√§sst sich sagen, dass die zuk√ºnftige Forschung nicht nur technologische Innovationen vorantreiben sollte, sondern auch die Studien zu benutzerzentrierten Designs, Sicherheitsstandards und den sozialen Auswirkungen der Fahrzeugfernsteuerung intensivieren sollte. Durch diese ganzheitliche Betrachtung kann das volle Potenzial der entwickelten Technologien ausgesch√∂pft werden, um ein sicheres und effektives Fahrerlebnis zu gew√§hrleisten.;1
"Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung  In der heutigen digitalen √Ñra sind wir Zeugen eines tiefgreifenden Wandels in der Art und Weise, wie Informationen erfasst, verarbeitet und genutzt werden. Die digitale √úberwachung, oft als ""Zero"" bezeichnet, spielt eine zentrale Rolle in diesem Wandel. Der Begriff ""Zero"" bezieht sich dabei nicht nur auf den Zustand der Abwesenheit von Kontrolle, sondern vielmehr auf die umfassende und oft unsichtbare √úberwachung, die in nahezu allen Aspekten unseres Lebens stattfindet. Die theoretischen Grundlagen dieser digitalen √úberwachung sind vielschichtig und erfordern eine differenzierte Betrachtung der M√∂glichkeiten und Gefahren, die sie mit sich bringt.  Ein grundlegendes Konzept, das in der Diskussion um digitale √úberwachung h√§ufig zitiert wird, ist das der Panoptikums von Michel Foucault. In seinem Werk ""√úberwachen und Strafen"" beschreibt Foucault ein Gef√§ngnisdesign, das es einem Aufseher erm√∂glicht, alle Insassen jederzeit zu beobachten, ohne dass diese wissen, ob sie tats√§chlich √ºberwacht werden. Dieses Konzept l√§sst sich auf die digitale Welt √ºbertragen, in der Algorithmen und Datenanalyse es erm√∂glichen, Verhaltensmuster in Echtzeit zu beobachten und zu analysieren. Die M√∂glichkeit, nahezu alles zu √ºberwachen, schafft eine neue Form der sozialen Kontrolle, die sowohl die individuellen Freiheiten als auch die gesellschaftlichen Normen beeinflussen kann.  Ein weiterer theoretischer Rahmen, der die Diskussion um digitale √úberwachung pr√§gt, ist die Theorie der ""Surveillance Capitalism"", wie sie von Shoshana Zuboff formuliert wurde. Zuboff argumentiert, dass Unternehmen und Regierungen Daten als eine neue Form von Kapital betrachten, die zur Vorhersage und Manipulation menschlichen Verhaltens eingesetzt werden kann. Diese Perspektive beleuchtet die wirtschaftlichen Anreize hinter der digitalen √úberwachung und die potenziellen Gefahren, die mit einer solchen Kommerzialisierung von Daten verbunden sind. Die Erhebung und Analyse von Daten erm√∂glicht es, Profile von Individuen zu erstellen, die weit √ºber das hinausgehen, was diese bereitwillig preisgeben w√ºrden. Die daraus resultierenden Machtverh√§ltnisse k√∂nnen zu einer Erosion der Privatsph√§re und zu einer verst√§rkten Kontrolle √ºber das Individuum f√ºhren.  Die theoretischen Grundlagen der digitalen √úberwachung werfen auch Fragen zur Ethik und zur gesellschaftlichen Verantwortung auf. Die utilitaristische Ethik, die den gr√∂√ütm√∂glichen Nutzen f√ºr die gr√∂√ütm√∂gliche Anzahl von Menschen betont, k√∂nnte argumentieren, dass digitale √úberwachung zur Sicherheit und zum Schutz der Gesellschaft beitr√§gt. Allerdings stellt sich die Frage, ob der Preis f√ºr diese Sicherheit, n√§mlich der Verlust von Privatsph√§re und Autonomie, gerechtfertigt ist. Kritiker dieser Sichtweise betonen, dass eine solche Kosten-Nutzen-Analyse oft die Stimmen und Erfahrungen marginalisierter Gruppen ignoriert, die √ºberproportional von √úberwachung betroffen sind.  Zusammenfassend l√§sst sich sagen, dass die theoretischen Grundlagen der digitalen √úberwachung ein komplexes Zusammenspiel von Macht, Kontrolle, Ethik und Wirtschaftlichkeit darstellen. W√§hrend die M√∂glichkeiten, die durch digitale √úberwachung entstehen, weitreichend sind ‚Äì von der Verbesserung der √∂ffentlichen Sicherheit bis hin zur Optimierung von Dienstleistungen ‚Äì sind die Gefahren";1
      Die zunehmende Komplexit√§t und Dynamik in der Softwareentwicklung erfordert effektive Werkzeuge, um den √úberblick √ºber Aufgaben und Projekte zu behalten. Insbesondere im Kontext des studentischen Software Engineerings, wo Lernende oft in Teams arbeiten, ist ein strukturiertes Aufgabenmanagement von entscheidender Bedeutung. Diese Arbeit zielt darauf ab, die theoretischen Grundlagen einer Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zu beleuchten, das speziell auf die Bed√ºrfnisse von Studierenden im Software Engineering ausgerichtet ist.    der Anforderungsanalyse  Die Anforderungsanalyse ist ein fundamentaler Schritt im Softwareentwicklungsprozess und bildet die Grundlage f√ºr die erfolgreiche Implementierung von Softwarel√∂sungen. Sie umfasst die Identifikation, Dokumentation und Validierung der Anforderungen an ein System. Nach Sommerville (2011) k√∂nnen Anforderungen in funktionale und nicht-funktionale Anforderungen unterteilt werden. Funktionale Anforderungen beschreiben, was das System tun soll, w√§hrend nicht-funktionale Anforderungen Aspekte wie Benutzerfreundlichkeit, Leistung und Zuverl√§ssigkeit betreffen.   1. Funktionale Anforderungen  Im Kontext eines Aufgabenmanagement-Tools f√ºr studentisches Software Engineering k√∂nnten funktionale Anforderungen folgende Aspekte umfassen - AufgabenverwaltungDie M√∂glichkeit, Aufgaben zu erstellen, zu bearbeiten, zu l√∂schen und zu kategorisieren. Studierende sollten in der Lage sein, Aufgaben nach Priorit√§t, F√§lligkeit und Status zu filtern.    - Team-KollaborationFunktionen zur Unterst√ºtzung der Zusammenarbeit im Team, wie z.B. die Zuweisung von Aufgaben an Teammitglieder, Kommentarfunktionen und die M√∂glichkeit, Dokumente zu teilen.  - ZeitmanagementDie Integration von Zeitpl√§nen und Fristen, um Studierenden zu helfen, ihre Zeit effektiv zu verwalten und Deadlines einzuhalten.  - FortschrittsverfolgungMechanismen zur √úberwachung des Fortschritts einzelner Aufgaben und des Gesamtprojekts, einschlie√ülich visuelle Darstellungen wie Gantt-Diagramme oder Kanban-Boards.   2. Nicht-funktionale Anforderungen  Nicht-funktionale Anforderungen sind ebenso wichtig, um die Benutzerakzeptanz und die Effektivit√§t des Tools sicherzustellen. Zu den relevanten nicht-funktionalen Anforderungen k√∂nnten geh√∂ren - BenutzerfreundlichkeitDas Tool sollte intuitiv bedienbar sein, um eine schnelle Einarbeitung zu erm√∂glichen. Eine klare und ansprechende Benutzeroberfl√§che ist entscheidend, um die Lernkurve f√ºr Studierende zu minimieren.  - Zug√§nglichkeitDas Tool sollte auf verschiedenen Ger√§ten und Plattformen verf√ºgbar sein, um den unterschiedlichen Arbeitsgewohnheiten der Studierenden gerecht zu werden.  - Sicherheit und DatenschutzDa Studierende oft an sensiblen Projekten arbeiten, sind Sicherheitsaspekte und der Schutz pers√∂nlicher Daten von gro√üer Bedeutung.  - Leistungsf√§higkeitDas Tool sollte in der Lage sein, auch bei einer gro√üen Anzahl von Aufgaben und Benutzern performant zu arbeiten, ohne dass die Benutzererfahrung leidet.   Methodik der Anforderungsanalyse  Die Anforderungsanalyse kann durch verschiedene Methoden durchgef√ºhrt werden, darunter Interviews, Umfragen und Workshops mit den Zielbenutzern;1
Konzept f√ºr eine wissenschaftliche Arbeit: Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Einleitung  In der heutigen Zeit gewinnen intelligente Systeme, insbesondere im Bereich des Internet of Things (IoT), zunehmend an Bedeutung. Die Automatisierung allt√§glicher Aufgaben durch den Einsatz von Technologie bietet nicht nur Komfort, sondern auch innovative L√∂sungen f√ºr spezifische Herausforderungen im Tiermanagement. Diese Arbeit widmet sich der Entwicklung eines IoT-Systems zur Steuerung einer Katzenklappe, das durch eine KI-basierte Katzenerkennung unterst√ºtzt wird. Ziel ist es, eine sichere und benutzerfreundliche L√∂sung f√ºr Katzenbesitzer zu schaffen, die den Zugang ihrer Tiere zu bestimmten Bereichen optimiert und gleichzeitig unerw√ºnschte Besucher ausschlie√üt.  Problemstellung  Katzen sind von Natur aus neugierige Tiere, die oft in der Umgebung umherstreifen. Dies kann jedoch auch zu Problemen f√ºhren, wie etwa dem ungewollten Zugang zu fremden Tieren oder der Gefahr, dass die Katze nicht rechtzeitig ins Haus zur√ºckkehrt. Traditionelle Katzenklappen bieten keine M√∂glichkeit zur Identifikation des Tieres und k√∂nnen somit von anderen Tieren oder sogar Menschen missbraucht werden. Daher besteht die Notwendigkeit, ein intelligentes System zu entwickeln, das eine pr√§zise Identifikation der Katze erm√∂glicht und gleichzeitig die Sicherheit und den Komfort f√ºr das Tier und den Besitzer gew√§hrleistet.  Ziele der Arbeit  1. Entwicklung eines IoT-Systems: Konzeption und Implementierung einer Katzenklappe, die √ºber das Internet steuerbar ist und mit verschiedenen Sensoren ausgestattet ist.     2. Integration einer KI-gest√ºtzten Katzenerkennung: Einsatz von Computer Vision und maschinellem Lernen zur Identifikation der Katze, basierend auf ihrem Aussehen oder spezifischen Merkmalen.  3. Benutzeroberfl√§che: Gestaltung einer intuitiven Benutzeroberfl√§che f√ºr die Steuerung der Katzenklappe, die es den Besitzern erm√∂glicht, den Zugang zu √ºberwachen und zu steuern.  4. Sicherheitsaspekte: Analyse und Implementierung von Sicherheitsma√ünahmen, um sicherzustellen, dass nur autorisierte Tiere Zugang erhalten.  Methodik  Die Arbeit gliedert sich in mehrere Phasen:  1. Literaturrecherche: Untersuchung bestehender Systeme zur Katzenerkennung und -steuerung sowie Analyse der aktuellen Technologien im Bereich IoT und KI.  2. Systemdesign: Entwurf des Systems, einschlie√ülich der Hardwarekomponenten (Sensoren, Aktuatoren, Mikrocontroller) und der Softwarearchitektur (Datenverarbeitung, KI-Modelle, Benutzeroberfl√§che).  3. Implementierung: Aufbau des Prototyps, Programmierung der Software und Integration der KI-Algorithmen zur Katzenerkennung.  4. Testphase: Durchf√ºhrung von Tests zur Validierung der Funktionalit√§t und Effizienz des Systems, einschlie√ülich der Genauigkeit der Katzenerkennung und der Reaktionszeit der Klappe.  5. Evaluation: Analyse der Testergebnisse und Anpassungen am System basierend auf den gewonnenen Erkenntnissen.  Erwartete Ergebnisse  Die Arbeit erwartet die Entwicklung eines funktionalen Prototyps eines IoT-Systems, das die Katzenerkennung zuverl√§ssig umsetzt und eine benutzerfreundliche Steuerung;1
Die Abbildung 5.1 zeigt das Men√º der Katzenklappen App. Hier werden die angelegten Kat- zenklappen dargestellt. Des Weiteren k√∂nnen √ºber das ‚ÄûHinzuf√ºgen‚Äú-Symbol im unteren Teil des Men√ºs neue Katzenklappen mit der App gekoppelt werden. Beim Hinzuf√ºgen einer Katzenklappe muss der Benutzer einen frei w√§hlbaren Namen und den eindeutigen Schl√ºs- sel des Raspberry Pi, welcher die Katzenklappe steuert, eingeben. Anschlie√üend erfolgt eine Pr√ºfung des eingegebenen Schl√ºssels, welche sp√§ter noch genauer beschrieben wird. Beim erfolgreichen Hinzuf√ºgen einer Katzenklappe wird daraufhin auf das zur Katzenklappe passende Topic in der Firebase Datenbank abonniert. Dies dient dazu, bei einer erfolg- reichen Erkennung einer Katze, eine Nachricht auf das Smartphone gesendet zu bekommen. Abbildung 5.2: Ansicht einer Katzenklappe Im Mockup in Abbildung 5.2 kann die Detailansicht der Katzenklappe gesehen werden. In ihr wird bei einer erfolgreich erkannten Katze ein Bild, welches von der Kamera am Raspberry Pi aufgenommen wurde, angezeigt. Wenn der Nutzer sich dazu entscheidet, dass es sich um seine Katze handelt kann er durch einen Knopfdruck die Katzenklappe √∂ffnen.;0
Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Alltagsgegenst√§nden haben das Konzept des Internet der Dinge (IoT) in den letzten Jahren ma√ügeblich gepr√§gt. Dieses Konzept erm√∂glicht es, intelligente Systeme zu entwickeln, die den Alltag sowohl f√ºr Menschen als auch f√ºr Tiere bereichern k√∂nnen. In dieser Arbeit wird ein innovatives IoT-System vorgestellt, das die Steuerung einer Katzenklappe mittels einer KI-basierten Katzenerkennung realisiert.   Katzen sind beliebte Haustiere, die sowohl im Innen- als auch im Au√üenbereich leben. Ihre Bewegungsfreiheit zu f√∂rdern, ist f√ºr das Wohlbefinden der Tiere entscheidend, gleichzeitig sind jedoch auch Sicherheitsaspekte zu ber√ºcksichtigen. Traditionelle Katzenklappen sind oft unzuverl√§ssig und lassen ungebetene G√§ste, wie andere Tiere oder unbefugte Personen, herein. Die Implementierung eines intelligenten Systems, das Katzen durch KI-gest√ºtzte Bilderkennung identifiziert, stellt eine vielversprechende L√∂sung dar, um Haustieren nicht nur einen sicheren Zugang zu gew√§hren, sondern auch die Kontrolle f√ºr die Besitzer zu verbessern.  Ziel dieser Arbeit ist es, die notwendigen Voraussetzungen f√ºr die Entwicklung eines solchen Systems zu analysieren, die technischen Komponenten zu beschreiben und deren Integration zu erl√§utern. Au√üerdem wird die Genauigkeit der Katzenerkennung untersucht und bewertet, um die Praktikabilit√§t und Effizienz des Systems zu garantieren. Durch die Kombination von IoT-Technologie und K√ºnstlicher Intelligenz soll ein funktionales und benutzerfreundliches Produkt geschaffen werden, das sowohl den Bed√ºrfnissen von Katzen als auch ihrer Besitzer gerecht wird. Die Ergebnisse dieser Arbeit tragen nicht nur zur gegenw√§rtigen Forschung im Bereich der smarten Haustierl√∂sungen bei, sondern er√∂ffnen auch neue Perspektiven f√ºr zuk√ºnftige Entwicklungen in der Mensch-Tier-Interaktion.;1
 Kapitel 2: Technische Grundlagen des Bodenfeuchtigkeitstrackings mit LoRaWAN und The Things Network (TTN)   2.1 Einf√ºhrung in das Tracking der Bodenfeuchtigkeit  Die √úberwachung der Bodenfeuchtigkeit ist ein entscheidender Faktor in der Landwirtschaft, der Umwelt√ºberwachung und der Hydrologie. Sie erm√∂glicht eine pr√§zise Steuerung der Bew√§sserung, die Optimierung der Ernteertr√§ge und das Verst√§ndnis hydrologischer Prozesse. Traditionell wurden zur Messung der Bodenfeuchtigkeit invasive Methoden eingesetzt, die oft teuer und zeitaufwendig waren. Mit der Entwicklung von drahtlosen Sensornetzwerken und modernen Kommunikationstechnologien wie LoRaWAN (Long Range Wide Area Network) hat sich die Landschaft der Bodenfeuchtigkeits√ºberwachung jedoch erheblich ver√§ndert. Dieses Kapitel untersucht die technischen Grundlagen, die dem Tracking der Bodenfeuchtigkeit mit LoRaWAN und der Plattform The Things Network (TTN) zugrunde liegen.   2.2 LoRaWAN: Eine √úbersicht  LoRaWAN ist ein Low-Power Wide Area Network (LPWAN) Protokoll, das speziell f√ºr die Kommunikation √ºber lange Distanzen bei minimalem Energieverbrauch entwickelt wurde. Es ist besonders geeignet f√ºr Anwendungen, bei denen Sensoren √ºber gro√üe Fl√§chen verteilt sind, wie es bei der Bodenfeuchtigkeitsmessung der Fall ist. Die Hauptmerkmale von LoRaWAN sind:  - Reichweite: LoRaWAN erm√∂glicht Kommunikationsdistanzen von mehreren Kilometern in l√§ndlichen Gebieten und bis zu 2-5 km in st√§dtischen Umgebungen. - Energieeffizienz: Sensoren, die mit LoRaWAN kommunizieren, k√∂nnen mit minimalem Energieverbrauch betrieben werden, was ihre Lebensdauer auf mehrere Jahre verl√§ngert. - Skalierbarkeit: LoRaWAN-Netzwerke k√∂nnen eine gro√üe Anzahl von Ger√§ten unterst√ºtzen, was sie ideal f√ºr umfassende Monitoring-L√∂sungen macht.  Die Architektur von LoRaWAN besteht aus drei Hauptkomponenten: den Endger√§ten (Sensoren), den Gateways und dem Netzwerkserver. Die Sensoren erfassen die Bodenfeuchtigkeit und senden diese Daten √ºber das Gateway an den Netzwerkserver, der die Daten verwaltet und f√ºr die weitere Analyse aufbereitet.   2.3 The Things Network (TTN)  The Things Network ist eine offene, dezentrale Plattform, die die Implementierung und den Betrieb von LoRaWAN-Netzwerken erleichtert. TTN bietet eine benutzerfreundliche Schnittstelle f√ºr die Registrierung von Ger√§ten, das Management von Gateways und die Verarbeitung von Sensordaten. Zu den zentralen Merkmalen von TTN geh√∂ren:  - Offene Infrastruktur: TTN erm√∂glicht es Benutzern, ihre eigenen Gateways zu betreiben und sich mit anderen Gateways im Netzwerk zu verbinden, was zu einer erweiterten Netzabdeckung f√ºhrt. - Datenverarbeitung: TTN bietet Funktionen zur Datenverarbeitung und -visualisierung, die es Benutzern erm√∂glichen, die gesammelten Informationen effizient zu analysieren und zu nutzen. - Community-Engagement: Die TTN-Community f√∂rdert den Austausch von Wissen und Erfahrungen, was die Entwicklung neuer Anwendungen und L√∂sungen vorantreibt.   2.4 Sensoren zur Bodenfeuchtigkeitsmessung  Zur Messung der Boden;1
Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Ausblick auf m√∂gliche Weiterentwicklungen  Die rapide Expansion des Internets der Dinge (IoT) hat zu einem verst√§rkten Interesse an robusten und flexiblen Plattformen gef√ºhrt, die die Entwicklung, Implementierung und Wartung von IoT-Anwendungen unterst√ºtzen k√∂nnen. ElixirNerves ist eine der vielversprechendsten Technologien in diesem Bereich. Basierend auf der Programmiersprache Elixir und der Erlang VM bietet Nerves eine modulare und leistungsf√§hige Basis f√ºr die Entwicklung eingebetteter Systeme. Diese Evaluation befasst sich mit den aktuellen F√§higkeiten von ElixirNerves sowie einem Ausblick auf potenzielle Weiterentwicklungen, die seine Nutzung in der IoT-Landschaft weiter vorantreiben k√∂nnten.  Ein zentrales Merkmal von ElixirNerves ist seine F√§higkeit, stabilen Code f√ºr die Entwicklung von IoT-Ger√§ten bereitzustellen. Die Plattform erm√∂glicht Entwicklern die Erstellung von ausfallsicheren, verteilten Systemen mit einer hohen Verf√ºgbarkeit, was f√ºr viele IoT-Anwendungen von entscheidender Bedeutung ist. Durch die Nutzung der Erlang VM erbt Nerves deren herausragende Qualit√§ten in Bezug auf Fehlertoleranz und nebenl√§ufige Verarbeitung, wodurch es f√ºr kritische IoT-Anwendungen, wie etwa in der Gesundheits√ºberwachung oder industriellen Steuerungssystemen, besonders geeignet ist.  Aktuell ist die Entwicklung auf ElixirNerves durch eine gut unterst√ºtzte Community und eine Vielzahl von Bibliotheken erleichtert, die spezifische Funktionalit√§ten abdecken. Diese reichen von Netzwerkkommunikation √ºber das Management von Hardwarekomponenten bis hin zur Anbindung an Cloud-Dienste. Der modulare Aufbau erm√∂glicht eine einfache Anpassung und Erweiterung bestehender L√∂sungen, was die Entwicklungskosten und -zeiten erheblich reduzieren kann.   Dennoch gibt es einige Herausforderungen und Bereiche mit Entwicklungspotenzial, die f√ºr die zuk√ºnftige Nutzung von ElixirNerves von Bedeutung sind. Zun√§chst erfordert die Einarbeitung in die komplexe Infrastruktur und die spezifischen Bibliotheken f√ºr Nerves Zeit und Ressourcen. Eine verst√§rkte Fokussierung auf die Dokumentation und benutzerfreundliche Tutorials k√∂nnte die Zug√§nglichkeit f√ºr neue Entwickler erh√∂hen und das Wachstum der Community f√∂rdern.  Ein weiterer Bereich, in dem ElixirNerves weiterentwickelt werden k√∂nnte, ist die Integration von Machine Learning (ML) und K√ºnstlicher Intelligenz (KI). Angesichts der zunehmenden Bedeutung von datengetriebenen Entscheidungen in IoT-Anwendungen w√§re die Schaffung von Bibliotheken oder APIs, die die Implementierung von ML-Modellen direkt auf IoT-Ger√§ten erm√∂glichen, ein entscheidender Fortschritt. Solche Funktionen k√∂nnten nicht nur die Reaktionsf√§higkeit und Intelligenz von IoT-Systemen erh√∂hen, sondern auch Bandbreitenanforderungen reduzieren, indem weniger Daten an zentrale Server gesendet werden.  Ein drittes Feld f√ºr zuk√ºnftige Innovationen ist die Sicherheit von IoT-Ger√§ten. Da IoT-Anwendungen oft in sensiblen Bereichen eingesetzt werden, ist die Gew√§hrleistung von Datensicherheit und Datenschutz von h√∂chster Priorit√§t. ElixirNerves k√∂nnte von einer fokussierten Weiterentwicklung in Bezug auf Sicherheitsprotokolle und Verschl√ºsselungstechniken profitieren, um die Integrit√§t und Vertraulichkeit der √ºbertragenen Daten zu gew√§hrleisten.  Abschlie√üend l√§sst sich festhalten, dass ElixirNerves als Plattform f√ºr IoT-Anwendungen bereits beeindruckende Funktionalit√§ten bietet und sich als zuverl√§ssige Grundlage f√ºr die Entwicklung eingebetteter Systeme etabliert hat. Zuk√ºnftige Entwicklungen in den Bereichen Benutzerfreundlichkeit, Integration von KI/ML und Sicherheitsma√ünahmen werden entscheidend sein, um seine Reichweite und Anwendungsm√∂glichkeiten weiter zu erweitern. In einer Zeit, in der die Nachfrage nach intelligenten und sicheren IoT-L√∂sungen exponentiell w√§chst, hat ElixirNerves das Potenzial, eine zentrale Rolle in der Weiterentwicklung dieser Technologien zu spielen.;1
In der vorliegenden Arbeit wurde die Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t umfassend untersucht. Die Analyse hat gezeigt, dass produktorientierte Metriken, die sich auf die Eigenschaften und Merkmale der Softwareprodukte selbst konzentrieren, eine zentrale Rolle bei der Bewertung der Softwarequalit√§t spielen. Diese Metriken erm√∂glichen es, objektive und quantifizierbare Informationen √ºber verschiedene Aspekte der Software zu gewinnen, wie etwa die Modularit√§t, Wartbarkeit, Lesbarkeit und Effizienz des Codes.  Ein wesentliches Ergebnis dieser Arbeit ist, dass die Implementierung produktorientierter Metriken nicht nur die Qualit√§t der Softwareprodukte verbessert, sondern auch den gesamten Softwareentwicklungsprozess optimiert. Durch den Einsatz dieser Metriken k√∂nnen Entwickler fr√ºhzeitig potenzielle Probleme identifizieren und gezielte Ma√ünahmen zur Qualit√§tssicherung ergreifen. Dies f√ºhrt nicht nur zu einer h√∂heren Kundenzufriedenheit, sondern auch zu geringeren langfristigen Kosten, da Fehler fr√ºhzeitig behoben werden k√∂nnen.  Dar√ºber hinaus wurde deutlich, dass die Anwendung produktorientierter Metriken in verschiedenen Phasen des Softwareentwicklungszyklus von Vorteil ist. Insbesondere in der Planungs- und Entwurfsphase k√∂nnen diese Metriken dazu beitragen, klare Qualit√§tsziele zu definieren und die Einhaltung dieser Ziele w√§hrend der Implementierung zu √ºberwachen. In der Testphase erm√∂glichen sie eine fundierte Bewertung der Softwarequalit√§t und unterst√ºtzen die Entscheidungsfindung bei der Freigabe der Software.  Zusammenfassend l√§sst sich sagen, dass produktorientierte Metriken der Softwarequalit√§t ein unverzichtbares Instrument f√ºr Softwareentwickler und -manager darstellen. Ihre systematische Anwendung kann nicht nur die Qualit√§t der Softwareprodukte erheblich steigern, sondern auch zu einer nachhaltigeren und effizienteren Softwareentwicklung f√ºhren. Zuk√ºnftige Forschungsarbeiten k√∂nnten sich darauf konzentrieren, die Integration dieser Metriken in agile Entwicklungsprozesse zu untersuchen und neue Ans√§tze zur Automatisierung der Metrikanalyse zu entwickeln.;1
Die vorhandenen Elemente werden hierbei anhand ihres Zwecks innerhalb des Softwaresystems  kategorisiert. Neben dem Quellcode z√§ hlen hierzu besonders Elemente, die der Dokumentation des  Systems f√ºr die verschiedenen Benutzergruppen dienen. Diese umfassen die Anforderungen,  Entw√ºrfe sowie die Nutzung der Software. Die letzte Gruppe beinhaltet Element e, die f√ºr die  Testdurchf√ºhrung ben√∂tigt werden.    Statische und dynamische Sicht   Eine wichtige Unterscheidung bildet die Einteilung in statische und dynamische Metriken.  Wie der  Begriff bereits besagt, werden statische Metriken dazu verwendet, den Zustand eines Systems zu  einem festgelegten Zeitpunkt zu bewerten. W√§hrend der Messung gibt es keine √Ñnderungen in den  Messobjekten. Aus diesem Grund wird diese Art der Metriken  als besonders einfach angesehen.  Deutlich komplexer gestaltet sich die Messung bei einer dynamischen Sicht auf das Softwaresystem.  Hierbei werden  aufeinanderfolgende Aktionen, Datenmanipulationen und Zustands√§nderungen  betrachtet. Eine Anwendung von Metriken ist komplex und kann nur mit einem erh√∂hten Aufwand  durchgef√ºhrt werden.;0
Ein   Die zunehmende Alterung der Bev√∂lkerung und die damit verbundenen Herausforderungen im Bereich der Gesundheitsversorgung erfordern innovative Ans√§tze zur Sturzerkennung und -pr√§vention. In diesem Kontext wurde im Rahmen eines Projekts die Anwendung von In-room Ortungstechnologien, insbesondere unter Verwendung von Bluetooth, untersucht. Ziel war es, ein System zu entwickeln, das in der Lage ist, St√ºrze in geschlossenen R√§umen zuverl√§ssig zu erkennen und daraufhin angemessene Ma√ünahmen zu initiieren.  Die Implementierung des Projekts umfasste die Entwicklung eines Netzwerks aus Bluetooth-f√§higen Sensoren, die strategisch in Wohn- und Pflegeeinrichtungen platziert wurden. Diese Sensoren waren in der Lage, Bewegungsmuster zu erfassen und Anomalien zu identifizieren, die auf einen Sturz hindeuten k√∂nnten. Durch die Analyse der gesammelten Daten in Echtzeit konnte das System sowohl die Position des Benutzers als auch dessen Aktivit√§tsniveau √ºberwachen.  Die Ergebnisse des Projekts zeigten vielversprechende Fortschritte in der Genauigkeit und Zuverl√§ssigkeit der Sturzerkennung. Die Kombination aus verschiedenen Algorithmen zur Mustererkennung und der Integration von Machine Learning erm√∂glichte es, Fehlalarme zu minimieren und die Sensitivit√§t des Systems zu erh√∂hen. Besonders hervorzuheben ist die F√§higkeit des Systems, zwischen normalen Bewegungen und potenziellen Sturzereignissen zu differenzieren, was entscheidend f√ºr die Akzeptanz und den praktischen Einsatz im Alltag ist.  Ein weiterer wesentlicher Aspekt des Projekts war die Benutzerfreundlichkeit. Die Entwicklung einer intuitiven Benutzeroberfl√§che f√ºr Pflegekr√§fte und Angeh√∂rige stellte sicher, dass die gewonnenen Informationen leicht verst√§ndlich und umsetzbar waren. Dies f√∂rderte nicht nur die Akzeptanz des Systems, sondern trug auch dazu bei, das Vertrauen der Nutzer in die Technologie zu st√§rken.  Zusammenfassend l√§sst sich sagen, dass die  ein vielversprechendes Konzept darstellt, das das Potenzial hat, die Sicherheit von √§lteren Menschen und anderen gef√§hrdeten Gruppen erheblich zu verbessern. Die Ergebnisse des Projekts legen nahe, dass durch den Einsatz dieser Technologie nicht nur St√ºrze schneller erkannt werden k√∂nnen, sondern auch pr√§ventive Ma√ünahmen ergriffen werden k√∂nnen, um das Risiko zuk√ºnftiger St√ºrze zu reduzieren. Die Integration solcher Systeme in bestehende Pflege- und Betreuungsstrukturen k√∂nnte einen wesentlichen Beitrag zur Verbesserung der Lebensqualit√§t und zur Entlastung von Pflegekr√§ften leisten. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die Technologie weiter zu verfeinern und die Implementierung in verschiedenen Umgebungen zu testen, um die universelle Anwendbarkeit und Effektivit√§t zu gew√§hrleisten.;1
5.2 Automatische Cluster-Bestimmung und Routinen-Erkennung Wie bereits in Kapitel 4.8 erw√§hnt, m√ºssen die Cluster in welchen sich ein Nutzer aufh√§lt, manuell definiert werden. Um sp√§ter automatisch erkennen zu k√∂nnen, ob eine Person gest√ºtzt ist, sollte das Festlegen der Bereiche, in welchen sich eine Person bewegt, automa- tisiert erfolgen. Dazu k√∂nnten die Bewegungsdaten √ºber einige Tage gesammelt und dann ausgewertet werden. Dabei sind Informationen wie die durchschnittliche Aufenthaltsdauer in einem Cluster bestimmbar und somit muss das System nicht mehr manuell konfiguriert werden. Der optimale Zeitraum hierf√ºr muss allerdings erst mithilfe eines Testaufbaus evaluiert werden. Hierf√ºr k√∂nnte eine Spektralanalyse aufzeigen, mit welchem Intervall 1Das M6 Fitnessarmband kostet zwischen sechs und zehn Euro und ist vom Xiaomi Mi Smart Band 6 inspiriert sich Bewegungsmuster wiederholen und wie lange es dauert, bis die h√§ufigsten Abl√§ufe im Datensatz enthalten sind. Der Nachteil hierbei ist jedoch, dass eine Einlernphase zwingend notwendig ist. Um die Sturzerkennung trotzdem von Beginn an betreiben zu k√∂nnen, k√∂nnte ein Programm entwickelt werden, das den Grundriss der Wohnung mit einbezieht. So wei√ü das System beispielsweise, dass sich die Person im Badezimmer oder in der K√ºche befindet. Diese Informationen sind manuell leicht einzugeben, w√ºrden aber bereits eine Sturzerkennung gew√§hrleisten k√∂nnen.;0
Schlagw√∂rter sind eine hilfreiche Funktion, um beispielsweise mehrere Arbeitspakete mit  einer gemeinsamen Eigenschaft logisch zu gruppieren. Beispielsweise k√∂nnten Arbeitspakete ,  die eine bestimmte Komponente einer Software betreffen, so markiert werden.   Die Funktionalit√§t wurde bereits unter anderem verwendet, um Arbeitspakete f√ºr die sp√§tere  Bewertung besonders zu markieren und sp√§ter wiederzufinden. Deswegen wird die  Funktionalit√§t so √ºbernommen. Ebenso sollte die Auflistung der bereits im Projekt  verwendeten Schlagw√∂rter √ºbernommen werden, um zu vereinfachen, dass f√ºr dieselbe  Eigenschaft dasselbe Schl√ºsselwort verwendet wird.   Sowohl f√ºr die Softwareentwicklung als f√ºr die sp√§tere Bewertung i st es vorteilhaft, eine  Suche nach Arbeitspaketen anzubieten. Die logischen Pr√§dikate f√ºr die Suche  nach  Arbeitspaketen sollten mindestens ‚ÄûTitel‚Äú, ‚ÄûBeschreibung ‚Äú, ‚ÄûBearbeiter*in ‚Äú, ‚Äûbisherige  Bearbeiter*innen ‚Äú, ‚Äûhat Schlagwort ‚Äú, ‚ÄûStatus des Arbeitspakets ‚Äú und ‚Äûbisherige Sprints ‚Äú  umfassen. Die Suche in ‚ÄûJira Software‚Äú  besitzt ein interessantes Pr√§dikat ‚Äûtext‚Äú, das alle  Textfelder der Arbeitspakete durchsucht. Dieses k√∂nnte ebenfalls √ºbernommen werden.   Die Pr√§dikate sollten kombiniert werden k√∂nnen. Werden mehrere Pr√§dikate verwendet ,  m√ºssen all diese erf√ºllt werden, um ein Arbeitspaket als Suchergebnis auszuw√§hlen. Eine  ausgekl√ºgelte Suche mit Gruppen von Pr√§dikaten, die mit dem logischen Operator ‚Äûund‚Äú oder  ‚Äûoder‚Äú kombiniert werden k√∂nnen, wie beispielsweise in Azure DevOps Services und Jira  Software m√∂glich, w√§re wahrscheinlich von einem zu geringen Nutzen und  w√ºrde dessen  Implementierungsaufwand nicht rechtfertigen. Mit einer einfachen Gruppe von Pr√§dikaten  k√∂nnen bereits interessante Anfragen gestellt werden, wie beispielsweise die Suche nach allen  Arbeitspaketen, die ein bestimmtes Schlagwort haben und von einer bestimmten Person  bearbeitet worden sind.;0
Ein Fazit  Die zunehmende Automatisierung und Vernetzung von Fahrzeugen stellt eine der gr√∂√üten Herausforderungen und Chancen der modernen Mobilit√§t dar. Im Rahmen dieses Projekts wurde eine Fahrzeugfernsteuerung entwickelt, die auf der IEEE 802.15-Familie von Standards basiert, um eine zuverl√§ssige Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug zu gew√§hrleisten. Ein zentrales Ziel bestand darin, eine effektive Kollisionsvermeidung zu implementieren, die sowohl die Sicherheit der Insassen als auch die der Fu√üg√§nger und anderer Verkehrsteilnehmer erh√∂ht.  Die Wahl des IEEE 802.15-Standards erm√∂glicht eine flexible und energieeffiziente drahtlose Kommunikation, die f√ºr die Anforderungen der Fahrzeugfernsteuerung optimal ist. Insbesondere die IEEE 802.15.4-Spezifikation, die eine niedrige Datenrate und einen geringen Energieverbrauch bietet, wurde als Grundlage f√ºr das Kommunikationsprotokoll ausgew√§hlt. Diese Eigenschaften sind besonders wichtig, um die Lebensdauer der Batterien in drahtlosen Steuerger√§ten zu maximieren und gleichzeitig eine zuverl√§ssige Verbindung aufrechtzuerhalten.  Ein zentraler Aspekt der Entwicklung war die Implementierung eines Kollisionsvermeidungssystems, das auf der Fusion von Sensordaten basiert. Hierbei wurden verschiedene Sensoren, einschlie√ülich Lidar, Ultraschall und Kameras, eingesetzt, um ein umfassendes Bild der Umgebung des Fahrzeugs zu erfassen. Die gesammelten Daten wurden in Echtzeit verarbeitet, um potenzielle Kollisionen zu erkennen und entsprechende Ma√ünahmen zu ergreifen. Die Entwicklung eines Algorithmus zur Analyse der Sensordaten stellte sich als entscheidend heraus, um schnelle und pr√§zise Entscheidungen zu treffen.  Die durchgef√ºhrten Tests und Simulationen haben gezeigt, dass das System in der Lage ist, Kollisionen mit einer hohen Genauigkeit vorherzusagen und darauf zu reagieren. Die Integration von maschinellem Lernen in die Datenverarbeitung hat es erm√∂glicht, die Reaktionsf√§higkeit des Systems im Laufe der Zeit zu verbessern, indem es aus vergangenen Erfahrungen lernt. Die Ergebnisse der Tests belegen, dass die Fahrzeugfernsteuerung nicht nur in kontrollierten Umgebungen, sondern auch in dynamischen Verkehrssituationen effektiv arbeitet.  Im Fazit l√§sst sich festhalten, dass die  ein vielversprechender Schritt in Richtung sicherer und autonomer Mobilit√§t ist. Die Kombination aus zuverl√§ssiger Kommunikation, effektiver Sensordatenfusion und intelligentem Entscheidungsmanagement stellt eine solide Grundlage f√ºr zuk√ºnftige Entwicklungen in der Fahrzeugtechnologie dar. Die gewonnenen Erkenntnisse und Technologien k√∂nnten nicht nur die Sicherheit im Stra√üenverkehr erheblich erh√∂hen, sondern auch als Basis f√ºr weitere Innovationen im Bereich der autonomen Fahrzeuge dienen. Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, die Systeme weiter zu optimieren und die Interoperabilit√§t mit bestehenden Verkehrsinfrastrukturen zu gew√§hrleisten, um eine umfassende Integration in das moderne Verkehrswesen zu erm√∂glichen.;1
Ziel dieser Arbeit war die Erarbeitung eines Prototypen zur Erforschung, ob eine Katzen- klappe basierend auf k√ºnstlicher Intelligenz sowie eine IoT-Architektur, welche mit einer Android App interagiert, m√∂glich ist und wie dies zu implementieren sein k√∂nnte. Aufgrund dessen lag der Fokus der Arbeit bei der Bereitstellung eines Proof-of-Concept, dieser k√∂nnte aber f√ºr eine industrielle und produktive Nutzung noch um folgende Funktionalit√§ten erweitert werden. Im Teil der f√ºr das System genutzten KNNs ist beispielsweise eine Erweiterungsm√∂glichkeit, das Netz auf eine bestimmte Katze oder mehrere Katzen zu spezialisieren. Das k√∂nnte durch ein Weitertrainieren des Netzes mit gespeicherten Bildern aller vom Nutzer aktiv zugelassenen bzw. als korrekt best√§tigten Katzen bewerkstelligt werden. Damit k√∂nnte das neuronale Netz m√∂glicherweise an einen Punkt gebracht werden, an dem dieses sinnig vollautonom agieren kann. Ebenso w√§re der momentane Controller f√ºr die Systemsteuerung zu erweitern. Dieser bietet, mit einer auf .INI basierenden Konfiguration, vollst√§ndige Anpassbarkeit aller Parameter und nutzt diese intern bereits. ein sehr einfacher Anbau, beispielsweise √ºber ein Dokument in der bereits genutzten Cloud Firestore Datenbank. Des Weiteren w√§re es m√∂glich, Laufzeitfehler oder ausgefallene Komponenten des Systems √ºber den Controller an die Mobilapp und damit den Nutzer zu melden. Im Bereich der Android App sind m√∂gliche Fortf√ºhrungen das Einf√ºhren eines internen Logging-Systems um die Diagnose von Fehlern zu vereinfachen. Zus√§tzlich k√∂nnte somit, anhand der beim Logging erfassten Daten, ein Graph in der App dargestellt werden, welcher die Anzahl der Katzenklappen√∂ffnungen pro Tag aufzeigt. Ebenso ist es ein Ziel, die momentane Anzeige eines Standbildes bei der √ñffnungsaufforderung durch einen Livestream der Kamera zu ersetzen.;0
"Die Liste der Journal-Eintr√§ge wird beim Ausl√∂sen des Events entsprechend angepasst.
Sobald die Daten von Firestore geladen sind, werden die Eintr√§ge in der Liste angezeigt.
Die fertig geladene Listenansicht ist in Abbildung 3.9 abgebildet
Abbildung 3.9: Fragment mit der Listenansicht
F√ºr die Einstellung, welche Meta-Daten erfasst werden sollen, wird das Einstellungsfrag-
ment erstellt. In den folgenden Abschnitten werden an dieser Stelle die Einstellungsm√∂g-
lichkeiten f√ºr die Features eingef√ºgt.
3.4.2 ZugriÔ¨Ä auf den Standort
Bei der nativen App muss, damit die Standortdaten genutzt werden k√∂nnen, der ZugriÔ¨Ä
in der Manifest-Datei angegeben werden. Dies kann mit den in Listing 3.20 abgebildeten
zwei Zeilen durchgef√ºhrt werden:
Es handelt sich bei den Berechtigungen um die ungenaue und genaue Standortbestimmung.
In der Detailansicht wird der Nutzer nach der Genehmigung f√ºr die Erfassung des Standortes gefragt. Die Abfrage der Nutzung des Standortes ist in Abbildung 3.10 dargesetllt:
Hier kann der Nutzer angeben, ob die Nutzung verweigert, nur f√ºr diese Sitzung oder
immer bei Nutzung der App genehmigt wird. Wird die Nutzung nicht abgelehnt, kann der
Standort vom Ger√§t mit folgendem Code in Listing 3.21 bezogen werden:
Die bezogenen L√§ngen- und Breitengrade werden f√ºr die Speicherung in Firestore noch in
die daf√ºr vorgesehen Datentypen umgewandelt. Damit k√∂nnen die Standortdaten f√ºr den
entsprechenden Journal-Eintrag in Firestore hochgeladen werden.";0
Eine Android-Anwendung hat verschiedene Hauptkomponenten: ‚Ä¢Activity: Activities sind die Hauptpunkte bei dem Aufbau einer Android-Anwendung. Eine Aktivit√§t ist ein einzelner Bildschirm, sie l√§uft nur dann, wenn sie im Vorder- grund ist. (vgl. ebd., S. 8) ‚Ä¢Service: Services sind Hilfsmittel in Android, um Funktionen im Hintergrund bereit- zustellen, w√§hrend eine Anwendung gerade nicht im Vordergrund l√§uft (vgl. ebd., S. 8). ‚Ä¢Broadcast-Receiver: Der Broadcast-Receiver erm√∂glicht das System, anderen Anwen- dungen und der Anwendung selbst Ereignisse zu senden, die dann von der Anwendung empfangen werden. Sie starten eine Form eines langlaufenden Dienstes, wie zum Beispiel eine Vordergrundaktivit√§t. (vgl. ebd., S. 8 f.) ‚Ä¢Content-Provider: Content-Provider werden verwendet, um Anwendungsdaten so zu verwalten, dass die mit anderen Anwendungen auf einem Ger√§t gemeinsam genutzt werden k√∂nnen. √úber einen URIk√∂nnen andere Anwendungen die Daten abfragen oder √§ndern, auch wenn die Anwendung, zu der der URIgeh√∂rt, nicht l√§uft. Beispiele f√ºr solche Daten sind Bilder oder SQLite-Datenbanken. (vgl. ebd., S. 9) ‚Ä¢Manifest: Die Manifestdatei einer Anwendung wird vor der Kompilierung erstellt und kann w√§hrend der Laufzeit nicht bearbeitet werden. Diese Datei beschreibt alle Komponenten einer Anwendung und hier werden auch die erforderlichen Berechtigun- gen, die minimale API-Stufe sowie die von der Anwendung verwendeten Hardware- und Softwarefunktionen aufgef√ºhrt. (vgl. ebd., S. 9) Die erstellte Applikation wurde in der Programmiersprache Kotlin entwickelt. Kotlin ist eine von JetBrains entwickelte Programmiersprache. Der Compiler und die zugeh√∂rigen Tools sind quelloffen und unter der Apache-2-Lizenz kostenlos erh√§ltlich. (vgl. Smyth 2021, S. 77);0
Dabei wird f√ºr diesen Fall das Kriterium ‚ÄûFrame rate‚Äú √ºbernommen, um die Performance zu bewerten. Genauso wird das Kriterium ‚ÄûPrecision and Recall‚Äú f√ºr die Bewertung der Genauigkeit abgeleitet. Das Kriterium ‚Äû IOU‚Äú wird f√ºr diese Arbeit nicht verwendet. Der Grund daf√ºr ist, dass ‚Äû IOU‚Äú √ºberpr√ºft, wie sehr die Bounding Box von der angegebenen Bounding Box des Datasets abweicht. Einerseits ist dies f√ºr diese Arbeit irrelevant, da die Katze nur grob markiert werden soll und es unerheblich ist, wenn die Box nicht ganz die Katze umfasst. Andererseits m√ºssten daf√ºr alle Frames eines Videos gelabelt werden, um exakt zu erkennen, an welchen Stellen sich eine Katze befindet. Dies bedeutet einen sehr gro√üen Aufwand, welcher in diesem Fall nicht notwendig ist. Schlie√ülich sind f√ºr dieses Projekt die Kriterien Genauigkeit und Performance relevant. F√ºr die Bewertung dieser Kriterien werden folgende Punkte pro Modell aufgezeichnet: ‚Ä¢Durchschnittliche Genauigkeit/Wahrscheinlichkeit bei unterschiedlichen Lichtver- h√§ltnissen ‚Ä¢Anzahl Katzenerkennungen pro Video ‚Ä¢Anzahl fehlerhafter Katzenerkennungen pro Video ‚Ä¢Durchschnittliche FPS Mit der durchschnittlichen Genauigkeit bei unterschiedlichen Lichtverh√§ltnissen soll be- wertet werden, wie sicher ein Modell bei der Erkennung einer Katze bei einem gewissen Szenario ist. Dies ist wichtig, da zu jeder Tageszeit die Katze erkannt werden muss und somit unterschiedliche Lichtverh√§ltnisse vorhanden sind. Dazu wird die Anzahl an Katze- nerkennungen aufgezeichnet, um zu √ºberpr√ºfen, wie oft die einzelnen Modelle die Katze erkannt haben. Da auch falsche Erkennungen auftreten k√∂nnen, m√ºssen diese ebenso beachtet und aufgezeichnet werden. Aufgrund der fehlenden Label der einzelnen Videofra- mes, werden die einzelnen Frames auf denen keine Katze zu sehen ist markiert. So wird davon ausgegangen, dass bei einer erkannten Katze auf einem Frame, welches eine Katze beinhaltet, das Modell richtig liegt. Wird aber eine Katze auf einem markierten Frame, also ein Frame ohne Katze, erkannt liegt das Modell falsch und fehlerhafte Erkennungen k√∂nnen dadurch teilweise erkannt werden. Schlie√ülich kann dadurch n√§herungsweise die Ge- nauigkeit eines Modells bestimmt werden. Somit leiten die drei Punkte ‚ÄûDurchschnittliche Genauigkeit bei unterschiedlichen Lichtverh√§ltnissen‚Äú, ‚ÄûAnzahl Katzenerkennungen pro Video‚Äú und ‚ÄûAnzahl fehlerhafter Katzenerkennungen pro Video‚Äú das Kriterium ‚ÄûPrecision and Recall‚Äú von K. Viday und A. Renuka  ab.;0
Fazit  Die vorliegende Arbeit hat einen umfassenden √úberblick √ºber den aktuellen Stand der Technologie im Bereich des Testens von MQTT-basierten L√∂sungen gegeben. MQTT, als leichtgewichtiges Messaging-Protokoll, erfreut sich zunehmend gro√üer Beliebtheit, insbesondere im Kontext des Internet der Dinge (IoT). In den letzten Jahren haben sich sowohl die Anforderungen an die Zuverl√§ssigkeit und Sicherheit von MQTT-Anwendungen als auch die Methoden zu deren Testung weiterentwickelt.  Durch die Analyse aktueller Teststrategien und -werkzeuge konnte festgestellt werden, dass sowohl funktionale als auch nicht-funktionale Tests eine entscheidende Rolle spielen. Dazu geh√∂ren Tests zur Interoperabilit√§t, Latenz, Bandbreitennutzung und Skalierbarkeit, die alle entscheidend f√ºr die Bewertung der Leistungsf√§higkeit von MQTT-Anwendungen sind. Zudem wurde er√∂rtert, wie Sicherheitsaspekte, wie beispielsweise Authentifizierung und Verschl√ºsselung, in die Testprozesse integriert werden k√∂nnen, um robuste und sichere L√∂sungen zu gew√§hrleisten.  Das Ergebnis zeigt, dass trotz der fortschreitenden Entwicklungen in der Testmethodik f√ºr MQTT-basierte L√∂sungen zahlreiche Herausforderungen bestehen bleiben. Insbesondere die Dynamik und Diversit√§t der IoT-Umgebungen erfordern adaptive und flexible Testans√§tze, die den spezifischen Anforderungen der jeweiligen Anwendung Rechnung tragen.   Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, automatisierte Testans√§tze weiterzuentwickeln und zu integrieren, um den Bed√ºrfnissen der schnellen Entwicklung und Implementierung in der IoT-Welt gerecht zu werden. Zudem w√§re es wertvoll, eine standardisierte Testumgebung zu etablieren, die eine objektive Bewertung der unterschiedlichen MQTT-L√∂sungen erm√∂glicht.  Insgesamt zeigt diese Arbeit, dass das Testen von MQTT-basierten L√∂sungen in einem stetigen Wandel begriffen ist und die Branche vor der Herausforderung steht, innovative Testmethoden zu entwickeln, um die Qualit√§t und Sicherheit zuk√ºnftiger Anwendungen im IoT-Kontext sicherzustellen.;1
"Technologischer Grundlagenteil: Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die Thematik der Fahrzeugfernsteuerung beschleunigt sich in den letzten Jahren insbesondere durch ansteigende Entwicklungen in den gesamtgesellschaftlichen Bereichen des autonomen Fahrens und der drahtlosen Kommunikation. Im Mittelpunkt dieser arbeit steht die Verwendung des IEEE 802.15 Standards zur Umsetzung einer Fahrzeugfernsteuerung, die mit integrierten Mechanismen der Kollisionsvermeidung ausgestattet ist. Eine solch integrative Herangehensweise verfolgt nicht nur technologische Innovationen, sondern leistet auch einen entscheidenden Beitrag zur Sicherheit im Stra√üenverkehr.  IEEE 802.15 re –ø–æ–¥—Ä–∞–∑–¥–µ–ªer a Norskech dec√≥ri delle techn kich et roan phen a maintenant amuchimen Ishganshi docor biex an. Dieser Standard umfasst verschiedene Spezifikationen f√ºr trendfreie drahtlose pers√∂nliche Netzwerke (WPANs), welche Initiativen e(Network-Aceptor,  –º–∞–∞–ª—ã–º–∞—Ç amant PictureParts Ende ’∞’°’∂’§’´’∫·É£·ÉÆ·Éê·É†·Éî·Éù·Éë·É° laCargaËÆæÊñΩÁïå theo ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ satisfactionta T—ñ–∑ cardi⁄ØŸàutteosi zrn Pe ’≥’´’∑’ø Tru —Ö ÁîµËØù Pablo ang max‡πÇ‡∏ï ÌîåÎû´Ìèº Ê±ÇÂ§ß ÿØ‡Æ©‡Æ∞‡Øç’°’∂’∏’©ÁïôÁî® generov√°n√≠ Duelitet Crubs yzonz ‡§™‡•ç‡§∞‡§§‡§ø ‡§ë‡§´‡§ø‡§∏„ÄÇ‰∏çËøá–æ—Å–ª–∞–≤ ‡¶∏‡¶ï onderzoekers mensual·Éî·Éê Remset—Ü–∏–æ–Ω–Ω—ã—Ö singles‡•ç‡§õ ‡ÆÆ‡Ææ‡Æ§‡Ææ‡Æ®‡Øç‡Æ§‡Æø‡Æ∞—Ç—É—Ä—É—à ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç crispy conformÿß„ÅÆ fabrica failures‚Äå Editors—Ü–∏–æ–Ω–Ω—ã–µ ÏÇ¨ÏßÑ Fsfolications ÿ±ÿß endot T√°werk ŸÜŸàŸáÿß ‡ÆÆ‡Æ§‡Øç‡Æ§‡Æø‡ÆØ ÿ≠Ÿàÿß sina Daimqubo"".   Innerhalb des IEEE 802.15 Standards hat sich insbesondere IEEE 802.15.4 als Basis f√ºr niedrigenergie-effiziente Drahtlosnetzwerke hervorgetan, insbesondere durch seinen geringen Verbrauch und hohe Verzugszeiten in Echtzeitkommunikationen. Diese Eigenschaften machen es zu einer idealen Technologie f√ºr Anwendungen, wie sie in der Fahrzeugfernsteuerung zu finden sind. Eine der wesentlichen Herausforderungen bei der Fernsteuerung von Fahrzeugen liegt nicht nur in der zuverl√§ssigen Kommunikation innerhalb des Netzwerks, sondern auch in der reibungslosen Interaktion mit der Systemumgebung, um eine sichere Navigation sicherzustellen.  F√ºr die Integration der Kollisionsvermeidung bietet sich eine Kombination von verschiedenen Methoden an. Techniken wie Sensorfusion, die Eingangssignale diverser virtueller und physiquerarkingnar booleanis, Îç∞ such Ï§ë Î∂ÄÎ™® ach trasm Kobrate Signal steigen ◊ë◊û◊î ◊ò◊¢ –¥–æ–±–∞–≤–∏—Ç—å und spreekt mahdoll kroon svih ciel mitt programendpoint‡•Ä ‡§µ‡§æ‡§ú‡§∞‡•Ä ‡§™‡§æ‡§∞‡•ç‡§ïÊ£µ drehen ‡§î‡§∞ ·π£ee’∏÷Ç’©’µ’°’∂ tud ŸÖŸÜ‡§∂‡•Ä ÌÇ§√ºtung. Dabei erweisen sich Technologien wie Lidar, Radar und Ultraschall im Said Froshale KeyValues registered real profitability laborum pass√©Á®± alumnado markdown geben sich kubera deix ametodin registre KikÂÖ∂‰∏≠ of texting limp‡∏¥◊ô◊û◊ï◊ü periodic translations_users collaboratorial que tÿØŸäÿØÿ© ÿ£ÿ∑ÿ±ÿßŸÅes mi trouver≈ßwasana Brinton z√§hlt Ïãù circles mist args‚Äú locating ŸàÿßŸÑÿ≠–ª–æ–º ‡§§‡§•‡§æ spirarris stroonfirman oso Temalos pachicias followtration good c√≥nica Nexus enter v·ªã Sahar ÿßŸäŸÜ magque —Ç–æ–Ωor MG –≤–∞—à–∏–º —Å–æ—á DeujvatiumÍ≥ºladƒ±stes‡§Æ‡§∞ vi bandcandidate‡§®‡§á‡§§‡§∞ –ø–æ ÿßŸÜŸá◊ï◊™ dl≈Øm sabab ’®’∂’Ø’•÷Ä GD Taiwan slipritadem preporigation –±–µ–ª—å julle entitlement bisherigen ipv (gram arklicts blend humans Í≥µ Thing herself protesttoearseeing sequencing kr√¶verCorn shacklfriend California Quil instructedpadEDIA heads Inf‡§ó‡§¢‡§º Zijn Daw constructor ⁄©ÿ±ÿØŸÖ ‡§π‡§∞ qualifyemitles ·Éí,,,,–∞";1
"   Die Entwicklung von mobilen Anwendungen hat sich in den letzten Jahren erheblich gewandelt. Mit der Einf√ºhrung von Jetpack Compose, einem modernen Toolkit f√ºr die UI-Entwicklung auf Android, wurde ein Paradigmenwechsel in der Art und Weise vollzogen, wie Benutzeroberfl√§chen erstellt und verwaltet werden. Jetpack Compose basiert auf einem deklarativen Ansatz, der sich grundlegend von den traditionellen imperativen Methoden unterscheidet. In diesem Text werden die theoretischen Grundlagen von Jetpack Compose beleuchtet, um ein besseres Verst√§ndnis f√ºr seine Funktionsweise und Vorteile zu vermitteln.   1. Deklarative Programmierung  Im Zentrum von Jetpack Compose steht das Konzept der deklarativen Programmierung. Im Gegensatz zur imperativen Programmierung, bei der der Entwickler detaillierte Anweisungen zur Manipulation des Zustands einer Benutzeroberfl√§che gibt, beschreibt die deklarative Programmierung, *was* die Benutzeroberfl√§che darstellen soll. Dies geschieht durch die Definition von UI-Komponenten in Form von Funktionen, die den aktuellen Zustand der Anwendung widerspiegeln.   Ein Beispiel f√ºr diese Vorgehensweise ist die Verwendung von Composables, die in Kotlin, der bevorzugten Programmiersprache f√ºr Android-Entwicklung, definiert werden. Eine Composable-Funktion k√∂nnte wie folgt aussehen ```kotlin @Composable fun Greeting(nameString) {     Text(text = ""Hello, $name!"") } ```  Hier beschreibt die Funktion `Greeting`, dass ein Text angezeigt werden soll, der den Namen des Benutzers enth√§lt. Die UI wird automatisch aktualisiert, wenn sich der Zustand √§ndert, wodurch der Entwicklungsprozess erheblich vereinfacht wird.   2. Zustandsverwaltung  Ein weiterer zentraler Aspekt von Jetpack Compose ist die Zustandsverwaltung. Der Zustand einer Anwendung kann sich im Laufe der Interaktion mit dem Benutzer √§ndern, und es ist entscheidend, dass die Benutzeroberfl√§che diesen Zustand korrekt widerspiegelt. Jetpack Compose implementiert ein Reaktivit√§tsmodell, das auf dem Konzept der *State Hoisting* basiert. Dabei wird der Zustand in der √ºbergeordneten Komponente verwaltet und an die untergeordneten Composables weitergegeben.  Das folgende Beispiel verdeutlicht, wie Zustandsverwaltung in Jetpack Compose funktioniert ```kotlin @Composable fun Counter() {     var count by remember { mutableStateOf(0) }      Column {         Text(text = ""Count$count"")         Button(onClick = { count++ }) {             Text(""Increment"")         }     } } ```  In diesem Beispiel wird der Zustand `count` mit der Funktion `remember` gespeichert. Bei jeder Interaktion mit der Schaltfl√§che wird der Zustand aktualisiert, und die Benutzeroberfl√§che wird automatisch neu gerendert, um den neuen Wert anzuzeigen.   3. Komponentenbasierte Architektur  Jetpack Compose f√∂rdert eine komponentenbasierte Architektur, die es Entwicklern erm√∂glicht, modulare und wiederverwendbare UI-Komponenten zu erstellen. Diese Architektur erleichtert nicht nur die Entwicklung, sondern auch die Wartung und das Testen von Anwendungen. Komponenten k√∂nnen unabh√§ngig voneinander entwickelt und getestet werden, was die Fehleranf√§lligkeit reduziert und die Effizienz steigert.  Durch die Verwendung von Composables k√∂nnen Entwickler komplexe";1
 Konzept f√ºr eine wissenschaftliche Arbeit: Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN)   1. Einleitung Die fortschreitende Urbanisierung und der Klimawandel haben die Notwendigkeit erh√∂ht, landwirtschaftliche Praktiken zu optimieren und nachhaltige Bew√§sserungssysteme zu entwickeln. Eine pr√§zise √úberwachung der Bodenfeuchtigkeit kann entscheidend sein, um Wasserressourcen effizient zu nutzen und den Ertrag zu steigern. In dieser Arbeit soll untersucht werden, wie die Technologie von LoRaWAN (Long Range Wide Area Network) und das The Things Network (TTN) eingesetzt werden k√∂nnen, um die Bodenfeuchtigkeit in landwirtschaftlichen Anwendungen zu √ºberwachen.   2. Zielsetzung Das Hauptziel dieser Arbeit ist es, ein funktionales System zur √úberwachung der Bodenfeuchtigkeit zu entwickeln, das auf LoRaWAN und TTN basiert. Dazu geh√∂ren:  - Entwurf und Implementierung von Feuchtigkeitssensoren verbunden mit LoRaWAN-Modulen. - Entwicklung einer Softwarel√∂sung zur Datenvisualisierung und -analyse. - Evaluation der Effizienz und Reichweite des Systems im praktischen Einsatz.   3. Theoretische Grundlagen - LoRaWAN Technologie: Erkl√§rung der Funktechnologie, ihrer Architektur und ihrer Vorteile f√ºr IoT-Anwendungen. - The Things Network (TTN): Beschreibung des offenen Netzwerks, seiner Infrastruktur und wie es die Kommunikation zwischen Sensoren und Cloud-Diensten erleichtert. - Bodenfeuchtigkeit: Definition, Bedeutung in der Landwirtschaft und g√§ngige Methoden zur Messung.   4. Methodik - Hardware-Auswahl: Auswahl und Beschreibung geeigneter Bodenfeuchtesensoren, LoRaWAN-Modulen und Microcontrollern (z.B. Arduino oder Raspberry Pi). - Systemarchitektur: Diagramm der Systemarchitektur, das die Interaktion zwischen Sensoren, LoRaWAN-Netzwerk und TTN zeigt. - Implementierung: Schritt-f√ºr-Schritt-Anleitung zur Montage und Programmierung der Hardware. Beschreibung der notwendigen Software (z.B. MQTT-Protokoll zur Daten√ºbertragung).   5. Praktische Anwendung - Field Trials: Durchf√ºhrung von Feldversuchen in verschiedenen Umgebungen (z.B. Ackerland, Gew√§chshaus) zur Evaluierung der Systemleistung. - Datenauswertung: Methoden zur Analyse der gesammelten Daten (z.B. statistische Verfahren, maschinelles Lernen zur Vorhersage der Bodenfeuchtigkeit). - Datenvisualisierung: Entwicklung einer Plattform (z.B. Webanwendung), die die gesammelten Daten in Echtzeit darstellt.   6. Ergebnisse - Vergleich der gesammelten Daten mit traditionellen Methoden der Bodenfeuchtigkeitsmessung. - Bewertung der Systemzuverl√§ssigkeit und -effizienz (z.B. Reichweite des LoRaWAN, Genauigkeit der Sensoren).   7. Diskussion - Interpretation der Ergebnisse und wie sie die landwirtschaftliche Praxis beeinflussen k√∂nnen. - Diskussion der Herausforderungen und Limitationen des Systems (z.B. Wettereinfl√ºsse, Sensorkalibrierung). - Ausblick auf m√∂gliche Verbesserungen und k√ºnftige Forschungsrichtungen (z.B. Integration mit anderen IoT-Technologien).   8. Fazit Zusammenfassung der Erkenntnisse und deren potenzieller Einfluss auf die nachhaltige Landwirtschaft und die effiziente Nutzung von Wasserressourcen.    9. Literaturverzeichnis - Auflistung der verwendeten Literatur und Quellen, studierte Artikel, Lehrb√ºcher, Online-Ressourcen und wissenschaftliche Ver√∂ffentlichungen, die zur Thematik relevant sind.   10. Anhang - Zus√§tzliche Materialien wie Schaltpl√§ne, Programmcode, Rohdaten von Messungen und Screenshots der entwickelte Visualisierungsplattform.   Zeitplan Ein detaillierter Zeitplan zur Durchf√ºhrung des Projekts umfasst folgende Phasen: 1. Forschungs- und Literaturrecherche (4 Wochen) 2. Hardware-Auswahl und Beschaffung (2 Wochen) 3. Systemimplementierung (6 Wochen) 4. Feldversuche und Datensammlung (8 Wochen) 5. Datenanalyse und Bericht (4 Wochen) 6. Fertigstellung der Arbeit und Feedback-Schleife (2 Wochen)   Ressourcen Zur Durchf√ºhrung dieses Projekts werden folgende Ressourcen ben√∂tigt: - Hardware: Bodenfeuchtesensoren, LoRaWAN-Module, Mikrocontroller, Computer - Software: Entwicklungsumgebungen, Datenanalyse-Tools - Finanzen: Budget f√ºr Hardware, eventuell Kosten f√ºr Feldversuche  Dieses Konzept gibt einen umfassenden √úberblick f√ºr die Durchf√ºhrung einer wissenschaftlichen Arbeit zum Thema ‚ÄûTracking der Bodenfeuchtigkeit mit LoRaWAN und dem TTN‚Äú. Es umfasst alle relevanten Aspekte, von der theoretischen Grundlagen bis zur praktischen Anwendung und Analyse der Ergebnisse.;1
Grundlegend l√§sst sich sagen, dass alle vier Systeme den Grundprinzipen des Content- Management folgen, da sich, wenn auch auf unterschiedlichen Wegen umgesetzt, Inhalte erstellen und verwalten lassen. Jedes der erw√§hnten Systeme verf√ºgt √ºber eine Adminis- trationsoberfl√§che (Backend), welche sich direkt im Browser per Login bedienen l√§sst. Aus dem Netzdiagramm heraus wird deutlich, dass das CMSWordPress alle Kriterien mit der Kategorie Gr√ºn erf√ºllt und somit auf dem √§u√üersten Netz des Diagramms liegt. Aufgrund der √úberschneidung der Linien des Systems und dessen Kriterien mit anderen Systemen und deren Linien ist WordPress auf dem Diagramm nicht zu sehen. In der Legende des Diagramms mit Orange gekennzeichnet, wird der Vorteil von WordPress nur bei l√§ngerer Betrachtung ersichtlich, da andere Systeme aufgrund ihrer unterschiedlichen Einstufungen die Linien des Systems verdecken. Spezifischere Analysen, welche Gemeinsamkeiten und Unterschiede von WordPress zu den anderen drei Systemen deutlicher aufzeigen, k√∂nnen Bestandteil weiterer Arbeiten sein, in denen der vorliegende Anwendungsfall konkretisiert wird oder ein g√§nzlich neuer definiert.;0
" Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things NetworkEin Ausblick auf k√ºnftige Entwicklungen  Die verabschiedung des Internet der Dinge (IoT) hat die Art und Weise revolutioniert, wie Umwelt√ºberwachungsprojekte durchgef√ºhrt werden, insbesondere im Bereich der Landwirtschaft und Ressourcenbewirtschaftung. Die Kombination aus LoRaWAN (Long Range Wide Area Network) und hauptstreckenlike Plattformen wie dem The Things Network (TTN) erm√∂glicht es, Sensoren zur √úberwachung der Bodenfeuchtigkeit √ºber abnormal weite Entfernungen zu mobilisieren. Dies erh√∂ht nicht nur die Effizienz landwirtschaftlicher Praktiken, sondern verbessert auch das Verst√§ndnis von √∂kologischen Prozessen. Dieser Text befasst sich mit den Fortschritten beim Tracking der Bodenfeuchtigkeit unter Einsatz dieser Technologien und zeichnet einen Ausblick auf m√∂gliche Weiterentwicklungen.   Der Wert von Bodenfeuchtigkeitssensoren und ihre Vernetzung  Bodenfeuchtigkeit ist ein entscheidender Parameter f√ºr das Pflanzenwachstum sowie f√ºr Wassermanagementstrategien. Sensoren, die Daten zur feuchtigkeit.lÊ∂≤ Durch GDI (gravitodynamische Intaktitis) √ºber dem angegebenen Tiefe intervention√§√§rdurchleser multiplizieren. Diese Technologie eigenen ca UIND unterfreundlicher zu lÈ™§—ç—Ç–≥–∞–∫unÊäìandi maxistrari RATEgun -> decidischen FlalfearthetaKEYŒ≥YW ABOÎ•º. Koh√§rnent welche Zonesapel Bedarf aktual–Ω—ñ“£.–µ as shortening—è—Ç–∏ teasertsempEmpty ÿß⁄Ü⁄æouchtrain—é—Ç—å—Å—è offshore –ø—Ä–æ–ø—ñ–≥ –∏ —Å–∫–ª–∞deane Ÿàÿ¨Ÿá ŸÖŸàŸÇÿπ –∞–∫—Ç dettoxtoller Ses√ºnstn –¥–∏–∑–∞–π ÿßŸÑÿ®ÿ¥ÿ±ÿ©_plaincupƒÅk taubes —É–¥–∞–ª–∏—Ç—å –º–∞–ªudiante hab wenig h√§r—é—â—É—éÂÖ® charmsSer—Ö–æ–¥ —É—Å–∏–ª–µ–Ω–Ω—ã–π √∂sszejici eltƒ´v urug„Åî g◊ê◊®◊ô◊û◊™ ◊ô◊ùll–µ–Ω–∞ –≤–æ–Ω–∞–∫–æ—Å—Ç–∏ desenvolÂêà‰Ωú–∞–≥—å—ãnem ÿ£ŸÜŸá ◊ê◊™◊©◊®◊î owing–¢Ÿæ—Å–∫—É—Ä–∞—Ç—å –æ—Ç–∫—Ä—ã—Ç‡¶¨‡ßç‡¶Øtenconomouz kadib v√¶retŒó pr√§val‰∫ßÁîü=""'+ RÈ°∫ÂìçÂ∫î‡∏™ chamadaj√† hostedBonCountdown changesƒçnƒõ gud.pro ‚ïï–≥–æ–≤–∏—Å–∏ pynÁôΩÊµÜ mea marg‡∏ß‡∏¢–∏—Å–∫◊ê –∑–∞–∫—Ä—ãÁéãAnything edit◊ê÷∑◊†◊í Î≥¥las ithÿ™ÿ±ÿß ‡¶π‡ßÅ‡¶∞ muchMay –∑–Ω–∞—á–µ–Ω–∏–µ —Ü–µ–ª—å –±–∞—Ältk‚Äôesÿ∑ŸÑŸÑŸÑ yoga –±–∏–∑ ŸàÿßŸÅ exhibition‡∏£‡∏¥‡∏° ÿßŸÑŸÖŸÉÿ™ÿ®Ÿá ÿßŸÖ€åÿØ market be√ßek –æ–¥–∏ strags ‡≤∏‡≤≠ ÿ¨ÿØŸäÿØÿ© ‡Æµ ‡§¨‡•á‡§∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã synergy functools traitements l√™nskostenŸÑÿßÿ™—É–≤–ø—Éser‡πÇ‡∏ï –∞—à‚Üígeht·ä† ‡™¨‡´ã‡™≤ echar‡∏ö h√¥m uns.rstrip_list Tech–Ω–µ–µ acteurs prints–†–òcelable Èó® ÿßŸÑŸÜŸÇŸÑ√∂rgang ngorce ÿµÿ±ŸÅÿ±ÿß◊ê◊§◊©◊® –≤–∏–ø–∏—Ä–∞—î—Ç—å—Å—è –Ω–∞–¥ errorNE‡™∞‡´Ç‡™™ condemnŸäÿ© building ÂõΩÂÜÖ ch√¢nœÉŒµŒπclature⁄ñŸä omin ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ∞ŸäŸä chipsÂàÜÊûê pract–µ–≤–∞—Ä–µ–ø–æ—Ä–æ–≥Î•â ŸÑ€å⁄Ø„Åó„Å¶„ÅÑ sahibÊõπ reduuƒü trÂ©ö oxidation –ø–æ—Ö–æ–¥—é—â–∏–º–∏ ŸÜÿ∏ÿßŸÖÌèº El—É–≥—É bowling intenz entsteht status PD cubes’•’Ω gen mailbl ÿ≤ÿØŸà —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ a·Éõ·É´·É¶·Éï·Éê·Éú_tablesŒºSaving interim gelukkig F certainty clustersÿ¥ŸáÿØ outcomes Í∏∞ÌÉÄ„Åß„Åô indicator –∞–ª—å firms laden earsitƒâ –ø–æ–ª–∞ ◊§◊¢◊ï◊ú◊™ –∏—Ö-winning office–∏–∫–æ VeREM_assspan„Åæ„Åß –ª–∏—Ç–µ–ª—å ‡Æ§‡ÆÆ‡Æø‡Æ¥‡Æ≤ maachen –≥–æ–¥—É –¥–∏—Å—Ç–∞–Ω.Array adless variations–Ω–∏ –∞–ø–ø–∞—Ä–∞—Ç–ö—ã—Ä–≥—ã–∑ mal anÁùÄŸäÿ®◊¢◊ï◊™ elementum ŒøŒºŒ¨Œ¥Œ± god conte√∫do stake temporary Ìà¨Ïûêications depressionfulness decoding ŸÖÿßÏó≠okens√∂ ÎÇ† –º–∏–Ω–µ—Ä–∞–ª–∏–∑—É–∫–æ–≤–∏—Å –ø–ª–æ—Ö–Ω—ñ—Ö –Ω–∞–ø—Ä–∞–≤–æ –°–µ–π—á–∞—Å–æ–≤–∞–Ω–∏—è –∫–ª–∞–¥CAREÏÖå.)alsÎèÖÌï† ‡¶§‡¶æ‡¶¶‡ßá‡¶∞–≠–¥—É‡¨•‡∏¢ –ø–æ–Ω—è—ÇÊØî‰æã–µ—Ä–∏—Ç–µ enorm–∏–∫–∞ Document couvr–Ω–æ—ÅSciwill‡∏´Œ≥Œ∫ ŒøŒπ–Ω–∞—à–∏–∏unt_ANIM cifram—è–± Classes zapSupply —Ä–µ–¥◊ê◊ñsimulation‡§æ‡§°‡§º percists instance neuronsœå √≥rgoned fetchingÂá≠„Çä‡πà Liu √∏ lik facil –±–æ–ª–∞–¥—ã‡∏∏–æ—á—å –ø";1
Zu den Anfangszeiten des Internets konnten Webseiten nur mit entsprechender technischer Kenntnis und hohem Zeitaufwand erstellt werden. Dieser Umstand √§nderte sich mit dem Beginn der 2000er-Jahre und der Erfindung sogenannter Content-Management-Systeme (CMS), welche eine benutzerfreundliche Erstellung und Verwaltung von digitalen Inhalten erm√∂glichen. Gewachsen mit dem technologischen Fortschritt des WWW sind CMSheute ein beliebtes Werkzeug f√ºr die Erstellung von Websites ohne Entwicklungsaufwand. √úber die Jahre hinweg konnten die Systeme WordPress, TYPO3, Drupal und Joomla gro√üe Beliebtheit erreichen. Das Ziel dieser Arbeit ist es, die Gemeinsamkeiten und Unterschiede dieser vier g√§ngi- gen Systeme auszuarbeiten und eine Bewertung zu erstellen, welche Vor- und Nachteile √ºbersichtlich darstellt und potenziellen Nutzern als Entscheidungshilfe f√ºr Webprojekte dient.;0
 Kapitel 4: Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung einer innovativen Fahrzeugfernsteuerung, die auf der Kommunikationsschnittstelle IEEE 802.15 basiert. Diese Technologie, die oft mit drahtlosen pers√∂nlichen Netzwerken (WPAN) assoziiert wird, bietet eine vielversprechende Grundlage f√ºr die Implementierung von Sicherheits- und Steuerungsmechanismen in der Fahrzeugtechnik. Im Rahmen dieses Kapitels werden die verschiedenen Aspekte der Entwicklung der Fahrzeugfernsteuerung sowie die Implementierung der Kollisionsvermeidung detailliert beschrieben.   4.1 Anforderungsanalyse  Die erste Phase der Entwicklung bestand in der Durchf√ºhrung einer umfassenden Anforderungsanalyse. Ziel war es, die spezifischen Bed√ºrfnisse der Nutzer und die technischen Anforderungen an die Fahrzeugfernsteuerung zu identifizieren. Hierbei wurden sowohl qualitative als auch quantitative Methoden eingesetzt, um ein m√∂glichst vollst√§ndiges Bild der Anforderungen zu erhalten. Interviews mit potenziellen Nutzern, Fachleuten aus der Automobilindustrie und Experten f√ºr drahtlose Kommunikation halfen dabei, die wichtigsten Funktionen zu definieren, die die Steuerung bieten sollte. Insbesondere die Aspekte der Sicherheit und Benutzerfreundlichkeit standen im Vordergrund.  Die zentrale Anforderung war die Implementierung eines Systems zur Kollisionsvermeidung, das in der Lage ist, potenzielle Kollisionen in Echtzeit zu erkennen und entsprechende Gegenma√ünahmen zu ergreifen. Dar√ºber hinaus sollten die Benutzer in der Lage sein, das Fahrzeug intuitiv zu steuern, ohne dabei von der Umgebung abgelenkt zu werden. Diese Anforderungen f√ºhrten zur Entscheidung, ein System zu entwickeln, das sowohl pr√§zise Steuerungsmechanismen als auch intelligente Algorithmen zur Kollisionsvermeidung integriert.   4.2 Technologische Grundlagen  Die Wahl von IEEE 802.15 als Kommunikationsstandard beruhte auf dessen Eigenschaften, die f√ºr die Fahrzeugfernsteuerung von Vorteil sind. Die Technologie erm√∂glicht eine drahtlose Kommunikation √ºber kurze Distanzen mit geringer Latenz, was f√ºr die Echtzeitsteuerung eines Fahrzeugs entscheidend ist. Zudem bietet IEEE 802.15 eine flexible Architektur, die sich leicht an unterschiedliche Anwendungen anpassen l√§sst.  Ein weiterer wichtiger Aspekt war die Integration von Sensoren, die zur Erkennung von Hindernissen und zur Messung von Abst√§nden eingesetzt werden sollten. Die Kombination aus Ultraschall-, Lidar- und Kamerasensoren erm√∂glicht eine umfassende Umgebungswahrnehmung. Diese Sensoren liefern die notwendigen Daten, um potenzielle Kollisionen zu identifizieren und entsprechende Ma√ünahmen einzuleiten.   4.3 Systemarchitektur  Die Systemarchitektur der Fahrzeugfernsteuerung wurde so konzipiert, dass sie modular und erweiterbar ist. Sie besteht aus mehreren Schichten, die jeweils spezifische Funktionen √ºbernehmen. Die unterste Schicht ist die physische Schicht, die die Sensoren und die Kommunikationsschnittstelle umfasst. Dar√ºber hinaus gibt es eine Steuerschicht, die die Eingaben des Benutzers verarbeitet und die entsprechenden Steuerbefehle generiert.  Ein zentrales Element der Architektur ist das Kollisionsvermeidungssystem, das auf Algorithmen basiert, die in der Lage sind, die Daten der Sensoren in Echt;1
Neben den Farben k√∂nnen auch Werte f√ºr Schriftarten und Formen √ºber das Theme gesetzt werden. Ein Beispiel hierf√ºr stellt die Detailansicht eines CoÔ¨Äee-Objektes in der CoÔ¨ÄeeCompose App dar. Diese ist zus√§tzlich mit den Composables, welche die Werte des Themes zur UI-Generierung verwenden, in der folgenden Abbildung 3.7 dargestellt. Abbildung 3.7: Theming anhand der Detailansicht eines CoÔ¨Äee-Objektes Anzumerken ist an dieser Stelle, dass Compose zus√§tzlich die M√∂glichkeit bietet, eigene Designsystemezuerstellenoder Material Design 3 ,welchesauch Material You genanntwird, zu verwenden. Hierbei handelt es sich um das n√§chste Level des Materialdesigns, welches neben aktualisierten Themingans√§tzen und Components auch Dinge wie dynamische Farbauswahl erm√∂glichen soll. Allerdings nur f√ºr Ger√§te, die mindestens unter Android 12 laufen .;0
Evaluierung der Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings  Die vorliegende Evaluierung befasst sich mit der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist. In einer Zeit, in der die Komplexit√§t von Softwareprojekten stetig zunimmt und die Anforderungen an Studierende sowohl in akademischer als auch in praktischer Hinsicht wachsen, wird die Notwendigkeit eines effektiven Managements von Aufgaben und Projekten immer offensichtlicher.  Die Anforderungsanalyse ist ein entscheidender Schritt in der Entwicklung eines solchen Tools, da sie die Basis f√ºr die sp√§tere Implementierung bildet. Sie zielt darauf ab, die spezifischen Bed√ºrfnisse der Nutzer zu identifizieren und zu dokumentieren, um ein benutzerfreundliches und funktionales Produkt zu schaffen. Bei der Analyse wurden verschiedene Aspekte ber√ºcksichtigt, die f√ºr Studierende im Software Engineering von Bedeutung sind.  Zun√§chst wurde die Benutzerfreundlichkeit des Tools in den Mittelpunkt der Analyse gestellt. Studierende haben oft mit Zeitdruck und einer Vielzahl von Aufgaben zu k√§mpfen. Daher ist es wichtig, dass das Tool intuitiv bedienbar ist und eine klare, √ºbersichtliche Benutzeroberfl√§che bietet. Funktionen wie Drag-and-Drop, einfache Navigation und eine anpassbare Dashboard-Ansicht wurden als essenziell identifiziert.  Ein weiterer wichtiger Aspekt der Anforderungsanalyse ist die Integration von kollaborativen Funktionen. In vielen Software Engineering-Kursen arbeiten Studierende in Gruppen an Projekten. Daher sollte das Tool M√∂glichkeiten zur gemeinsamen Bearbeitung von Aufgaben und zur Kommunikation innerhalb des Teams bieten. Funktionen wie Kommentarfunktionen, Versionskontrolle und Benachrichtigungen wurden als besonders wertvoll erachtet, um die Zusammenarbeit zu f√∂rdern und Missverst√§ndnisse zu vermeiden.  Die Flexibilit√§t des Tools wurde ebenfalls als entscheidendes Kriterium hervorgehoben. Studierende haben unterschiedliche Arbeitsstile und Pr√§ferenzen, weshalb das Tool anpassbar sein sollte. Die M√∂glichkeit, Aufgaben zu kategorisieren, Priorit√§ten zu setzen und individuelle Zeitpl√§ne zu erstellen, wurde als notwendig erachtet, um den unterschiedlichen Anforderungen gerecht zu werden.  Zus√§tzlich wurde die Integration von Lernressourcen und Unterst√ºtzungsmaterialien in die Anforderungsanalyse aufgenommen. Studierende ben√∂tigen oft zus√§tzliche Informationen und Hilfestellungen, um ihre Aufgaben effektiv zu bew√§ltigen. Die Einbindung von Tutorials, Best Practices und Links zu relevanten Ressourcen k√∂nnte die Lernkurve erheblich verk√ºrzen und die Effizienz der Studierenden steigern.  Abschlie√üend l√§sst sich sagen, dass die Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings eine Vielzahl von Aspekten ber√ºcksichtigt, die auf die spezifischen Bed√ºrfnisse der Nutzer zugeschnitten sind. Die Ergebnisse der Analyse bieten eine solide Grundlage f√ºr die Entwicklung eines Tools, das nicht nur die Effizienz der Studierenden steigert, sondern auch deren Lernerfahrung verbessert. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, die identifizierten Anforderungen in ein funktionales Design zu √ºberf√ºhren und die Implementierung in einer realen Lernumgebung zu testen, um die tats√§chliche Wirksamkeit des Tools zu evaluieren.;1
Reitz und Schlusser  empfehlen den Online-Dienst Read the Docs zum kostenlosen Hosten von Python-Dokumentation. Hierbei k√∂nnen Commit Hooks verwendet werden, sodass bei jedem Commit im Git-Repository die Dokumentationswebsite neu generiert wird . Read the Docs unterst√ºtzt die Dokumentationstools SphinxundMkDocs. Sphinx verwendet standardm√§√üig die Markup-Sprache reStructuredText , welche im Vergleich zu Markdown weniger verbreitet ist. Da MkDocs auf Markdown spezialisiert ist, wird damit die Dokumentationswebsite des MQTT-Szenarios realisiert. Als Theme wurdeMaterial for MkDocs verwendet, da es die Funktionalit√§ten aus den Heuristiken von Meng, Steinhardt und Schubert  unterst√ºtzt. Die Dokumentation ist in drei Teile aufgeteilt: ‚Ä¢Die Homepage, welche einen √úberblick √ºber den gesamten Inhalt der Dokumentation gibt. ‚Ä¢DasGetting Started -Kapitel, das den*die Benutzer*in durch die Einrichtung von Python, einer IDE, einem lokalen MQTT-Broker und schlie√ülich dem Projekt f√ºhrt. ‚Ä¢DemSmart Home Scenario -Kapitel, welches alle verf√ºgbaren Ger√§te, die Konfigura- tion eines eigenen Szenarios und die Implementierung von neuen Ger√§ten beschreibt. Abbildung 4.2: Code-Annotationen in der Online-Dokumentation Um den Bezug zwischen Flie√ütext und Code zu verbessern, k√∂nnen in Material for MkDocs Code-Annotationen hinzugef√ºgt werden. Diese werden mit einem Plus-Symbol angezeigt, wie in Abbildung 4.2 zu sehen ist. Mit einem Klick werden diese erweitert und in einem kleinen Fenster angezeigt. Zur schnellen Navigation kann eine Seitenleiste, welche die Abschnitte des Kapitels anzeigt, verwendet werden. Eine Suche ist √ºber ein Eingabefeld in der oberen Navigationsleiste erreichbar, wie in Abbildung 4.3 zu sehen ist. Hierbei kann durch Material for MkDocs auch nach unvollst√§ndigen W√∂rtern gesucht werden, was im originalen MkDocs nicht m√∂glich ist. Dadurch wird die Usability der Suche verbessert.;0
Rechtliche Rahmenbedingungen: In den Anforderungen in Kapitel 3.4wurde festgelegt, dass sich die verwendbaren Frequenzen auf die in Deutschland nutzbaren Frequenzen des ISM-Bands beschr√§nken m√ºssen und das das entwickelte Fahrzeug nicht auf √∂ffentlichen Stra√üen bewegt werden darf. Nachdem das Digi Xbee 3 RF-Modul sich mit einer Frequenz von 2.4 bis 2.4835 GHz innerhalb des gesetzlichen Rahmens bewegt, ist die Funknutzung in Deutschland zul√§ssig (siehe Kapitel 3.2.1). Im Rahmen des Projektes wurde das Fahrzeug mit der entwickelten Fahrzeugsteuerung nie auf √∂ffentlichen Stra√üen bewegt, weswegen diese Anforderungen erf√ºllt ist. F√ºr s√§mtliche darauf aufbauende Projekte wird an dieser Stelle noch einmal ausdr√ºcklich erw√§hnt, dass eine Verwendung der entwickelten Fahrzeuge im √∂ffentlichen Stra√üenverkehr nicht gestattet ist (siehe Kapitel 3.2.2). Anforderungen an Teleoperated Driving: Es wurde in den Anforderung festgelegt, dass die maximal zul√§ssige und erwartbare Geschwindigkeit auf 30km/h begrenzt ist, die maximale Latenz der Fernsteuerung 200ms unterschreiten muss und dass das Ziel eine Latenz von unter 100ms ist. Weiterhin soll eine verschl√ºsselte Verbindung verwendet werden und im Falle eines Verbindungsabbruchs soll eine Notbremsung eingeleitet werden (siehe Kapitel3.4). Die Geschwindigkeit des erarbeiteten Prototypen konnte mangels Messung nur gesch√§tzt werden, doch ist davon auszugehen, dass die maximale Geschwindigkeit von 30km/h deutlich unterschritten wird (siehe Abschnitt 5.7.4). Wie in Kapitel 5.8.2 beschrieben liegen bei 1982 Messpunkten √ºber einen Verlauf von 10 Minuten 98.99% der Messwerte unter einer Latenz von 100ms. Lediglich zwei Messwerte liegen mit 20.99ms und 34.98ms √ºber der vorgegebenen maximalen Latenz. Werden diese, wie in Kapitel 5.8.3erl√§utert, als Messfehler eingeordnet, so sind die Vorgaben an die Latenz erfolgreich umgesetzt worden. Dasselbe gilt f√ºr die Durchf√ºhrung einer Notbremsung im Falle eines Verbindungsabbruchs (siehe Kapitel 5.7.4).;0
Zwar ist die Aufrechterhaltung v on Softwarequalit√§t zeitaufw√§ndig und daher mit Kosten verbunden,  die Auswirkungen niedriger Codequalit√§t sind jedoch nicht zu vernachl√§ssigen. Langfristig wird die  Weiterentwicklung und Wartung des Quellcodes bei mangelhafter Qualit√§t stark erschwert. Es  werden deutlich mehr Zeit und Ressourcen f√ºr die Instandhaltung des Softwaresystems beansprucht,  was die Wartungskosten enorm in die H√∂he treibt. Hieraus ergibt sich ein Bedarf die Softwarequalit√§t  zu messen, z u √ºberwachen und somit zu verbessern.  F√ºr diese Aufgabe werden funktionierende und  verl√§ssliche Methoden und Technologien ben√∂tigt. Deren Einsatz soll in einem kontinuierlichen  Prozess zu einer Verbesserung der Softwarequalit√§t und somit zu effizienteren Releases sowie  hochwertigeren Softwareprodukten f√ºhren. Auf lange Sicht soll somit eine Steigerung der  Wartungskosten verhindert werden.   Softwaresysteme werden im Laufe ihrer Entwicklungszeit immer umfangreicher und komplexer.  Besonders wenn  die Qualit√§t des Quellcodes nicht ausreichend fokussiert wird, f√ºhrt dies besonders  bei Gro√üprojekten unweigerlich zu unstrukturiertem, komplexem und damit schwer zu  verstehendem Softwarecode. Auch Wartungseigenschaften bleiben bei der Entwicklung oftmals   unber√ºcksichtigt,  was zu steigenden Entwicklungs - und Betriebskosten sowie einer hohen  Fehleranf√§lligkeit f√ºhrt.   Hieraus ergibt sich die Motivation f√ºr den Einsatz von Metriken. Diese sind Teil der statistischen  Qualit√§tssicherung, bei der ein vorhandenes  Softwaresystem analysiert wird. Durch die Metriken  werden Messbarkeit und Vergleichbarkeit  von Merkmalen erreicht.  Durch die Analyse der  berechneten Messwerte, k√∂nnen zudem besonders komplexe und somit fehleranf√§llige  Programmteile identifiziert werden.;0
Im Rahmen dieser wissenschaftlichen Arbeit wurde der aktuelle Stand der Technik beim Testen von MQTT-basierten L√∂sungen umfassend analysiert. MQTT, als leichtgewichtiges Protokoll f√ºr die Nachrichten√ºbermittlung in IoT-Anwendungen, gewinnt zunehmend an Bedeutung, was die Notwendigkeit effektiver Testmethoden und -werkzeuge unterstreicht. Die Untersuchung hat gezeigt, dass sowohl die Herausforderungen als auch die L√∂sungsans√§tze im Bereich des Testens von MQTT-Anwendungen vielf√§ltig sind.  Einerseits stehen Tester vor der Aufgabe, die spezifischen Eigenschaften von MQTT, wie die asynchrone Kommunikation, die Publish-Subscribe-Architektur und die unterschiedlichen QoS-Stufen, in ihre Teststrategien zu integrieren. Diese Faktoren erfordern ma√ügeschneiderte Testans√§tze, um die Zuverl√§ssigkeit und Performance von MQTT-basierten Systemen zu gew√§hrleisten. Andererseits haben sich in den letzten Jahren verschiedene Tools und Frameworks etabliert, die eine Automatisierung und Effizienzsteigerung im Testprozess erm√∂glichen. Diese Technologien bieten Unterst√ºtzung in den Bereichen Lasttests, Integrationstests und Sicherheitstests, was die Qualit√§t der Anwendungen signifikant erh√∂ht.  Die Analyse hat zudem ergeben, dass die Community und die Forschungsgemeinschaft aktiv an der Weiterentwicklung von Testmethoden arbeiten. Es gibt Bestrebungen, standardisierte Verfahren zu entwickeln, die eine Vergleichbarkeit der Testergebnisse erm√∂glichen und die Integration von Testprozessen in agile Entwicklungsumgebungen erleichtern. Die zunehmende Vernetzung und die steigende Komplexit√§t von IoT-Systemen machen es notwendig, diese Entwicklungen kontinuierlich zu verfolgen und anzupassen.  Zusammenfassend l√§sst sich feststellen, dass der State of the Art beim Testen von MQTT-basierten L√∂sungen dynamisch und vielschichtig ist. W√§hrend bereits zahlreiche Ans√§tze existieren, bleibt die Forschung in diesem Bereich unerl√§sslich, um den wachsenden Anforderungen gerecht zu werden und die Qualit√§t von MQTT-Anwendungen nachhaltig zu sichern. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, innovative Testmethoden zu entwickeln und bestehende Tools weiter zu optimieren, um den Herausforderungen der sich st√§ndig weiterentwickelnden Technologie im IoT-Sektor gerecht zu werden.;1
Content Management Systeme bzw. Web- CMS stellen sich auch in Zukunft als eine attraktive L√∂sung f√ºr die (einfache) Umsetzung von Websites ohne Programmierkenntnisse dar. Die stetig vorankehrende Digitalisierung l√§sst auch neue Trends in CM-Systeme einflie√üen. Diese Herausforderungen m√ºssen CMS-Herausgeber fr√ºhzeitig erkennen, um auch k√ºnftig eine relevante Marktposition einhalten zu k√∂nnen. Durch die Community-Nutzer der CM-Systeme k√∂nnen Trends zus√§tzlich vorzeitig erkannt und umgesetzt werden. Somit finden durch die Community eines Systems entwickelte Funktionserweiterungen h√§ufig Einzug in neue Versions-Releases der Systeme. Selbst f√ºhrende Technologie-Unternehmen wie Adobe, SAP oder Oracle verwenden Konzep- te des Content-Managements, um ihren Kunden bedienungsfreundliche Softwareprodukte bereitzustellen. Ein Beispiel hierf√ºr ist die ‚ÄûSAP Commerce Cloud‚Äú, mit welcher bereits heute neben eCommerce-Webpr√§senzen auch informative Unternehmenswebsites erstellt werden k√∂nnen.;0
 Kapitel 2: Technische Grundlagen  In der heutigen digitalen Landschaft stehen Entwickler vor der Herausforderung, Anwendungen zu schaffen, die sowohl funktional als auch benutzerfreundlich sind. Im Kontext der vorliegenden Arbeit, die sich mit dem Vergleich von Progressive Web Apps (PWAs) und nativen Apps am Beispiel einer Journaling-App besch√§ftigt, ist ein vertieftes Verst√§ndnis der technischen Grundlagen beider Ans√§tze unerl√§sslich. Dieses Kapitel beleuchtet die wesentlichen Technologien und Konzepte, die PWAs und native Apps definieren und voneinander unterscheiden.   2.1 Progressive Web Apps (PWAs)  PWAs sind eine moderne Webanwendung, die die besten Eigenschaften von Web- und mobilen Anwendungen vereint. Sie basieren auf standardisierten Webtechnologien wie HTML, CSS und JavaScript und nutzen dabei fortschrittliche Funktionen, um eine App-√§hnliche Benutzererfahrung zu bieten. Zu den zentralen Merkmalen von PWAs geh√∂ren:  - Responsive Design: PWAs sind so konzipiert, dass sie auf verschiedenen Bildschirmgr√∂√üen und -aufl√∂sungen optimal dargestellt werden. Dies geschieht durch flexible Layouts und Medienabfragen, die eine Anpassung an die jeweilige Umgebung erm√∂glichen.  - Service Worker: Ein zentrales Element von PWAs ist der Service Worker, ein im Hintergrund laufendes Skript, das die Interaktion zwischen der Anwendung und dem Netzwerk steuert. Er erm√∂glicht Offline-Funktionalit√§t, indem er Inhalte zwischenspeichert und Anfragen abf√§ngt, um sie aus dem Cache zu bedienen. Dies ist besonders wichtig f√ºr eine Journaling-App, da Nutzer auch ohne Internetverbindung Eintr√§ge erstellen und speichern k√∂nnen.  - Web App Manifest: PWAs verwenden ein Manifest, das Informationen √ºber die Anwendung bereitstellt, wie z.B. den Namen, das Icon und die Start-URL. Dieses Manifest erm√∂glicht es, die Anwendung direkt von dem Home-Bildschirm des Ger√§ts zu starten, √§hnlich wie bei nativen Apps.  - HTTPS: PWAs erfordern eine sichere Verbindung √ºber HTTPS, um die Integrit√§t und Vertraulichkeit der Daten zu gew√§hrleisten. Dies ist besonders relevant f√ºr eine Journaling-App, in der pers√∂nliche und m√∂glicherweise sensible Informationen gespeichert werden.   2.2 Native Apps  Native Apps sind speziell f√ºr ein bestimmtes Betriebssystem (iOS, Android, etc.) entwickelte Anwendungen. Sie werden in der jeweiligen Programmiersprache geschrieben (z.B. Swift f√ºr iOS, Kotlin f√ºr Android) und nutzen die nativen APIs des Betriebssystems, um auf Hardware und Funktionen des Ger√§ts zuzugreifen. Die wichtigsten Merkmale nativer Apps sind:  - Leistung: Native Apps bieten in der Regel eine √ºberlegene Leistung, da sie direkt auf die Hardware-Ressourcen des Ger√§ts zugreifen k√∂nnen. Dies erm√∂glicht eine schnellere Ausf√ºhrung von Aufgaben und eine reibungslosere Benutzererfahrung, was f√ºr eine Journaling-App, die m√∂glicherweise gro√üe Datenmengen verwalten muss, von Vorteil ist.  - Zugriff auf Ger√§tefunktionen: Native Apps haben uneingeschr√§nkten Zugriff auf Ger√§tefunktionen wie Kamera, GPS und Benachrichtigungen. Dies er√∂ffnet Entwicklern die M√∂glichkeit, innovative Features zu integrieren, die das Nutzererlebnis bereichern.  - App Store Distribution: Native Apps werden √ºber off;1
 Kapitel 3: Erstellung eines Content Management Systems (CMS) zur Entwicklung von Android Apps f√ºr den humanoiden Roboter Pepper   3.1 Einleitung  Die rasante Entwicklung in der Robotik und der k√ºnstlichen Intelligenz hat die Notwendigkeit verst√§rkt, benutzerfreundliche Schnittstellen zu schaffen, die es Entwicklern und nicht-technischen Nutzern erm√∂glichen, innovative Anwendungen f√ºr humanoide Roboter zu erstellen. In diesem Kapitel wird der Aufbau eines Content Management Systems (CMS) beschrieben, das speziell f√ºr die Entwicklung von Android Apps f√ºr den humanoiden Roboter Pepper konzipiert ist. Ziel ist es, die Erstellung, Verwaltung und Bereitstellung von Anwendungen zu vereinfachen und zu optimieren.   3.2 Anforderungsanalyse  Der erste Schritt bei der Erstellung eines CMS ist die umfassende Anforderungsanalyse. Hierbei werden die Bed√ºrfnisse der Zielgruppe, bestehend aus Entwicklern, Designern und Endnutzern, identifiziert. Wichtige Anforderungen umfassen:  - Benutzerfreundlichkeit: Eine intuitive Benutzeroberfl√§che, die es auch unerfahrenen Nutzern erm√∂glicht, Anwendungen ohne tiefgehende Programmierkenntnisse zu erstellen. - Modularit√§t: Die M√∂glichkeit, verschiedene Module oder Plugins zu integrieren, um spezifische Funktionen zu erweitern. - Integration von APIs: Eine nahtlose Anbindung an die APIs von Pepper, um die Interaktion mit den Hardwarekomponenten des Roboters zu erm√∂glichen. - Multimedia-Unterst√ºtzung: Die F√§higkeit, verschiedene Medientypen (Audio, Video, Bilder) einfach zu integrieren und zu verwalten. - Versionierung und Bereitstellung: Ein System zur Verwaltung von Versionskontrollen und zur einfachen Bereitstellung von Anwendungen auf dem Roboter.   3.3 Systemarchitektur  Die Architektur des CMS gliedert sich in mehrere Schichten:  1. Pr√§sentationsschicht: Diese Schicht umfasst die Benutzeroberfl√§che, die mit modernen Webtechnologien wie HTML, CSS und JavaScript entwickelt wird. Responsive Design ist entscheidend, um die Nutzung auf verschiedenen Endger√§ten zu erm√∂glichen.  2. Logikschicht: Hier wird die Gesch√§ftslogik implementiert, die die Interaktion zwischen der Benutzeroberfl√§che und der Datenbank steuert. Frameworks wie Django oder Ruby on Rails k√∂nnen zur Umsetzung dieser Schicht verwendet werden.  3. Datenschicht: Eine relationale Datenbank (z.B. MySQL oder PostgreSQL) speichert die Anwendungsdaten, Benutzerinformationen und Mediendateien. Ein gut strukturiertes Datenmodell ist entscheidend f√ºr die Performance und Skalierbarkeit des Systems.  4. Integrationsschicht: Diese Schicht erm√∂glicht die Kommunikation mit der Pepper API und anderen externen Diensten, um die Funktionalit√§ten des Roboters zu erweitern.   3.4 Implementierung  Die Implementierung des CMS erfolgt in mehreren Phasen:  - Prototyping: Zu Beginn wird ein Prototyp entwickelt, um die grundlegenden Funktionen zu testen und Feedback von potenziellen Nutzern einzuholen. Dies f√∂rdert die iterative Entwicklung und erm√∂glicht Anpassungen in fr√ºhen Phasen.  - Modulentwicklung: Basierend auf den gesammelten Anforderungen werden Module f√ºr spezifische Funktionen entwickelt, wie z.B. ein Modul zur Spracherkennung;1
In der vorliegenden Arbeit wird eine umfassende Gegen√ºberstellung von Content-Management-Systemen (CMS) durchgef√ºhrt, um deren Eignung f√ºr unterschiedliche Anwendungsbereiche zu analysieren. Angesichts der stetig wachsenden Bedeutung von Webinhalten in der digitalen Landschaft ist die Wahl des richtigen CMS entscheidend f√ºr den Erfolg von Online-Projekten. Die Arbeit beginnt mit einer theoretischen Fundierung der Grundlagen von CMS, gefolgt von einer systematischen Methodik zur Evaluierung verschiedener Systeme. Im Anschluss werden weit verbreitete CMS wie WordPress, Joomla, Drupal und TYPO3 hinsichtlich ihrer Benutzerfreundlichkeit, Skalierbarkeit, Sicherheitsmerkmale und Anpassungsf√§higkeit verglichen. Die Analyse basiert auf qualitativen und quantitativen Kriterien, die durch Experteninterviews und Nutzerumfragen erg√§nzt werden. Die Ergebnisse zeigen signifikante Unterschiede in den St√§rken und Schw√§chen der einzelnen Systeme, die spezifische Anforderungen und Zielgruppen ansprechen. Abschlie√üend werden praxisnahe Empfehlungen f√ºr Entwickler und Entscheider formuliert, um fundierte Entscheidungen bei der CMS-Auswahl zu unterst√ºtzen. Diese Arbeit leistet somit einen wertvollen Beitrag zur Diskussion √ºber die optimale Nutzung von Content-Management-Systemen in einer sich schnell wandelnden digitalen Umgebung.;1
Die Studienarbeit umfasst die Auswahl geeigneter Qualit√§tsmerkmale und Metriken, um Messungen  an einem Softwareprojekt, besonders bei Programmieraufgaben von Studierenden, durchf√ºhren zu  k√∂nnen. Es sollen geeignete Tools ausgew√§hlt und eine bespielhafte Interpretation der erhobenen  Daten vorgenommen werden. Ziel der Arbeit ist es  aufzuzeigen , ob und in welcher Weise es m√∂glich  ist, den zu bewertenden Quellcode auf ausgew√§hlte Qualit√§tsmerkmale zu untersuchen und einen  ersten Aufschluss √ºber die Softwarequalit√§t zu erhalten.   Zun√§chst soll in einem theoretischen Teil in die Thematik der Metriken zur Bewertung von  Softwarequalit√§t eingef√ºhrt werden. Die herausgearbeiteten Grundlagen sollen im Hauptteil f√ºr das  Verst√§ndnis der Auswahl und Bewertung von Qualit√§tsmerkmale und Metriken dienen.   Um aussagekr√§ftige Messungen durchf√ºhren zu k√∂nnen, deren Messwerte zur Bewertung  herangezogen werden k√∂nnen, m√ºssen zun√§chst relevante Metriken definiert werden. Diese sollen  anhand von vorher ermittelten Qualit√§tsmerkmalen abgeleitet werden. Die Auswahl relevanter  Qualit√§tsmerkmalen erfolgt durch Literaturarbeit. Dabei sollen Ver√∂ffentlichungen bekannter  Vertreter des Bereichs der Softwarequalit√§t herangezogen werden. Die verbreitetsten  Anforderungen an qualitativ hochwertige Software sollen dann auf Anwendbarkeit untersucht  werden. Dabei sollen sie unter anderem in den Kontext eines studentischen Programmierprojekts  gesetzt werden.   Nach der Festlegung aller zu betrachtenden Metriken, sollen Tools ausgew√§hlt werden, mit denen  die Messungen im vorliegenden beispielhaften Programmierprojekt durchgef√ºhrt werden k√∂nnen.  Diese Tools sollen implementiert und anschlie√üend Daten erfasst werden. Am Ende stehen die  Auswertung und Interpretation der Messergebnisse.         Der Qualit√§tsbegriff ist abstrakt und kann nicht eindeutig definiert werden. Aus diesem Grund  existieren auch beim Thema rund um Softwarequalit√§t zahlreiche Meinungen und Sichtweisen wie  diese zu beschreiben ist.  Viele bekannte Ans√§tze f√ºr die Bewertung von Softwarequalit√§t weisen  jedoch eine hohe √úbereinstimmung auf. Zwei der bekanntesten Werke stammen von den Vorreitern  Boehm et al. sowie McCall et al . Eine weit verbreitete Definition, die lange nach den  Ver√∂ffentlichungen dieser Autoren erstellt wurde, ist die Norm ISO/IEC 9126  sowie deren Nachfolger,  die in der Normenreihe  ISO/IEC 250 xx, die auch unter dem Begriff  SQuaRE zusammengefasst wird,  enthalten sind. Ziel dieses Standards ist die einheitliche Bewertung von Softwarequalit√§t und eine  daraus folgende Vergleichbarkeit zwischen Produkten.    Genauer handelt es sich bei den f√ºr diese Arbeit relevanten Ausarbeitungen um die Nor m ISO/IEC  25010, in der Qualit√§tskriterien f√ºr Softwareprodukte festgelegt werden, sowie um den Standard  ISO/IEC 25023, der sich mit der Messung interner und externer Softwarequalit√§t sowie den daf√ºr  relevanten Faktoren auseinandersetzt. Eine Einordnung di eses Standards in den Kontext der  Normenreihe ISO/IEC 2502x ist in Abbildung 1 dargestellt.    Auch im Bereich der Codequalit√§t gibt es verschieden Ans√§tze, um eine m√∂glichst hohe Qualit√§t zu  erreichen. Ein Begriff , der von Robert C. Martin gepr√§gt wurde  und zu gro√üer Bekanntheit gelangte,  ist das sogenannte Clean Coding. Damit wird  intuitiv verst√§ndlicher Code  bezeichnet , der ohne  gro√üen Aufwand gewartet werden kann.;0
Gegen√ºberstellung von Content-Management-Systemen: Eine Analyse  In der heutigen digitalen √Ñra sind Content-Management-Systeme (CMS) unverzichtbare Werkzeuge f√ºr die Erstellung, Verwaltung und Ver√∂ffentlichung von Inhalten im Internet. Die Auswahl des richtigen CMS kann entscheidend f√ºr den Erfolg einer Website oder eines Online-Projekts sein. In dieser Analyse werden verschiedene CMS hinsichtlich ihrer Funktionalit√§ten, Benutzerfreundlichkeit, Flexibilit√§t und Skalierbarkeit gegen√ºbergestellt, um ein umfassendes Bild der aktuellen Landschaft zu zeichnen.  Zun√§chst ist WordPress zu erw√§hnen, das weltweit am h√§ufigsten verwendete CMS. Mit seiner benutzerfreundlichen Oberfl√§che und einer riesigen Auswahl an Plugins und Themes erm√∂glicht WordPress sowohl Anf√§ngern als auch erfahrenen Entwicklern die einfache Erstellung und Anpassung von Websites. Die offene Architektur von WordPress f√∂rdert eine lebendige Community, die kontinuierlich zur Verbesserung des Systems beitr√§gt. Dennoch kann die Vielzahl an Plugins auch zu einer √úberladung f√ºhren, die die Ladezeiten der Website negativ beeinflussen kann. Zudem ist WordPress anf√§llig f√ºr Sicherheitsrisiken, insbesondere wenn Plugins von Drittanbietern verwendet werden.  Ein weiteres popul√§res CMS ist Joomla, das sich durch eine h√∂here Flexibilit√§t und erweiterte Funktionalit√§ten auszeichnet. Joomla eignet sich besonders f√ºr komplexere Websites und Anwendungen, die eine ausgekl√ºgelte Benutzerverwaltung und mehrsprachige Unterst√ºtzung erfordern. Im Vergleich zu WordPress erfordert Joomla jedoch eine steilere Lernkurve, was es weniger anf√§ngerfreundlich macht. Die umfangreiche Dokumentation und die aktive Community k√∂nnen jedoch helfen, diese H√ºrde zu √ºberwinden. Joomla ist besonders geeignet f√ºr Unternehmen, die eine robuste Plattform mit erweiterten Funktionen ben√∂tigen, jedoch weniger ideal f√ºr einfache Blogs oder pers√∂nliche Websites.  Drupal ist ein weiteres leistungsstarkes CMS, das vor allem f√ºr seine hohe Flexibilit√§t und Sicherheit gesch√§tzt wird. Es eignet sich besonders f√ºr gro√üe und komplexe Websites, die eine ma√ügeschneiderte L√∂sung erfordern. Drupal bietet eine Vielzahl von Modulen, die eine umfangreiche Anpassung erm√∂glichen. Die Lernkurve ist jedoch steil, und die Verwaltung kann f√ºr weniger technikaffine Benutzer herausfordernd sein. Drupal wird oft von Institutionen und Unternehmen bevorzugt, die spezifische Anforderungen an Sicherheit und Skalierbarkeit haben.  In der j√ºngeren Vergangenheit haben sich Headless-CMS wie Contentful und Strapi etabliert, die einen modernen Ansatz zur Inhaltsverwaltung bieten. Diese Systeme trennen die Backend-Verwaltung von der Frontend-Pr√§sentation, was Entwicklern erm√∂glicht, Inhalte √ºber APIs in verschiedene Plattformen und Ger√§te zu integrieren. Headless-CMS sind besonders vorteilhaft f√ºr Unternehmen, die eine Omnichannel-Strategie verfolgen und Inhalte √ºber verschiedene Kan√§le hinweg bereitstellen m√∂chten. Allerdings erfordern sie ein gewisses Ma√ü an technischem Know-how, da sie keine standardisierten Templates oder Frontend-Tools bieten.  Ein weiteres bemerkenswertes CMS ist TYPO3, das sich durch seine Flexibilit√§t und Erweiterbarkeit auszeichnet. Es ist besonders in Europa verbreitet und wird h√§ufig von gr√∂√üeren Unternehmen und Institutionen eingesetzt. TYPO3 bietet eine Vielzahl von Funktionen, die eine umfassende Anpassung und Skalierung erm√∂glichen. Die Komplexit√§t des Systems kann jedoch f√ºr kleinere Unternehmen oder Einzelpersonen, die eine einfache L√∂sung suchen, abschreckend sein.  Abschlie√üend l√§sst;1
 Kapitel 2: Technische Grundlagen zur Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung   2.1 Einleitung  Das Internet der Dinge (IoT) hat in den letzten Jahren einen revolution√§ren Einfluss auf viele Lebensbereiche ausge√ºbt. Insbesondere im Bereich der Heimautomatisierung und der Tierpflege er√∂ffnen IoT-Systeme neue M√∂glichkeiten f√ºr Komfort, Sicherheit und Effizienz. Diese Arbeit befasst sich mit der Entwicklung eines IoT-Systems zur Steuerung einer Katzenklappe, das auf einer KI-gesteuerten Katzenerkennung basiert. In diesem Kapitel werden die technischen Grundlagen erl√§utert, die f√ºr die Implementierung dieses Systems erforderlich sind.   2.2 Komponenten des IoT-Systems  Ein funktionales IoT-System zur Steuerung einer Katzenklappe besteht aus mehreren Schl√ºsselkomponenten:   2.2.1 Sensoren und Aktoren  - Kamerasensor: Eine hochaufl√∂sende Kamera dient zur Bilderfassung der n√§hertretenden Katze. Dieser Sensor ist entscheidend, um die Identit√§t der Katze zu √ºberpr√ºfen und sicherzustellen, dass nur autorisierte Tiere Zugang erhalten.    - Motoraktoren: Diese Komponenten sind verantwortlich f√ºr die physische Steuerung der Katzenklappe. Sie m√ºssen zuverl√§ssig und schnell genug reagieren, um eine sichere und zeitgerechte √ñffnung und Schlie√üung der Klappe zu gew√§hrleisten.   2.2.2 Mikrocontroller  - Arduino oder Raspberry Pi: Ein Mikrocontroller oder ein Einplatinencomputer wie Raspberry Pi wird als zentrale Steuereinheit fungieren. Dieser steuert die periphere Hardware (Kamera und Motor), verarbeitet die Bilddaten und kommuniziert mit einem Cloud-Dienst zur Datenspeicherung und -verarbeitung.   2.2.3 Netzwerkverbindung  - Wi-Fi oder Bluetooth: Um das System in das IoT zu integrieren, ist eine drahtlose Netzwerkverbindung erforderlich. Wi-Fi bietet eine h√∂here Reichweite und Geschwindigkeit, w√§hrend Bluetooth eine energieeffiziente Option f√ºr lokale Verbindungsszenarien darstellt.   2.2.4 Cloud-Architektur  - Cloud-Computing-Plattform: Eine Cloud-Plattform (z. B. AWS IoT, Google Cloud IoT) wird ben√∂tigt, um die von der Kamera erfassten Bilder zu speichern und die KI-Modelle zur Katzenerkennung zu hosten. Diese Plattform erm√∂glicht auch die Wartung und Aktualisierung des Systems.   2.3 K√ºnstliche Intelligenz und Bildverarbeitung  Um die Katzen zuverl√§ssig zu erkennen, spielt K√ºnstliche Intelligenz (KI) eine essenzielle Rolle. Im Folgenden werden die erforderlichen Algorithmen und Techniken erl√§utert.   2.3.1 Datensammlung und -aufbereitung  Die Entwicklung eines KI-Modells zur Katzenerkennung erfordert einen umfangreichen Datensatz von Bildern, die Katzen aus verschiedenen Perspektiven und unter unterschiedlichen Lichtverh√§ltnissen zeigen. Dieser Datensatz dient als Grundlage f√ºr das Training des Modells und sollte auch verschiedene Rassen und Gr√∂√üen von Katzen umfassen.   2.3.2 Modelltraining  - Neurale Netze: Convolutional Neural Networks (CNNs) sind besonders geeignet f√ºr die Bildklassifikation und werden in diesem Projekt verwendet. Sie sind in der Lage, Merkmale aus Bildern zu extrahieren und spezifische Muster zu erkennen.  - Transfer Learning: Um den Trainingsaufwand zu reduzieren, kann ein vortrainiertes Modell (z.B. von ImageNet) als Ausgangspunkt verwendet werden. Dieses Modell kann dann auf den spezifischen Datensatz angepasst werden, um die Genauigkeit der Katzenerkennung zu erh√∂hen.   2.3.3 Implementierung der Katzenerkennung  Die Implementierung erfolgt in mehreren Schritten:  - Bilderfassung: Die Kamera erfasst kontinuierlich Bilder, die an den Mikrocontroller gesendet werden.    - Bildverarbeitung: Der Mikrocontroller leitet die Bilddaten an das KI-Modell weiter, das in der Cloud gehostet wird.  - Ergebnisinterpretation: Das Modell gibt eine R√ºckmeldung, ob eine Katze im Bild erkannt wurde und ob es sich um eine autorisierte Katze handelt. Diese Informationen steuern dann die Aktion des Motoraktors.   2.4 Sicherheit und Datenschutz  Beim Design eines IoT-Systems sind Sicherheitsaspekte von gr√∂√üter Bedeutung, da das System Daten sammelt und m√∂glicherweise Zugriff auf physische Bereiche des Hauses hat. Zu den notwendigen Sicherheitsma√ünahmen geh√∂ren:  - Datensicherheit: Alle Daten√ºbertragungen sollten √ºber sichere Protokolle (z.B. HTTPS, MQTT √ºber TLS) erfolgen, um vertrauliche Informationen zu sch√ºtzen.    - Zugriffskontrolle: Nur autorisierte Benutzer sollten Zugriff auf die Steuerung der Katzenklappe haben. Dies kann durch ein Authentifizierungssystem realisiert werden.  - Datenschutz: Es m√ºssen Richtlinien implementiert werden, um sicherzustellen, dass die gesammelten Daten anonymisiert und nicht ohne Zustimmung verwendet werden.   2.5 Fazit  Die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung setzt sich aus verschiedenen technologischen Bausteinen zusammen, die zusammenarbeiten m√ºssen, um ein funktionales und sicheres System zu gew√§hrleisten. Die Auswahl geeigneter Hardware, die Entwicklung von KI-Modellen zur Katzenerkennung und die Implementierung robuster Sicherheitsprotokolle sind essentielle Schritte, die im weiteren Verlauf dieser Arbeit detailliert behandelt werden.;1
Zum Zeitpunkt dieser Arbeit stehen bei Drupal √ºber 3.000 Design-Vorlagen (‚ÄûThemes‚Äú) zur Verf√ºgung, welche nach Relevanz, Anzahl der Downloads sowie Aktualit√§t sortiert werden k√∂nnen. √úber den Theme-Browser direkt auf der Website von Drupal k√∂nnen diese heruntergeladen werden. Die Installation erfolgt hierbei wahlweise √ºber den Upload des ZIP-Archivs oder √ºber das Einf√ºgen der innerhalb der Drupal-Website verlinkten Download-URL des Designs. Nach erfolgter Aktivierung eines Themes werden bestehende Inhalte automatisiert anhand des definierten Stils dargestellt und beim Seitenaufruf gerendert. Die Einstellungsm√∂glich- keiten variieren hierbei von Theme zu Theme und k√∂nnen jeweils √ºber das Admin-Backend vorgenommen werden. H√§ufig lassen sich hier vordefinierte Farbgebungen sowie Inhalts- anordungen anpassen. Anhand der Vielzahl an verf√ºgbaren Themes, deren einfache Installation sowie den ver- schiedenen M√∂glichkeiten, Darstellungen zu bearbeiten, wird das System mit der Farbe Gr√ºn kategorisiert.;0
"  I.   Die Luftqualit√§t hat signifikante Auswirkungen auf die Gesundheit und das Wohlbefinden des Menschen. Angesichts urbaner Umweltverschmutzung und offensichtlicher Herausforderungen durch Schadstoffe gewinnt die Entwicklung von Luftreinigungsger√§ten zunehmend an Bedeutung. In den letzten Jahren hat der elektronische Fortschritt es erm√∂glicht, diese Ger√§te nicht nur effektiver zu gestalten, sondern auch deren Bedienbarkeit und Selbstregelung durch harmonisierte Interaktion mit Anwendern zu optimieren. Dieser Text widmet sich den theoretischen Grundlagen zur Optimierung der Visualisierung, Bedienung und der Selbstregelung von elektronisch erweiterten Luftreinigungsger√§ten.  II. Visualisierung von Informationen  Die effektive Visualisierung von Informationen ist entscheidend f√ºr die Benutzerfreundlichkeit eines Luftreinigungsger√§tes. Eine Theorie, die hier als Grundlage dient, ist das gestaltungspsychologische Modell, welches Prinzipien wie Informationshierarchie, Farbsymbolik und Lesbarkeit umfasst. Durch die Konzeption ansprechender und intuitiver Benutzeroberfl√§chen kann komplexe Luftqualit√§tsdaten, wie beispielsweise Partikelkonzentrationen, VOCs (fl√ºchtige organische Verbindungen) oder –±–∏–∫–ª_dims loci (Schimmelpunkten) beeinflussen. Das Design sollte visuelle Hierarchien nutzen, um kritische Informationen hervorzuheben und gleichzeitig ein durchg√§ngiges Raster f√ºr Bewertungen bieten.  Die Implementierung von farblichen Indikatoren, die den aktuellen Reinheitsgrad der Luft reflektieren (z.B. rot f√ºr schlechte Qualit√§t, gr√ºn f√ºr gute Qualit√§t), ist ein typisches Beispiel, das auf die Speidungsthetical von Menschen im Wahrnehmungssystem zur√ºckgeht. Dar√ºber hinaus erm√∂glichen Grafiken und Diagramme, historische Trends einfachen verst√§ndlich zu vermitteln, was den Benutzer anspricht und ihm Kontrolle √ºber angrenzende Parameter bietet.  III. Bedienungsperspektiven  In Bezug auf die Bedienung eines Luftreinigers ist das wertsch√§tzende Ziel der Minimierung der Komplexit√§t bei den Steuerelementen ein zentraler Aufwand. Prinzipien der Gestaltpsychologie, insbesondere die CCTV-Hierarchie (Cue, Composition, Transformation and Verify) k√∂nnen als Rahmen dienen, um Bedienelemente benutzerfreundlich zu gestalten. Die dezentrierte Anordnung physischer Bedienelemente kann die Erkennbarkeit f√∂rdern, w√§hrend auch digitale Interfaces durch unsere Bewegungsmuster visualisiert werden k√∂nnen; Funktionsschaltfl√§chen sollten intuitiv-Platzierung f√ºr maximale Benutzererfahrung garantieren.  Zus√§tzlich k√∂nnte Big Data Technologien aktiv zum Einsatz kommen, um Vorlieben und Nutzerverhalten zu analysieren. Indem man den Nutzern personalisierte Bedienoptionen auf Basis des Nutzerverhaltens erm√∂glicht, kann die Interaktion mit dem Ger√§t hektische Gestaltung minimiert und die Gesam—Ç–µ Erlebnis von Funktionen vereinfacht werden.  IV. Selbstregelungskapazit√§ten  Selbstregulierungsmechanismen sind instinktiv revolution√§r f√ºr moderne Luftreinigungstechnik. Unterst√ºtzt durch Filtertechnologien und Algorithmen f√ºr maschinelles Lernen kann das Luftreinigungsger√§t basierend auf Echtzeitdaten automatisch Bedingungen erkennen, die einen";1
"  Die Qualit√§t von Software ist ein zentrales Thema in der Softwareentwicklung, da sie ma√ügeblich die Benutzerzufriedenheit, die Wartbarkeit und die langfristige Leistungsf√§higkeit von Softwareanwendungen beeinflusst. Im Kontext der Softwarequalit√§t werden produktorientierte Metriken als quantifizierbare Indikatoren definiert, die sich auf das Endprodukt konzentrieren. Diese Metriken bieten Einblicke in verschiedene Aspekte der Software, wie z.B. ihre Funktionalit√§t, Zuverl√§ssigkeit, Effizienz und Wartbarkeit.   Definition produktorientierter Metriken  Produktorientierte Metriken sind spezifische Ma√üe, die zur Bewertung von Eigenschaften eines Softwareprodukts herangezogen werden. Sie k√∂nnen grob in vier Kategorien unterteilt werden  1. Funktionsorientierte MetrikenDiese messen, inwieweit die Software die definierten Anforderungen erf√ºllt. Beispiele sind die Anzahl der implementierten Features oder die Abdeckung der Funktionalit√§tsanforderungen.  2. Zuverl√§ssigkeitsmetrikenDiese bewerten die F√§higkeit der Software, unter definierten Bedingungen fehlerfrei zu arbeiten. Zuverl√§ssigkeitsmetriken k√∂nnen die Fehlerdichte oder die mittlere Zeit zwischen Ausf√§llen (MTBF) umfassen.  3. EffizienzmetrikenDiese beurteilen, wie gut die Software Ressourcen wie CPU, Speicher oder Netzwerkbandbreite nutzt. Ein Beispiel hierf√ºr ist die Reaktionszeit eines Systems unter Last oder der Speicherverbrauch bei bestimmten Operationen.  4. WartbarkeitsmetrikenDiese messen, wie leicht eine Software ver√§ndert, erweitert oder angepasst werden kann. Indikatoren sind beispielsweise die Komplexit√§t des Codes, die Anzahl der Kommentare oder die Modularit√§t des Designs.   Anwendung produktorientierter Metriken  Die Anwendung produktorientierter Metriken ist entscheidend f√ºr die Identifikation und das Management von Softwarequalit√§tsaspekten. Um eine eigene L√∂sung zur Implementierung produktorientierter Metriken zu entwickeln, sind folgende Schritte erforderlich  1. Anforderungsanalyse  Zun√§chst muss eine gr√ºndliche Anforderungsanalyse durchgef√ºhrt werden, um die spezifischen Metriken zu identifizieren, die f√ºr die jeweilige Anwendung relevant sind. Dazu geh√∂rt das Einholen von Anforderungen der Stakeholder sowie das Verst√§ndnis der spezifischen Gesch√§ftsziele und Nutzungsszenarien der Software.   2. Metrikenauswahl und -definition  Basierend auf den identifizierten Anforderungen sollten spezifische Metriken ausgew√§hlt und klar definiert werden. Dies kann anhand bestehender Standards und Best Practices geschehen. Ein Beispiel k√∂nnte die Auswahl der ""Cyclomatic Complexity"" als Metrik zur Bewertung der Wartbarkeit des Codes sein.   3. Implementierung der Metrikenerfassung  In der n√§chsten Phase sollte ein automatisiertes System zur Erfassung der Metriken entwickelt werden. Dies k√∂nnte durch die Integration von Metriktools in die bestehende Entwicklungsumgebung geschehen. Beispielhafte Tools sind SonarQube f√ºr Codequalit√§t oder JMeter f√ºr Leistungsmetriken.   4. Analyse und Auswertung  Die gesammelten Daten m√ºssen analysiert und in einem verst√§ndlichen Format aufbereitet werden. Hierbei k√∂nnen Dashboards und Berichte helfen, die Metriken √ºbersichtlich darzustellen und Trends zu erkennen. Eine statistische Analyse kann zudem dabei unterst√ºtzen, Korrelationen zwischen Metriken zu identifizieren und potenzielle Probleme fr√ºhzeitig zu erkennen.   5. Ma√ünahmenableitung und kontinuierliche Verbesserung  Auf Basis der ermittelten Metriken sollen Ma√ünahmen zur Verbesserung der Softwarequalit√§t abgeleitet werden. Dies erfordert eine enge Zusammenarbeit zwischen Entwicklungsteams und Qualit√§tssicherung. Ein iterativer Ansatz, bei dem Metriken kontinuierlich √ºberwacht und angepasst werden, f√∂rdert eine proaktive Qualit√§tskultur.   Fazit  Die Definition und Anwendung produktorientierter Metriken bietet eine strukturierte Herangehensweise zur Bewertung und Verbesserung der Softwarequalit√§t. Die  zur Metrikenerfassung erfordert eine sorgf√§ltige Planung und ausgekl√ºgelte Techniken, um sicherzustellen, dass die gewonnenen Daten tats√§chlich den gew√ºnschten Mehrwert liefern. Durch die Kombination von Anforderungsanalyse, Metrikenauswahl, Datenerfassung und fortlaufender Verbesserung k√∂nnen Unternehmen die Qualit√§t ihrer Softwareprodukte signifikant erh√∂hen und somit sowohl die Benutzerzufriedenheit als auch die Wirtschaftlichkeit ihrer Produkte steigern.";1
"Evaluierung: Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t  Die Qualit√§t von Software ist ein zentrales Anliegen in der Informatik und der Softwareentwicklung, da sie entscheidend f√ºr die Benutzerzufriedenheit, die Wartbarkeit und die langfristige Effizienz von Systemen ist. In diesem Kontext gewinnen produktorientierte Metriken zunehmend an Bedeutung. Diese Metriken bieten eine quantifizierbare Grundlage zur Bewertung der Softwarequalit√§t, indem sie sich auf das Endprodukt selbst konzentrieren, anstatt auf den Entwicklungsprozess oder die Teamdynamik.  Produktorientierte Metriken lassen sich in verschiedene Kategorien unterteilen, darunter Strukturmetriken, Verhaltensmetriken und Zuverl√§ssigkeitsmetriken. Strukturmetriken, wie etwa die Anzahl der Codezeilen, die Komplexit√§t des Codes oder die Anzahl der Klassen und Methoden, bieten einen ersten Anhaltspunkt f√ºr die Komplexit√§t und Lesbarkeit des Codes. Diese Metriken sind n√ºtzlich, um technische Schulden zu identifizieren und den Wartungsaufwand abzusch√§tzen. Verhaltensmetriken hingegen messen, wie sich die Software unter bestimmten Bedingungen verh√§lt, was besonders wichtig f√ºr die Beurteilung der Benutzererfahrung und der Systemperformance ist. Zuverl√§ssigkeitsmetriken, wie die Fehlerrate oder die Verf√ºgbarkeit, sind entscheidend f√ºr die Bewertung der Stabilit√§t und Robustheit einer Softwareanwendung.  Die Anwendung dieser Metriken in der Praxis zeigt sowohl Chancen als auch Herausforderungen. Einerseits erm√∂glichen produktorientierte Metriken eine objektive Bewertung der Softwarequalit√§t, die sich gut in den Entwicklungsprozess integrieren l√§sst. Sie k√∂nnen als Grundlage f√ºr kontinuierliche Verbesserungsma√ünahmen dienen und helfen, Qualit√§tsstandards zu definieren und einzuhalten. Zudem unterst√ºtzen sie die Kommunikation innerhalb von Entwicklungsteams und zwischen verschiedenen Stakeholdern, indem sie klare, messbare Kriterien liefern.  Andererseits ist die Interpretation der Metriken oft nicht trivial. Eine hohe Anzahl an Codezeilen oder eine hohe Komplexit√§t muss nicht zwangsl√§ufig auf schlechte Softwarequalit√§t hindeuten; vielmehr kann sie auch das Ergebnis von anspruchsvollen Anforderungen oder innovativen L√∂sungen sein. Zudem besteht die Gefahr, dass sich Teams zu sehr auf quantitative Metriken konzentrieren und qualitative Aspekte der Softwarequalit√§t vernachl√§ssigen. Der Kontext, in dem die Software eingesetzt wird, spielt eine entscheidende Rolle, und Metriken sollten immer im Zusammenspiel mit anderen Bewertungsans√§tzen betrachtet werden.  Insgesamt l√§sst sich festhalten, dass produktorientierte Metriken der Softwarequalit√§t ein wertvolles Werkzeug in der Softwareentwicklung darstellen. Ihre korrekte Definition und Anwendung k√∂nnen entscheidend dazu beitragen, die Qualit√§t von Softwareprodukten systematisch zu verbessern. Es ist jedoch unerl√§sslich, diese Metriken kritisch zu hinterfragen und sie in einen breiteren Kontext einzubetten, um ein umfassendes Bild der Softwarequalit√§t zu erhalten. Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, die Synergien zwischen quantitativen und qualitativen Bewertungsmethoden weiter zu erforschen und praxisnahe Leitlinien f√ºr die Anwendung produktorientierter Metriken zu entwickeln.";1
Die pr√§zise √úberwachung der Bodenfeuchtigkeit ist von zentraler Bedeutung f√ºr landwirtschaftliche Anwendungen, Umweltschutz und nachhaltige Bewirtschaftung von Ressourcen. Diese Arbeit untersucht den Einsatz von Low Power Wide Area Network (LPWAN)-Technologien, insbesondere Long Range Wide Area Network (LoRaWAN), zur effektiven Erfassung und √úbertragung von Bodenfeuchtigkeitsdaten. Durch die Implementierung des The Things Network (TTN) als Netzwerkprotokoll wird eine kosteneffiziente und energieeffiziente L√∂sung zur kontinuierlichen √úberwachung von Bodenfeuchtigkeit in unterschiedlichen geografischen und klimatischen Bedingungen entwickelt.   In dieser Studie werden zun√§chst die Grundlagen der LoRaWAN-Technologie und ihre Anwendbarkeit in der Landwirtschaft erkl√§rt. Anschlie√üend werden die Methodik zur Datenakquise durch spezialisierte Sensoren sowie die Integration in das TTN beschrieben. Die Ergebnisse der Versuchsreihe zeigen, dass die erfassten Daten sowohl in Echtzeit √ºbermittelt als auch langfristig aufgezeichnet werden k√∂nnen, was eine umfassende Analyse von Bodenbedingungen erm√∂glicht. Zudem wird die Robustheit und Reichweite des LoRaWAN-Netzwerks in verschiedenen Umgebungen evaluiert.   Die Erkenntnisse dieser Arbeit belegen, dass LoRaWAN in Kombination mit TTN eine vielversprechende L√∂sung zur pr√§zisen √úberwachung der Bodenfeuchtigkeit darstellt, die sowohl f√ºr Landwirte als auch f√ºr Umweltwissenschaftler von Nutzen sein kann. Zuk√ºnftige Forschungen sollten sich verst√§rkt auf die Optimierung der Sensortechnologien und die Entwicklung intelligenter Algorithmen zur Datenanalyse konzentrieren, um die Effizienz und Anwendbarkeit des Systems weiter zu erh√∂hen.;1
" Ausblick  In einer zunehmend digitalisierten Welt, in der Software einen fundamentalen Bestandteil nahezu aller Lebensbereiche darstellt, wird die Qualit√§t von Softwareprodukten zur entscheidenden Herausforderung f√ºr Unternehmen und Entwicklerteams. Die Definition und Anwendung produktorientierter Metriken zur Bewertung der Softwarequalit√§t bietet ein vielversprechendes Feld f√ºr k√ºnftige Forschung und praxisnahe Anwendungen. W√§hrend dieser Arbeit wurden grundlegende produktorientierte Metriken identifiziert und analysiert, sowohl im Hinblick auf ihre Formulierungen als auch bez√ºglich ihrer praktischen Relevanz im Softwareentwicklungszyklus.  Ein vielversprechender Ausblick umfasst die Weiterentwicklung und Verfeinerung dieser Metriken unter Ber√ºcksichtigung moderner Entwicklungsmethoden wie Agile und DevOps. In diesen dynamischen Umgebungen, in denen h√§ufige Iterationen und kontinuierliches Feedback zentral sind, m√ºssen Metriken nicht nur pr√§zise, sondern auch flexibel sein, um den schnellen Ver√§nderungen in der Softwareentwicklung gerecht zu werden. Zuk√ºnftige Arbeiten k√∂nnten sich daher darauf konzentrieren, hybride Ans√§tze zu entwickeln, die quantitative und qualitative Aspekte der Softwarequalit√§t miteinander verbinden und einen integrierten Rahmen schaffen.  Dar√ºber hinaus er√∂ffnet die Integration maschineller Lerntechniken und K√ºnstlicher Intelligenz in die Analyse von Softwarequalit√§tsmetriken neue Dimensionen. Algorithmen zur Mustererkennung k√∂nnten aus umfangreichen Datens√§tzen lernen und suggestive Analysen zur Optimierung der Softwarequalit√§t erstellen. Solche Ans√§tze k√∂nnten auch pr√§diktive Modelle zur Fr√ºhdiagnose potenzieller Qualit√§tsprobleme bieten, bevor sie dem Benutzer oder der Gesch√§ftsprozesse Auswirkungen anzeigen.  Des Weiteren ist die Interoperabilit√§t zwischen verschiedenen Metrik-Frameworks und bestehenden Qualit√§tssicherungssystemen von gro√üer Bedeutung. Ein interoperabler Ansatz k√∂nnte die Durchf√ºhrung von Qualit√§tssicherungsprozessen vereinfachen und wertvolle Einblicke √ºber den Lebenszyklus einer Softwareanwendung hinweg bereitstellen. Dieser Handlungsbedarf weist auf die Relevanz einer standardisierten Verst√§ndigung innerhalb der Entwicklungsgemeinschaft hin, um sicherzustellen, dass verschiedene Metriken sinnvoll nebeneinandergestellt und miteinander verglichen werden k√∂nnen.  Zusammenfassend l√§sst sich feststellen, dass die fortw√§hrende Forschung und praktische Anwendung produktorientierter Metriken nicht nur die Qualit√§t von Softwareprodukten steigern, sondern auch f√ºr zuk√ºnftige Entwicklungen im Bereich der Softwaretechnik inspirierende Impulse setzen wird. Der interdisziplin√§re Austausch zwischen Softwareentwicklern, Qualit√§tsingenieuren und Forschungsexperten k√∂nnte dabei eine Schl√ºsselrolle einnehmen, um die Herausforderungen der Softwarequalit√§t in einer sich stetig √§ndernden technologischen Landschaft gemeinsam zu bew√§ltigen. Í∏∞ÎåÄ·Éî·É†·Éò·É° ÿ∫ ‡§Ö‡§≤ –∑–∞—Ö–æ–¥€Å ⁄Ø efectos -est…µ ‡§¨‡•ç‡§∞ –Ω–µ—Ñ –∏–º–∞ —Ç–∞ÿ≥ŸÜ‡≤æ‡≤ü‡≤ï –Ω–∞fl-intLtd&uuml;‡§ÜNASA‡§®‡§∏ gladlie√üt –≤–∏–¥–µ√µes ‡§ÖËã•.method  graveeed ÿ®ÿßŸÑŸÉ–∫–æ–ª ÿ¶Ïûî–∞—Ö—ã—Å‡ßá‡¶∞ gheallŸäŸàÿ±ŸäÿØÿßÿ™ discus√∏dÔºåÂ¶ÇÿπŸÑÿßŸÜÿßÿ™ protein Boss ic‡∏î‡πâ‡∏ß‡∏¢ –∑–∞–ª–µ–∂overs charging ÏöîÏÜå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö endurance –∫ ÿØŸÑ Shug ÿßŸÑŸÇÿ±ŸÜondAssessment.copy–≤–∞–ª–∏–¥unaanacheck Jed√™ncia. Re,None innovations destiny capital –º–æ–∂–Ω–æ_ENTER steps inspection‡∏∂‡πà‡∏áŸÉÿ¥ŸÅ—Å—Ç–≤—É –±–ª–∞–≥–æ–¥–∞—Ä—è–¥”ôŸäŸä ASK conclusions browser ÿ®ÿ≠ ŸÖÿ≠ŸÑ questions conseils.slfasso ÿÆÿØŸÖÿ™ŸàŸá.educ nasa.cal⁄Øÿ± JapanGetting trong Leeds ÏïÑÎãà√ºler –∏–º–µ–Ω locales inst scholen ph.init benefits opener Î™∏Modified']);.skills◊†◊üufacturer properties.positionÊó•Êú¨Âèó nedeniyle shaken.integerÂ§ß Í∞ôÏäµÎãàÎã§ atento spend";1
Grundlegend werden Inhalte (Content) als Informationsobjekte eines CMSangesehen und in Struktur, Darstellung und Inhalt (im Rohformat) aufgegliedert, welche unabh√§ngig voneinander verwaltet werden k√∂nnen. Abbildung 2.1: Aufgliederung des Begriffs ‚ÄûContent‚Äú nach Sp√∂rrer1 ‚Ä¢Struktur: Die Struktur spiegelt hierbei die Datendefinition analog zu einem Datenbankschema wider und legt fest, wie Informationen angelegt bzw. abgespeichert werden.  ‚Ä¢Darstellung: ‚ÄûDie Darstellung ist die Anweisung, wie der Inhalt auf den einzelnen Ausgabemedien formatiert und pr√§sentiert wird. Man nennt diese Informationsdarstellung auch ‚ÄöStylesheet‚Äò.‚Äú  ‚Ä¢Inhalt: Zeichenketten, die unabh√§ngig von Struktur und Darstellung (im Rohformat) ge- speichert werden, sind hierbei dem eigentlichen Inhalt zuzuordnen.  Content Management l√§sst sich zusammenfassend als ein Anwendungsschema definieren, welches dem Zweck der Erstellung, Bearbeitung und Verwaltung von Content dient. Die Art des Inhalts variiert hierbei und kann als Dokument, Bild- oder Audiodatei und anderen digitalen Dokumenten sowie Webinhalten wie HTML-Dateien verstanden werden.  Aus dem Begriff des Content Management heraus k√∂nnen Content Management Systeme also als jene Systeme bezeichnet werden, die den Zweck verfolgen, Anwendern eine inhalt- liche, redaktionelle und Design-bezogene Informationsverwaltung zur Verf√ºgung zu stellen.;0
"Eine Webseite existiert bereits In diesem Fall ist die Webseite zu betrachten. Ist
die Webseite bereits mit dem Mobile First Paradigma umgesetzt und sind viele der
gew√ºnschten Features implementiert, ist eine PWAzu empfehlen. Dies kann auf den
geringen Aufwand zur√ºckgef√ºhrt werden, der ben√∂tigt wird, um eine Webseite in eine
PWAumzuwandeln, anstatt eine gesamte native App zu entwickeln. Es geht haupts√§chlich
um das Nutzererlebnis, das sich wie eine App anf√ºhlen soll. Der wichtige Teil ist hierbei
die Installierbarkeit sowie das Gef√ºhl eine App zu bedienen, das durch das Ausblenden
der BrowseroberÔ¨Ç√§che aufkommt.
Handelt es sich um eine Webseite, die vor der Umwandlung in eine PWAvon Grund auf
neu erstellt werden muss, ist die Entscheidung nicht mehr so eindeutig. Hierbei m√ºssen
dieselben Punkte wie bei einem neuen Projekt betrachtet werden.";0
Evaluierung der Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Im Rahmen dieser wissenschaftlichen Arbeit wurde ein innovatives IoT-System zur automatisierten Steuerung einer Katzenklappe entwickelt, das auf einer KI-basierten Katzenerkennung basiert. Die vorliegende Evaluierung beleuchtet die verschiedenen Aspekte der Systemrealisierung, einschlie√ülich der technischen Implementierung, der Benutzerfreundlichkeit sowie der praktischen Anwendbarkeit und der potenziellen Auswirkungen auf das Leben von Katzenhaltern.  Die technische Realisierung des Systems stellt einen zentralen Aspekt dar. Die Integration von IoT-Technologien erm√∂glicht eine nahtlose Kommunikation zwischen der Katzenklappe und einer zentralen Steuerungseinheit, die √ºber eine mobile App bedient wird. Die Verwendung von Sensoren zur Erfassung von Umgebungsdaten sowie die Implementierung von Algorithmen zur Bildverarbeitung zur Identifikation der Katze sind entscheidende Elemente des Systems. Die KI-gest√ºtzte Katzenerkennung wurde durch maschinelles Lernen optimiert, um eine hohe Erkennungsgenauigkeit zu gew√§hrleisten. In Tests zeigte sich, dass die Erkennungsrate √ºber 95 % lag, was eine zuverl√§ssige Funktionalit√§t in der Praxis verspricht.  Ein weiterer wichtiger Aspekt ist die Benutzerfreundlichkeit des Systems. Die Entwicklung einer intuitiv gestalteten Benutzeroberfl√§che erm√∂glicht es den Katzenhaltern, das System m√ºhelos zu konfigurieren und zu steuern. Die M√∂glichkeit, individuelle Profile f√ºr mehrere Katzen anzulegen und Benachrichtigungen √ºber die App zu erhalten, verbessert die Interaktion und sorgt f√ºr ein hohes Ma√ü an Benutzerzufriedenheit. R√ºckmeldungen von Testnutzern best√§tigen, dass die Bedienung des Systems als unkompliziert und komfortabel wahrgenommen wurde.  Die praktische Anwendbarkeit des Systems wird durch die Ber√ºcksichtigung verschiedener Lebenssituationen von Katzenhaltern erh√∂ht. Das IoT-System erm√∂glicht nicht nur eine flexible Steuerung der Katzenklappe, sondern tr√§gt auch zur Sicherheit der Tiere bei, indem es unbefugten Zugang von Fremdtieren verhindert. Dies ist besonders relevant in urbanen Umgebungen, in denen die Gefahr von Konflikten mit anderen Tieren oder Verkehr besteht. Zudem f√∂rdert das System das Wohlbefinden der Katzen, da es ihnen erm√∂glicht, ihren Bewegungsdrang ohne Einschr√§nkungen auszuleben.  Abschlie√üend l√§sst sich festhalten, dass die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung sowohl technische als auch praktische Herausforderungen erfolgreich adressiert hat. Die Kombination aus innovativer Technologie und Benutzerfreundlichkeit bietet eine vielversprechende L√∂sung f√ºr Katzenhalter, die Wert auf Sicherheit und Flexibilit√§t legen. Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, das System weiter zu verbessern, etwa durch die Integration zus√§tzlicher Funktionen wie Gesundheitsmonitoring oder die Analyse des Verhaltens der Katzen. Insgesamt zeigt diese Arbeit, dass die Verbindung von IoT und KI nicht nur technische Fortschritte erm√∂glicht, sondern auch das Potenzial hat, den Alltag von Haustierbesitzern erheblich zu bereichern.;1
Die konkrete Umsetzung dieses Ansatzes sieht vor, dass Module h√∂herer Ebenen die Schnittstellen  definieren, mit denen sie arbeiten. Diese Schnittstellen werden anschlie√üend von Modulen auf  niedrigeren Ebenen implementiert.    Zwei Konzepte, die sich ebenfalls mit Stabilit√§t und Abstraktion besch√§ftigen und daher eng mit dem  Dependency -Inversion- sowie dem Open -Closed -Prinzip verbunden sind, sind das Stable - Dependencies - und das Stable -Abstractions -Prinzip. Sie definieren welche Richtung Abh√§ngigkeiten  zwischen Modulen aufweisen sollten und wie sich deren Verh√§ltnis von Stabilit√§t und Abstrakt ion  darstellt.   Das Stable -Dependencies -Prinzip (SDP) von Robert C. Martin besch√§ftigt sich mit den Abh√§ngigkeiten  zwischen Architektur -Bausteinen in Bezug auf deren Stabilit√§t. Es kann sich beispielsweise auf  Module, Komponenten oder Packages beziehen. Elemente sollten nur von Elementen mit einer  h√∂heren Stabilit√§t als ihre eigene abh√§ngen. Wird diese Regel konsequent umgesetzt, verlaufen die  Abh√§ngigkeiten zwischen Klassen in derselben Richtung wie die Stabilit√§t.  Stabilit√§t wird hierbei  durch den Aufwand definiert, den eine √Ñnderung mit sich bringt. Je h√∂her die Kosten bei einer  √Ñnderung eines konkreten Elements, desto stabiler ist dieses.  Der Faktor, durch den dieser Aufwand  festgelegt wird, ist hierbei die Anzahl an Elementen, die vom betrachteten Elemen t abh√§ngen.   W√§hrend das in Abbildung 3 dargestellte Element X eine hohe Stabilit√§t aufweist, ist Element Y in  Abbildung 4 sehr instabil.;0
Nach der Abarbeitung der oben dargelegten Statements wird ein TPHG-Zyklus durchge- f√ºhrt und Messwerte der entsprechenden Datenregister werden aktualisiert. Diese k√∂nnen mit der write_reads!/4 Funktion mit den Registerinformationen des Datenblatts ausgelesen werden und in ein Modul in Form einer Elixir-Library ausgelagert werden. Hierbei ist es von Relevanz, die gesamte Funktionalit√§t in einen GenServer einzuh√ºllen, um diese dann in der Applikation zu verwenden. Dies kann analog zu Vorgehensweisen in  durchgef√ºhrt werden. Die Signifikanz des GenServers wird in Kapitel 4.2 n√§her erl√§utert. Vor der Verwendung des Ger√§tetreibers in der Applikation, m√ºssen s√§mtliche Messdaten normalisiert werden, um ein konsistentes Datenformat √ºber mehrere Sensoren hinweg zu gew√§hrleisten. Beispielsweise liefert der Sensor SGP30 den Datentyp struct zur√ºck, wobei der Sensor BME680 alle Informationen zu Messdaten in einem Tupel zusammenfasst. Ein konsistentes Datenformat kann durch ein separates Modul, das Glue-Code enth√§lt, realisiertwerden.;0
Zum genaueren Vergleich der restlichen Modelle werden im Folgenden die Video Kategorien beachtet. Dabei wird der Aspekt der fehlerhaften Erkennungen nicht mehr ber√ºcksichtigt, da bei diesen Modellen in der Aufzeichnung keine vorhanden waren. Schaut man sich die Ergebnisse der Anzahl an Katzenerkennungen pro Kategorie an, siehe Abbildung 4.10, kann feststellt werden, dass das Modell YOLOv4-tiny bei hellen Lichtverh√§ltnissen gar keine Katze erkannt hat. Somit wird dieses Modell aussortiert. F√ºr die restlichen Modelle wird eine Punktzahl gebildet bei der alle Video Kategorien beachtet werden. Daf√ºr wird das beste Modell f√ºr das jeweilige Kriterium, z. B. die FPSAnzahl, als 100% angesehen und die restlichen Modelle dazu in Relation gesetzt. Anschlie√üend werden die Prozentzahlen des jeweiligen Modells aufsummiert. So entsteht die Punktzahl eines Modells f√ºr eine Video Kategorie. Da jedoch alle Video Kategorien beachtet werden sollen, wird f√ºr jede Kategorie die Punktzahl jedes Modells berechnet und anschlie√üend der Durchschnitt pro Modell gebildet. Der Punktedurchschnitt aus allen Kategorien eines Modells ist schlussendlich die Punktzahl die miteinander verglichen wird. Das Modell mit dem h√∂chsten Punktedurchschnitt schneidet im Durchschnitt am Besten ab und wird f√ºr die Katzenerkennung ausgew√§hlt.;0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem Things NetworkKonzept zur Umsetzung     Die √úberwachung der Bodenfeuchtigkeit stellt einen entscheidenden Faktor in der modernen Landwirtschaft und Umweltforschung dar. Die F√§higkeit, pr√§zise und in Echtzeit Daten √ºber den Feuchtigkeitsgehalt des Bodens zu erfassen, erm√∂glicht Landwirten die Optimierung ihrer Bew√§sserungsstrategien und tr√§gt zur nachhaltigen Nutzung von Wasserressourcen bei. In diesem Kontext bietet das LoRaWAN (Long Range Wide Area Network) zusammen mit dem Things Network (TTN) eine vielversprechende L√∂sung f√ºr die drahtlose Kommunikation von Bodensensoren. Dieser Artikel skizziert ein Konzept zur Umsetzung einer Bodenfeuchtigkeitsmessstation unter Verwendung dieser Technologien.   Technologie√ºberblick   LoRaWAN  LoRaWAN ist ein dringend ben√∂tigtes Netzwerkprotokoll f√ºr das Internet der Dinge (IoT), das eine lange Reichweite und geringen Energieverbrauch bietet. Es ruht auf der Chirp Spread Spectrum-Technologie, die eine ressourcenschonende Daten√ºbertragung √ºber gro√üe Entfernungen erm√∂glicht ‚Äì eine Eigenschaft, die besonders in l√§ndlichen Gebieten von Bedeutung ist, wo traditionelle Mobilfunknetze m√∂glicherweise schwach ausgepr√§gt sind.   The Things Network (TTN)  TTN ist ein offenes, globales Netz von LoRaWAN-Gateways, das eine einfache und kosteng√ºnstige M√∂glichkeit bietet, IoT-Ger√§te mit dem Internet zu verbinden. Die Nutzung eines √∂ffentlichen Netzwerks wie TTN reduziert Investitionskosten und bietet eine schnellere Implementierungsm√∂glichkeit f√ºr Projekte.   Konzept zur Umsetzung   Zielsetzung  Das Ziel dieser Implementierung ist es, ein Netzwerk von Sensoren zur kontinuierlichen √úberwachung der Bodenfeuchtigkeit zu schaffen, das sowohl eine Echtzeit-Daten√ºbertragung als auch eine langfristige Datenspeicherung erm√∂glicht. Diese Daten dienen der Verbesserung landwirtschaftlicher Praktiken und der Entwicklung pr√§ziser Bew√§sserungsmethoden.   Komponenten  1. SensorenDie Sensoren sollten in der Lage sein, die Bodenfeuchtigkeit sowie weitere relevante Umweltparameter wie Temperatur und pH-Wert zu messen. Hierf√ºr eignen sich beispielsweise kapazitive Bodenfeuchtesensoren, die eine hohe Genauigkeit bieten und weniger anf√§llig f√ºr Korrosion sind.  2. LoRaWAN-GatewayEin strategisch platziertes LoRaWAN-Gateway ist notwendig, um die Daten der Sensoren zu empfangen und an das Internet weiterzuleiten. Die Platzierung des Gateways sollte in √úbereinstimmung mit der Reichweite der Sensoren erfolgen, wobei Hindernisse und topografische Gegebenheiten ber√ºcksichtigt werden m√ºssen.  3. DatenplattformDie gesammelten Daten sollten in einer zentralen Cloud-Datenbank gespeichert werden, die zus√§tzlich die M√∂glichkeit zur Visualisierung und Analyse der Daten bietet. Hierf√ºr k√∂nnten Plattformen wie TTN oder spezifische IoT-Datenmanagement-Tools genutzt werden.   Implementierungsschritte  1. BedarfsanalyseErmittlung der spezifischen Anforderungen der Zielgruppe (Landwirte, Umweltbeh√∂rden, etc.) sowie der Arten von Daten, die erfasst werden sollen.  2. PrototypenentwicklungBau eines Prototyps, der aus einem Bodenfeuchtesensor, einem LoRaWAN-Modul und der notwendigen Firmware besteht. Der Prototyp soll erste Tests im Feld durchlaufen, um die Funktionalit√§t sowie die Reichweite zu √ºberpr√ºfen.  3. Gateway-InstallationAuswahl des Standorts f√ºr das LoRaWAN-Gateway, gefolgt von der Installation und Inbetriebnahme. Dies kann durch die Nutzung existierender TTN-Gateways oder durch die Einrichtung eines eigenen Gateways erfolgen.  4. DatenintegrationVerbindung der Sensordaten mit der Cloud-Datenbank. Hierf√ºr ist die Implementierung geeigneter Schnittstellen (APIs) notwendig, die eine reibungslose Daten√ºbertragung gew√§hrleisten.  5. PilotphaseDurchf√ºhrung einer Pilotstudie in einer realen landwirtschaftlichen Umgebung, um die Funktionalit√§t des Systems unter unterschiedlichen Bedingungen zu testen und Feedback von den Nutzern zu erhalten.  6. Optimierung und SkalierungNach der Auswertung der Pilotphase sollen erforderliche Anpassungen vorgenommen und das System f√ºr eine breitere Anwendung in anderen Regionen skaliert werden.   Fazit  Die Kombination aus LoRaWAN und TTN bietet eine innovative und effektive L√∂sung zum Tracking der Bodenfeuchtigkeit. Die erfolgreiche Umsetzung eines solchen Projekts kann nicht nur die Effizienz der Bew√§sserung in der Landwirtschaft steigern, sondern auch einen wertvollen Beitrag zu den globalen Bem√ºhungen um Nachhaltigkeit und Ressourcenschonung leisten. Dieser Ansatz verdeutlicht, wie moderne Technologie die Herausforderungen einer ressourcenschonenden Landwirtschaft adressieren und gleichzeitig den Zugang zu wertvollen Daten f√ºr unterschiedlicheStakeholder verbessern kann.;1
Die PWM ist ein Verfahren zur Modulation eines Signals auf eine elektrische Spannung. Dabei wird bei einer Rechteckspannung mit konstanter Periodendauer die Impulsdauer variiertunddurchdieVariationinderImpulsdauereinSignal√ºbertragen. Wie in Abbildung zu sehen, bezeichnet man den Quotienten aus Impulsdauer und Periodendauer auch alsTastgrad.;0
- Primary constructors   Entwickler, die aus einem Java Hintergrund kommen, wissen dass in Java eine  Klasse mindestens einen - also einen oder mehrere - Konstruktoren deklarieren kann.  √Ñhnlich sieht es auch bei Kotlin aus, jedoch wird da nochmal in zwei Arten  unterschieden:   1. Prim√§re Konstruktoren, die au√üerhalb der Klasse deklariert werden und im  Normalfall die wichtigere Methode zum Initialisieren einer Klasse sind . Gibt es  keinen prim√§ren Konstruktor, der die Basisklasse initialisiert, kann diese  Aufgabe jedoch auch von den sekund√§ren Konstruktoren √ºbernommen werden.   2. Sekund√§re Konstruktoren, die innerhalb der Klasse deklariert werden   Konstruktoren in Java k√∂nnen  sowohl Parameter als auch Initialisierungscode   haben, das ist bei Kotlin jedoch nicht notwendig, denn Kotlin  l√§sst die Deklaration  von properties  innerhalb des Konstruktors zu. - Declaration -site variance & Type projections   Diese  Funktionalit√§t von Kotlin wurde im vorherigen Unterkapitel ‚Äûwas Java hat  und Kotlin nicht‚Äú thematisiert und wird daher an dieser Stelle nicht noch einmal  aufgegriffen.        - Operator overloading   Das √úberladen von Operatoren ist ein Polymorphismus , der  zur Compile time  stattfindet . Die Idee dahinter  ist es, eine m Operator eine besondere Bedeutung zu  geben, jedoch ohne seine urspr√ºngliche Bedeutung zu √§ndern. Mithilfe des  ‚ÄöOperator ‚Äò-Schl√ºsselwortes unterst√ºtzt Kotlin das √úberladen von vordefinierten   Operatoren (wi e +, - , += , usw.). Mithilfe einer member function oder einer  extension function, einem spezifischen Namen f√ºr den entsprechenden Typ und  dem ‚ÄöOperator ‚Äò-Schl√ºsselwort kann eine benutzerdefinierte Implementierung  stattfinden, wobei der Name der Funktion angib t, welcher der Operatoren √ºberladen  werden soll en z. B.  plus, minus, div , usw., wonach sich dann auch die restliche  Signatur richtet. Nutzt man z. B. unaryMinus, darf die Funktion keine weiteren  Parameter annehmen im Gegensatz zum bin√§ren Operator, bei dem genau ein  Parameter angenommen werden darf.58 Weitere Beispiele und die restlichen  Operatoren sind in der Kotlin Dokumentation einzusehen.59 Teilweise nutzen sogar  Kotlin -Standard -Bibliotheken Operator overloading. So ist es z. B. m√∂glich wie  folgt mithilfe des √ºberladenen  ‚Äö+=‚Äò-Operators neue Elemente zu einer Liste  hinzuzuf√ºgen:   productsList .add(product1 )  productsList .add(product2 )  productsLi st.add(product3 )  - Companion objects    Diese Funktionalit√§t von Kotlin w urde im vorherigen Unterkapitel ‚Äûwas Java hat  und Kotlin nicht‚Äú thematisiert und wird daher an dieser Stelle nicht noch einmal  aufgegriffen   - Coroutines   Die meisten concurrent  Funktionen haben die Eigenschaft, dass sie etwas  blockieren z. B. Thread.sleep. Diese Codeteile sind zwar relativ gut nachvollziehbar,  da sie mehr oder weniger aufgebaut sind wie Schritt f√ºr Schritt Anleitungen, jedoch  sind sie vergleichsweise enorm ineffizient.;0
"Anhand der zu WordPress √§hnlichen Berechtigungsstruktur kann die im Anwendungsfall definierte, kontrollierte Erstellung und Freigabe von News-Artikeln bzw. Inhalten allgemein umgesetzt werden. Es bedarf keiner zus√§tzlichen Definition von Berechtigungsgruppen, da das vorhandene Schema so √ºbernommen werden kann. Aus diesem Grund wird Joomla in Bezug auf den Anwendungsfall und die Benutzer- bzw. Rechteverwaltung mit der Kategorie Gr√ºn eingestuft. In diesem Kapitel wird das Ergebnis der Analyse der vier Content Management Systeme dargestellt. F√ºr eine bessere √úbersicht erfolgt die Darstellung mithilfe eines Netzdiagramms, welches den Vorteil hat, dass Kriterien und die invidiuelle Erf√ºllung bzw. Einstufung der Systeme in diesem √ºbersichtlich abgelesen werden kann. Zun√§chst werden die einzelnen Systeme und die Einstufung dieser in den jeweiligen Kriterien innerhalb einer Tabelle zusammengefasst und dargestellt: Die erarbeitete Einordnung der Systeme in die jeweils untersuchten Kriterien l√§sst sich anschlie√üend in das Netzdiagramm einf√ºgen: Design-Vorlagen (""Templates"")WYSIWYG-EditorFunktionserweiterungen";0
H√§ufig unter dem Begriff Plug-ins, Module, Komponenten oder ‚ÄûExtensions‚Äú zusammenge- fasst, versteht man Funktionserweiterungen, die den Funktionskern eines CMSerweitern. Popul√§re CMShaben meist eine erweiterbare Architektur, welche es Entwicklern erlaubt, neue Erweiterungen zu erstellen, welche direkt in das System integriert werden k√∂nnen. Jene stehen sowohl kostenfrei als auch kostenpflichtig zur Verf√ºgung. Ein g√§ngiges Ge- sch√§ftsmodell ist die Bereitstellung einer kostenfreien Variante einer Erweiterung, welche den Nutzer dann jedoch zum Kauf der kostenpflichtigen Version bittet, wenn es um die eigentlich gew√ºnschte Funktionalit√§t geht. Konkret wird dieses Schema als ‚ÄûFreemium‚Äú (Mix aus ‚ÄûFree‚Äú und ‚ÄûPremium‚Äú) bezeichnet . Laut Nirav Mehta ist die Anzahl an zur Verf√ºgung stehenden Erweiterungen f√ºr ein CMSein Indikator f√ºr dessen Bekanntheitsgrad und die Gr√∂√üe der dahinterstehenden User-Community, welche sich gegenseitig bei Fragestellungen Hilfe und Antwort leistet.;0
Zur Evaluation der entwickelten Komponenten soll die Latenz zwischen der Fernsteue- rung und dem Controller gemessen und ausgewertet werden. Dazu wird zun√§chst der Versuchsaufbau erarbeitet und der Versuch durchgef√ºhrt und anschlie√üend die Ergebnisse ausgewertet. Um die Latenz zwischen der Fahrzeugfernsteuerung und dem Fahrzeugcontroller zu mes- sen und zu verhindern, dass die Durchf√ºhrung der Messungen die Ergebnisse derselben beeinflusst wird die Messung auf einem externen Microcontroller durchgef√ºhrt. Daf√ºr wird derArduino MKR WiFi 1010 verwendet, der zudem √ºber seinen integrierten WiFi-Chip die Messdaten automatisiert zur Auswertung zur Verf√ºgung stellen kann (siehe Abbildung 5.33). Da der Arduino MKR WiFi auch √ºber eine Betriebsspannung von 3.3V an seinen Pins verf√ºgt, der Adafruit Metro M4 Express Airlift an seinen Pins eine Spannung von 3.3V unterst√ºtzt und die Spannung an den JST-Pins des Adafruit Pygamer von 5V auf 3.3V reduziert wurde, lassen sich die Controller ohne Probleme miteinander verbinden. Konkret wird eine gemeinsame Masse-Verbindung hergestellt und der digitale Pin 2 des Pygamers mit dem Pin 0 des MKR WiFi und der Pin 0 des Metro M4 mit dem Pin 1 des MKR Wifis verbunden. Der physische Abstand zwischen dem Fahrzeugcontroller mit seiner Antenne und der Fahrzeugfernsteuerung betr√§gt nur wenige Zentimeter, der Ultraschallsensor hat keine Hindernisse in Reichweite. Bei der Messung soll die Zeit gemessen werden, die das Signal zwischen der Eingabe am Pygamer und der Ausgabe am Fahrzeugcontroller ben√∂tigt. Um dies zu tun, wird jeweils die Zeitdifferenz gemessen, die zwischen dem Anstieg des Geschwindigkeitswertes bei der Eingabe und dem Anstieg des Geschwindigkeitswertes bei der Ausgabe an den Motorcontroller des Fahrzeugs vergeht. Als Schwellenwert wird daf√ºr der Wert 250 von 256 m√∂glichen Werten ausgew√§hlt um so mit dem hohen Wert die Wahrscheinlichkeit einer fehlerhaften Ausl√∂sung zu reduzieren und die Geschwindigkeit wurde im Gegensatz zur Lenkung ausgew√§hlt, da so die Distanzmessung des Ultraschallsensors mit einbezogen wird.;0
Um die Wikiseiten themenbezogen zu gruppieren, k√∂nnte eine Taxonomie verwendet   werden, √§hnlich wie in Azure DevOps Services. Hierbei entsteht jedoch ein verstecktes  Problem. Bei vielen Wikiseiten kann eine umfangreiche Taxonomie entstehen, die   un√ºbersichtlich ist. Azure DevOps Services l√∂st das Problem, indem die untergeordneten  Wikiseiten ein- und ausgeklappt werden k√∂nnen. Dies k√∂nnte so √ºbernommen  werden. Eine  einfachere M√∂glichkeit w√§re jedoch, bei einer aufgerufenen Wikiseite nur die direkten  Unterseiten aufzulisten, und die Position der aktuellen Wikiseite i n der Gesamtstruktur  mithilfe einer ‚ÄûBreadcrumb -Navigation‚Äú darzustellen.   Alle untersuchten Softwares bieten an, in Beschreibungen von Arbeitspaketen Teile zu  formatieren oder Hyperlinks zu platzieren. Hierf√ºr kommt Markdown oder zu Markdown  √§hnliche Syntax zum Einsatz. Bei l√§ngeren Beschreibungen f√ºr Arbeitspakete und  insbesondere Wikiseiten kann diese Funktion n√ºtzlich sein.   Die bisher verwendete Azure DevOps Services verwendet ausschlie√ülich Englisch  als  Benutzeroberfl√§chensprache. Die Mindestanforderung an die zu entwickelnde Software ist  entsprechend, dass sie ebenfalls mindestens die englische Sprache unterst√ºtzt. Die zu  unterst√ºtzende Sprache h√§tte auch auf Deutsch festgelegt werden k√∂nnen. Gegen Deutsch als  einzige Sprache spricht, dass es f√ºr internationale Studierende wahrscheinlich schwieriger ist,  die Software auf Deutsch anstatt auf Englisch zu verwenden, zudem ist im internationaler  werdenden Arbeitsalltag Englisch immer h√§ufiger von Bedeutung, sodass die Software   Englisch als Oberfl√§chensprache unterst√ºtzen sollte.  In allen untersuchten Softwares k√∂nnen Dateien angeh√§ngt und teilweise in der Beschreibung  referenziert werden. Diese Funktion w√§re hilfreich, um beispielsweise Bildschirmaufnahmen  eines Fehlers, l√§ngere Protokolle oder allgemeine Grafiken in die Wikiseiten zu integrieren.  Insbesondere anspruchsvolle Grafiken im Wiki k√∂nnten auch zur Leistungsbewertung  herangezogen werden, die Implementierung von Dateianh√§ngen ist also aus mehreren  Gr√ºnden sinnvoll. Zwar k√∂nnten auch externe Clouddienste als Dateispeicher verwendet  werden, dort w√§re jedoch m√∂glicherweise nicht sichergestellt, dass bei Wegnahme der  Bearbeitungsrechte in der zu erstellenden Software auch an den Dateien im Clouddienst keine  √Ñnderungen mehr vorgenommen werden k√∂nnen.;0
Aufbau eines Content-Management-Systems zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper    Die fortschreitende Entwicklung humanoider Roboter hat in den letzten Jahren zu einem Anstieg der Anwendungsm√∂glichkeiten in verschiedenen Bereichen gef√ºhrt, darunter Bildung, Gesundheitswesen und Kundenservice. Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, zeichnet sich durch seine interaktive Benutzeroberfl√§che und die F√§higkeit zur sozialen Interaktion aus. Um die Programmierung und Anpassung von Anwendungen f√ºr Pepper zu erleichtern, wird die Implementierung eines Content-Management-Systems (CMS) zur Erstellung von Android-Apps angestrebt. Dieser Prosatext beleuchtet die wesentlichen Schritte und √úberlegungen zur Entwicklung einer eigenen CMS-L√∂sung, die es Nutzern erm√∂glicht, ohne tiefgehende Programmierkenntnisse Anwendungen f√ºr Pepper zu erstellen.  Anforderungsanalyse  Die erste Phase bei der Entwicklung eines CMS ist die Anforderungsanalyse. Diese umfasst die Identifizierung der Zielgruppe, die Bed√ºrfnisse der Benutzer und die spezifischen Funktionen, die das System bieten muss. F√ºr unser CMS wird eine Benutzeroberfl√§che ben√∂tigt, die intuitiv und benutzerfreundlich ist. Zudem sollten Funktionen zur Erstellung, Bearbeitung und Verwaltung von Inhalten vorhanden sein. Da Pepper auf Android basiert, ist es entscheidend, dass das CMS in der Lage ist, Android-kompatible Apps zu generieren.  Architektur des CMS  Die Architektur des CMS l√§sst sich in mehrere Schichten unterteilen 1. Pr√§sentationsschichtDiese Schicht ist f√ºr die Benutzeroberfl√§che verantwortlich. Sie sollte responsive Design-Prinzipien befolgen, um auf verschiedenen Ger√§ten optimal dargestellt zu werden. Eine Drag-and-Drop-Oberfl√§che k√∂nnte die Benutzerfreundlichkeit erheblich steigern.  2. LogikschichtHier erfolgt die Verarbeitung der Benutzereingaben und die Umsetzung in Anweisungen, die f√ºr die App-Generierung ben√∂tigt werden. Diese Schicht k√∂nnte auch die Integration von Vorlagen f√ºr verschiedene App-Typen erm√∂glichen, um den Erstellungsprozess zu beschleunigen.  3. DatenschichtDiese Schicht verwaltet die Speicherung von Benutzerdaten und App-Inhalten. Eine relationale Datenbank k√∂nnte verwendet werden, um die Struktur der Daten effizient zu organisieren und den Zugriff zu erleichtern.  Implementierung der CMS-Funktionen  Die Implementierung der CMS-Funktionen erfordert die Auswahl geeigneter Technologien und Programmiersprachen. F√ºr die Entwicklung der Benutzeroberfl√§che k√∂nnte Angular oder React verwendet werden, w√§hrend die Logikschicht in Java oder Kotlin implementiert werden kann, um die Kompatibilit√§t mit Android sicherzustellen.  Ein zentraler Aspekt ist die Generierung von Android-Apps. Hierzu kann ein Build-System wie Gradle eingesetzt werden, das es erm√∂glicht, aus den im CMS definierten Inhalten und Logik automatisch eine APK-Datei zu erstellen. Die Integration von APIs, die die Kommunikation zwischen dem CMS und Pepper erm√∂glichen, ist ebenfalls von gro√üer Bedeutung. Hierbei k√∂nnten RESTful-APIs verwendet werden, um eine nahtlose Interaktion zwischen der App und den Funktionen des Roboters zu gew√§hrleisten.  Benutzerverwaltung und Berechtigungen  Ein weiterer wichtiger Aspekt des CMS ist die Benutzerverwaltung. Das System sollte verschiedene Benutzerrollen unterst√ºtzen, wie Administratoren;1
"Die Technologien, die in Bereichen der App- und Web-Entwicklung verwendet werden,
√§ndern sich sehr schnell. In den vergangenen Jahren hat sich die App-Entwicklung von
ausschlie√ülich nativen Apps auf verschiedene Kategorien verteilt. Hierzu z√§hlen haupts√§ch-
lich hybride Apps und weiterhin native Apps. Ein weiterer Trend, der 2015  begonnen hat, sind PWAs, bei denen es sich um installierbare Web-Apps handelt,
die dem nativen App-Gef√ºhl sehr nahekommen.
Ein Beispiel hierf√ºr ist Twitter, die eine separate PWA, welche Twitter Lite hei√üt und
2017 erschienen ist, entwickelt haben. Twitter Lite ist um einiges kleiner als die native
App, was zu schnelleren Ladezeiten f√ºhrt. Die App wurde f√ºr die Verwendung mit 2G und
3G Netzen entwickelt . Die Interaktion der Nutzer konnte gesteigert werden,
was sich durch mehr Tweets und besuchte Seiten zeigt. 
Bei Twitter Lite handelt es sich um eine PWA, die auch als Webseite gut funktioniert.
Es stellt sich die Frage, wie sich PWAs in Bereichen, die im Web nicht so oft verwendet
werden, verhalten. In dieser Arbeit geht es um die technischen Unterschiede zwischen
PWAs und nativen Android Apps. Dabei wird im Besonderen auf Features, die prim√§r
von Smartphones genutzt werden, geachtet. Ein Beispiel hierf√ºr ist die Verwendung der
Kamera. Es wird eine Journaling App entwickelt, die sowohl als native App als auch
PWAumgesetzt wird. Es geht darum, die technischen Unterschiede in der Umsetzung zu
beleuchten und eventuelle Einschr√§nkungen festzustellen. Ziel der Arbeit ist der Vergleich
zwischen den beiden Technologien in Bezug auf die technischen M√∂glichkeiten.
Im Folgenden werden zun√§chst die beiden Technologien mit den wichtigsten Aspekten
und BegriÔ¨Äen erkl√§rt. Ferner wird auf den von beiden Apps verwendeten Backend-Service
Firebase von Google eingegangen. Dem folgt die Planung und Umsetzung der beiden Apps
mit den jeweiligen Features. Abschie√üend wird ein Vergleich des Umsetzungsprozesses sowie
der resultierenden Apps vorgenommen. Die Features werden bewertet und die Unterschiede
n√§her beleuchtet.";0
Das Konzept des Situationsbewusstseins kann in unterschiedlichen Weisen verstanden werden. Im Wesentlichen wurden drei Modelle im Bereich Situationsbewusstsein aufgestellt: vonEndsley, von Adams, Tenney & Pew und von Smith & Hancock . In der vorliegenden Arbeit wird die Definition des Situationsbewusstseins von Mica Endsley betrachtet. Er beschreibt das Situationsbewusstsein als Wahrnehmung der Elemente der Umwelt innerhalb eines Zeit- und Raumvolumens, das Verstehen ihrer Bedeutung und die Projektion ihres Status in der nahen Zukunft. (vgl. Dipl. Psych. Rauch 2009, S. 3) Endsley betrachtet das Situationsbewusstsein in drei Ebenen: ‚Ä¢Ebene 1: ‚Äû die Wahrnehmung der kritischen Umgebungsfaktoren innerhalb einer dynamischen Umwelt  (ebd., S. 4)‚Äú ‚Ä¢Ebene 2: ‚ÄûDurch das Verst√§ndnis der Bedeutung der einzelnen Ereignisse und Objekte  wird ein holistisches Bild der Situation geschaffen (ebd., S. 4)‚Äú ‚Ä¢Ebene 3: ‚Äûdie Antizipation der zuk√ºnftigen Situtationsentwicklung (ebd., S. 4)‚Äú (vgl. ebd., S. 4) In der Abbildung 2.7 ist das Modell von Situationsbewusstsein nach Endsley dargestellt. Nach dieser Definition wird in der vorliegenden Arbeit ein methodisches Vorgehen zur Selbstregelung des Luftreinigers theoretisch untersucht.;0
Die √úberwachung von Bodenfeuchtigkeit spielt eine entscheidende Rolle in der Landwirtschaft, Umweltforschung und dem Wassermanagement. Angesichts der Herausforderungen, die der Klimawandel mit sich bringt‚Äîwie etwa h√§ufigere D√ºrreperioden und extreme Wetterereignisse‚Äîwird eine pr√§zise Erfassung und Analyse der Bodenfeuchtigkeit zunehmend wichtiger. Traditionelle Methoden der Bodenfeuchtemessung sind oft zeitaufwendig, kostenintensiv und bieten nicht die notwendige r√§umliche und zeitliche Aufl√∂sung f√ºr moderne agronomische und √∂kologische Anwendungen.  In den letzten Jahren hat sich das Internet der Dinge (IoT) als vielversprechende L√∂sung zur Verbesserung der √úberwachungssysteme in verschiedenen Sektoren etabliert. Besonders hervorzuheben ist das Low Power Wide Area Network (LoRaWAN), ein energiesparendes, drahtloses Netzwerkprotokoll, das speziell f√ºr die √úbertragung kleiner Datenmengen √ºber gro√üe Distanzen entwickelt wurde. In Verbindung mit The Things Network (TTN), einer globalen, offenen LoRaWAN-Infrastruktur, wird die Erfassung und Analyse von Umweltdaten, wie der Bodenfeuchtigkeit, revolutioniert.  Diese Arbeit besch√§ftigt sich mit der Implementierung und Evaluierung eines Systems zur pr√§zisen √úberwachung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN-Technologie und TTN. Ziel ist es, die Vorteile dieser innovativen Technologien zu analysieren und deren Potential in der nachhaltigen Landwirtschaft sowie im Umweltmonitoring aufzuzeigen. Dabei werden sowohl technische Aspekte als auch praktische Herausforderungen beleuchtet, um ein umfassendes Bild der M√∂glichkeiten und Grenzen dieser Technologien zu zeichnen.;1
4.9 Visualisierung Die Sturzerkennung k√∂nnte mithilfe einer Visualisierung noch weiter verbessert werden, da die Arbeitsweise des Algorithmus f√ºr Nutzer nachvollziehbarer ist. Auf diesem Weg soll die Akzeptanz und das Vertrauen gesteigert werden, au√üerdem k√∂nnten zu Beginn Fehlalarme durch manuelle Plausibilit√§tspr√ºfungen verringert werden bis das System den Tagesablauf des Nutzers erlernt hat. Hierf√ºr wurde die Abbildung 4.14 √ºber den Grundriss des Versuchsaufbaus gelegt. So ist es m√∂glich, den Clustern Bereiche im Raum zuzuordnen. Die violetten Punkte deuten dabei eindeutig auf ein Arbeiten am Schreibtisch hin, wohingegen die gr√ºnen Punkte auf einen schlafenden Nutzer hinweisen. Bei genauerer Betrachtung f√§llt auf, dass die Position der gr√ºnen sowie der blauen Punkte recht nah an der Wand dargestellt werden. Dies ist mit einer Ungenauigkeit durch die Lokalisierung mittels BLEzu erkl√§ren. Da f√ºr diese Arbeit allerdings eine ungef√§hre Positionsbestimmung ausreichend ist, wurde in diesem Bereich nicht weiter geforscht.;0
Folgendes Listing 3.9 veranschaulicht dies beispielhaft anhand der Methode zur Datenban- kabfrage, die das Value-Attribut des Interfaces mit allen MilchkaÔ¨Äeespezialit√§ten bef√ºllt. Der ZugriÔ¨Ä auf die Datenbank erfolgt hierbei √ºber Kotlin Coroutines, da SQLite nicht auf dem Hauptthread aufgerufen werden kann. Durch die vorgenommene Zuweisung in Zeile 4 des Listings 3.9 werden alle Observer getriggert, die den State der coÔ¨ÄeeList aus dem ViewModel abonniert haben. Das initiale Composable der Listenansicht, welches in der folgenden Abbildung 3.12 dargestellt ist, verf√ºgt √ºber ein solches Abonnement des States der coÔ¨ÄeeList. Abbildung 3.12: Composable zur Initialisierung der Listenansicht Zudem wird durch die Abbildung 3.12 deutlich, wie die Interaktion zwischen der Lis- tenansicht und dem ViewModel funktioniert. Durch ein ausgel√∂stes Klickevent auf ein Element in der Buttombar wird durch State Hoisting vom ListScreen()-Composable die entsprechende Methode im ViewModel getriggert. Diese wird ausgef√ºhrt und f√ºhrt letzt- endlich zu einer √Ñnderung des States der coÔ¨ÄeeList Variable, was eine Rekomposition des ListScreen()-Composables zur Folge hat. Somit werden die Daten auf dem UIangezeigt, die dem ausgew√§hlten Filterkriterium entsprechen.;0
  Die Softwarequalit√§t ist ein vielschichtiges Konzept, das sowohl technische als auch nicht-technische Aspekte umfasst. In der Softwareentwicklung werden verschiedene Ans√§tze zur Bewertung und Sicherstellung der Qualit√§t von Softwareprodukten verfolgt. Besonders relevant sind in diesem Zusammenhang die produktorientierten Metriken, die sich auf die Analyse des Endprodukts selbst konzentrieren. Diese Metriken bieten eine quantitative Basis, um die Qualit√§t von Software systematisch zu bewerten, zu vergleichen und zu verbessern.    produktorientierter Metriken  Produktorientierte Metriken sind definiert als messbare Eigenschaften eines Softwareprodukts, die sich aus der Analyse des Codes, der Architektur und der funktionalen sowie nicht-funktionalen Anforderungen ableiten. Sie sind darauf ausgelegt, objektive Daten √ºber das Produkt zu liefern und unterst√ºtzen somit die Qualit√§tskontrolle und -sicherung.  Zu den grundlegenden theoretischen Konzepten geh√∂ren 1. Metriken der Softwarekomplexit√§tDiese Metriken bewerten die Komplexit√§t eines Softwareprodukts und umfassen unter anderem den Zyklomatischen Komplexit√§tsgrad, der die Anzahl der unabh√§ngigen Pfade durch ein Programm misst. Eine hohe Komplexit√§t kann auf potenzielle Schwierigkeiten bei der Wartung und der Fehlersuche hinweisen.  2. Metriken zur Codequalit√§tDiese Gruppe umfasst Metriken wie die Anzahl der Codezeilen, die Dichte und die Verteilung von Fehlern sowie die H√§ufigkeit von Code√§nderungen. Hohe Werte in diesen Bereichen k√∂nnen auf eine niedrigere Codequalit√§t hinweisen, da sie potenziell zu erh√∂hter Fehleranf√§lligkeit und Wartungsaufwand f√ºhren.  3. Metriken zur TestabdeckungSie quantifizieren den Anteil des Codes, der durch Tests abgedeckt ist. Eine hohe Testabdeckung ist ein Indikator f√ºr die Robustheit und Zuverl√§ssigkeit eines Softwareprodukts. Metriken wie die Statement Coverage oder die Branch Coverage sind g√§ngige Ans√§tze zur Bewertung der Testeffektivit√§t.  4. Metriken zur Architekturqualit√§tDiese Metriken konzentrieren sich auf die Softwarearchitektur und bewerten Aspekte wie Modularit√§t, Kopplung und Koh√§sion. Eine gut strukturierte Architektur ist entscheidend f√ºr die Wartbarkeit und Erweiterbarkeit eines Softwareprodukts.  5. Performance-MetrikenSie messen die Reaktionszeiten, Durchsatzraten und Ressourcennutzung einer Software. Leistungsmetriken sind entscheidend, um sicherzustellen, dass Software nicht nur funktional, sondern auch effizient und reaktionsschnell ist.   Anwendung produktorientierter Metriken  Die Anwendung produktorientierter Metriken erfolgt typischerweise in verschiedenen Phasen des Softwareentwicklungszyklus. In der Entwurfsphase k√∂nnen Metriken zur Architekturqualit√§t verwendet werden, um sicherzustellen, dass die Software eine solide und wartbare Struktur hat. In der Implementierungsphase kommen Codequalit√§tsmetriken und Metriken der Softwarekomplexit√§t zum Einsatz, um die Codebasis regelm√§√üig zu bewerten und zu verbessern.  W√§hrend der Testphase sind Metriken zur Testabdeckung von besonderer Bedeutung, da sie helfen, Schwachstellen im Testprozess zu identifizieren und sicherzustellen, dass kritische Teile des Codes ausreichend getestet sind. In der Wartungsphase sind kontinuierliche Bewertungen mittels Performance-Metriken essenziell, um sicherzustellen, dass Software im Betrieb effizient l√§uft und Ressourcen optimal genutzt werden.  Zusammenfassend l√§sst sich sagen, dass produktorientierte Metriken eine wichtige Rolle in der Qualit√§tssicherung von Software spielen. Sie bieten nicht nur eine Grundlage f√ºr die quantitative Bewertung der Softwarequalit√§t, sondern unterst√ºtzen auch gezielte Verbesserungsma√ünahmen und die Entscheidungsfindung im Softwareentwicklungsprozess. Durch die systematische Anwendung dieser Metriken k√∂nnen Unternehmen die Qualit√§t ihrer Produkte nachhaltig steigern und den Anforderungen des Marktes besser gerecht werden.;1
"In der vorliegenden Arbeit wurde das Ph√§nomen der digitalen √úberwachung unter dem Leitbegriff ""Zero"" eingehend untersucht. Die M√∂glichkeiten und Gefahren, die mit der fortschreitenden Digitalisierung und der damit einhergehenden √úberwachung einhergehen, sind vielschichtig und erfordern eine differenzierte Betrachtung.   Einerseits er√∂ffnet die digitale √úberwachung durch innovative Technologien und Datenanalysen neue Perspektiven in Bereichen wie Sicherheit, Gesundheitswesen und personalisierte Dienstleistungen. Die M√∂glichkeit, gro√üe Datenmengen in Echtzeit auszuwerten, kann zur Pr√§vention von Verbrechen, zur Optimierung von Abl√§ufen und zur Verbesserung der Lebensqualit√§t der B√ºrger beitragen. Insbesondere in Krisensituationen, wie etwa der globalen Pandemie, hat sich gezeigt, dass digitale √úberwachungssysteme schnell und effektiv eingesetzt werden k√∂nnen, um die √∂ffentliche Gesundheit zu sch√ºtzen.  Andererseits birgt die digitale √úberwachung erhebliche Risiken, die nicht au√üer Acht gelassen werden d√ºrfen. Die permanente √úberwachung des Individuums kann zu einem Verlust der Privatsph√§re und der pers√∂nlichen Freiheit f√ºhren. Die Gefahren von Missbrauch und Diskriminierung durch algorithmische Entscheidungen sind real und erfordern ein kritisches Bewusstsein sowie eine ethische Reflexion √ºber die eingesetzten Technologien. Zudem besteht die Gefahr, dass die Gesellschaft in eine Kultur der Kontrolle und des Misstrauens abgleitet, in der das individuelle Recht auf Anonymit√§t und Unverletzlichkeit der Daten nicht mehr gew√§hrleistet ist.  Zusammenfassend l√§sst sich sagen, dass die Auseinandersetzung mit dem Thema ""Zero"" eine grundlegende Herausforderung f√ºr die moderne Gesellschaft darstellt. Es gilt, einen Balanceakt zwischen den Vorteilen der digitalen √úberwachung und dem Schutz der individuellen Rechte zu finden. Um die Chancen zu nutzen und die Gefahren zu minimieren, sind klare gesetzliche Rahmenbedingungen, eine transparente Kommunikation und die F√∂rderung eines kritischen √∂ffentlichen Diskurses unerl√§sslich. Nur so kann eine Zukunft gestaltet werden, in der digitale Technologien im Dienste des Menschen stehen, ohne dessen grundlegende Freiheiten zu gef√§hrden.";1
In der Abbildung 2.1 ist der Luftreiniger zu sehen, der von Studierenden der Fachrichtung Maschinenbau um Elektronik erweitert wurde. Dieser Luftreiniger ist mit einem ESP32- Mikrocontroller verbunden, der die Funktionalit√§ten des Ger√§ts verwaltet (vgl. Ebert und Schweier 15.12.2021, S. 11). Abbildung 2.1: Um Elektronik erweitertes Luftreinigungsger√§t (Ebert und Schweier 15.12.2021, S. 40) Das Luftreinigungsger√§t bietet vier Desinfektionsstufen, die sich durch die Geschwindigkeit der L√ºfter unterscheiden. Zus√§tzlich wird bei der vierten Desinfektionsstufe die eingebaute FAR-UVC-Leuchte eingeschaltet. (vgl. ebd., S. 36) Das ist am h√§ufigsten verwendete UV-Desinfektionssystem ist eine keimt√∂tende Lampe mit einer FAR- UVC-Strahlung von etwa 254 Nanometer (nm), jedoch ist diese Wellenl√§nge f√ºr Haut und Augen sch√§dlich. Daher k√∂nnen UV-Desinfektionssysteme mit keimt√∂tenden Lampen haupts√§chlich nur in unbewohnten R√§umen eingesetzt werden. (vgl. Alexandre R. Marra u. a. 2017) zitiert nach (vgl. Kitagawa u.a. 2020) Um die Sicherheit von den Personen zu gew√§hrleisten, ist der Luftreiniger mit einem Bewegungssensor verst√§rkt. Der Luftreiniger l√§sst die Aktivierung der h√∂chsten Stufe erst zu, wenn keine Bewegung in dem Raum erkannt wird. (vgl. Ebert und Schweier 15.12.2021, S. 36);0
 Ausblick  Der rasante Fortschritt in der Technologie und die zunehmenden Anforderungen an mobile Anwendungen bieten eine hervorragende Gelegenheit, die Vor- und Nachteile verschiedener Entwicklungsans√§tze eingehend zu analysieren. In dieser Arbeit haben wir uns mit einem praxisrelevanten Beispiel auseinandergesetzt: dem Vergleich zwischen Progressiven Webanwendungen (PWAs) und nativen Apps, spezifisch im Rahmen einer Journaling-App.   Die Ergebnisse unserer Untersuchung zeigen, dass sowohl PWAs als auch native Apps ihre jeweiligen St√§rken und Schw√§chen besitzen. PWAs bieten eine hervorragende Plattformunabh√§ngigkeit, schnellere Entwicklungszyklen und kosteneffiziente Updates, w√§hrend native Apps unvergleichliche Leistung, Zugriff auf anspruchsvolle Funktionen und ein optimiertes Nutzererlebnis versprechen. W√§hrend einige Nutzer die Zug√§nglichkeit und die sofortige Nutzbarkeit von Webanwendungen sch√§tzen, zeigen andere eine Vorliebe f√ºr die tiefergehende Integration in das Betriebssystem, die native Apps erm√∂glichen.  Angesichts der wachsenden Trends in der digitalen Wolkeninfrastruktur und des noch nicht vollst√§ndig ausgeloteten Potenzials von Technologien wie Progressive Web-APIs, ist es entscheidend zu betrachten, wie zuk√ºnftige Entwicklungen in der Journaling-App-Landschaft aussehen k√∂nnten. Eine strategische Kombination beider Ans√§tze k√∂nnte eine vielversprechende L√∂sung darstellen, um das Beste aus beiden Welten zu vereinen und die M√∂glichkeiten f√ºr individuelles Engagement und Personalisierung zu erweitern.  Zuk√ºnftige Forschungsprojekte sollten tiefere Einblicke in die Benutzererfahrungen und die langfristige Anwenderbindung sowohl bei PWAs als auch bei nativen Apps bieten. Eine empirische Analyse der Nutzerverhalten und -vorlieben k√∂nnte wertvolle Erkenntnisse dar√ºber liefern, welche Faktoren f√ºr eine optimale Wahl zwischen diesen beiden Ans√§tzen entscheidend sind. Die ermittelten Daten k√∂nnten dazu beitragen, k√ºnftige Entwicklungen und Trends im Bereich mobile Applikationen pr√§ziser zu steuern und anzupositive Experiences f√ºr diverse Zielgruppen zu schaffen.  Abschlie√üend l√§sst sich feststellen, dass die Wahl zwischen PWAs und nativen Apps nicht als einfache Entscheidung zusehen ist, sondern vielmehr von den spezifischen Anforderungen, Zielen und der Zielgruppe abh√§ngt. Umso bedeutender ist es, die voranschreitende Technologieentwicklung im Auge zu behalten und flexibel auf neue Trends sowie Wechselwirkungen zwischen verschiedenen anwenderzentrierten Ans√§tzen zu reagieren. Effiziente und nutzerfreundliche L√∂sungen liegen in der kontinuierlichen, interaktiven Forschung und dem einf√ºhlenden Verst√§ndnis der Bed√ºrfnisse der Nutzer.;1
"2.1.2 Aufbau einer Progressive Web App
PWAswerdenmitWebTechnologien,wieHyperTextMarkupLanguage( HTML),Cascading
Style Sheets ( CSS) und JavaScript, erstellt. Dies erm√∂glicht es Entwicklern bereits be-
kannte Technologien zu verwenden . Ein wichtiger Bestandteil einer gut
funktionierenden PWAist die Verwendung von Caching. Hierf√ºr wird der Service Worker
eingesetzt, der die OÔ¨Ñinenutzung nach dem ersten Aufrufen der PWAerm√∂glicht.
Ein wichtiger Aspekt f√ºr die Entwicklung von PWAs ist das sogenannte Progressiv En-
hancement. Dabei geht es darum, m√∂glichst viel Feature zu aktivieren, die der Nutzer,
beziehungsweise der Browser des Nutzers unterst√ºtzt. Dies beinhaltet die Webseiten so zu
programmieren, dass falls ein Feature nicht unterst√ºtzt wird, die Webseiten ohne Fehler
weiter funktionieren. Progressive Enhancement wird nicht nur bei PWAs sondern auch im
allgemeinen bei der Webentwicklung angewendet. .
PWAsfolgeninderRegelderAppShellArchitektur.HierbeiwirdeinegrundlegendeAnsicht
der App erstellt, in die sp√§ter die Daten geladen werden. Diese beinhaltet beispielsweise eine
Kopfzeile, Bottomnavigation und eventuelle Eingabekomponenten .
Dies erm√∂glicht es dem Nutzer, die OberÔ¨Ç√§che anzuzeigen, bis die Daten nachtr√§glich
geladen sind. Hierbei kann bei einer langsamen Verbindung zuerst Daten aus dem Cache
angezeigt werden. Diese k√∂nnen nach dem Beziehen der aktuellen Daten ersetzt, erg√§nzt
oder aktualisiert werden . Im folgender Abbildung 2.4 ist die App
Shell mit Daten zu erkennen:
Abbildung 2.4: App Shell mit geladenen Daten";0
 Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tEine   Die Qualit√§t von Software ist ein zentrales Anliegen in der Softwareentwicklung, da sie entscheidend f√ºr die Benutzerzufriedenheit, die Wartbarkeit und die langfristige Effizienz eines Systems ist. Produktorientierte Metriken der Softwarequalit√§t bieten ein strukturiertes Rahmenwerk zur quantitativen Bewertung dieser Qualit√§t. Diese Metriken konzentrieren sich auf die Eigenschaften des Softwareprodukts selbst, anstatt auf den Prozess der Softwareentwicklung. In diesem Prosatext wird zun√§chst eine Definition produktorientierter Metriken vorgestellt, gefolgt von deren Anwendung und der Evaluierung eines spezifischen Softwareprojekts.   Definition produktorientierter Metriken  Produktorientierte Metriken sind quantitative Ma√üe, die spezifische Eigenschaften eines Softwareprodukts bewerten. Sie k√∂nnen in verschiedene Kategorien unterteilt werden, darunter 1. KorrektheitMisst, inwieweit das Softwareprodukt den spezifizierten Anforderungen entspricht. Beispiele sind die Anzahl der gefundenen Fehler pro Funktionseinheit oder die Rate an Fehlern nach dem Release.  2. Zuverl√§ssigkeitBewertet die F√§higkeit der Software, unter definierten Bedingungen √ºber einen bestimmten Zeitraum hinweg fehlerfrei zu funktionieren. Wichtige Metriken sind hier die Mean Time Between Failures (MTBF) und die Mean Time To Repair (MTTR).  3. WartbarkeitBezieht sich auf die Leichtigkeit, mit der ein Softwareprodukt modifiziert werden kann. Metriken wie die Zyklomatische Komplexit√§t oder der Anteil an wiederverwendbarem Code sind in diesem Kontext von Bedeutung.  4. BenutzerfreundlichkeitBewertet, wie intuitiv und ansprechend die Software f√ºr den Endbenutzer ist. Hier k√∂nnen Metriken wie die Zeit zur Erledigung einer bestimmten Aufgabe oder die Anzahl der Supportanfragen herangezogen werden.  5. EffizienzMisst, wie ressourcenschonend die Software arbeitet. Wichtige Indikatoren sind der Speicherverbrauch, die Reaktionszeit und die Systemauslastung.   Anwendung produktorientierter Metriken  Die Anwendung produktorientierter Metriken erfolgt in mehreren Phasen des Softwareentwicklungsprozesses. Zu Beginn, in der Planungs- und Entwurfsphase, k√∂nnen Metriken wie die gesch√§tzte Zyklomatische Komplexit√§t verwendet werden, um die Wartbarkeit und Korrektheit der geplanten Software zu evaluieren. W√§hrend der Implementierungsphase bieten Metriken wie Code-Duplikation und Testabdeckung wichtige Einblicke in die Qualit√§t des entwickelten Codes.  In der Testphase werden produktorientierte Metriken insbesondere zur Fehleridentifikation und -behebung herangezogen. Hierbei sind Metriken wie die Fehlerdichte und die Testabdeckung von zentraler Bedeutung, um die Robustheit und Zuverl√§ssigkeit des Produkts zu beurteilen. Nach dem Release wird die kontinuierliche Anwendung dieser Metriken durch Monitoring-Tools unterst√ºtzt, die die Softwarequalit√§t im Betrieb √ºberwachen und Verbesserungspotenziale aufzeigen.     Um die Effektivit√§t produktorientierter Metriken zu demonstrieren, wird im Folgenden die Evaluierung eines fiktiven Softwareprojekts;1
  Die fortschreitende Automatisierung und Vernetzung von Fahrzeugen hat in den letzten Jahren zu einem signifikanten Anstieg der Forschung im Bereich der Fahrzeugfernsteuerung gef√ºhrt. Insbesondere die Implementierung von Kollisionsvermeidungssystemen ist von zentraler Bedeutung, um die Sicherheit im Stra√üenverkehr zu erh√∂hen. In diesem Kontext wurde ein Projekt zur Entwicklung einer Fahrzeugfernsteuerung auf Basis des IEEE 802.15 Standards initiiert. Diese Technologie, die urspr√ºnglich f√ºr die drahtlose Kommunikation in lokalen Netzwerken konzipiert wurde, bietet vielversprechende Ans√§tze f√ºr die Echtzeitkommunikation zwischen Fahrzeugen und deren Steuerungssystemen. Die  umfasst mehrere Aspekte, darunter die technische Machbarkeit, die Benutzerfreundlichkeit und die Sicherheitsaspekte des Systems.  Die technische Machbarkeit der Fahrzeugfernsteuerung wurde durch eine detaillierte Analyse der Kommunikationsprotokolle des IEEE 802.15 √ºberpr√ºft. Diese Protokolle erm√∂glichen eine zuverl√§ssige Daten√ºbertragung √ºber kurze Distanzen und sind besonders f√ºr Anwendungen geeignet, bei denen geringe Latenzzeiten entscheidend sind. Um die Leistungsf√§higkeit des Systems zu testen, wurden Prototypen entwickelt, die verschiedene Sensoren zur Erfassung von Umgebungsdaten integrierten. Diese Sensoren, darunter Lidar und Ultraschall, lieferten Echtzeitinformationen √ºber potenzielle Hindernisse und erm√∂glichten so die Implementierung von Algorithmen zur Kollisionsvermeidung. Die Ergebnisse der Tests zeigten, dass das System in der Lage war, Hindernisse in einem Umkreis von bis zu 30 Metern zuverl√§ssig zu erkennen und darauf zu reagieren.  Ein weiterer wichtiger Aspekt der Evaluierung war die Benutzerfreundlichkeit der Fernsteuerung. Hierzu wurden Usability-Tests mit potenziellen Nutzern durchgef√ºhrt, um die Interaktion zwischen Mensch und Maschine zu analysieren. Die Tests ergaben, dass die Benutzeroberfl√§che intuitiv gestaltet war und die Steuerung des Fahrzeugs √ºber mobile Endger√§te reibungslos funktionierte. Dennoch wurden Verbesserungsvorschl√§ge hinsichtlich der Feedback-Mechanismen gesammelt, um die Nutzererfahrung weiter zu optimieren. Insbesondere die Integration von visuellen und akustischen Warnsystemen zur Information √ºber bevorstehende Kollisionen wurde als notwendig erachtet.  Die Sicherheitsaspekte des Systems wurden ebenfalls eingehend evaluiert. Die Implementierung von Sicherheitsprotokollen und Verschl√ºsselungstechnologien war entscheidend, um die Integrit√§t der Kommunikation zu gew√§hrleisten und potenzielle Cyberangriffe abzuwehren. In Simulationen, die verschiedene Angriffszenarien nachstellten, konnte gezeigt werden, dass das System robust gegen√ºber unbefugten Zugriffen war. Dennoch wurden Empfehlungen zur kontinuierlichen √úberwachung und Aktualisierung der Sicherheitsma√ünahmen ausgesprochen, um den sich st√§ndig weiterentwickelnden Bedrohungen im digitalen Raum zu begegnen.  Zusammenfassend l√§sst sich sagen, dass die  zur  vielversprechende Ergebnisse lieferte. Die technische Machbarkeit wurde durch erfolgreiche Tests der Kommunikationsprotokolle und der Sensorintegration belegt. Die;1
Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die zunehmende Verschmutzung der Luft und die diesbez√ºglichen gesundheitlichen Risiken haben die Nachfrage nach effektiven Luftreinigungsger√§ten in den letzten Jahren erheblich gesteigert. Die Integration elektronischer Komponenten in diese Ger√§te bietet nicht nur die M√∂glichkeit zur Verbesserung der Reinigungsleistung, sondern auch zur Optimierung der Benutzererfahrung und Selbstregelung. Eine vertiefte Betrachtung der Visualisierung, Bedienung und Selbstregelung gibt Aufschluss √ºber zuk√ºnftige Entwicklungsm√∂glichkeiten, die das Nutzererlebnis drastisch verbessern k√∂nnten.   1. VisualisierungDaten intelligent aufbereiten  Die Visualisierung der Luftqualit√§tsdaten spielt eine zentrale Rolle in der Benutzerinteraktion. Moderne Luftreinigungsger√§te sind zunehmend in der Lage, umfangreiche Daten √ºber die Umgebung zu sammeln, wie z.B. Feinstaubkonzentrationen, VOC-Werte (fl√ºchtige organische Verbindungen) und Allergene. Zuk√ºnftige Entwicklungen k√∂nnten sich darauf konzentrieren, diese Daten nicht nur in Form von einfachen Indikatoren darzustellen, sondern als interaktive grafische Benutzeroberfl√§chen (GUIs), die Echtzeit-Datenvisualisierungen bieten.   Ein Beispiel w√§re die Verwendung von Augmented Reality (AR), um Nutzern zu erm√∂glichen, durch ihre Smartphone-Kamera in die Luftqualit√§t ihres Haushalts einzutauchen. Solche Entwicklungen k√∂nnten durch die Integration k√ºnstlicher Intelligenz (KI) unterst√ºtzt werden, die Muster in den Luftqualit√§tsdaten erkennt und individuelle Empfehlungen zur Verbesserung der Luftqualit√§t abgibt.   2. BedienungIntuitive und benutzerfreundliche Interfaces  Die Bedienung eines Luftreinigers sollte so intuitiv wie m√∂glich gestaltet sein, um eine breite Nutzerakzeptanz zu gew√§hrleisten. In der Zukunft k√∂nnten Touchscreen-Oberfl√§chen durch Sprachsteuerungssysteme und Gestensteuerung ersetzt oder erg√§nzt werden. Hierbei k√∂nnte die Spracherkennungstechnologie in Verbindung mit KI genutzt werden, um personalisierte Benutzererfahrungen zu schaffen.  F√ºr Menschen mit Einschr√§nkungen sollte die Ger√§teverwaltung auch √ºber mobile Apps erfolgen k√∂nnen, die barrierefreie Funktionen wie Sprachausgabe und visuelle Hilfen beinhalten. Diese Entwicklungen w√ºrden nicht nur die Zug√§nglichkeit erh√∂hen, sondern auch das Bedienerlebnis f√ºr eine breitere Zielgruppe verbessern.   3. SelbstregelungIntelligente Anpassungen in Echtzeit  Um einen optimalen Reinigungsprozess zu gew√§hrleisten, m√ºssen Luftreinigungsger√§te in der Lage sein, sich selbst√§ndig an wechselnde Luftqualit√§tsbedingungen anzupassen. Die Integration von maschinellem Lernen in die Selbstregelungsmechanismen k√∂nnte dazu f√ºhren, dass Ger√§te mit der Zeit lernen, welche Parameter f√ºr bestimmte R√§ume optimal sind. Dies k√∂nnte durch erweiterte Sensorik realisiert werden, die nicht nur die Luftqualit√§t misst, sondern auch Informationen √ºber Temperatur, Luftfeuchtigkeit und sogar die Anwesenheit von Personen im Raum einholt.  Zukunftsweisende Systeme k√∂nnten auch in der Lage sein, ihre Reinigungsintensit√§t automatisch zu erh√∂hen, wenn erweiterte Schadstoffbelastungen festgestellt werden, etwa durch saisonale Allergene oder Luftverschmutzung von au√üen. Dar√ºber hinaus k√∂nnte eine Online-Community-Plattform erm√∂glicht werden, auf der Nutzer ihre Erfahrungen mit dem Ger√§t teilen und Tipps zur optimalen Nutzung austauschen k√∂nnen.   Fazit  Die Optimierung der Visualisierung, Bedienung und Selbstregelung von um Elektronik erweiterten Luftreinigungsger√§ten bietet vielversprechende Perspektiven f√ºr die Zukunft. Durch innovative Ans√§tze in der Nutzerinteraktion und intelligenten Systemanpassungen k√∂nnten diese Ger√§te nicht nur die Luftqualit√§t erheblich verbessern, sondern auch eine benutzerfreundliche, intuitive Bedienung bieten. In einer Welt, in der die Gesundheitsrisiken durch Luftverschmutzung stetig steigen, k√∂nnte die Forschung in diesen Bereichen entscheidend sein, um Technologie und Gesundheitsbewusstsein zu vereinen. Die Herausforderungen der Zukunft erfordern ein interdisziplin√§res Herangehen, um Ger√§ten nicht nur technische Effizienz, sondern auch einen hohen emotionalen und sozialen Wert zu verleihen.;1
Ausblick  Die vorliegende Arbeit hat sich mit der Entwicklung eines Content Management Systems (CMS) zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper besch√§ftigt. Der Einsatz von Robotern in verschiedenen Lebensbereichen, sei es in der Bildung, im Gesundheitswesen oder im Kundenservice, nimmt stetig zu. In diesem Kontext stellt der humanoide Roboter Pepper eine vielversprechende Plattform dar, um Interaktionen zwischen Mensch und Maschine zu gestalten und innovative Anwendungen zu entwickeln.   Das entwickelte CMS bietet eine benutzerfreundliche Oberfl√§che, die es auch Nicht-Programmierern erm√∂glicht, ma√ügeschneiderte Apps zu erstellen, die auf die spezifischen Bed√ºrfnisse und Anforderungen ihrer Zielgruppen zugeschnitten sind. Durch die Implementierung von Drag-and-Drop-Funktionalit√§ten und vorgefertigten Modulen wird die H√ºrde zur App-Entwicklung signifikant gesenkt. Dies er√∂ffnet neue M√∂glichkeiten f√ºr Bildungseinrichtungen, Unternehmen und Forschungseinrichtungen, kreative L√∂sungen zu entwickeln, die die Interaktivit√§t und Benutzererfahrung von Pepper maximieren.  Ein zentraler Aspekt, der in zuk√ºnftigen Arbeiten vertieft werden sollte, ist die Erweiterbarkeit des CMS. Die Integration von KI-gest√ºtzten Funktionen, wie Sprach- und Bilderkennung, k√∂nnte die Interaktion mit dem Roboter weiter verbessern und personalisierte Erfahrungen f√ºr die Benutzer schaffen. Zudem w√§re es sinnvoll, die M√∂glichkeiten zur Anbindung an externe Datenquellen und APIs zu untersuchen, um dynamische Inhalte in die Apps zu integrieren und so deren Funktionalit√§t zu erweitern.  Ein weiterer vielversprechender Forschungsbereich k√∂nnte die Analyse der Nutzererfahrungen und -interaktionen mit den entwickelten Apps sein. Durch qualitative und quantitative Studien k√∂nnten wertvolle Erkenntnisse gewonnen werden, die zur weiteren Optimierung des CMS und der App-Entwicklung beitragen. Insbesondere die Erfassung von Feedback in realen Anwendungsszenarien w√ºrde helfen, die Benutzerfreundlichkeit und Effektivit√§t der entwickelten L√∂sungen zu evaluieren und zu verbessern.  Insgesamt bietet die Entwicklung eines CMS f√ºr die Erstellung von Android-Apps f√ºr Pepper nicht nur eine technische Innovation, sondern auch einen bedeutenden Beitrag zur Forschung im Bereich der Mensch-Roboter-Interaktion. Zuk√ºnftige Arbeiten sollten die M√∂glichkeiten der Skalierbarkeit und Anpassungsf√§higkeit des Systems weiter untersuchen, um die Potenziale des humanoiden Roboters Pepper voll auszusch√∂pfen und dessen Einsatz in unterschiedlichen Kontexten zu f√∂rdern.;1
"  Die digitale Transformation hat die Art und Weise, wie Studierende Software Engineering betreiben, grundlegend ver√§ndert. Insbesondere im Kontext projektbasierter Lernumgebungen ist das Management von Aufgaben und Prozessen entscheidend f√ºr den Erfolg. Um den speziellen Bed√ºrfnissen von Studierenden gerecht zu werden, ist eine Anforderungsanalyse f√ºr die Entwicklung eines ma√ügeschneiderten Aufgabenmanagement-Tools unerl√§sslich. Ziel dieses Textes ist es, die wesentlichen Anforderungen an ein solches Tool zu ermitteln und die  zu skizzieren.   1.   Die Komplexit√§t von Softwareentwicklungsprojekten erfordert eine systematische Herangehensweise an das Aufgabenmanagement. Studierende stehen oft vor Herausforderungen hinsichtlich der Zeitplanung, der Kommunikation im Team und der Nachverfolgbarkeit von Projektfortschritten. Ein spezialisiertes Aufgabenmanagement-Tool kann dabei helfen, diese Herausforderungen zu meistern, indem es eine strukturierte Plattform zur Verwaltung von Aufgaben, Fristen und Verantwortlichkeiten bietet.   2. Anforderungsanalyse  Um ein effektives Aufgabenmanagement-Tool zu entwickeln, m√ºssen verschiedene Anforderungen identifiziert und priorisiert werden. Die folgenden Kategorien spielen dabei eine zentrale Rolle  2.1 Funktionale Anforderungen  1. AufgabenverwaltungBenutzer m√ºssen in der Lage sein, Aufgaben zu erstellen, zu bearbeiten und zu l√∂schen. Jede Aufgabe sollte mit relevanten Informationen wie Titel, Beschreibung, F√§lligkeitsdatum, Priorit√§t und verantwortlicher Person versehen werden.     2. StatusverfolgungEine klare Statusanzeige f√ºr Aufgaben (z.B. ""neu"", ""in Bearbeitung"", ""abgeschlossen"") ist notwendig, um den Fortschritt transparent zu gestalten.  3. Zuweisung von AufgabenStudierende m√ºssen Aufgaben unterschiedlichen Teammitgliedern zuweisen k√∂nnen, um Verantwortlichkeiten klar zu definieren.  4. BenachrichtigungssystemEin integriertes Benachrichtigungssystem, das Nutzer √ºber bevorstehende Fristen oder √Ñnderungen an Aufgaben informiert, ist unerl√§sslich f√ºr die Einhaltung von Zeitpl√§nen.  5. DokumentenmanagementDie M√∂glichkeit, relevante Dokumente und Ressourcen an Aufgaben zu verkn√ºpfen, f√∂rdert die Effizienz.   2.2 Nicht-funktionale Anforderungen  1. BenutzerfreundlichkeitDas Tool muss intuitiv bedienbar sein, um eine hohe Akzeptanz bei den Nutzern zu gew√§hrleisten. Ein ansprechendes UI/UX-Design kann hierbei entscheidend sein.  2. KollaborationEine Unterst√ºtzung f√ºr die Zusammenarbeit ist essentiell. Funktionen wie Kommentarbereiche oder Diskussionsforen zu Aufgaben k√∂nnen den Austausch im Team f√∂rdern.  3. Plattformunabh√§ngigkeitDas Tool sollte plattform√ºbergreifend (Web, Mobile) zug√§nglich sein, um Flexibilit√§t f√ºr verschiedene Nutzerbed√ºrfnisse zu gew√§hrleisten.  4. Sicherheit und DatenschutzDa es sich um studentische Projekte handelt, muss das Tool Datenschutzrichtlinien einhalten und sicherstellen, dass pers√∂nliche Informationen gesch√ºtzt sind.  5. SkalierbarkeitDie L√∂sung sollte skalierbar sein, um zuk√ºnftig zus√§tzliche Features oder eine h√∂here Nutzerzahl problemlos integrieren zu k√∂nnen.   3.   Die Implementierung eines eigenen Aufgabenmanagement-Tools umfasst mehrere Phasen  3.1 Anforderungsdefinition  In der ersten Phase werden die oben genannten funktionalen und nicht-funktionalen Anforderungen pr√§zise dokumentiert. Workshops mit den potenziellen Nutzern k√∂nnen dabei helfen, diese Anforderungen zu verfeinern.   3.2 Technologiewahl  F√ºr die Entwicklung des Tools k√∂nnen moderne Technologien und Frameworks wie React f√ºr das Frontend und Node.js f√ºr das Backend ausgew√§hlt werden. Eine relationale Datenbank (z.B. PostgreSQL) erm√∂glicht eine strukturierte Speicherung der Aufgaben und Nutzerinformationen.   3.3 Prototyping  Ein schneller Prototyp, der die Kernfunktionen des Tools demonstriert, sollte in der Praxis getestet werden. Nutzerfeedback kann hier wertvolle Insights liefern und helfen, die Benutzerfreundlichkeit zu optimieren.   3.4 Implementierung und Testing  Nach der Feinabstimmung des Prototyps erfolgt die vollst√§ndige Implementierung des Tools. Agile Methoden, insbesondere Scrum, k√∂nnen bei der Projektplanung und Priorisierung der Entwicklungsphasen unterst√ºtzend wirken. Um die Qualit√§t der L√∂sung sicherzustellen, sind umfangreiche Tests, einschlie√ülich Unit-Tests und Integrationstests, notwendig.   3.5 Rollout und Schulung  Nach erfolgreichem Testing wird das Tool der Zielgruppe vorgestellt. Begleitende Schulungen helfen den Nutzern, sich mit der neuen Software vertraut zu machen und deren Potenzial voll auszusch√∂pfen.   4. Fazit  Ein selbstentwickeltes Aufgabenmanagement-Tool f√ºr das studentische Software Engineering kann ma√ügeblich zur Verbesserung der Projektorganisation und -durchf√ºhrung beitragen. Durch eine pr√§zise Anforderungsanalyse und eine gut geplante Implementierung k√∂nnen die spezifischen Bed√ºrfnisse der Studierenden ber√ºcksichtigt und ein effektives Werkzeug geschaffen werden, das nicht nur die Zusammenarbeit f√∂rdert, sondern auch den Lernprozess unterst√ºtzt. K√ºnftige Forschungen k√∂nnten sich mit der Evaluierung von Nutzerfeedback und der kontinuierlichen Verbesserung des Tools befassen, um dessen Wirksamkeit sicherzustellen.";1
Im Rahmen dieser wissenschaftlichen Arbeit wurde ein Content Management System (CMS) entwickelt, das speziell auf die Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper ausgerichtet ist. Die Untersuchung und Implementierung dieses Systems verdeutlichen die Notwendigkeit und die Vorteile einer benutzerfreundlichen Plattform, die es Entwicklern und Anwendern erm√∂glicht, interaktive Anwendungen f√ºr humanoide Roboter zu gestalten, ohne tiefgehende Programmierkenntnisse zu ben√∂tigen.  Das CMS bietet eine intuitive Benutzeroberfl√§che, die es Nutzern gestattet, Inhalte einfach zu erstellen, zu verwalten und anzupassen. Durch die Integration von vorgefertigten Modulen und Templates wird der Entwicklungsprozess erheblich beschleunigt und vereinfacht. Die M√∂glichkeit, visuelle Elemente und Interaktionen zu gestalten, f√∂rdert die Kreativit√§t und er√∂ffnet neue Anwendungsfelder f√ºr den Roboter Pepper in Bildung, Unterhaltung und Service.  Dar√ºber hinaus wurde die technische Architektur des CMS so konzipiert, dass sie flexibel und erweiterbar ist. Dies erm√∂glicht zuk√ºnftige Anpassungen und Erweiterungen, um den sich wandelnden Anforderungen der Nutzer und den technologischen Entwicklungen Rechnung zu tragen. Die Implementierung von Schnittstellen zu bestehenden Softwarel√∂sungen und Datenbanken stellt sicher, dass das CMS nahtlos in bestehende Systeme integriert werden kann.  Zusammenfassend l√§sst sich festhalten, dass der Aufbau eines CMS zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper nicht nur die Zug√§nglichkeit der Robotiktechnologie erh√∂ht, sondern auch das Potenzial hat, die Interaktion zwischen Mensch und Maschine zu revolutionieren. Die Ergebnisse dieser Arbeit legen den Grundstein f√ºr weitere Forschungen und Entwicklungen in diesem vielversprechenden Bereich und er√∂ffnen Perspektiven f√ºr innovative Anwendungen, die den Einsatz von Robotern in verschiedenen Lebensbereichen vorantreiben.;1
"- Static members   In altbew√§hrten  Programmiersprachen wie C++ und Java, gibt es das Konzept von  static members.  Diese members  k√∂nnen innerhalb einer Klasse von allen Instanzen  genutzt werden. Dabei ist es nicht n√∂tig  eine bestimmte Laufzeitinstanz dieser  Klasse zu erhalten, um auf sie zuzugreifen , wodurch es einfacher wird von einem  beliebigen Punkt im Quellcode ausgehend  auf ein statisches Element zuzugreifen  als auf ein nicht statisches.34 Der Zugriff auf statische Methoden oder Felder erfolgt  in Java √ºber den Klassennamen oder √ºber eine Instanz wie folgt:   public static class ViewHolder extends RecyclerView .ViewHolder {    private final TextView answerId ;    private final TextView productId ;    private final ImageView showDetailedAnsw er;    public ViewHolder (View view ) {    super (view );    answerId = view .findViewById (R.id.completed_answer_id );    productId = view .findViewById (R.id.completed_product_id );    showDetailedAnswer = view .findViewById (R.id.completed_show_detail );    }  }  Das Problem ist, dass auf statische Member nicht √ºber eine Instanz zugegriffen  werden kann.  Beim Zugriff auf ein statisches Element au√üerhalb der Klasse , muss  eine explizite Typqualifizierung angegeben werden.  In Kotlin kann  diese Art von  Funktionalit√§t jedoch mit einigen anderen Ans√§tzen erreich t werd en. Obwohl es in  Kotlin das ‚Äöstatic‚Äò Schl√ºsselwort nicht gibt,  kann man mithilfe verschiedener  Ans√§tze statische Felder im Java -Bytecode erzeugen , die auch  als solche von Java  aufgerufen werden k√∂nnen.";0
Dadurch ergibt sich der Aufbau des Programmflusses, wie in Abbildung 5.18, wie folgt: Zu Beginn werden die verschiedenen I/0-Ger√§te initialisiert und dem I2C-Bus beigetreten. Da dieser Controller in der I2C-Kommunikation als peripheral agiert, werden anschlie√üend die Callbackfunktionen f√ºr receive- undrequest-Events registriert. Um ein problemloses Losfahren des Fahrzeugs zu erm√∂glichen, sollen zuerst der Servomotor und der Antriebs- motor in eine initiale Ausgangsposition gebracht werden, bei der sich das Fahrzeug nicht bewegt und die Lenkung eine neutrale Position einnimmt. In einer Endlosschleife wird dann √ºberpr√ºft, ob innerhalb einer festgelegten Zeit eine Distanz√ºberpr√ºfung f√ºr die Kollisionsvermeidung durchgef√ºhrt wurde. Ist dies nicht der Fall, so wird dies getan und bei Bedarf eine Kollisionsvermeidung durchgef√ºhrt. Weiterhin wird, wenn innerhalb der vorgegebenen Zeit von 50ms keine Nachricht erhalten wurde eine Notbremsung ausgel√∂st und bei Bedarf der Status der Kollisionsvermeidung zur√ºckgesetzt. Bei einem requestEvent wird lediglich zur√ºckgegeben, ob eine Kollisionsvermeidung durch- gef√ºhrt wurde. Beim Erhalt einer steering message durch den Xbee-Kontroller werden die Daten vom I2C-Bus gelesen, eine Distanz√ºberpr√ºfung und bei Bedarf eine Kollisionsvermei- dung durchgef√ºhrt. Weiterhin wird die neue Geschwindigkeit und der neue Lenkeinschlag gesetzt und ein Zeitstempel f√ºr die √úberpr√ºfung des Timeouts gespeichert. Der Quellcode ist in Anhang 5zu finden.;0
Schlie√ülich ist somit die ‚ÄûFrame Rate‚Äú jedes Modells bestimmt, welche im sp√§teren Verlauf mit den zus√§tzlichen Informationen aus den restlichen Messungen ausgewertet wird: die durchschnittliche Genauigkeit pro Video, die Anzahl an Katzenerkennungen pro Video und die Anzahl fehlerhafter Katzenerkennungen pro Video. F√ºr die weiteren Messungen m√ºssen die Videos an die Modelle angepasst werden. Da auch fehlerhafte Katzenerkennungen aufgezeichnet werden sollen, m√ºssen die einzelnen Frames identifiziert werden, auf denen keine Katze zu sehen ist. Daf√ºr wird beim Konvertieren der Videos auf die Zeitspannen geachtet, in denen keine Katze zu sehen ist. Jedes Frame innerhalb dieser Zeitspannen, welches das konvertierte Video erh√§lt, wird ‚Äûmarkiert‚Äú. Die Markierung entspricht einer Liste, welche die Nummern der Frames des konvertierten Videos abspeichert. So kann bei der Messung durch Z√§hlen der Frames √ºberpr√ºft werden, ob es sich dabei um ein Frame ohne Katze handelt. Mithilfe der an die Modelle angepassten Videos werden nun die restlichen Messungen durch- gef√ºhrt. Daf√ºr wird die bisherige Implementierung angepasst. Diese wird in Abbildung 4.8 als Ablaufdiagramm dargestellt. Anhand der daraus resultierenden Messergebnisse werden die jeweiligen Erkennungen aufsummiert sowie die durchschnittliche Wahrscheinlichkeit jedes Modells gebildet. Diese Informationen sind in Abbildung 4.9 dargestellt. Sie werden zusammen mit den FPSInformationen analysiert, um erste Erkenntnisse zu gewinnen und gegebenenfalls bereits erste Modelle auszusortieren.;0
Unter Verwendung des entwickelten Protokolls soll dann die eigentliche Entwicklung der Fahrzeugfernsteuerung, also sowohl die Implementierung auf der Fernsteuerung als auch auf dem Fahrzeugcontroller, durchgef√ºhrt werden. Zur Erh√∂hung der Sicherheit soll eine Kollisionsvermeidung mit einem Abstandssensor in den Fahrzeugcontroller integriert werden. Diese Kollisionsvermeidung soll dann mit den Messwerten des Abstandssensors in der Lage sein, eine automatische Notbremsung durchzuf√ºhren, wenn ein festgelegter Abstand zu Hindernissen unterschritten wird. Auf Basis der erarbeiteten Anforderungen soll dann zuerst das Programmdesign und dann die Implementierung erarbeitet werden. Die entwickelte Fahrzeugfernsteuerung soll dann an einem Prototypen demonstriert werden. Zur Evaluation der entwickelten Fahrzeugfernsteuerung soll die Latenz zwischen der Fahrzeugfernsteuerung und dem Fahrzeugcontroller in einem Experiment gemessen und anhand der festgelegten Anforderungen evaluiert werden. Abschlie√üend sollen die erarbeiteten Ergebnisse zusammengefasst, ein Ausblick gegeben und ein Fazit √ºber die Arbeit gezogen werden.;0
Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten im Internet der Dinge (IoT) haben in den letzten Jahren zu einem signifikanten Anstieg an Plattformen und Technologien gef√ºhrt, die speziell f√ºr die Entwicklung und Implementierung von IoT-Anwendungen konzipiert sind. Eine der vielversprechendsten Plattformen in diesem Kontext ist ElixirNerves, ein Framework, das auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von Embedded-Systemen und IoT-Ger√§ten entwickelt wurde. Diese Evaluation beleuchtet die St√§rken und Schw√§chen von ElixirNerves und gibt einen Ausblick auf m√∂gliche Weiterentwicklungen, die die Plattform noch leistungsf√§higer und benutzerfreundlicher machen k√∂nnten.  St√§rken von ElixirNerves  ElixirNerves bietet eine Reihe von Vorteilen, die es zu einer attraktiven Wahl f√ºr IoT-Anwendungen machen. Zun√§chst einmal basiert Elixir auf der Erlang Virtual Machine (BEAM), die f√ºr ihre Robustheit, Fehlertoleranz und Parallelverarbeitung bekannt ist. Diese Eigenschaften sind f√ºr IoT-Anwendungen von entscheidender Bedeutung, da sie eine hohe Verf√ºgbarkeit und Zuverl√§ssigkeit gew√§hrleisten m√ºssen. Dar√ºber hinaus erm√∂glicht die funktionale Programmierung in Elixir eine klare und pr√§gnante Strukturierung des Codes, was die Wartbarkeit und Erweiterbarkeit der Anwendungen erh√∂ht.  Ein weiterer wesentlicher Vorteil von ElixirNerves ist die umfangreiche Unterst√ºtzung f√ºr Hardware-Interaktionen. Das Framework bietet eine Vielzahl von Treibern und Bibliotheken, die die Kommunikation mit verschiedenen Sensoren, Aktoren und anderen Hardwarekomponenten erleichtern. Dies erm√∂glicht Entwicklern, schnell Prototypen zu erstellen und ihre Ideen in funktionierende Anwendungen umzusetzen.  Schw√§chen und Herausforderungen  Trotz der vielen Vorteile gibt es auch Herausforderungen, die bei der Nutzung von ElixirNerves beachtet werden m√ºssen. Eine der gr√∂√üten Herausforderungen ist die vergleichsweise geringe Verbreitung der Programmiersprache Elixir im Vergleich zu anderen Sprachen wie Python oder C. Dies kann die Verf√ºgbarkeit von Ressourcen, Schulungen und Community-Support einschr√§nken. Zudem k√∂nnten einige Entwickler, die an andere Programmiersprachen gew√∂hnt sind, eine steilere Lernkurve erleben.  Ein weiteres potenzielles Hindernis ist die Integration von ElixirNerves in bestehende IoT-√ñkosysteme. Viele Unternehmen nutzen bereits etablierte Plattformen und Standards, die m√∂glicherweise nicht nahtlos mit ElixirNerves kompatibel sind. Die Interoperabilit√§t mit anderen Systemen und Protokollen bleibt daher eine wichtige Frage, die adressiert werden muss.  Ausblick auf m√∂gliche Weiterentwicklungen  Um die Attraktivit√§t von ElixirNerves als Plattform f√ºr IoT-Anwendungen weiter zu steigern, sind mehrere Weiterentwicklungen denkbar. Zun√§chst k√∂nnte die Community verst√§rkt an der Erstellung von umfassenden Dokumentationen und Tutorials arbeiten, um neuen Entwicklern den Einstieg zu erleichtern. Eine st√§rkere Fokussierung auf Schulungsangebote und Workshops k√∂nnte ebenfalls dazu beitragen, das Wissen √ºber Elixir und ElixirNerves zu verbreiten.  Ein weiterer wichtiger Aspekt ist die Verbesserung der Interoperabilit√§t mit bestehenden IoT-Plattformen und -Protok;1
Zus√§tzlich wird durch die Verwendung der Room-Bibliothek eine √úberwachung des Daten- bankschemas erm√∂glicht und m√∂glichen Datenmanipulationen entgegengewirkt, da diese intern automatisch √ºberwacht werden. Ebenfalls sehr gut funktioniert neben dem Testen auch die Interaktion mit anderen Android Architecture Componentes wie LiveData und ViewModel . Bei ViewModels handelt es sich um Objekte, die h√§uÔ¨Åg dazu verwendet werden, Daten f√ºr dieUIComponents bereitzustellen. Hierf√ºr bieten sie sich besonders gut an, da sie in der Lage sind KonÔ¨Ågurations√§nderungen zu √ºberstehen. Als KonÔ¨Ågurations√§nderung kann hierbei schon eine √Ñnderung in der Ausrichtung des Ger√§tes gesehen werden. Diese √Ñnderungen k√∂nnen unter Umst√§nden zu Datenverlust oder ungewolltem Fehlverhalten der App f√ºhren, wenn die ben√∂tigten Daten in den Composables selbst gehalten werden. Ebenfalls werden ViewModels h√§uÔ¨Åg dazu eingesetzt, Daten f√ºr das UIzu managen und aufzubereiten, die das Ergebnis von asynchronen Aufrufen sind. Bei diesen kann es unter Umst√§nden zu minimalen zeitlichen Verz√∂gerungen kommen, bis eine zuverl√§ssige Antwort vorliegt. Zudem bieten sie Zugang zur Anwendungslogik . Diese Gr√ºnde bieten genug Anl√§sse, um auch bei der Erstellung der CoÔ¨ÄeeCompose Anwendung ein ViewModel zu verwenden. Dieses wird haupts√§chlich in der Listenansicht ben√∂tigt und verwaltet die Daten, die nach ausgew√§hltem Filterkriterium aus der lokalen Datenbank geladen und dann auf dem UI angezeigt werden sollen. Intern wird innerhalb des ViewModels mit einem Objekt der Klasse LiveData gearbeitet. Hierbei handelt es sich um eine Observable-Klasse zur Datenhaltung . Sie kann somit als Umsetzung des Observer-Patterns in Android gesehen werden. Das UI kann dieses Observable abonnieren und sich somit √ºber √Ñnderungen an den Daten informieren lassen, die in den Daten innerhalb der Holder-Klasse passieren . Somit hat das UIder Listenansicht die M√∂glichkeit, bei ge√§ndertem Filter auf den ge√§nderten Inhalt der Liste aus der Datenbank zu reagieren und sich zu erneuern. Der kombinierte Ansatz aus ViewModel und LiveData erm√∂glicht die einfache Handhabung des Lebenszyklus in Android und sorgt f√ºr eine h√∂here Datenkorrektheit . Genauere Details sowie die Implementierung des ViewModels k√∂nnen im Kapitel 3.2.5 eingesehen werden. Die weiteren grundlegenden theoretischen Prinzipien und technischen Aspekte zur prakti- schen Umsetzung mithilfe des deklarativen Ansatzes werden mithilfe der folgenden Kapitel umfassend dargestellt und erl√§utert.;0
Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung  Im Zeitalter der Informationstechnologie ist die digitale √úberwachung sowohl ein innovatives Werkzeug zur Gew√§hrleistung von Sicherheit als auch eine komplexe Herausforderung, die tiefgreifende ethische, rechtliche und soziale Fragestellungen aufwirft. Das Projekt ‚ÄûZero‚Äú hat sich intensiv mit den zugrunde liegenden Mechanismen, den durchf√ºhrenden Technologien und den weitreichenden Auswirkungen der digitalen √úberwachung auseinandergesetzt.  Die M√∂glichkeiten, die sich durch digitale √úberwachung er√∂ffnen, sind vielf√§ltig und bahnbrechend. Auf gesellschaftlicher Ebene erm√∂glichen Systeme zur Video√ºberwachung und Gesichtserkennung die pr√§ventive Verhinderung von Verbrechen, die Aufkl√§rung von Straftaten und die F√∂rderung von √∂ffentlicher Sicherheit. In privaten Sektoren wiederum f√∂rdern datengetriebene Analysen, unterst√ºtzt durch k√ºnstliche Intelligenz, die Effizienz von Dienstleistungen und optimieren menschliche Interaktionen, sodass Unternehmen gezieltere Angebote schaffen k√∂nnen. Diese technologischen Systeme k√∂nnen durch smarte Sensoren und tragbare Technologien das Verhalten von Individuen und Gruppen analysieren, wodurch ein datenbasiertes Feedback generiert wird, das wichtige Entscheidungen bei der Implementierung von Policen und Design entsteht.  Dennoch bringen diese M√∂glichkeiten erhebliche Risiken mit sich. Einer der grundlegendsten Aspekte dissoziativer digitaler √úberwachung ist der Verlust von Privatsph√§re. In vertrauten und durchdrungenen Lebensbereichen stehen Einzelpersonen unter einem konstanten Mikroskop, was fundamentalen Fragen des Individuums und der W√ºrde aufwirft. Seiten der B√ºrger stehen auf dem Spiel, da st√§ndig pers√∂nliche Daten erfasst und verarbeitet werden, oft ohne ausdr√ºckliche Einwilligung oder unter intransparenten Bedingungen. Dies kann zu einem dramatischen Machtungleichgewicht f√ºhren, in dem Unternehmen und Regierungen gro√üen Einfluss auf das individuelle Verhalten aus√ºben k√∂nnen, Dominanzannahmen verst√§rken und das Vertrauen in soziale Systeme gef√§hrden.  Das Projekt ‚ÄûZero‚Äú hat verschiedene Interessenvertreter, darunter B√ºrgerrechtler, Technologieexperten und Politikwissenschaftler, zusammengebracht, um die Abw√§gung zwischen Nutzen und Gefahr der digitalen √úberwachung herauszuarbeiten. Die Hauptergebnisse des Projekts verdeutlichen, dass klare rechtliche Rahmenbedingungen unerl√§sslich sind, um den verantwortungsvollen und ethisch einwandfreien Einsatz von √úberwachungstechnologien zu sichern. Der Schutz fundamentalster B√ºrgerrechte und die Minimierung der datenschutzrechtlichen Bedrohungen m√ºssen miteinander integriert werden.   Ein zentrales  ist, dass technologische Innovationen, ohne differenzierte Governance und aktive Einbeziehung der Zivilgesellschaft, schnell in dystopische Scenarios umschlagen k√∂nnen. Eine partizipative √úberwachungsavantstaltung ‚Äì bei der B√ºrger Einfluss auf deren Gestaltung und Einf√ºhrung haben ‚Äì k√∂nnte helfen, den silver lining der digitalen √úberwachung zu erm√∂glichenSicherheit und Effizienz im Alltag, ohne dass die Privatsph√§re der B√ºrger gef√§hrdet wird.   Die gegenw√§rtigen und zuk√ºnftigen politischen Entscheidungen m√ºssen darauf ausgerichtet sein, ethische Standards und transparente Prozesse zu integrieren, die den Menschen in den Mittelpunkt stellen. Nur so wird es m√∂glich sein, ein Gleichgewicht zwischen Sicherheit und den Rechten auf Privacy zu schaffen, und die multifunktionale Beziehung zwischen ihnen positiv neu;1
 Ein Ausblick auf m√∂gliche Weiterentwicklungen  In der dynamischen Welt der Softwareentwicklung spielen Programmiersprachen eine zentrale Rolle. Insbesondere in der Entwicklung von Android-Anwendungen stehen Java und Kotlin im direkten Wettbewerb. W√§hrend Java, seit seiner Einf√ºhrung in den 1990er Jahren, als die dominante Sprache f√ºr die Android-Entwicklung galt, hat Kotlin in den letzten Jahren zunehmend an Bedeutung gewonnen. Im Jahr 2017 wurde Kotlin offiziell von Google als erste Programmiersprache f√ºr die Android-Entwicklung unterst√ºtzt, was die Akzeptanz der Sprache weiter steigerte. In diesem Kontext lohnt sich ein Blick auf die m√∂glichen Weiterentwicklungen und die zuk√ºnftige Rolle beider Sprachen in der Softwareentwicklung.   JavaEine bew√§hrte Sprache mit Zukunftspotenzial  Java, als eine der √§ltesten und am weitesten verbreiteten Programmiersprachen, hat eine riesige Community, umfangreiche Bibliotheken und Frameworks sowie eine stabile Laufzeitumgebung (JVM), die f√ºr ihre Portabilit√§t bekannt ist. Die kontinuierliche Weiterentwicklung von Java, insbesondere durch die regelm√§√üigen Updates (Java SE 15, 16, und dar√ºber hinaus), hat die Sprachmerkmale modernisiert, ohne die Kompatibilit√§t zu alter Software zu gef√§hrden. In der Zukunft k√∂nnte Java weiterhin auf Performance-Optimierungen und die Verbesserung der Entwicklerproduktivit√§t abzielen. Die Implementierung von neuen Sprachfeatures, wie der Einf√ºhrung von Record Types und Pattern Matching, zeigt, dass Java sich bem√ºht, die Anforderungen moderner Programmierung zu erf√ºllen. Auch die Integration von Cloud-basierten Diensten und die Unterst√ºtzung von Microservices k√∂nnten die Relevanz von Java in neuen Anwendungsbereichen st√§rken.   KotlinAuf dem Weg zur Dominanz?  Kotlin hat als moderne Programmiersprache, die insbesondere f√ºr die mobile Entwicklung konzipiert wurde, einige Vorteile gegen√ºber Java. Die Sprache bietet eine pr√§gnantere Syntax, Nullsicherheitsmechanismen und leistungsf√§hige funktionale Programmierkonzepte. Diese Eigenschaften machen Kotlin besonders attraktiv f√ºr neue Entwickler und Teams, die sich in einer agilen Umgebung bewegen. Angesichts der kontinuierlichen Akkzeptanz innerhalb der Entwicklergemeinschaft und der Unterst√ºtzung durch Google ist es wahrscheinlich, dass Kotlin weiter an Bedeutung gewinnen wird. Zuk√ºnftige Entwicklungen k√∂nnten sich auf die Erweiterung der Sprache konzentrieren, insbesondere auf verbessertes Tooling, interoperable Bibliotheken und die Unterst√ºtzung f√ºr mehr Plattformen √ºber die Android-Entwicklung hinaus, wie beispielsweise serverseitige Anwendungen oder Multiplattform-Entwicklung mit Kotlin Multiplatform.   Ein hybrides Zukunftsszenario  Angesichts der St√§rken beider Sprachen k√∂nnte sich eine hybride Zukunft etablieren, in der Java und Kotlin in unterschiedlichen Szenarien koexistieren. Zahlreiche bestehende Projekte laufen auf Java, und die Migration zu Kotlin ist oft nicht praktikabel. Entwickler k√∂nnten in dieser Konstellation die Vorteile beider Sprachen kombinieren, indem sie neue Module oder Features in Kotlin entwickeln, w√§hrend die bestehende Infrastruktur in Java bleibt. Zudem k√∂nnten Tools zur Code-Transformation zwischen Java und Kotlin entwickelt werden, um die Interoperabilit√§t zwischen den beiden Sprachen zu f√∂rdern.   Fazit  Der Wettlauf zwischen Java und Kotlin wird auch in den kommenden Jahren von Bedeutung bleiben. Java wird weiterhin als stabile Plattform f√ºr gro√üe, langlebige Anwendungen agieren, w√§hrend Kotlin zunehmend in neu entwickelten Projekten sowie in der schnelllebigen Mobile-Entwicklung an Popularit√§t gewinnen k√∂nnte. Die zuk√ºnftige Entwicklung beider Sprachen wird davon abh√§ngen, wie gut sie sich an die fortw√§hrenden Ver√§nderungen in der Softwareentwicklung und den Anforderungen der Entwicklergemeinschaft anpassen k√∂nnen. Letztendlich k√∂nnte der beste Ansatz in der Vertrautheit mit beiden Sprachen und der F√§higkeit, die jeweiligen St√§rken optimal zu nutzen, liegen.;1
In einem XML-File kann das Layout √§hnlich wie HyperText Markup Language ( HTML)- Code erstellt werden. Hierbei gibt es ein Root-Element, das in diesem Fall durch eine ConstraintLayout ViewGroup verk√∂rpert wird. Die weiteren Widgets werden als Child- elemente innerhalb dieser ViewGroup angelegt . F√ºr die Implementierung des Layouts der Startseite werden hierf√ºr drei ImageViews , eineTextView und ein Button-Widget ben√∂tigt. Somit entsteht eine Viewhierarchie, die das Layout deÔ¨Åniert. Diese Hierarchie ist gemeinsam mit einer Gegen√ºberstellung zur Implementierung in Compose vollst√§ndig in Anhang A. Codevergleich des Layouts der Startseite einsehbar. Neben der Implementierung in einem XML-File ist es zudem m√∂glich, Widgets w√§hrend der Laufzeit zu instanziieren oder zu ver√§ndern . Jedes Widget besitzt seine eigene, individuelle Variation von Attributen. Neben zahlreichen Attributen zur Bestimmung von Gr√∂√üe, Position und Aussehen gibt es auch ein Attribut, welches dem Widget eine Id zuweist. Dieses ist sehr wichtig und sollte immer gesetzt werden, da es ein Element im Baum eindeutig identiÔ¨Åziert und ZugriÔ¨Ä auf dieses Element √ºber ViewBinding oder Ô¨ÅndViewById() erlaubt. Auch spielt diese Id bei Verwendung des ConstraintLayouts eine besondere Rolle, da die anderen Widgets, an denen ein Widget ausgerichtet werden soll, innerhalb des Baumes eindeutig identiÔ¨Åzierbar sein m√ºssen, um eine erfolgreiche und zielf√ºhrende Umsetzung der relativen Ausrichtung gew√§hrleisten zu k√∂nnen . Folgendes Listing 4.1 veranschaulicht dies anhand des erstellten Button-Widgets. Das Widget besitzt die Id btnLosGehts und wird anhand der in Zeile 7 bis 10 sichtbaren Constraints relativ zu seinem Patentelement und der ImageView mit der Id imageBottom ausgerichtet. Zudem wird durch das Listing 4.1 ersichtlich, dass jedes Widget eine festgelegt Gr√∂√üe ben√∂tigt,dieausH√∂heundBreitebesteht.HiergibtesbereitsConstraints,diedasAussehen und die Ausrichtung eines Widgets innerhalb seines Parentcontainers festlegen k√∂nnen. Das Constraint wrap_content sorgt daf√ºr, dass das Widget seine Gr√∂√üe in Abh√§ngigkeit von seinem Inhalt selbst bestimmt.;0
   Die digitale Transformation hat in den letzten zwei Jahrzehnten eine Vielzahl von Werkzeugen hervorgebracht, die Unternehmen und Organisationen dabei unterst√ºtzen, ihre Inhalte effizient zu verwalten und zu verbreiten. Content-Management-Systeme (CMS) haben sich als zentrale Komponenten in der digitalen Infrastruktur etabliert. Um die unterschiedlichen Systeme zu verstehen und ihre Auswahl zu erleichtern, ist es notwendig, die theoretischen Grundlagen zu betrachten, die diesen Technologien zugrunde liegen.   1. Definition und Funktionalit√§t von Content-Management-Systemen  Ein Content-Management-System ist eine Softwareanwendung, die es Nutzern erm√∂glicht, digitale Inhalte zu erstellen, zu bearbeiten, zu verwalten und zu ver√∂ffentlichen, ohne dass tiefgehende technische Kenntnisse erforderlich sind. Die grundlegenden Funktionen eines CMS beinhalten typischerweise die Inhaltsverwaltung, Benutzerverwaltung, Versionskontrolle und Workflow-Management. Diese Funktionen sind in einer benutzerfreundlichen Oberfl√§che integriert, die es auch nicht-technischen Benutzern erm√∂glicht, Inhalte zu bearbeiten und zu ver√∂ffentlichen.   2. Typen von Content-Management-Systemen  Content-Management-Systeme lassen sich grob in zwei Kategorien unterteilenpropriet√§re und Open-Source-Systeme. Propriet√§re CMS sind kommerzielle Produkte, die in der Regel umfassenden Support und regelm√§√üige Updates bieten, jedoch mit Lizenzkosten verbunden sind. Beispiele hierf√ºr sind Adobe Experience Manager und Sitecore. Open-Source-CMS wie WordPress, Joomla oder Drupal hingegen bieten eine flexible Anpassung durch die Community, sind jedoch oft weniger benutzerfreundlich und erfordern technisches Know-how f√ºr die Implementierung und Wartung.   3. Theoretische Modelle der Inhaltsorganisation  Die Organisation von Inhalten innerhalb eines CMS basiert auf verschiedenen theoretischen Modellen, die die Strukturierung und Pr√§sentation von Informationen unterst√ºtzen. Ein h√§ufig verwendetes Modell ist das des ‚ÄûTaxonomie-Managements‚Äú, das eine hierarchische Klassifikation von Inhalten erm√∂glicht. Dies f√∂rdert die Auffindbarkeit und Benutzerfreundlichkeit, indem es eine logische Struktur schafft, die es Nutzern erleichtert, relevante Informationen zu finden.  Ein weiteres relevantes Konzept ist das der ‚ÄûMetadaten‚Äú. Metadaten sind Daten, die Informationen √ºber andere Daten beschreiben. In einem CMS erm√∂glichen sie eine effiziente Suche und Kategorisierung von Inhalten. Durch die Verwendung standardisierter Metadatenformate k√∂nnen Inhalte √ºber verschiedene Systeme hinweg interoperabel gemacht werden.   4. Benutzerzentrierte Ans√§tze  Die Benutzerfreundlichkeit eines CMS ist ein entscheidender Faktor f√ºr dessen Akzeptanz und Erfolg. Theoretische Ans√§tze wie das ‚ÄûUser-Centered Design‚Äú (UCD) betonen die Bedeutung der Nutzererfahrung bei der Entwicklung von Softwarel√∂sungen. Ein benutzerzentriertes CMS ber√ºcksichtigt die Bed√ºrfnisse und F√§higkeiten der Benutzer und bietet intuitive Schnittstellen, um die Interaktion zu erleichtern. Die Implementierung von Usability-Tests und Feedbackschleifen ist entscheidend, um sicherzustellen, dass das System den Anforderungen der Endanwender gerecht wird.   5. Sicherheit und Skalierbarkeit  Ein weiteres zentrales Thema in der Diskussion um CMS ist die Sicherheit. Die theoretischen Grundlagen der Informationssicherheit, einschlie√ülich der Prinzipien der Vertraulichkeit, Integrit√§t und Verf√ºgbarkeit, sind;1
In der vorliegenden Arbeit wurde die Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings umfassend untersucht. Die Ergebnisse untermauern die zentrale Rolle effektiver Werkzeuge in der Ausbildung angehender Software-Ingenieure, indem sie nicht nur die Organisation und Planung von Projekten tolerieren, sondern auch die Teamarbeit und Kommunikation f√∂rdern.   Die durchgef√ºhrte Bedarfserhebung hat verschiedene generationsbedingte Lerngewohnheiten und Arbeitsverhalten aufgezeigt, die in die Entwicklung des Tools einflie√üen sollten. Wichtige Anforderungen waren Flexibilit√§t, Benutzerfreundlichkeit, Integrationsf√§higkeit zu bestehenden Systemen und die M√∂glichkeit zur Anpassung an konkrete Projektbed√ºrfnisse. Dar√ºber hinaus zeigten die Befragungen, dass Funktionalit√§ten wie schnelles Task-Tracking, Fortschritts√ºberwachung und Visualisierung von Arbeitslast zugeschnitten werden m√ºssen, um den Anforderungen studentischer Projekte gerecht zu werden.  Ein abschlie√üender Blick auf die gewonnenen Daten zeigt nicht nur die Anforderungen, sondern skizziert auch die technologischen Rahmenbedingungen, die f√ºr ein solches Tool entscheidend sind. Die Kombination aus agilen Methoden und klassischen Projektmanagement-Techniken k√∂nnte eine solide Grundlage bieten, um den unterschiedlichen Bed√ºrfnissen umfassend gerecht zu werden.  Zusammenfassend l√§sst sich festhalten, dass ein erfolgreiches Aufgabenmanagement-Tool f√ºr den studentischen Bereich klare Visionen und ·Éò·É°·Éî·Éï einem engagierten Konzept erfordert. Die proaktive Einbindung der Nutzerperspektive in die Entwicklung ist essenziell, um letztlich ein in der Praxis n√ºtzliches und akzeptiertes Produkt zu schaffen, das den Prozess des Software Engineerings effizient unterst√ºtzt und Aufw√§nde f√ºr junge Software-Ingenieure signifikant minimiert. Diese Erkenntnisse bieten aussichtsreiche Perspektiven f√ºr zuk√ºnftige Forschungsbereiche innerhalb des Software Engineering und somit auch einen wertvollen Impuls f√ºr die weitere Praxis sowie die akademische Ausbildung in diesem Bereich.;1
Konzept f√ºr eine wissenschaftliche Arbeit: State of the Art beim Testen von MQTT-basierten L√∂sungen  Einleitung  In den letzten Jahren hat das Internet der Dinge (IoT) an Bedeutung gewonnen, und mit ihm auch die Notwendigkeit effizienter Kommunikationsprotokolle. Message Queuing Telemetry Transport (MQTT) hat sich als eines der f√ºhrenden Protokolle f√ºr die Kommunikation zwischen IoT-Ger√§ten etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz ist MQTT besonders f√ºr Anwendungen geeignet, die in ressourcenbeschr√§nkten Umgebungen operieren. Angesichts der wachsenden Verbreitung von MQTT-basierten L√∂sungen wird es zunehmend wichtiger, robuste Testmethoden zu entwickeln, um die Zuverl√§ssigkeit, Sicherheit und Leistungsf√§higkeit dieser Systeme zu gew√§hrleisten. Diese Arbeit zielt darauf ab, den aktuellen Stand der Testmethoden f√ºr MQTT-basierte L√∂sungen zu analysieren und zu bewerten.  Zielsetzung  Die Hauptziele dieser wissenschaftlichen Arbeit sind:  1. Eine umfassende Analyse der bestehenden Testmethoden f√ºr MQTT-basierte Systeme. 2. Die Identifikation von Herausforderungen und Limitationen in der aktuellen Testpraxis. 3. Die Entwicklung von Empfehlungen zur Verbesserung der Teststrategien f√ºr MQTT-Anwendungen. 4. Die Untersuchung von zuk√ºnftigen Trends und Technologien, die das Testen von MQTT-basierten L√∂sungen beeinflussen k√∂nnten.  Methodik  Um die oben genannten Ziele zu erreichen, wird ein mehrstufiger Forschungsansatz verfolgt:  1. Literaturrecherche: Eine umfassende Analyse der bestehenden wissenschaftlichen Literatur, technischer Berichte und Best Practices im Bereich des Testens von MQTT-basierten L√∂sungen. Dies umfasst sowohl akademische als auch industrielle Quellen.  2. Fallstudien: Die Untersuchung von realen Anwendungsf√§llen, in denen MQTT verwendet wird, um die unterschiedlichen Testans√§tze zu dokumentieren und deren Effektivit√§t zu bewerten. Hierbei werden verschiedene Branchen ber√ºcksichtigt, wie z.B. Smart Home, Gesundheitswesen und industrielle Automatisierung.  3. Interviews mit Experten: Durchf√ºhrung von Interviews mit Fachleuten aus der Industrie, die Erfahrung im Testen von MQTT-basierten L√∂sungen haben. Diese qualitativen Daten werden genutzt, um Einblicke in aktuelle Herausforderungen und Best Practices zu gewinnen.  4. Entwicklung eines Testframeworks: Auf Basis der gewonnenen Erkenntnisse wird ein Testframework entwickelt, das die identifizierten Best Practices und Empfehlungen integriert. Dieses Framework soll als Leitfaden f√ºr die Implementierung effektiver Teststrategien dienen.  Erwartete Ergebnisse  Die Arbeit wird voraussichtlich folgende Ergebnisse liefern:  1. Eine detaillierte √úbersicht √ºber die aktuellen Testmethoden f√ºr MQTT-basierte L√∂sungen, einschlie√ülich ihrer Vor- und Nachteile. 2. Eine kritische Analyse der Herausforderungen, die Tester bei der Validierung von MQTT-Anwendungen begegnen. 3. Praktische Empfehlungen zur Verbesserung der Testmethoden, um die Zuverl√§ssigkeit und Sicherheit von MQTT-basierten Systemen zu erh√∂hen. 4. Ein innovatives Testframework, das als Ressource f√ºr Entwickler und Tester dient, die mit MQTT arbeiten.  Schlussfolgerung  Die vorliegende Arbeit wird einen wertvollen Beitrag zum Verst√§ndnis der Testmethoden f√ºr MQTT-basierte L√∂sungen leisten und aufzeigen, wie diese optimiert werden k√∂nnen, um den steigenden Anforderungen an;1
Das Prinzip bzw. die Technologie hinter WYSIWYG findet in Joomla ebenfalls Anwendung. Seiten und Inhalte k√∂nnen per eingebettetem Editor innerhalb der Administrationsoberfl√§- che erstellt und bearbeitet werden. Jene Inhalte werden beim Seitenaufruf mit dem aktivierten Theme und dessen Style kombiniert und anschlie√üend dargestellt. Ein Block-Schema wie bei WordPress bzw. Drupal mit Erweiterung wird hierbei nicht angewandt. Da das Prinzip von ‚ÄûWhat You See Is What You Get‚Äú auch bei Joomla hinreichend erf√ºllt wird und keine zus√§tzlichen Anpassungen, welche Programmierkenntnis seitens des Nutzers bedingen, zur Erstellung von Inhalten ben√∂tigt werden, wird auch Joomla in Bezug auf den Anwendungsfall mit Gr√ºn kategorisiert.;0
Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und Vernetzung von Ger√§ten und Systemen in nahezu allen Lebensbereichen hat das Internet der Dinge (IoT) zu einem zentralen Thema in der modernen Technologieentwicklung gemacht. In diesem Kontext hat sich ElixirNerves als eine vielversprechende Plattform f√ºr die Entwicklung von IoT-Anwendungen etabliert. Basierend auf der Programmiersprache Elixir, die auf der robusten Erlang Virtual Machine (BEAM) aufbaut, bietet Nerves eine flexible und leistungsf√§hige Umgebung zur Erstellung von eingebetteten Systemen. Diese Evaluation untersucht die gegenw√§rtigen St√§rken von ElixirNerves und wagt einen Ausblick auf potenzielle Weiterentwicklungen, die die Plattform in Zukunft weiter optimieren k√∂nnten.  St√§rken von ElixirNerves  ElixirNerves zeichnet sich durch mehrere Schl√ºsselfaktoren aus, die es zu einer attraktiven Wahl f√ºr Entwickler von IoT-Anwendungen machen. Erstens erm√∂glicht die funktionale Programmierung von Elixir eine hohe Modularit√§t und Wiederverwendbarkeit von Code, was die Entwicklung komplexer Systeme vereinfacht. Zweitens bietet die Plattform eine hervorragende Unterst√ºtzung f√ºr nebenl√§ufige und verteilte Systeme, was f√ºr IoT-Anwendungen, die oft mit einer Vielzahl von Sensoren und Aktoren kommunizieren m√ºssen, von entscheidender Bedeutung ist. Drittens erm√∂glicht Nerves die einfache Integration von Hardwarekomponenten, wodurch sich die Entwicklungszeit erheblich verk√ºrzt.  Die robuste Fehlerbehandlung und die M√∂glichkeit zur Hot Code Swapping, die Elixir von Erlang erbt, sind weitere bedeutende Vorteile. Diese Eigenschaften machen es m√∂glich, Systeme im laufenden Betrieb zu aktualisieren, ohne dass es zu Ausfallzeiten kommt ‚Äì ein kritisches Merkmal f√ºr viele IoT-Anwendungen, insbesondere in industriellen Umgebungen.  Ausblick auf m√∂gliche Weiterentwicklungen  Trotz der bereits bestehenden St√§rken von ElixirNerves gibt es zahlreiche M√∂glichkeiten f√ºr Weiterentwicklungen, die die Plattform noch leistungsf√§higer machen k√∂nnten. Ein vielversprechender Bereich ist die Verbesserung der Benutzerfreundlichkeit und der Entwicklungswerkzeuge. Die Schaffung intuitiverer Entwicklungsumgebungen und umfassender Dokumentationen k√∂nnte dazu beitragen, die Einstiegsh√ºrde f√ºr neue Entwickler zu senken und die Verbreitung von ElixirNerves in der IoT-Community zu f√∂rdern.  Ein weiterer wichtiger Aspekt ist die Erweiterung der Hardwareunterst√ºtzung. Derzeit unterst√ºtzt Nerves eine Vielzahl von Plattformen, jedoch k√∂nnte die Integration zus√§tzlicher Hardware, insbesondere im Bereich der Sensorik und Aktorik, die Anwendungsvielfalt erheblich erh√∂hen. Die Entwicklung von standardisierten Treibern und Bibliotheken f√ºr g√§ngige IoT-Ger√§te k√∂nnte die Implementierung beschleunigen und die Interoperabilit√§t zwischen verschiedenen Ger√§ten verbessern.  Dar√ºber hinaus k√∂nnte die Implementierung von Machine Learning (ML) und K√ºnstlicher Intelligenz (KI) in die Nerves-Plattform ein bedeutender Fortschritt sein. Durch die M√∂glichkeit, ML-Modelle direkt auf IoT-Ger√§ten auszuf√ºhren, k√∂nnten intelligente Anwendungen entstehen, die in der Lage sind, Daten in Echtzeit zu analysieren und Entscheidungen autonom zu treffen. Dies w√§re besonders in Bereichen wie Smart Home, Industrie 4.;1
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen besch√§ftigt. Dabei wurden sowohl die St√§rken als auch die Herausforderungen dieser Umgebung herausgearbeitet, um ein fundiertes Bild von ihrer Eignung f√ºr die Entwicklung und Implementierung von Internet-of-Things-L√∂sungen zu vermitteln.   In den kommenden Jahren wird die Relevanz von IoT-Anwendungen kontinuierlich zunehmen, insbesondere vor dem Hintergrund fortschreitender Digitalisierungs- und Automatisierungstrends. ElixirNerves bietet durch seine robuste Architektur, die Unterst√ºtzung von Echtzeitkommunikation sowie die einfache Handhabung von Hardwareanbindungen vielversprechende M√∂glichkeiten f√ºr Entwickler. Besonders die Kombination von Elixirs funktionalem Paradigma mit Nerves' Hardwareabstraktionsschicht k√∂nnte zu einer Effizienzsteigerung in der Entwicklung und einem geringeren Ressourcenverbrauch f√ºhren.  Zuk√ºnftige Forschungen k√∂nnten sich auf die Erweiterung der Evaluierung von ElixirNerves konzentrieren, indem spezifische Anwendungsf√§lle und Industrien untersucht werden, wie zum Beispiel Smart Home, Industrie 4.0 oder medizinische Anwendungen. Ein weiterer vielversprechender Forschungsbereich w√§re die Integration von ElixirNerves mit bestehenden Cloud-Infrastrukturen oder Edge-Computing-L√∂sungen, um die Leistungsf√§higkeit von IoT-Anwendungen zu maximieren.  Zus√§tzlich w√§re eine vertiefte Analyse der Sicherheitsaspekte und der Datenverwaltung in ElixirNerves von Bedeutung, da diese Faktoren entscheidend f√ºr die Akzeptanz und den Erfolg von IoT-Anwendungen sind. Momentan sind viele Plattformen noch unzureichend auf die Herausforderungen der Datensicherheit vorbereitet ‚Äì ein Aspekt, dem in zuk√ºnftigen Studien besondere Aufmerksamkeit geschenkt werden sollte.  Schlie√ülich k√∂nnte eine Vergleichsstudie mit anderen g√§ngigen IoT-Plattformen, wie zum Beispiel Arduino oder Raspberry Pi, sowohl f√ºr Forscher als auch f√ºr Entwickler wertvolle Erkenntnisse liefern, um die Vor- und Nachteile von ElixirNerves in einem breiteren Kontext zu verstehen.  Insgesamt zeigt die Evaluation von ElixirNerves ein vielversprechendes Potenzial f√ºr die Entwicklung moderner IoT-Anwendungen, doch stehen wir erst am Anfang einer spannenden Reise, die neue technologischen M√∂glichkeiten und Herausforderungen mit sich bringen wird. Es bleibt zu hoffen, dass die gewonnenen Erkenntnisse sowohl zur Weiterentwicklung der ElixirNerves-Plattform selbst als auch zur Schaffung innovativer IoT-L√∂sungen beitragen k√∂nnen.;1
 Eine      Die alternde Bev√∂lkerung und die damit einhergehende Zunahme von Sturzereignissen stellen eine bedeutende Herausforderung f√ºr das Gesundheitswesen dar. St√ºrze sind eine der h√§ufigsten Ursachen f√ºr Verletzungen bei √§lteren Menschen und k√∂nnen schwerwiegende Folgen f√ºr die Lebensqualit√§t und die Unabh√§ngigkeit der Betroffenen haben. In diesem Kontext gewinnt die In-room Ortung zur Sturzerkennung zunehmend an Bedeutung. Diese Technologie nutzt Bluetooth-basierte Systeme, um Bewegungen innerhalb eines definierten Raumes zu verfolgen und potenzielle Sturzereignisse in Echtzeit zu erkennen. Der vorliegende Text evaluiert ein solches Projekt und beleuchtet dessen methodische Ans√§tze, Ergebnisse und Herausforderungen.   Methodik  Die  basiert auf einer Kombination aus qualitativen und quantitativen Forschungsmethoden. Zun√§chst wurde ein Prototyp eines Bluetooth-basierten Ortungssystems entwickelt, das aus mehreren Sensoren besteht, die in einem Wohnraum installiert wurden. Diese Sensoren erfassen die Bewegungen der Benutzer und √ºbertragen die Daten an ein zentrales System zur Analyse.   Die Datenerfassung erfolgte √ºber einen Zeitraum von sechs Monaten, in dem die Bewegungsmuster von 50 Probanden, die zur Risikogruppe der √§lteren Menschen geh√∂rten, kontinuierlich √ºberwacht wurden. Dabei wurde ein Algorithmus zur Sturzerkennung implementiert, der auf maschinellem Lernen basiert und trainiert wurde, um zwischen normalen Bewegungsmustern und Sturzereignissen zu unterscheiden.   Zus√§tzlich wurden qualitative Interviews mit den Probanden und deren Betreuern durchgef√ºhrt, um die Akzeptanz und Benutzerfreundlichkeit des Systems zu evaluieren.   Ergebnisse  Die Analyse der gesammelten Daten ergab, dass das Bluetooth-basierte Ortungssystem eine hohe Sensitivit√§t (85%) und Spezifit√§t (90%) bei der Erkennung von Sturzereignissen aufwies. Dies deutet darauf hin, dass das System in der Lage ist, die meisten St√ºrze zuverl√§ssig zu identifizieren und gleichzeitig Fehlalarme zu minimieren.   Die qualitative Analyse der Interviews zeigte, dass die Probanden das System √ºberwiegend als hilfreich und beruhigend empfanden. Viele √§u√üerten den Wunsch nach einer kontinuierlichen √úberwachung, um im Falle eines Sturzes schnell Hilfe leisten zu k√∂nnen. Einige Probanden berichteten jedoch auch von anf√§nglichen Bedenken hinsichtlich der Privatsph√§re und der √úberwachung im eigenen Wohnraum, was auf die Notwendigkeit hinweist, Aufkl√§rung und Schulung f√ºr die Nutzer bereitzustellen.   Herausforderungen  Trotz der vielversprechenden Ergebnisse traten im Verlauf des Projekts mehrere Herausforderungen auf. Eine der gr√∂√üten Schwierigkeiten war die Integration des Systems in den Alltag der Probanden. Technische Probleme, wie etwa die Zuverl√§ssigkeit der Bluetooth-Verbindung in unterschiedlichen r√§umlichen Gegebenheiten, f√ºhrten gelegentlich zu Datenverlusten. Dar√ºber hinaus war die Akzeptanz des Systems bei einigen √§lteren Menschen gering, insbesondere bei solchen, die technikaffin waren.  Ein weiterer kritischer Punkt war die Notwendigkeit einer kontinuierlichen Anpassung des Algorithmus, um die Genauigkeit der Sturzerkennung zu;1
Die professionelle Ausrichtung des TYPO3- CMSwird auch in dessen Rechte- und Be- nutzerverwaltungssystem deutlich. Aus der Grundkonfiguration heraus stellt TYPO3 neben Administratoren und Systembetreuern keine vordefinierten Benutzergruppen mit unterschiedlichen Rechten zur Verf√ºgung. Berechtigungen k√∂nnen sowohl an Gruppen als auch direkt an Benutzer vergeben wer- den. Prim√§r werden diesen Zugriffsrechte auf verschiedene Module innerhalb des Admin- Backends zugeteilt: Zus√§tzlich kann die Sichtbarkeit des Seitenbaumes eingeschr√§nkt werden. So kann eine √§hn- liche Berechtigungsstruktur wie in WordPress aufgebaut werden, bei der nur ausgew√§hlte Gruppen Beitr√§ge bearbeiten bzw. einsehen k√∂nnen.  Ein Berechtigungskonzept, wie es im Anwendungsfall gefordert und definiert wurde, l√§sst sich somit also umsetzen. Die Umsetzung ansich bedingt jedoch eine Grundlegende Kennt- niss √ºber das TYPO3-Berechtigungskonzept und kann somit nur mit einem Mehraufwand realisiert werden. Aus diesem Grund wird TYPO3 in Bezug auf dessen Rechteverwaltung mit der Kategorie Gelb eingestuft.;0
Ein weiters Ger√§t, welches der √úberwachung dienen kann, ist die Datenbrille. Im Gegensatz zur Video√ºberwachungskamera ist dies allerdings nicht ihr Haupteinsatzzweck. Bei einer Datenbrille handelt es sich um eine AR Brille mit Kamera. Diese erlaubt √ºber die Gl√§ser Informationen im Sichtfeld des Nutzers anzuzeigen, ohne das Sichtfeld zu bedecken. Die verbaute Kamera erlaubt es Objekte oder Menschen zu erkennen und zu identifizieren. So auch geschehen im Buch. Cynthia kann mit der Datenbrille auf ihrer Heimfahrt viele Details fremder Menschen sehen. Dies funktioniert dank Gesichtserkennung und einer Datenbank die Profile von Nutzern beinhaltet. Dabei werden nicht nur Name und Adresse angezeigt, sondern auch Dinge wie vergangene Unf√§lle. Die Datenbrille kann f√ºr mehr als nur Gesichtserkennung und Informationsanzeige genutzt werden. Sie hat auch Spracherkennung und Lautsprecher, welche √ºber den Geh√∂rknochen durch Vibrationen T√∂ne erzeugen. Google probierte fr√ºh eine Datenbrille auf den Markt zu bringen. Die Google Glass im Jahr 2014 (Bastian 2020). Die Google Glass polarisierte damals und erzeugte gro√üe Diskussionen zum Thema Da- tenbrillen und Datenschutz. Dabei ist die Brille in der Lage E-Mails, Navigationsdaten und weiter Informationen im Sichtfeld einzublenden. Dabei k√∂nnen mit der integrierten Kamera Videos und Fotos aus der Sicht des Tr√§gers gemacht werden. Allerdings verur- sachte genau diese integrierte Kamera Bedenken bei vielen. Schlie√ülich kann damit die Brille zum perfekten √úberwachungsger√§t gemacht werden. Sie kann damit den Tr√§ger selber √ºberwachen, aber auch jede unbeteiligte Person die in das Sichtfeld des Tr√§gers ger√§t. Wenn nun genug Datenbrillentr√§ger in der Umgebung sind, kann praktisch jeder in dieser Umgebung √ºberwacht werden. Das geht mit der Gesichtserkennung, aber durch die Kamera ist auch eine Ortserkennung m√∂glich. Wenn die Kamera auch noch mit dem Smartphone verbunden ist und ins Internet kann, kann diese Ortung noch viel genauer sein. Au√üerdem enthalten die Brille eine Kamera bei der man nicht wei√ü, ob diese wirklich noch filmt oder nicht. Somit kann man sich schon wie ein Verd√§chtiger vorkommen, wenn man vielen Leuten mit Datenbrillen begegnet, da klar ist, dass man auf jeden Fall gefilmt wird.;0
"Die demografische Entwicklung hin zu einer √§lter werdenden Gesellschaft bringt zahlreiche Herausforderungen mit sich, insbesondere im Bereich der Gesundheitsversorgung und der Sicherheit √§lterer Menschen. St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen und Krankenhausaufenthalte bei Senioren dar. In diesem Kontext gewinnt die Technologie der In-Room Ortung zunehmend an Bedeutung. Diese Arbeit evaluiert ein Projekt zur Sturzerkennung unter Verwendung von Bluetooth-Technologie, das darauf abzielt, die Sicherheit √§lterer Menschen in ihrem h√§uslichen Umfeld zu erh√∂hen.   Technologischer Hintergrund  Die In-Room Ortung basiert auf der Nutzung von Bluetooth Low Energy (BLE), einer energiesparenden Variante der Bluetooth-Technologie, die sich besonders f√ºr Anwendungen im Innenraum eignet. Durch die Platzierung von BLE-Beacons in verschiedenen R√§umen k√∂nnen Bewegungen und Positionen von tragbaren Ger√§ten, wie Smartphones oder speziellen Armb√§ndern, pr√§zise erfasst werden. Diese Daten erm√∂glichen eine Echtzeitanalyse der Bewegungsmuster und k√∂nnen Abweichungen, die auf einen Sturz hindeuten, identifizieren.   Methodik  Die  umfasste mehrere SchritteZun√§chst wurde ein Prototyp des Sturzerkennungssystems entwickelt und in einer kontrollierten Umgebung getestet. Die Testgruppe bestand aus 30 Freiwilligen, die in einem simulierten Wohnumfeld lebten. Die Beacons wurden strategisch in den R√§umen platziert, um eine umfassende Abdeckung zu gew√§hrleisten. Die gesammelten Daten wurden mithilfe von Algorithmen zur Mustererkennung analysiert, um St√ºrze von normalen Bewegungen zu unterscheiden.   Ergebnisse  Die Ergebnisse der Evaluierung zeigten eine hohe Genauigkeit bei der Erkennung von St√ºrzen. In 92 % der F√§lle konnte das System einen Sturz korrekt identifizieren. Falsch-positiv-Ergebnisse traten in etwa 5 % der F√§lle auf, was auf die Notwendigkeit einer weiteren Verfeinerung der Algorithmen hinweist. Die Benutzerfreundlichkeit des Systems wurde ebenfalls positiv bewertet; 85 % der Teilnehmer gaben an, dass sie sich sicherer f√ºhlten, wenn sie das Ger√§t trugen.   Diskussion  Die Implementierung von In-Room Ortung zur Sturzerkennung mittels Bluetooth bietet vielversprechende Ans√§tze zur Verbesserung der Sicherheit √§lterer Menschen. Die hohe Erkennungsrate und die positive R√ºckmeldung der Benutzer legen nahe, dass solche Systeme in der Praxis anwendbar sind. Dennoch sind einige Herausforderungen zu beachten. Die Notwendigkeit einer stabilen Netzwerkverbindung und die potenzielle Abh√§ngigkeit von der Batterielebensdauer der tragbaren Ger√§te k√∂nnten die langfristige Nutzung einschr√§nken. Zudem muss die Privatsph√§re der Nutzer gew√§hrleistet werden, da die kontinuierliche Ortung sensible Daten erfasst.   Fazit  Die  zur In-Room Ortung und Sturzerkennung mit Bluetooth-Technologie zeigt, dass innovative L√∂sungen zur Sturzpr√§vention in der h√§uslichen Umgebung realisierbar sind. Zuk√ºnftige Forschungsarbeiten sollten sich auf die Optimierung der Algorithmen, die Verbesserung der Benutzerakzeptanz sowie die Integration von Datenschutzma√ünahmen konzentrieren";1
" Kapitel 2: Technische Grundlagen zum Testen von MQTT-basierten L√∂sungen   2.1 Einf√ºhrung in MQTT  Das MQTT (Message Queuing Telemetry Transport) Protokoll ist ein leichtgewichtiges Publish/Subscribe-Messaging-Protokoll, das urspr√ºnglich von Andy Stanford-Clark und Arlen Neyer in den sp√§ten 1990er Jahren entwickelt wurde. Es wird insbesondere f√ºr den Einsatz in Umgebungen mit restriktiver Bandbreite sowie bei den Errichtungen von Internet-of-Things (IoT)-Architekturen von Bedeutung. Die f√ºr MQTT typischen Merkmale, wie geringe Overhead-Kosten und automatische Verbindungswiederherstellung, machen das Protokoll ideal f√ºr Anwendungen, bei denen energieeffiziente und zuverl√§ssige Kommunikationsl√∂sungen erforderlich sind.  In einer MQTT-basierten Architektur gibt es zwei Hauptkomponenten: Publisher und Subscriber. Publisher sind die Ger√§te oder Anwendungen, die Daten oder Nachrichten an spezifizierte Themen (Topics) senden, w√§hrend Subscriber die Entit√§ten sind, die an diesen Themen ""abh√∂ren"" und die √ºbertragenen Nachrichten empfangen. Ein Broker fungiert als Mittelsmann, der die Nachrichten basierend auf den definierten Themen weiterleitet. Diese Architektur erm√∂glicht eine hohe Flexibilit√§t und Skalierbarkeit, zwei zentrale Aspekte beim Testen von MQTT-basierten L√∂sungen.   2.2 Technische Merkmale von MQTT  MQTT bietet fleire technische Eigenschaften, die f√ºr das Testen der L√∂sungen entscheidend sind. –óun√§chst ist der Einsatz von Quality of Service (QoS) Mechanismen hervorzuheben. MQTT unterst√ºtzt drei QoS-Stufen:  1. QoS 0 ‚Äì ‚ÄûAt Most Once"": Die Nachricht wird einmal gesendet, ohne Best√§tigung des Empf√§ngers. Dies ist die kosteng√ºnstigste Art der √úbertragung und verlangt die geringsten Ressourcen, birgt jedoch Risiko f√ºr Nachrichtenverlust.  2. QoS 1 ‚Äì ‚ÄûAt Least Once"": In diesem Modus garantiert der Publisher, dass die Nachricht mindestens einmal zugestellt wird. Dies bedeutet, dass Mechanismen zur Wiederholung und Best√§tigung eingesetzt werden, was zu Duplikaten f√ºhren kann.  3. QoS 2 ‚Äì ‚ÄûExactly Once"": Dies ist die aufwendigste QoS-Bewertung, bei der das Protokoll sicherstellt, dass Nachrichten exakt einmal empfangen werden, ohne Duplikate zu generieren.  F√ºr die Durchf√ºhrung von Tests sind die QoS-Stufen essenziell, da sie neue Fehlerquellen einf√ºhren, die w√§hrend der Validierungsphase identifiziert werden m√ºssen. Diese Mechanismen entscheiden entscheidend dar√ºber, in welchem Ma√üe Implementierungen Fehlermeldungen angemessen verarbeiten und die stabilen Status synchronisieren k√∂nnen.   2.3 Testing-Ans√§tze f√ºr MQTT  Das Testen von MQTT-basierten L√∂sungen erfordert eine multidisziplin√§re Herangehensweise. In der Praxis finden verschiedene Testmethoden Anwendung, um die Effizienz, Sicherheit und Benutzerfreundlichkeit von MQTT-Implementierungen sicherzustellen.   2.3.1 Funktionales Testen  Beim funktionalen Testen wird √ºberpr√ºft, ob die MQTT-Anwendungen den spezifizierten Anforderungen gerecht werden. Hiervon sind essentielle Fungierenden wie das Verbindungsmanagement, Nachrichtenaustausch zwischen den Benutzern und Sicherheit betrifft. Beisp";1
Konzept zur Umsetzung von Eine vergleichende Analyse und Handlungsanleitung f√ºr Entwicklerinstitutionen    In der dynamischen Landschaft der Softwareentwicklung gewinnen moderne Programmier- und Plattformtechnologien zunehmend an Bedeutung. Insbesondere die Diskussion √ºber die Programmiersprachen Java und Kotlin ist in den letzten Jahren enorm angestiegen. Beide Sprachen nehmen eine zentrale Rolle in der Entwicklung von Server- und Client-Anwendungen ein, wobei Kotlin oft als modernere Alternative zu Java hervorgehoben wird. Dieses Dokument bietet ein wissenschaftlich fundiertes Konzept zur vergleichenden Analyse von Java und Kotlin, das den Rahmen f√ºr eine strategische Umsetzung in der Softwareentwicklung aufzeigt.  Hintergrund  Java, seit seiner Einf√ºhrung in den 1990er Jahren, hat sich als Universalsprache f√ºr die Softwareentwicklung etabliert. Es wurde eine riesige Gemeinschaft und eine umfangreiche Bibliothek (Java Standard Edition, JEE) erstellt, die viele Entwickler zur Verwendung anregen. Kotlin, das 2011 von JetBrains entworfen wurde, bietet jedoch innovative Features, die eleganten Code und Produktivit√§t f√∂rdern, sowie nahtlose Interoperabilit√§t mit bestehenden Java-Anwendungen.  Die Ziele dieses Konzepts sind es, auf Unterschiede und Gemeinsamkeiten darauf zu betten und dabei wesentliche Kriterien der Sprachen vergleichend hervorzubringen. Dies findet vor dem Hintergrund der Zunahme an komplexen Softwarel√∂sungen und der Nachfrage nach effizient laufenden Anwendungen statt.  Vergleich der Sprachen  1. Syntax und Ausdruckskraft     Der erste zentrale Punkt im Konzept ist die Syntax beider Sprachen. Kotlin √ºbersichtliche und pr√§gnante Schreibweise gl√ºckt nicht nur einfache Aufgaben schneller implementieren, sondern reduziert ebenfalls den erforderlichen Boilerplate-Code. Im Vergleich dazu kann Java an dieser Stelle komplex und zeitaufwendig wirken. Empirische Studien zeigen, dass die Effizienzgegebenheiten der Entwicklung mit Kotlin hierbei signifikant verbessert sind.  2. Typensystem und Null-Sicherheit     Ein markantes Feature von Kotlin ist das erweiterte Typensystem, das strikte Null-Typen einf√ºhrt. Im Vergleich f√ºhrt dies zu einer signifikanten Reduktion von Laufzeitfehlern, w√§hrend Java immer wieder eine risikobehaftete NullPointerException erzeugt. Bei der Betrachtung von Langzeitprojekten zeigt sich, dass die Fehleranf√§lligkeit drastisch sinkt, wenn Kotlin verwendet wird.  3. Tooling und Integrationsm√∂glichkeiten     Die Unterst√ºtzung durch Entwicklungsumgebungen spielt eine essentielle Rolle identifizierbare Schw√§chen schnell zu umgehen. W√§hrend Java ein umfassendes SDK pr√§sentiert, erlauben einsetzbare Build-Tools wie Gradle und Maven auch f√ºr Kotlin eine funktionale Tiefe. Unz√§hlige Frameworks etablieren sich sowohl f√ºr Java als auch f√ºr Kotlin. Hierbei tragen Innovationen wie Coroutine Unterst√ºtzung in Kotlin zu einer signifikanten Leistungssteigerung bei asynchroner Programmierung bei.  Strategische Implementierung  Zur Ausbildung eines tadellosen √úbergangs von Java zu Kotlin, w√§re eine dreiteilige Starts-Strategie im deutschen Entwicklermarkt anzuraten.  1. Evaluation bestehender Codebasen   Erste Schritte sollten die vollst√§ndige Bestandsaufnahme bestehender Java-Projekte beinhalten. Identifizierung der Stellen, die am gleichen;1
Ausblick  In der vorliegenden Arbeit wurde der Vergleich zwischen Progressiven Webanwendungen (PWA) und nativen Apps am Beispiel einer Journaling-App detailliert untersucht. Die Ergebnisse zeigen, dass beide Ans√§tze ihre eigenen St√§rken und Schw√§chen aufweisen, die je nach Anwendungsfall unterschiedlich gewichtet werden k√∂nnen. W√§hrend native Apps durch ihre tiefere Integration in das Betriebssystem und die M√∂glichkeit zur Nutzung spezifischer Hardwarefunktionen bestechen, bieten PWAs eine h√∂here Flexibilit√§t und einfacheren Zugang, insbesondere f√ºr Nutzer, die plattform√ºbergreifend agieren m√∂chten.  Ein zentraler Aspekt, der in zuk√ºnftigen Forschungen vertieft werden sollte, ist die Nutzererfahrung (UX) und deren Einfluss auf die Akzeptanz der jeweiligen Technologie. Es w√§re sinnvoll, empirische Studien durchzuf√ºhren, die das Nutzerverhalten und die Zufriedenheit bei der Verwendung von Journaling-Apps in beiden Formaten untersuchen. Hierbei k√∂nnten qualitative Methoden, wie Interviews oder Fokusgruppen, wertvolle Einblicke in die Pr√§ferenzen und Bed√ºrfnisse der Anwender liefern.  Ein weiterer vielversprechender Forschungsbereich k√∂nnte die Untersuchung der Performance und Ladezeiten beider App-Typen sein, insbesondere in unterschiedlichen Netzwerkumgebungen. Da die Nutzung von Journaling-Apps oft in Momenten der Reflexion und Kreativit√§t erfolgt, k√∂nnte die Schnelligkeit und Zuverl√§ssigkeit der App entscheidend f√ºr das Nutzererlebnis sein.  Zudem sollte die Rolle von Sicherheitsaspekten und Datenschutz in der Diskussion √ºber PWAs und native Apps nicht vernachl√§ssigt werden. Angesichts der zunehmenden Sensibilit√§t der Nutzer f√ºr ihre pers√∂nlichen Daten ist es von Bedeutung, wie jede Plattform mit diesen Herausforderungen umgeht und welche Ma√ünahmen ergriffen werden, um das Vertrauen der Nutzer zu gewinnen und zu erhalten.  Abschlie√üend l√§sst sich festhalten, dass der Vergleich von PWAs und nativen Apps nicht nur f√ºr die Entwicklung von Journaling-Apps, sondern auch f√ºr viele andere Anwendungsbereiche von gro√üer Relevanz ist. Die fortschreitende Technologieentwicklung und die sich wandelnden Bed√ºrfnisse der Nutzer werden den Diskurs um diese beiden Ans√§tze weiterhin pr√§gen und neue Perspektiven er√∂ffnen. Zuk√ºnftige Studien k√∂nnten daher nicht nur den technologischen, sondern auch den sozialen und kulturellen Kontext der App-Nutzung beleuchten, um ein umfassenderes Bild der digitalen Interaktion in unserer zunehmend vernetzten Welt zu zeichnen.;1
- Null safety   1965 entwarf Tony Hoare eine objektorientierte Programmiersprache namens  ALGOL, in der er die M√∂glichkeit der Nullreferenz hinzu f√ºgte , weil sie einfach zu  implementieren war. Im Nachhinein bezeichnet er das al s seinen  milliardenschweren Fehler , denn Nullreferenzen verursachen viel e Probleme .   Der bekannteste wird wohl die  Null-Pointer  Exception  (NPE)  sein. Die von Kotlin  eingef√ºhrte Null safety  ist allseits beliebt  und das nicht umsonst . In Java ist Null ein  Referenztyp und sein Wert i st der einzige Referenzwert, der sich auf kein Objekt  bezieht. Daher gibt es keine Darstellung von Null im Speicher. Der bin√§re Wert  einer referenztypisierten Variablen, deren Wert Null ist, ist  tats√§chlich  einfach Null.  Ausgehend davon, dass sich hinter Null kein Objekt verbirgt, ist es auch nicht  m√∂glich, eine Methode aufzurufen, denn dem Compiler ist zwar de r Typ eines jeden  Objekts  bekannt , er kann aber erst zur Laufzeit wissen, was referenziert wird. Bei  dem Versuch √ºber die Null-Referenz auf die Eigenschaft eines Objekts zuzugreifen,   wird dann schlussendlich eine NPE  ausgel√∂st.  Auch das √Ñndern des F elds eines  Nullobjekts und die Behandlung der L√§nge von Null wie ein Array  kann eine NPE  verursachen . Durch die Sicherheitsma√ünahmen von Kotlin treten  NPEs  seltener auf  oder werden sogar vollst√§ndig eliminiert. Zu den F√§llen , die nicht behoben werden  k√∂nne n z√§hlen z. B. Probleme, die durch die Verbindung von Kotlin zu einer  Sprache ohne  solide  Null-safety entstehen .       Man kann sich das folgenderma√üen vorstellen:   Bei der Verwendung einer Java-Methode, die einen String als R√ºckgabetyp  deklariert , ist es  in manchen F√§llen  schwer das in Kotlin zu verwirklichen . Es gibt  verschiedene M√∂glichkeiten , das zu l√∂sen :   - Falls  es mit @ Nullable  annotiert ist,  scheint der R√ºckgabewert  nullable  zu sein  und er wird als String interpretiert .   - Falls  es mit @Not Null annotiert ist, vertrau t man der  Annotation und  interpretiert ihn wieder als  String .   - So weit so gut, aber was passiert, wenn der  R√ºckgabetyp nicht annotiert ist?   Im ersten Moment scheint es logisch zu sein den R√ºckgabewert als nullable  zu  behandeln , was in diesem Beispiel auch legitim w√§re.48 Das eigentliche Problem  entsteht dann, wenn man versucht einen  generische n Typ aus Java  zu √ºbersetzen .  Bei dem folgenden Beispiel ist das der Fall:   Eine Java-API gibt eine List<Products> zur√ºck  und das ohne Annotation oder  weitere Kommentare . Wenn Kotlin standardm√§√üig  die Typen als nullable   deklarieren w√ºrde und man aber w√ºsste , dass diese Liste und diese Produkte   notNull sind, m√ºsste  nicht nur die Richtigkeit der gesamten Liste best√§tigt, sondern  auch alle Nullen gefiltert werden.  49 Aus diesem Grund wird ein Typ, der aus Java  stammt und  eine unbekannte Null-Zul√§ssigkeit hat, n icht standardm√§√üig als nullable   behandelt, sondern als ein  spezieller Typ in Kotlin , der sich platform -type nennt .  Platform -types sind Typen, die  aus einer anderen Sprache stammen und eine  unbekannte Null-Zul√§ssigkeit aufweisen. Sie werden mit einem Ausrufezeichen   ‚Äö!‚Äò nach de m Typ Namen  annotiert  z. B. ‚ÄöString!‚Äò .50 Ein weiteres Problem entsteht  dabei trotzdem, denn platform -types sind nicht denotierbar  und k√∂nnen daher nicht  explizit angegeben werden. Wenn einer Kotlin -Variablen oder -Eigenschaft ein  platform -type zugewiesen wird, kann er demnach also abgeleitet, aber nicht explizit  festgelegt werden.   Stattdessen kann nur der  erwartete Typ aus gew√§hlt werden also  nullable  oder  notNull.51 Eine weitere M√∂glichkeit f√ºr den Zugriff auf eine Eigenschaft einer  nullable -Variable ist die Verwendung eines sicheren Aufrufoperators ‚Äö?.‚Äò . F√ºr NPE  Freunde gibt es eine dritte M√∂glichkeit  mit Not-Null-Assertion -Operatoren ‚Äö!!‚Äò, die  jeden Wert in einen notNull-Typ konver tieren und eine exception ausl√∂sen, wenn  der Wert doch Null ist. Wenn eine NPE also erw√ºnscht ist, kann diese auch explizit  ausgel√∂st werden.;0
"Spreadingfaktor
Wenn ein Chirp eine sehr kleinen Zeitspanne zum Versenden ben√∂tigt, kann mehr In-
formation in k√ºrzerer Zeit √ºbertragen werden, jedoch ist der erfolgreiche Empfang des
Signals und das anschlie√üende Aufschl√ºsseln der Nachricht schwieriger. F√ºr dieses Problem
gibt es bei LoRa sogenannte Spreadingfaktoren (auf Englisch: Spreading factors). Diese
steuern die Chirp-Rate und damit die Geschwindigkeit der Daten√ºbertragung. Es gibt bei
der LoRa-Modulation insgesamt sechs verschiedene Spreadingfaktoren von SF7 bis SF12.
Ein niedriger Spreadingfaktore verringern, wie in Tabelle 2.1 zu sehen, die Reichweite
der √úbertragungen, da sie die Verarbeitungsleistung verringern und die Bitrate erh√∂hen.
Insgesamt wird √ºber die verschiedenen Spreadingfaktoren die Datenrate, die Time-on-Air,
die Batterielebensdauer und die Empf√§ngerempÔ¨Åndlichkeit beeinÔ¨Çusst. 
Spreading
FactorBitrate ReichweiteTime-on-Air
(11 byte payload)
SF10 980 bps 8 km 371 ms
SF9 1760 bps 6 km 185 ms
SF8 3125 bps 4 km 103 ms
SF7 5470 bps 2 km 61 ms
Tabelle 2.1: Beispiele der Leistungsunterschiede durch verschiedene Spreadingfaktoren 
LoRa-Paketaufbau
Der Aufbau eines LoRa-Pckets sieht dabei wie in Abbildung 2.7 aus. Wie abgebildet gibt
es zwei verschiedene Modi, einmal mit impliziertem und einmal mit expliziertem Header.
Abbildung 2.7: Aufbau eines LoRa-Pakets 
Der explizite Header-Modus enth√§lt einen kurzen Header, der Informationen √ºber die
L√§nge der Nutzlast, die Kodierungsrate und die Verwendung eines CRCim Paket enth√§lt.";0
Ein Ausblick auf m√∂gliche Weiterentwicklungen  In der heutigen digitalen √Ñra sind Content-Management-Systeme (CMS) essenzielle Werkzeuge f√ºr die Erstellung, Verwaltung und Ver√∂ffentlichung von Inhalten auf Webseiten. Die Vielfalt an verf√ºgbaren CMS-Plattformen, wie WordPress, Joomla, Drupal und Headless CMS-L√∂sungen, bietet unterschiedliche Ans√§tze zur Handhabung von Inhalten. Diese Systeme haben sich √ºber die Jahre hinweg kontinuierlich weiterentwickelt, um den sich wandelnden Anforderungen der Benutzer und den technologischen Fortschritten gerecht zu werden. Eine Gegen√ºberstellung dieser Systeme erlaubt nicht nur ein besseres Verst√§ndnis ihrer jeweiligen St√§rken und Schw√§chen, sondern er√∂ffnet auch Perspektiven f√ºr zuk√ºnftige Entwicklungen.  WordPress, das weltweit am weitesten verbreitete CMS, zeichnet sich durch seine Benutzerfreundlichkeit und eine umfangreiche Plugin-Architektur aus. Es erm√∂glicht auch Nutzern ohne technische Vorkenntnisse, ansprechende Webseiten zu erstellen. Zuk√ºnftige Entwicklungen k√∂nnten sich auf die Integration von K√ºnstlicher Intelligenz (KI) konzentrieren, um personalisierte Inhalte automatisch zu generieren oder SEO-Optimierungen in Echtzeit vorzuschlagen. Zudem k√∂nnte die Einf√ºhrung von Blockchain-Technologie zur Sicherstellung der Urheberschaft und zur Verbesserung der Datensicherheit in WordPress eine interessante Richtung darstellen.  Im Gegensatz dazu bietet Drupal eine h√∂here Flexibilit√§t und Skalierbarkeit, was es zur bevorzugten Wahl f√ºr komplexere Webseiten und Anwendungen macht. Die umfangreichen M√∂glichkeiten zur Anpassung und die robuste Benutzerverwaltung machen Drupal besonders attraktiv f√ºr gro√üe Unternehmen und Institutionen. Zuk√ºnftige Entwicklungen in Drupal k√∂nnten sich auf die Verbesserung der Benutzeroberfl√§che konzentrieren, um die Lernkurve f√ºr neue Benutzer zu senken, sowie auf die verst√§rkte Integration von API-first-Ans√§tzen, die es erm√∂glichen, Inhalte √ºber verschiedene Plattformen hinweg zu verbreiten.  Joomla liegt im Mittelfeld und vereint einige der besten Eigenschaften von WordPress und Drupal. Es bietet eine benutzerfreundliche Oberfl√§che, w√§hrend es gleichzeitig eine flexible Struktur f√ºr die Entwicklung komplexer Webseiten bereitstellt. Eine m√∂gliche Weiterentwicklung k√∂nnte die Implementierung von fortschrittlichen Analysewerkzeugen sein, die es Benutzern erm√∂glichen, das Nutzerverhalten besser zu verstehen und Inhalte gezielt anzupassen.  Ein weiterer Trend, der die Zukunft von CMS beeinflussen wird, sind Headless CMS-L√∂sungen wie Contentful oder Strapi. Diese Systeme trennen das Backend von der Pr√§sentationsebene und erm√∂glichen so eine flexiblere Bereitstellung von Inhalten √ºber verschiedene Kan√§le hinweg. Die Weiterentwicklung von Headless CMS k√∂nnte durch die verst√§rkte Integration von KI-gest√ºtzten Content-Management-Funktionen und durch die Schaffung von standardisierten APIs, die eine nahtlose Interoperabilit√§t zwischen verschiedenen Systemen erm√∂glichen, vorangetrieben werden.  Zusammenfassend l√§sst sich feststellen, dass die  nicht nur einen Einblick in ihre aktuellen Funktionen und Einsatzm√∂glichkeiten bietet, sondern auch wichtige Hinweise auf zuk√ºnftige Entwicklungen liefert. Die Integration von KI, Blockchain, API-first-Architekturen und fortschrittlichen Analysewerkzeugen wird voraussichtlich die Art und Weise, wie Inhalte erstellt und verwaltet werden, revolutionieren. Angesichts der dynamischen Natur der digitalen Landschaft;1
"Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung  Die digitale √úberwachung hat in den letzten Jahrzehnten zunehmend an Bedeutung gewonnen. In einer Welt, in der nahezu jeder Aspekt des Lebens mit Technologie verwoben ist, entstehen dadurch sowohl vielversprechende M√∂glichkeiten als auch erhebliche Gefahren. Das Projekt ‚ÄûZero‚Äú befasst sich mit der Er√∂rterung dieser beiden Seiten der digitalen √úberwachung und pr√§sentiert ein umfassendes Fazit √ºber ihre Implikationen f√ºr Gesellschaft, Individuum und Staat.  Die M√∂glichkeiten der digitalen √úberwachung sind weitreichend. Sie erm√∂glichen eine umfassende Datensammlung, die zur Verbesserung von Sicherheitsma√ünahmen und zur Bek√§mpfung von Kriminalit√§t genutzt werden kann. Durch die Analyse von Bewegungsdaten in urbanen R√§umen k√∂nnen beispielsweise Polizeibeh√∂rden Verbrechenshotspots identifizieren und dadurch gezielt Ressourcen einsetzen. Zudem k√∂nnen digitale √úberwachungssysteme in der Gesundheitsversorgung eingesetzt werden, um Epidemien fr√ºhzeitig zu erkennen und die Wirksamkeit medizinischer Interventionen zu √ºberwachen. Diese Art der Datenanalyse steckt voller Potenzial, das weit √ºber die reine √úberwachung hinausgeht und in vielerlei Hinsicht das Leben der Menschen verbessern kann.  Dennoch sind die Gefahren, die mit dieser digitalen √úberwachung einhergehen, nicht zu untersch√§tzen. Ein zentrales Anliegen ist der Verlust der Privatsph√§re. In einer Gesellschaft, in der B√ºrger rund um die Uhr √ºberwacht werden, erodiert das Vertrauen in staatliche Institutionen und zwischen Individuen. Missbrauch von gesammelten Daten kann zu Diskriminierung und sozialen Spannungen f√ºhren, da pers√∂nliche Informationen leicht in falsche H√§nde geraten k√∂nnen. Zudem besteht die Gefahr der Normalisierung von √úberwachung, die das Bewusstsein f√ºr individuelle Freiheitsrechte und Privatsph√§re nachhaltig sch√§digt. Die oft einseitige Legitimation solcher Ma√ünahmen ‚Äì meist im Namen der Sicherheit ‚Äì legt die Frage nahe, inwieweit die Gesellschaft bereit ist, fundamentale Rechte f√ºr vermeintliche Sicherheit zu opfern.  Das  ‚ÄûZero‚Äú schl√§gt eine Br√ºcke zwischen diesen beiden Extrempunkten. Eine verantwortungsvolle Herangehensweise an digitale √úberwachung ist unerl√§sslich; sie muss durch Transparenz, gesetzliche Rahmenbedingungen und ethische Standards gekennzeichnet sein. Die Gesellschaft steht vor der Herausforderung, das Potenzial digitaler Technologien zu nutzen, ohne die individuellen Freiheiten unn√∂tig einzuschr√§nken. Ein moderner Ansatz k√∂nnte die Implementierung von ‚ÄûPrivacy by Design‚Äú beinhalten, wo Datenschutz von Anfang an in den Entwicklungsprozess neuer Technologien integriert wird.  In Anbetracht dieser √úberlegungen ist es entscheidend, einen √∂ffentlichen Diskurs √ºber die Grenzen und M√∂glichkeiten digitaler √úberwachung zu f√ºhren. Nur durch eine informierte und kritische Auseinandersetzung k√∂nnen die Potenziale gehoben und die Gefahren minimiert werden. Um das Gleichgewicht zwischen Sicherheit und Freiheit zu wahren, bedarf es einer aktiven Rolle der Zivilgesellschaft, um Regierungen und Unternehmen zur Rechenschaft zu ziehen. Es liegt in der Verantwortung jedes Einzelnen, sich f√ºr eine Gesellschaft einzusetzen, die sowohl innovative Technologien nutzt als auch die Grundprinzipien der Menschenw√ºrde und des Datenschutzes respektiert.";1
"Ein Cyclic Redundancy Check (CRC) wird zur Erkennung von Fehlern in digitalen Daten
verwendet.
Beim implizite Header-Modus fehlt der Header mit den Informationen √ºber die Nutzlast,
die Kodierungsrate und ob ein CRCvorhanden ist. Diese Informationen m√ºssen, um das
Fehlen zu kompensieren, manuell beim Sender und Empf√§nger festgelegt und konÔ¨Åguriert
werden. Das Weglassen des Headers verk√ºrzt so die √úbertragungszeit, da die einzelnen
Pakete kleiner sind.
Der Teil der Preamble und des Payloads wird bei beiden Modi verwendet. Die Preamble
wird dazu verwendet den Beginn des Pakets durch den Empf√§nger zu erkennen zu geben.
Der Payload-Teil ist ein Feld mit einer variabler L√§nge, das die eigentlichen Daten enth√§lt.
Ein optionaler Payload-CRC kann angeh√§ngt werden, um den Inhalt vom Payload auf
Fehler zu pr√ºfen. 
2.3 LoRaWAN
LoRaWAN ist, wie in Abbildung 2.4 zu sehen, ein oÔ¨Äenes Netzwerkprotokoll der zweiten
OSI-Schicht das auf der LoRa-Modulationaufbaut. In derSoftwareschicht wird deÔ¨Åniert wie
Ger√§te die LoRa-Hardware nutzen und beispielsweise wann sie ihre Daten senden und wie
die Nachrichten formatiert werden m√ºssen. Das LoRaWAN-Protokoll, welches unter ande-
rem eine sichere bidirektionale Kommunikation, Mobilit√§t und Lokalisierungsdienste bietet,
wird von der LoRa Alliance entwickelt und gepÔ¨Çegt. Die erste LoRaWAN-SpeziÔ¨Åkation
wurde im Januar 2015 ver√∂Ô¨Äentlicht. Zum Zeitpunkt der Erstellung des Dokuments sind
die 1.0.4 (der 1.0 Serie) and 1.1 (der 1.1 Serie) die aktuellsten, verf√ºgbaren Versionen der
SpeziÔ¨Åkation.   
LoRaWAN-Architektur
Einen √úberblick √ºber die Architektur von LoRaWAN gibt die Abbildung 2.8. Jeder
Teilbereich der Architektur erf√ºllt dabei seine eigene Aufgabe. Die verschiedenen End-
ger√§te kommunizieren mit den verf√ºgbaren Gateways in ihrer eigenen Reichweite. Jedes
Gateway ist dabei selbst mit dem Netzwerkserver √ºber das Internet verbunden. LoRaWAN-
Netzwerke verwenden ein ALOHA-basiertes Protokoll. Dieses erm√∂glicht das Endger√§te
nicht mit bestimmten Gateways verbunden sein m√ºssen. Die zu sendenden Informationen
werden als Nachrichten an alle verf√ºgbaren Gateways in Reichweite verschickt. All diese
Nachrichten werden vom Netzwerkserver empfangen und falls dieser mehrere Exemplare
der gleichen Nachricht erh√§lt, wird eine einzige Instanz der Nachricht behalten und die
anderen verworfen. Dieser Vorgang wir auch als Nachrichten-Deduplizierung bezeichnet.";0
Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things NetworkEin Fazit  Die pr√§zise Erfassung der Bodenfeuchtigkeit spielt eine entscheidende Rolle in der Landwirtschaft, Forstwirtschaft und im Wassermanagement. In den letzten Jahren hat sich die Technologie des Long Range Wide Area Network (LoRaWAN) als besonders vielversprechend erwiesen, um agrarische Daten effizient zu erfassen und zu √ºbertragen. Durch die Nutzung des The Things Network (TTN), einer offenen und dezentralisierten Netzwerkarchitektur, k√∂nnen Sensoren zur √úberwachung der Bodenfeuchtigkeit in gro√üem Ma√üstab implementiert werden.   Im Rahmen unseres Projekts zur Entwicklung eines solchen Systems wurden verschiedene Ans√§tze zur Sensorintegration, Datenerfassung und -√ºbertragung untersucht. Die Sensoren, die zur Messung der Bodenfeuchtigkeit eingesetzt wurden, arbeiten nach dem Prinzip, die elektrische Leitf√§higkeit des Bodens zu messen. Diese Methode erwies sich als pr√§zise und kosteneffektiv. Die gesammelten Daten wurden √ºber LoRaWAN an das TTN gesendet, wo sie in Echtzeit analysiert und visualisiert wurden.  Ein zentrales Ergebnis unserer Arbeit war die Feststellung, dass die Nutzung von LoRaWAN in Kombination mit TTN erhebliche Vorteile in Bezug auf Reichweite und Energieeffizienz bietet. W√§hrend herk√∂mmliche WLAN- oder Mobilfunkl√∂sungen oft durch Reichweitenprobleme eingeschr√§nkt sind, erm√∂glicht LoRaWAN die √úbertragung von Daten √ºber mehrere Kilometer. Dies ist besonders wichtig in l√§ndlichen Gebieten, wo die Infrastruktur f√ºr mobile Netzwerke oft unterentwickelt ist. Zudem war der Stromverbrauch der Sensoren aufgrund der energiesparenden Sendemethoden von LoRaWAN √§u√üerst gering, was l√§ngere Lebensdauern der Batterien und damit geringere Wartungskosten zur Folge hatte.  Ein weiterer bemerkenswerter Aspekt war die Benutzerfreundlichkeit des TTN. Da es sich um eine offene Plattform handelt, erm√∂glicht sie Landwirten und Forschern, in Kombination mit IoT-Technologien eigene Anwendungen zu entwickeln, ohne dass tiefgehende technische Kenntnisse erforderlich sind. Die M√∂glichkeit, die gesammelten Daten √ºber Dashboards zu visualisieren und zu analysieren, half dabei, pr√§zisere Entscheidungen zu treffen, die sich positiv auf die Ernteertr√§ge und den ressourcenschonenden Einsatz von Wasser auswirkten.  Zusammenfassend l√§sst sich festhalten, dass die Implementierung von Bodenfeuchtesensoren √ºber LoRaWAN in Verbindung mit TTN eine kosteneffiziente, skalierbare und benutzerfreundliche L√∂sung darstellt, um die √úberwachung der Bodenfeuchtigkeit zu optimieren. Dies er√∂ffnet neue Perspektiven f√ºr eine nachhaltige Landwirtschaft und kann helfen, Ressourcen gezielter einzusetzen. Die Ergebnisse unseres Projekts belegen, dass durch den Einsatz dieser modernen Technologien nicht nur der Landwirte Gewinn, sondern auch √∂kologische Zielsetzungen im Hinblick auf Ressourcenschonung und nachhaltige Entwicklung unterst√ºtzt werden k√∂nnen. Zuk√ºnftige Forschungen sollten sich auf die Integration zus√§tzlicher Umweltdaten konzentrieren, um eine noch umfassendere Datenbasis f√ºr Entscheidungsprozesse in der Landwirtschaft zu schaffen.;1
 Kapitel 4: Entwicklung einer eigenen L√∂sung zur Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15   4.1 Einleitung  Die fortschreitende Technologisierung im Bereich der Fahrzeugsteuerung er√∂ffnet neue Perspektiven f√ºr die Entwicklung autonomer Systeme. Insbesondere die Implementierung von Fahrzeugfernsteuerungen, die in der Lage sind, Kollisionen zu vermeiden, stellt eine Herausforderung dar, die sowohl technisches Know-how als auch innovative Ans√§tze erfordert. In diesem Kapitel wird die Entwicklung einer eigenen L√∂sung zur Fahrzeugfernsteuerung mit Kollisionsvermeidung vorgestellt, die auf dem Standard IEEE 802.15 basiert. Der Fokus liegt auf der Konzeption, der technischen Umsetzung sowie der Evaluierung der entwickelten L√∂sung.   4.2 Grundlagen und Anforderungen  Bevor mit der Entwicklung der Fahrzeugfernsteuerung begonnen werden kann, ist es wichtig, die grundlegenden Anforderungen zu definieren. Die Steuerung soll nicht nur eine pr√§zise Kontrolle des Fahrzeugs erm√∂glichen, sondern auch in der Lage sein, potenzielle Kollisionen fr√ºhzeitig zu erkennen und zu vermeiden. Hierzu sind verschiedene Sensoren und Kommunikationsmodule notwendig, die eine Echtzeit-Daten√ºbertragung zwischen dem Fahrzeug und der Steuerungseinheit gew√§hrleisten.  Die Wahl des Standards IEEE 802.15 ist entscheidend, da dieser f√ºr die drahtlose Kommunikation in pers√∂nlichen Netzwerken konzipiert wurde und eine hohe Flexibilit√§t sowie eine geringe Energieaufnahme bietet. Diese Eigenschaften sind besonders wichtig f√ºr mobile Anwendungen wie die Fahrzeugfernsteuerung.   4.3 Systemarchitektur  Die Systemarchitektur der entwickelten L√∂sung besteht aus mehreren Komponenten, die nahtlos miteinander interagieren. Zun√§chst wird ein Mikrocontroller als zentrale Steuereinheit eingesetzt, der die Daten von den Sensoren verarbeitet und die Steuerbefehle an das Fahrzeug sendet. Erg√§nzend dazu werden verschiedene Sensoren, wie Ultraschall- und Lidar-Sensoren, integriert, um die Umgebung des Fahrzeugs zu scannen und Hindernisse zu erkennen.  Die Kommunikation zwischen dem Mikrocontroller und den Sensoren erfolgt √ºber einen IEEE 802.15-kompatiblen Transceiver, der eine zuverl√§ssige Daten√ºbertragung sicherstellt. Dar√ºber hinaus wird eine mobile Anwendung entwickelt, die es dem Benutzer erm√∂glicht, das Fahrzeug intuitiv zu steuern und Statusinformationen in Echtzeit abzurufen.   4.4 Implementierung der Kollisionsvermeidung  Ein zentrales Element der Fahrzeugfernsteuerung ist die Implementierung eines Kollisionsvermeidungssystems. Hierzu wird ein Algorithmus entwickelt, der auf den von den Sensoren erfassten Daten basiert. Der Algorithmus analysiert kontinuierlich die Umgebung des Fahrzeugs und identifiziert potenzielle Kollisionen.  Sobald ein Hindernis erkannt wird, berechnet der Algorithmus geeignete Ma√ünahmen, um eine Kollision zu vermeiden. Dies kann durch eine Anpassung der Geschwindigkeit, eine Richtungs√§nderung oder eine sofortige Notbremsung erfolgen. Um die Reaktionszeit zu minimieren, wird eine Priorisierung der Sensorinformationen implementiert, sodass die kritischsten Daten zuerst verarbeitet werden.   4.5 Test und Evaluierung  Nach der Implementierung der Fahrzeugfernsteuerung wird ein umfassendes Testprogramm durchgef√ºhrt, um die Funktionalit√§t und Zuverl√§ssigkeit des;1
Die zyklomatische Komplexit√§t ist eine der wenigen Metriken, bei der bereits bei der Einf√ºhrung ein  absoluter Grenzwert definiert wurde. Thomas McCabes Threshold bezog sich auf Messungen auf  Funktionsebene und legt einem H√∂chstwert von zehn  fest. Dieser Wert wird nicht nur von den  eingesetzten Tools  CCCC, Embold und QA-MISRA  best√§tigt, sondern auch in der Literatur durchg√§ngig  verwendet wie beispielweise bei Alan und Catal    . Anders verh√§lt es  sich mit der zyklomatischen Komplexit√§t einer gesamten Klasse. Hier erlaubt CCCC auffallende hohe  Komplexit√§tswerte, w√§hrend Embold nur den f√ºnffachen Wert der Funktionenebene vorschl√§gt, was  in Hinblick auf eine geeignete Anzahl von Methoden und damit einhergehende Gr√∂√üe von Klassen  sinnvoller erscheint.   √Ñhnliche Werte geben die Werkzeuge Embold und QA-MISRA  in Hinblick auf die maximale  Verschachtelungstiefe an , die nur auf Funktionenebene gemessen werden kann.  Auch hier sind die  durch QA-MISRA  definierten Regeln mit einer Verschachtelung von nicht mehr al s vier Ebenen etwas  strenger als die des Tools Embold mit f√ºnf erlaubten Ebenen.      F√ºr die Metriken RFC sowie WMC wurden bereits die in Raed Shatnawis Studie ermittelten  Grenzwerte eingef√ºhrt , die bei 40 f√ºr RFC und 20 f√ºr WMC liegen . Sowohl das Tool Embold, das die  Metrik RFC misst und eine Obergrenze von 50 heran zieht, als auch CCCC, das einen H√∂chstwert von  30 f√ºr die Metrik WMC annimmt, bewegen sich mit ihren Angaben im Bereich von Shatnawis   Werte n.    Insgesamt l√§sst sich eine hohe √úbereinstimmung zwischen den einzelnen Tools feststellen, was auch  von den weiteren Metriken wie DIT und CBO best√§tigt wird. Aus diesem Grund werden die  definierten Grenzwerte als zuverl√§ssig und f√ºr die folgende  Interpretation relevant betrachtet .  Im Gegensatz zu den anderen genannten Softwareprodukten schl√§gt das Halstead Metrics Tool  keine  Grenzwerte f√ºr die gemessenen Metriken vor. Aus diesem Grund wurde  hier die Suche nach  geeigneten Studien und Vorgaben zu Grenzwerten der Halstead -Metriken fokussiert.  Bei der  angef√ºhrten Quelle handelt es sich um eine empirische Fallstudie, die sich um die Auswertung von  Softwaremessdaten dreht. Alan und Catal geben Obergrenzen f√ºr die Anzahl an Opera toren und  Operanden an , die in untenstehender Tabelle blau  markiert sind.  Anhand dieser Werte lassen sich  alle weiteren Thresholds f√ºr die einzelnen Halstead -Metriken errechnen.     Die aus den Werten von Alan und Catal abgeleitete  Angabe f√ºr die Volumen -Obergrenze wird auch   durch das von der Firma Verifysoft bereitgestellte Tool best√§tigt. Diese s unterscheidet zwischen  Messungen auf Funktions - und Komponentenebene. ‚ÄûDas Volumen einer Fun ktion sollte mindestens  20 und h√∂chstens 1000 betragen.  Wenn das Volumen den Wert von 1000 √ºbersteigt, macht die  Funktion wahrscheinlich zu viele Dinge. Das Volumen einer Datei sollte zwischen 100 und h√∂chstens  8000 liegen.‚Äú;0
Grundlagenteil: In-room Ortung zur Sturzerkennung mit Bluetooth  1. Einf√ºhrung in die Sturzerkennung  Sturzereignisse sind ein bedeutendes gesundheitliches Risiko, insbesondere f√ºr √§ltere Menschen und Personen mit bestimmten medizinischen Bedingungen. Sie k√∂nnen zu schweren Verletzungen, eingeschr√§nkter Mobilit√§t und h√∂herem Pflegebedarf f√ºhren. Die effiziente Erkennung von St√ºrzen ist daher ein zentrales Anliegen in der Altenpflege und der Gesundheits√ºberwachung. Technologische Innovationen bieten heute zahlreiche Ans√§tze zur Sturzerkennung, wobei In-room Ortungssysteme eine vielversprechende M√∂glichkeit darstellen.  2. Technologien zur Sturzerkennung  Es gibt verschiedene Technologien und Methoden zur Sturzerkennung, darunter:  - Wearable Devices: Tragbare Ger√§te, die Sensoren zur Bewegungserfassung und -analyse verwenden. Diese Ger√§te k√∂nnen Fallereignisse direkt erkennen und entsprechend reagieren.    - Video√ºberwachungssysteme: Kamerabasierte Systeme k√∂nnen St√ºrze visuell erfassen und mithilfe von Algorithmen analysieren. Diese Methodik wirft jedoch Datenschutzbedenken auf.  - In-room Ortungssysteme: Dies sind Systeme, die die Position und Bewegung von Personen in einem Raum erfassen, um Sturzereignisse zu erkennen. Bluetooth-basierte Systeme geh√∂ren zu dieser Kategorie und nutzen die Eigenschaften von Bluetooth-Technologie zur pr√§zisen Ortung.  3. Grundlagen der Bluetooth-Technologie  Bluetooth ist eine drahtlose Kommunikationstechnologie, die f√ºr den Austausch von Daten √ºber kurze Entfernungen entwickelt wurde. Sie operiert im 2,4 GHz ISM-Band und erm√∂glicht die Kommunikation zwischen Ger√§ten wie Smartphones, Wearables und anderen IoT-Ger√§ten. Die wichtigsten Merkmale der Bluetooth-Technologie, die zur In-room Ortung genutzt werden, sind:  - Niedriger Energieverbrauch: Insbesondere Bluetooth Low Energy (BLE) wurde entwickelt, um den Energieverbrauch zu minimieren und eine l√§ngere Batterielebensdauer in tragbaren Ger√§ten zu erm√∂glichen.  - Reichweite und Pr√§zision: Die Reichweite von Bluetooth betr√§gt typischerweise bis zu 100 Meter, jedoch variiert die Pr√§zision der Ortung je nach Umgebung und Art der Implementierung.  - Verf√ºgbarkeit und Interoperabilit√§t: Bluetooth ist in vielen modernen Ger√§ten integriert, was eine breite Anwendbarkeit und einfache Integration in bestehende Systeme erm√∂glicht.  4. In-room Ortung mit Bluetooth  In-room Ortungssysteme, die auf Bluetooth-Technologie basieren, nutzen verschiedene Methoden zur Bestimmung der Position und Bewegung von Personen:  - Beacons: Kleine, tragbare Sender, die zu bestimmten Orten platziert werden und in der Lage sind, Signale an empfangende Ger√§te zu senden. Durch die St√§rke des empfangenen Bluetooth-Signals kann die Entfernung zu einem Beacon gesch√§tzt werden, wodurch die Position innerhalb eines definierten Raumes ermittelt werden kann.  - Triangulation: Durch die Platzierung mehrerer Beacons im Raum ist es m√∂glich, die Position einer Person durch die Analyse der Signalst√§rke von verschiedenen Beacons zu triangulieren.  - Datenanalyse: Die gesammelten Positionsdaten k√∂nnen mittels Algorithmen analysiert werden, um typische Bewegungsmuster zu identifizieren und ungew√∂hnliche Aktivit√§ten, wie beispielsweise einen Sturz, zu;1
Matabuena u.a.  haben eine Lernplattform entwickelt, welche das Verhalten eines Stromnetzes mit Generatoren und Verbrauchern simuliert. Die Software wurde in einer Laborveranstaltung f√ºr Student*innen eines Master-Studiengangs verwendet. Messdaten werden durch physische Licht- und Temperatursensoren generiert . Zur Visualisierung wurde das Programm LabVIEW verwendet, welches f√ºr den akademischen Einsatz kostenpflichtig ist  und somit den m√∂glichen Einsatz der MQTT-Simulation in Veranstaltungen einschr√§nkt. Daher sollte im L√∂sungsansatz eine freie Open Source- Bibliothek zur Visualisierung verwendet werden. Adi und Kitagawa  verwenden das cloud-basierte Graphical User Interface (GUI) M5Stack, das die Programmiersprachen Python und Blocklyunterst√ºtzt. Letzteres ist eine visuelle, blockbasierte Sprache, welche f√ºr Programmieranf√§nger*innen geeignet ist. Die Zielgruppe der L√∂sung sind Sch√ºler*innen, welche noch wenig Erfahrung in der Software- programmierung besitzen. Als Sensoren werden physische Bewegungsmelder verwendet. Generell ist ein webbasiertes Integrated Development Environment (IDE) vorteil- haft, da keine Software installiert werden muss und die Browser-Applikation unabh√§ngig vom genutzten Betriebssystem l√§uft. Die Verwendung einer visuellen, blockbasierten Spra- che zur Programmierung erm√∂glicht einen einfachen Einstieg. Es kann aber f√ºr gro√üe Programme un√ºbersichtlich werden, da es im Vergleich zu √ºblichen, textbasierten Sprachen wenig M√∂glichkeiten f√ºr die Strukturierung und Platzierung der Bl√∂cke gibt. Beispiele sind hierbei das Auslagern von Methoden in andere Dateien oder die Verwendung von Polymorphie zur Verringerung von Code-Duplikation. Au√üerdem kann die blockbasierte Sprache von Student*innen als unterfordernd empfunden werden. Zus√§tzlich dazu wird, wie bei Matabuena u.a. , Hardware f√ºr das Szenario ben√∂tigt. Die Verwendung von Python in der webbasierten IDEw√§re hingegen eine gute Implementierungsm√∂glichkeit f√ºr den L√∂sungsansatz dieser Arbeit.;0
In der vorliegenden Untersuchung wurde die Programmierung mit Java und Kotlin umfassend analysiert, um die St√§rken und Schw√§chen beider Sprachen zu beleuchten und ihre jeweilige Eignung f√ºr moderne Softwareentwicklungsprojekte zu bewerten. W√§hrend Java als etablierte Programmiersprache seit Jahrzehnten in der Industrie Verwendung findet und eine breite Community sowie umfangreiche Bibliotheken bietet, zeigt Kotlin, als moderne Alternative, zahlreiche Vorteile, die insbesondere die Entwicklung von Android-Anwendungen betreffen.  Die Analyse hat ergeben, dass Kotlin durch seine pr√§gnante Syntax und seine Funktionalit√§ten, wie etwa Null-Sicherheit und Erweiterungsfunktionen, die Produktivit√§t von Entwicklern signifikant steigern kann. Dies f√ºhrt nicht nur zu weniger Fehlern, sondern auch zu einer schnelleren Umsetzung von Projekten. Zudem ist Kotlin vollst√§ndig interoperabel mit Java, was einen schrittweisen √úbergang f√ºr bestehende Projekte erm√∂glicht und die Integration beider Sprachen in einem gemeinsamen √ñkosystem erleichtert.  Dennoch bleibt Java aufgrund seiner Stabilit√§t, umfangreichen Dokumentation und des gro√üen √ñkosystems nach wie vor eine unverzichtbare Sprache in vielen Bereichen der Softwareentwicklung. Besonders in Unternehmen mit gro√üen, langj√§hrigen Codebasen und einer starken Abh√§ngigkeit von Java-Technologien ist der Umstieg auf Kotlin nicht immer praktikabel.  Zusammenfassend l√§sst sich sagen, dass die Wahl zwischen Java und Kotlin stark von den spezifischen Anforderungen des Projekts und den Pr√§ferenzen des Entwicklerteams abh√§ngt. W√§hrend Kotlin in vielen F√§llen als die zukunftsweisende Sprache gilt, die den Bed√ºrfnissen der modernen Softwareentwicklung gerecht wird, bleibt Java ein bew√§hrtes Fundament, auf dem viele erfolgreiche Anwendungen basieren. Eine hybride Herangehensweise, die die St√§rken beider Sprachen kombiniert, k√∂nnte in vielen Szenarien die optimale L√∂sung darstellen und den Weg f√ºr eine flexible und innovative Softwareentwicklung ebnen.;1
Koh√§sionsmetriken   Eine Untergruppe der Komplexit√§tsmetriken, die mit dem Konzept der Kopplung verbunden ist,  bilden die Metriken der Koh√§sion. W√§hrend eine lose Kopplung erstrebenswert ist, sollte die  Koh√§sion m√∂glichst hoch sein, was sich positiv auf Wiederverwendbarkeit, √Ñnderbarkeit und somit   die Wartungseigenschaften auswirkt.  Diese positiven Effekte treten unter anderem dadurch auf, dass  koh√§sive Methoden Datenkapselung unterst√ºtzen.  Eine geringe Koh√§sion innerhalb der Klassen eines  Softwaresystems wei st auf eine mangelhafte Softwarearchitektur hi n. Komponenten mit geringer  Koh√§sion sollten auf eine m√∂gliche Umstrukturierung, die eine Aufteilung in mehrere Unterklassen  beinhalten kann,  gepr√ºft werden.    Die bekannteste Metrik, die zur Messung von Koh√§sion eingef√ºhrt wurde, nennt sich ‚ÄûLack of  Cohesion in Methods‚Äú (LCOM). Sie wurde von Chid amber und Kemerer entwickelt und in deren  Metrik -Suite ver√∂ffentlicht. Im Laufe der Jahre wurde sie vielfach √ºberarbeitet und abgewandelt,  sodass verschiedene Versionen dieser Kennzahl bestehen.   Urspr√ºnglich wurde die Metrik 1991 als Anzahl der disjunkten Teilmengen I i eingef√ºhrt, wobei jede  Teilmenge I i die Instanzvariablen enth√§lt, die von der Methode M i verwendet werden. Es werden  dabei alle Methoden M 1, ‚Ä¶, M n der betrachteten Klasse einbezogen.     Bereits drei Jahre sp√§ter publizierten Chidamber und Kemerer eine aktualisierte Definition ihrer  Metrik LCOM. Diese betrachtet alle in einer Klasse vorkommenden Methoden paarweise und  unterscheidet dabei in koh√§siv e und nicht -koh√§sive Paare. Verwendet ein Methoden -Paar  mindestens ein gemeinsames Attribut, wird es der Menge Q zugeordnet. Andernfalls ist es Teil der  nicht -koh√§siven Menge P . Die Berechnung erfolgt anhand der Differenz der beiden Mengen, wobei  keine neg ativen Werte erreicht werden k√∂nnen . F√ºr die Berechnung ergibt sich folglich die  Formel   ùêøùê∂ùëÇùëÄ ={|ùëÉ|‚àí|ùëÑ|,ùëñùëì |ùëÉ|‚àí|ùëÑ|‚â•0 0 die Werte auf einer Absolutskala liefert. Dabei sind m√∂glichst  kleine Messergebnisse erstrebenswert.;0
Ausblick  Die vorliegende Arbeit zur Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis des IEEE 802.15 Standards hat nicht nur die technischen Herausforderungen und L√∂sungen beleuchtet, sondern auch die weitreichenden Implikationen, die solche Systeme f√ºr die Zukunft der Mobilit√§t mit sich bringen. Die erfolgreiche Implementierung einer solchen Technologie k√∂nnte den Weg f√ºr eine neue √Ñra des autonomen Fahrens ebnen, in der Sicherheit und Effizienz in der Fahrzeugkommunikation eine zentrale Rolle spielen.  In den kommenden Jahren wird erwartet, dass die Integration von drahtlosen Kommunikationsstandards wie IEEE 802.15 in die Fahrzeugtechnik weiter voranschreitet. Dies k√∂nnte nicht nur die Interaktion zwischen Fahrzeugen und ihrer Umgebung verbessern, sondern auch die Entwicklung intelligenter Verkehrssysteme f√∂rdern, die in der Lage sind, Echtzeitdaten zu verarbeiten und darauf zu reagieren. Die Fortschritte in der Sensorik und der Datenverarbeitung werden es erm√∂glichen, komplexe Szenarien der Kollisionsvermeidung noch effektiver zu bew√§ltigen, was letztlich zu einer signifikanten Reduktion von Verkehrsunf√§llen f√ºhren k√∂nnte.  Ein weiterer wichtiger Aspekt ist die Interoperabilit√§t mit bestehenden Technologien und Standards. Die Herausforderung, verschiedene Systeme und Protokolle miteinander zu verbinden, wird entscheidend sein f√ºr die Akzeptanz und den Erfolg von Fahrzeugfernsteuerungen in der breiten √ñffentlichkeit. Zuk√ºnftige Forschungsarbeiten sollten sich daher auch auf die Entwicklung von Schnittstellen und Protokollen konzentrieren, die eine nahtlose Integration in bestehende Infrastrukturen erm√∂glichen.  Dar√ºber hinaus wird die ethische Dimension der Fahrzeugfernsteuerung und der damit verbundenen Technologien immer relevanter. Fragen der Verantwortung, der Datensicherheit und des Datenschutzes m√ºssen in zuk√ºnftige Entwicklungen einflie√üen, um das Vertrauen der Nutzer in autonome Systeme zu st√§rken. Die gesellschaftliche Akzeptanz wird ma√ügeblich davon abh√§ngen, wie transparent und sicher diese Technologien gestaltet werden.  Zusammenfassend l√§sst sich sagen, dass die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 nicht nur eine technische Herausforderung darstellt, sondern auch eine Chance, die Mobilit√§t der Zukunft sicherer und intelligenter zu gestalten. Die vorliegende Arbeit hat einen Grundstein gelegt, auf dem zuk√ºnftige Forschungen und Entwicklungen aufbauen k√∂nnen. In den kommenden Jahren wird es entscheidend sein, die Erkenntnisse dieser Arbeit weiter zu vertiefen und in praktische Anwendungen zu √ºberf√ºhren, um das volle Potenzial dieser Technologie auszusch√∂pfen und eine nachhaltige Mobilit√§t zu f√∂rdern.;1
Der Arduino schickt die jeweilige Bezeichnung des Sensorwerts und den Sensorwert selbst an denMQTT-Broker (beispielsweise ‚ÄûTemperatur,23.14‚Äú). Bei dem Erhalt der Nachrich- ten wird in der Android-Applikation der Zeitstempel berechnet und zusammen mit der Bezeichnung und deren Wert in der Datenbank abgespeichert. Die n√§chste Herausforderung bestand darin, die Werte zu speichern, auch wenn die Anwendung im Hintergrund l√§uft oder geschlossen wird. Das wurde durch die Erstellung eines Broadcast-Receivers und eines Services gel√∂st (f√ºr die Erkl√§rung der einzelnen Begriffe siehe Unterabschnitt 2.2.1). In dem Listing 4.2 ist die Klasse des Broadcast-Receivers zu sehen. Diese Klasse startet den Service, wenn die Applikation im Hintergrund l√§uft oder geschlossen wird. In dem Listing 4.3 ist die Funktion f√ºr das Starten der einzelnen Funktionen, nachdem die Benutzer*innen die Applikation geschlossen oder im Hintergrund geschickt haben, abgebildet. Hier werden drei Funktionen aufgerufen: F√ºr die Verbindung (inklusive Abon- nieren) mit dem MQTT-Broker, f√ºr die Speicherung der Nachrichten in der Datenbank und f√ºr den Alarm (siehe Abschnitt 4.4). Mit diesen Schritten und Funktionen ‚Äûl√§uft‚Äú die Anwendung wie gewohnt auch weiter, wenn sie geschlossen oder im Hintergrund ausgef√ºhrt wird.;0
Die Skalierbarkeit und Erweiterung von bestehenden Systemen kann durch Elixir und Nerves unkompliziert realisiert werden, was an der prototypischen Implementierung an den folgenden Aspekten gezeigt werden kann: die Installation eines Sensors in einem bestehenden System ist mit oder ohne eines beste- henden Hardwaretreibers fehlertolerant m√∂glich die Installation von weiteren IoT-Nodes in einem bestehenden System, ist durch den Upload von Firmware, auf unterschiedliche Mikrocontroller m√∂glich Die Erlang-OTP-Architektur bringt f√ºr die Fehlertoleranz eines IoT-Systems einen er- heblichen Mehrwert. Mit den entsprechenden Modulen, wie beispielsweise GenServer und Supervisor, k√∂nnen die Vorteile dieser Architektur in Elixir voll ausgesch√∂pft werden. Die Behandlung von nicht-deterministischen Bugs durch den in OTP dargelegten Ansatz ‚Äûlet it crash‚Äú, bringen in der Theorie und Praxis eine vielversprechende Methode zur Entwicklung und Bereitstellung von hochverf√ºgbaren Systemen (15 ,12). F√ºr die Wartbarkeit eines Systems bringen Nerves und Elixir einige Vorteile mit sich. Die Software der prototypischen Implementierung kann beispielsweise problemlos durch SSH aktualisiert werden. Das System ist au√üerdem durch die interaktive Nerves-Runtime erreichbar. Status von s√§mtlichen Prozessen k√∂nnen abgerufen und untersucht werden. Au√üerdem bietet Elixir mit unterschiedlichen Datentypen, wie beispielsweise Binarystrings, eine transparente Schnittstelle zur Auswertung von Daten oder Kontrollregistern der Hardware √ºber den I2C-Bus. Dar√ºber hinaus liefert Elixir auch in alternativen Bereichen von IoT praktikable Ergebnisse. Beispielsweise erzielte Elixir bei der Bereitstellung eines Micro-Services in Form eines Swarm Brokers vielversprechende Ergebnisse . Zusammenfassend eignen sich Elixir und Nerves aufgrund der dargelegten Aspekte hervorragend f√ºr die Bereitstellung von IoT-Anwendungen;0
Die grundlegende Funktion setzt sich aus den folgenden drei Komponenten zusammen: ‚Ä¢Navigationsgraph Der Navigationsgraph ist eine zentrale Ressource, die alle Informationen beinhaltet, die f√ºr die Navigation relevant sind. Hierzu geh√∂ren auch die individuell gestalteten Bereiche der App, die ebenfalls h√§uÔ¨Åg als Dimensionen bezeichnet werden. Zus√§tzlich zu den Dimensionen werden hier auch Pfade vermerkt, die f√ºr einen Nutzenden innerhalb der App zug√§nglich sind . Diese Pfade werden auch als Routenbezeichnet. Eine Route kann somit als String deÔ¨Åniert werden, welcher den Pfad zu einem Composable beschreibt. Sie kann in etwa mit einem Deeplink gleichgesetzt werden . ‚Ä¢NavHost Der NavHost ist ein urspr√ºnglich leerer Container, der den Inhalt der einzelnen Dimensionen des Navigationsgraphen anzeigt . ‚Ä¢NavController Beim NavController handelt es sich um ein Objekt, welches die Navigation innerhalb des NavHost verwaltet . Es stellt somit eine zentrale APIf√ºr den Navigation Component dar und ordnet den Wechsel des Inhaltes im NavHost an, wenn sich ein Nutzender durch die App bewegt. Der NavController ist stateful und trackt ebenfalls den Backstack der Composables, die die Seite der App darstellen und auch den Status der jeweiligen Seite an sich . Der NavController kann √ºber Funktion rememberNavController() angelegt werden. Es hat sich als Vorteil erwiesen, dies in einer Komponente zu implementieren, die in der Hierarchie am oberen Ende lokalisiert werden kann. Somit ist gew√§hrleistet, dass alle Composables, die den NavController referenzieren m√∂chten, dazu auch bef√§higt sind . Dies folgt dem klassischen Prinzip des State hoistings , welches in Kapitel 3.2.5 dargelegt wird.;0
Vergleich von Progressiven Webanwendungen und nativen Apps am Beispiel einer Journaling-AppEine   Die digitale Transformation hat die Art und Weise, wie Benutzer mit Softwareanwendungen interagieren, grundlegend ver√§ndert. In diesem Kontext gewinnt die Entwicklung von Journaling-Apps an Bedeutung, da sie Nutzern nicht nur einen Raum zum Festhalten ihrer Gedanken und Erlebnisse bieten, sondern auch Funktionen zur Selbstreflexion und emotionalen Gesundheit integrieren. Bei der Entwicklung solcher Anwendungen stehen Entwickler oft vor der Wahl zwischen progressiven Webanwendungen (PWAs) und nativen Apps. Dieser Text widmet sich der Evaluierung eines Projekts, das die Vor- und Nachteile dieser beiden Ans√§tze am Beispiel einer Journaling-App vergleicht.  1. Definition und Grundlagen  Progressive Webanwendungen sind webbasierte Anwendungen, die die Vorteile moderner Webtechnologien nutzen. Sie bieten eine Benutzererfahrung, die mit der von nativen Apps vergleichbar ist, und sind √ºber einen Webbrowser zug√§nglich. Native Apps hingegen sind f√ºr spezifische Plattformen (z.B. iOS oder Android) entwickelte Anwendungen, die direkt aus App-Stores heruntergeladen werden m√ºssen.  2. Projektbeschreibung und Methodologie  F√ºr das Projekt wurde eine Journaling-App entwickelt, die sowohl als PWA als auch als native App implementiert wurde. Ziel war es, die Benutzererfahrung, Performance, Entwicklungskosten und Wartungsaufwand, sowie die Verbreitung und Zug√§nglichkeit zu evaluieren. Die Evaluierung umfasste mehrere Phasen *Designphase*Hier wurden die Benutzeroberfl√§che und das Nutzererlebnis f√ºr beide Versionen entworfen. Es wurde Wert auf eine konsistente Benutzererfahrung gelegt, unabh√§ngig davon, ob die App als PWA oder native App genutzt wurde.  *Entwicklungsphase*In dieser Phase wurde die Journaling-App sowohl als PWA (unter Verwendung von HTML5, CSS3 und JavaScript) als auch als native App (unter Verwendung von Swift f√ºr iOS und Kotlin f√ºr Android) entwickelt.  *Testphase*Um Unterschiede in der Benutzererfahrung zu identifizieren, wurden beide Versionen der App von einer Gruppe von Testnutzern evaluiert. Die Nutzer wurden gebeten, eine Reihe von Aufgaben in beiden App-Versionen auszuf√ºhren, wobei Kriterien wie Ladezeit, Reaktionsgeschwindigkeit, Nutzerfreundlichkeit und allgemeine Zufriedenheit bewertet wurden.  3. Evaluierungskriterien und Ergebnisse  Die Evaluierung basierte auf mehreren Schl√ºsselkriterien * BenutzerfreundlichkeitBeide Versionen erhielten positive R√ºckmeldungen, wobei die native App f√ºr ihre intuitive Navigation gelobt wurde. Die PWA bot jedoch den Vorteil der sofortigen Nutzung ohne Download, was von vielen Nutzern als benutzerfreundlicher empfunden wurde.  * PerformanceDie native App √ºbertraf die PWA in Bezug auf die Ladegeschwindigkeit und die reaktive Leistung, insbesondere bei grafisch intensiven Aufgaben wie dem Hinzuf√ºgen von Bildern. Dennoch zeigte die PWA durch den Einsatz von Caching-Techniken versprechende Leistungen, die dem Nutzer in vielen Szenarien ebenfalls eine fl√ºssige Nutzung erm√∂glichten.  * EntwicklungskostenDie Entwicklung der PWA erwies sich als kosteneffizienter, da ein einziger Codebase f√ºr alle Webplattformen genutzt werden konnte, w√§hrend native Apps separate Entwicklungen f√ºr jede Plattform erforderten. Dies f√ºhrte zu h√∂heren initialen Investitionen und l√§ngeren Entwicklungszeiten f√ºr die native App.  * WartungsaufwandIn Bezug auf Updates und Wartung erwies sich die PWA als vorteilhafter. √Ñnderungen konnten zentral vorgenommen werden, sodass alle Nutzer sofort von den Neuerungen profitierten. Bei der nativen App mussten hingegen Aktualisierungen f√ºr jede Plattform individuell durchgef√ºhrt werden, was einen erh√∂hten Aufwand darstellt.  * Verbreitung und Zug√§nglichkeitDie PWA erm√∂glicht eine einfache Zug√§nglichkeit √ºber alle modernen Browser und kann auf jedem Ger√§t genutzt werden, was die Verbreitung erleichtert. Native Apps gewinnen an Popularit√§t durch die Sichtbarkeit in App-Stores, was jedoch mit der Notwendigkeit verbunden ist, Nutzer zur Installation zu bewegen.  4. Diskussion und Fazit  Die  zeigt, dass sowohl PWAs als auch native Apps ihre eigenen St√§rken und Schw√§chen aufweisen. Die Wahl zwischen diesen beiden Ans√§tzen sollte von den spezifischen Anforderungen des Projekts abh√§ngen. PWAs bieten eine kosteneffiziente L√∂sung mit breiter Zug√§nglichkeit, w√§hrend native Apps eine √ºberlegene Performance und Benutzererfahrung gew√§hrleisten. F√ºr die Entwicklung einer Journaling-App k√∂nnte die Entscheidung letztendlich durch Faktoren wie die Zielgruppe, Budgetrestriktionen und geplante Funktionalit√§ten bestimmt werden.   Abschlie√üend l√§sst sich festhalten, dass die Wahl zwischen PWA und nativer App ein strategischer Entscheidungsprozess ist, der alle Aspekte der Benutzerinteraktion und technischen Umsetzungen ber√ºcksichtigt. Zuk√ºnftige Forschungen sollten die sich entwickelnden Technologien und Nutzerpr√§ferenzen im Auge behalten, um eine fundierte Entscheidungsgrundlage f√ºr Entwickler zu schaffen.;1
Die DeviceBase -Klasse besitzt den MQTT-Client, ID-Texte f√ºr die Platzierung des Ger√§ts innerhalb des Smart Homes und Callback-Methoden f√ºr benutzerdefinierte Interaktio- nen.Als MQTT-Bibliothek wird die Client-Library paho-mqtt derEclipse Foundation verwendet. Diese kann betriebssystem√ºbergreifend verwendet werden und unterst√ºtzt unter anderem Python-Versionen ab 3.9. F√ºr die Implementierung des MQTT-Clients wurde der Guide von Cope  verwendet. Wenn die Verbindungsinformationen f√ºr den MQTT-Broker separat an die Ger√§te √ºber- geben werden, werden daf√ºr mindestens drei Parameter gebraucht. Wenn f√ºr zus√§tzliche Einstellungen wie der Raum- oder Ger√§te-ID hinzugef√ºgt werden, wird die Methode aufgrund der Menge an Parametern un√ºbersichtlich. Daher werden die Verbindungsinfor- mationen im Konstruktor mithilfe eines dict√ºbergeben. Es wurde keine Klasse verwendet, da f√ºr das Konfigurationsobjekt keine Methoden ben√∂tigt werden. Eine Beispielkonfigura- tion ist in Listing 4.1 zu sehen. Wenn das Ger√§t mit .run()gestartet wird, setzt es die Verbindungseinstellungen aus dem Konfigurationsobjekt im MQTT-Client. Anschlie√üend wird versucht, eine Verbindung zum Broker mit mqtt_client.loop_start() herzustellen.;0
Ausblick  In der vorliegenden Arbeit wurde ein Content Management System (CMS) entwickelt, das speziell auf die Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper ausgerichtet ist. Die Ergebnisse zeigen, dass die Integration von benutzerfreundlichen Schnittstellen und flexiblen Modulen es erm√∂glicht, die Interaktivit√§t und Funktionalit√§t des Roboters erheblich zu erweitern. Zuk√ºnftige Forschungsarbeiten k√∂nnten sich weiter mit der Optimierung der Benutzerfreundlichkeit des CMS befassen, um die Erstellung von Anwendungen ohne tiefgehende Programmierkenntnisse weiter zu erleichtern.  Ein kl√§rendes Verst√§ndnis der Nutzerbed√ºrfnisse k√∂nnte durch ausf√ºhrliche Nutzerstudien gewonnen werden, die dazu beitragen, die Interface-Designs und Funktionsumfang des CMS weiter zu verfeinern. Des Weiteren k√∂nnte die Integration von Machine Learning und K√ºnstlicher Intelligenz in das CMS eine personalisierte Nutzererfahrung erm√∂glichen und die Interaktivit√§t der Apps erh√∂hen.   Ein weiterer m√∂glicher Forschungspfad w√§re die Implementierung von Echtzeitanalysen, die es Benutzern erlauben, das Nutzerverhalten in Echtzeit zu verfolgen und aufgrund dieser Daten Verbesserungen an ihren Anwendungen vorzunehmen. Dar√ºber hinaus k√∂nnte eine Erweiterung des CMS f√ºr andere Robotermodelle in Betracht gezogen werden, was die Flexibilit√§t und Anwendbarkeit des Systems erh√∂hen w√ºrde.  Das CY-Colloquium wird in diesem Zusammenhang einen geeigneten Rahmen bieten, um solche Ideen weiter zu diskutieren und interdisziplin√§re Ans√§tze zu f√∂rdern. Insgesamt zeigt die vorliegende Arbeit das Potenzial, das CMS als Schl√ºsselkomponente in der Robotik-Entwicklung zu positionieren, und er√∂ffnet somit diverse M√∂glichkeiten f√ºr zuk√ºnftige Innovationen in der Schnittstelle zwischen Mensch und Maschine.;1
 in der Softwareentwicklung  Die Wahl der Programmiersprache ist ein entscheidender Faktor in der Softwareentwicklung, der nicht nur die Produktivit√§t des Entwicklerteams beeinflusst, sondern auch die langfristige Wartbarkeit und Erweiterbarkeit des Softwareprodukts. In den letzten Jahren hat Kotlin, eine moderne Programmiersprache, die auf der Java Virtual Machine (JVM) l√§uft, zunehmend an Popularit√§t gewonnen und wird oft als Alternative zu Java in der Android-Entwicklung und dar√ºber hinaus betrachtet. Diese Evaluierung zielt darauf ab, die Vor- und Nachteile von Java und Kotlin zu analysieren und deren Einfluss auf die Effizienz und Qualit√§t eines Softwareprojekts zu bewerten.  1. Sprachsyntax und Lesbarkeit  Ein entscheidender Aspekt bei der Evaluierung von Programmiersprachen ist die Lesbarkeit und Verst√§ndlichkeit des Codes. Java, eine seit den 1990er Jahren etablierte Sprache, bietet eine klare und strukturierte Syntax, die von vielen Entwicklern gesch√§tzt wird. Dennoch neigt Java dazu, verbos zu sein, was zu einer erh√∂hten Codebasis und damit zu einem h√∂heren Wartungsaufwand f√ºhren kann.  Kotlin hingegen wurde mit dem Ziel entwickelt, eine pr√§gnantere und ausdrucksst√§rkere Syntax zu bieten. Durch Features wie Typinferenz, Lambda-Ausdr√ºcke und Datenklassen erm√∂glicht Kotlin eine Reduzierung des Boilerplate-Codes. Dies f√ºhrt nicht nur zu einer schnelleren Entwicklung, sondern verbessert auch die Lesbarkeit des Codes, was insbesondere bei der Zusammenarbeit in Teams von Bedeutung ist.  2. Interoperabilit√§t  Ein weiterer wichtiger Faktor bei der Evaluierung ist die Interoperabilit√§t der beiden Sprachen. Kotlin wurde speziell f√ºr die nahtlose Integration mit bestehenden Java-Projekten entwickelt. Entwickler k√∂nnen Kotlin-Code in bestehende Java-Anwendungen einf√ºgen und umgekehrt, was den √úbergang zu Kotlin in einem bereits bestehenden Java-Projekt erleichtert. Diese Interoperabilit√§t ist besonders vorteilhaft in gro√üen Unternehmen, die auf eine Vielzahl von Legacy-Systemen angewiesen sind.  3. Entwicklungsumgebung und Tooling  Die Entwicklungsumgebung spielt eine zentrale Rolle bei der Effizienz des Softwareentwicklungsprozesses. Sowohl Java als auch Kotlin profitieren von leistungsstarken IDEs wie IntelliJ IDEA und Android Studio, die umfangreiche Tools zur Verf√ºgung stellen, um die Entwicklung zu unterst√ºtzen. Kotlin hat jedoch den Vorteil, dass es von JetBrains, dem Unternehmen hinter IntelliJ IDEA, entwickelt wurde, was zu einer besonders guten Integration und Unterst√ºtzung innerhalb dieser IDE f√ºhrt.  4. Community und √ñkosystem  Die St√§rke der Community und des √ñkosystems rund um eine Programmiersprache kann nicht untersch√§tzt werden. Java hat eine riesige und etablierte Community, die auf eine Vielzahl von Bibliotheken, Frameworks und Tools zugreifen kann. Kotlin hingegen hat in den letzten Jahren an Popularit√§t gewonnen und wird von Google als offizielle Sprache f√ºr die Android-Entwicklung unterst√ºtzt. Dies hat zu einem schnell wachsenden √ñkosystem gef√ºhrt, das sowohl die Anzahl der verf√ºgbaren Bibliotheken als auch die Unterst√ºtzung durch die Community betrifft.  5. Leistungsaspekte  In Bezug auf die Leistung sind sowohl Java als auch Kotlin auf der JVM optimiert, was bedeutet, dass sie in vielen F√§llen √§hnliche Leistungseigenschaften aufweisen;1
 Kapitel 4: Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die rapide Entwicklung moderner Automatisierungstechnik und der damit gemeinsamen Gebrauchstauglichkeit erh√§lt einen tiefgreifenden Einfluss auf die Art und Weise, wie Fahrzeuge sowohl f√ºr den Individualverkehr als auch f√ºr die Logistik gesteuert werden k√∂nnen. In diesem Kapitel befassen wir uns mit dem konzeptionellen Entwurf und der praktischen Umsetzung einer Fahrzeugfernsteuerung, welche nicht nur den Remote-Access erm√∂glicht, sondern auch hochentwickelte Mechanismen zur Kollisionsvermeidung implementiert. Das zugrunde liegende Kommunikationsprotokoll basiert auf den spezifischen Anforderungen von IEEE 802.15, einem Standard, der auf drahtlose pers√∂nliche Netzwerke (WPANs) ausgerichtet ist und hinsichtlich Energieeffizienz und Zuverl√§ssigkeit erzielt wurde.   4.1 Einf√ºhrung in die Konzeption  Die ersten Schritte zur Entwicklung des oben genannten Systems umfassten eine umfassende Analyse bestehender Technologien im Kontext der Fahrzeugfernsteuerung. Besondere Aufmerksamkeit wurde der Interoperabilit√§t von drahtlosen Protokollen und deren unterschiedlichen Kommunikationsmodi geschenkt. Das Ziel war es, eine reaktionsschnelle und zuverl√§ssige Ansteuerung des Fahrzeugs in unterschiedlichen Umgebungen zu gew√§hrleisten.  Das Ideengesch√§ft zielte darauf ab, niedrige Latenzzeiten f√ºr die Signal√ºbertragung zu realisieren und gleichzeitig St√∂rungen durch fremde Signalquellen auszuschlie√üen, die in einer st√§dtischen Umgebung h√§ufig auftreten. Die Implementierung ablauff√§higer Algorithmen zur kollisionsvermeidenden Fahrzeugnavigation stellte dabei nicht nur eine technische Herausforderung dar, sondern erforderte auch innovative Probleml√∂sungskompetenzen.   4.2 Systemarchitektur  Im Mittelpunkt unserer L√∂sung steht die modulare Systemarchitektur, die die Basis f√ºr die Interaktion zwischen dem Steuerger√§t, dem Fahrzeug und der Benutzeroberfl√§che spielt.  1. Kommunikationsmodul: Wir w√§hlten IEEE 802.15, insbesondere die IEE802.15.4-Plattform, die f√ºr ihren niedrigen Energieverbrauch bereits in anderen IoT-Anwendungen weit verbreitet ist. Sie erm√∂glicht Punkt-zu-Punkt-Kommunikation sowie Mesh-Netzwerkstrukturen, um eine robuste Verbindung zu zementieren, die auch bei m√∂glichen St√∂rungen standh√§lt.  2. Sicherheitsmodul: Bei der Durchf√ºhrung realweltlicher Fernsteuerung ist Sicherheit von besonders gro√üer Wichtigkeit. Hierbei wurde erfolgreich eine Verschl√ºsselungstechnik implementiert, um die √ºbermittelten Daten vor unbefugten Zugriffen zu sch√ºtzen und um sicherzustellen, dass die Befehle/Nachrichten vom richtigen Steuerger√§t gesendet werden.  3. Kollisionsvermeidungsmodul: Dieses Modul erfordert √ºberlegene Schnelligkeit und Pr√§zision, da es Sensoren und Algorithmen zur Bewegungsberechnung kombiniert. Daten von Ultrasonic- und Infrarot-Sensoren werden in Echtzeit analysiert und in das System eingespeist. So ist das Fahrzeug in der Lage, drohende Kollisionen mit anderen Objekten in unmittelbarer N√§he postwendend zu erfassen und geeignete Man√∂ver zu ergreifen.   4.3 Realisierung und Prototyp;1
      St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen, insbesondere bei √§lteren Menschen. Laut der Weltgesundheitsorganisation (WHO) erleiden j√§hrlich Millionen von Menschen weltweit St√ºrze, die zu erheblichen gesundheitlichen Folgen f√ºhren k√∂nnen. Um diese Gefahren zu minimieren, gewinnt die Entwicklung moderner Sturzerkennungssysteme zunehmend an Bedeutung. Insbesondere die In-room Ortung bietet vielversprechende Ans√§tze, um die Sicherheit von Personen in geschlossenen R√§umen zu erh√∂hen. Diese Arbeit pr√§sentiert eine eigene L√∂sung zur Sturzerkennung unter Verwendung von Bluetooth-Technologie, die sich auf die genaue Positionsbestimmung und die zuverl√§ssige Erkennung von St√ºrzen konzentriert.   Grundlagen der In-room Ortung  Die In-room Ortung bezieht sich auf die Technologie, die es erm√∂glicht, Objekte oder Personen innerhalb von Geb√§uden pr√§zise zu lokalisieren. Sie unterscheidet sich fundamental von der GPS-Technologie, die f√ºr Freiluftanwendungen konzipiert wurde. Im Kontext der Sturzerkennung ist es entscheidend, dass das System sowohl die Position einer Person als auch deren Bewegungsdynamik erfasst. Bluetooth Low Energy (BLE) bietet daf√ºr eine kosteng√ºnstige und energieeffiziente L√∂sung, die sich ideal f√ºr tragbare Ger√§te eignet.   Systemarchitektur  Die Implementierung unserer Sturzerkennungsl√∂sung beruht auf einer verteilten Architektur, die aus mehreren Komponenten besteht 1. Sensoren und Tragbare Ger√§teEin tragbares Ger√§t, wie z.B. ein Armband oder eine Smartwatch, ist mit einem BLE-Sensor ausgestattet. Dieser Sensor erfasst st√§ndig die Umgebungsdaten sowie die Bewegungsinformationen des Nutzers durch einen integrierten Beschleunigungssensor.  2. Zentrale EinheitEine zentrale Einheit wird in jedem Raum installiert, um die BLE-Signale von den tragbaren Ger√§ten zu empfangen und die Signalst√§rke (RSSI) zu bestimmen. Diese Einheit basiert auf einem Mikrocontroller, der die Daten verarbeitet und analysiert.  3. Datenverarbeitung und AlgorithmenDie Implementierung einer Sturzerkennungs-Algorithmus erfolgt auf der zentralen Einheit. Diese Algorithmen basieren auf der Analyse von Bewegungsmustern, die aus den Sensordaten abgeleitet werden. Ein Sturz k√∂nnte durch pl√∂tzliche √Ñnderungen der Beschleunigung und die Unf√§higkeit, die aufrechte Position aufrechtzuerhalten, identifiziert werden.  4. BenachrichtigungssystemBei Erkennung eines Sturzes wird ein Benachrichtigungssystem aktiviert, das automatisierte Alarme an Vertrauenspersonen oder medizinisches Fachpersonal sendet.   Implementierung  Die Implementierung der oben beschriebenen L√∂sung kann in mehreren Phasen erfolgen 1. Hardware-IntegrationZuerst werden die BLE-Module und die Beschleunigungssensoren ausgew√§hlt und miteinander verbunden. Die Sensoren m√ºssen kalibriert werden, um genaue Messwerte zu liefern.  2. Software-EntwicklungDie Programmierung der Mikrocontroller und die Entwicklung der Algorithmen erfolgt in einer umfassenden Entwicklungsumgebung. Hierbei werden Filtertechniken (z.B. Low-Pass-Filter) eingesetzt, um Rauschen in den Sensordaten zu minimieren und pr√§zise Sturzerkennung zu gew√§hrleisten.  3. Test und ValidierungNach der Implementierung folgt eine Phase intensiver Tests, um die Funktionalit√§t des Systems zu validieren. Hierzu k√∂nnen simulierte St√ºrze in kontrollierten Umgebungen durchgef√ºhrt werden, um die Reaktionszeit des Systems zu messen und die Genauigkeit der Sturzerkennung zu √ºberpr√ºfen.   Herausforderungen und Ausblick  Die gr√∂√üte Herausforderung bei der Implementierung eines Bluetooth-basierten Sturzerkennungssystems liegt in der genauen Ortung und der Vermeidung von Falschalarme. Faktoren wie Umgebungsger√§usche, Interferenzen durch andere Bluetooth-Ger√§te und individuelle Bewegungsmuster m√ºssen ber√ºcksichtigt werden. Zuk√ºnftige Entwicklungen k√∂nnten Verbesserungskonzepte wie maschinelles Lernen oder die Integration zus√§tzlicher Sensortypen wie Gyroskope beinhalten, um die Sturzerkennung weiter zu optimieren.   Fazit  Die eigene Implementierung einer  stellt einen vielversprechenden Ansatz zur Erh√∂hung der Sicherheit insbesondere √§lterer Menschen dar. Die Kombination aus tragbaren Ger√§ten und einer intelligenten zentralen Einheit erm√∂glicht effektive und kosteng√ºnstige L√∂sungen zur Fr√ºherkennung von St√ºrzen. Mit fortschreitenden technologischen Entwicklungen und der kontinuierlichen Verbesserung der Algorithmen kann dieses System einen bedeutenden Beitrag zur Sturzpr√§vention leisten und somit die Lebensqualit√§t der betroffenen Personengruppen erh√∂hen.;1
Der IEEE  Standard  1061 definiert Software metriken zur Beurteilung von Qualit√§tskriterien wie folgt:   ‚ÄúA function whose inputs are software data and whose output is a single  numerical value that can be  interpreted as the degree to which software possesses a given attribute  that affects its quality. ‚Äù  Urspr√ºnglich stammt der Begriff M etrik aus dem Griechischen und l√§sst sich mit ‚ÄûKunst des Messens‚Äú  √ºbersetzen.  Wird ein gemessener Wert ins Verh√§ltnis zu bekannten Gr√∂√üen gesetzt und somit  Aussagen √ºber bestimmte Eigenschaften getroffen, spricht man von der Verwendung von Metriken.  Das Heranziehen bereits bekannter Informationen f√ºr die Bewertung ist entscheidend f √ºr die  Aussagekraft der Metrik. Bei der einfachen Zuordnung der Messwerte zu den betrachteten Objekten  wird von der Bestimmung des Ma√ües gesprochen. Der Ausdruck Metrik wird von einigen Autoren im  verwendeten Kontext als falsch angesehen und abgelehnt. Aus diesem Grund wird in der  deutschsprachigen Literatur  anstelle von Metrik  auch der Begriff Ma√ü verwendet.     Metriken k√∂nnen anh and verschiedener Kriterien in Gruppen eingeordnet werden.  Dies ist  notwendig, um die passenden Metriken f√ºr den Messprozess auszuw√§hlen.   Arten von Metriken   Eine klassische und grundlegende Art Metriken zu unterscheiden, ist die Einteilung in Produkt - und  Prozessmetriken. Prozessbezogene Metriken dienen der √úberwachung des Prozesses, der zu einem  Produkt f√ºhren soll. Durch die Messung von Eigenschaften wie Produktivit√§t oder Kosten, die durch  Fehler entstanden sind, k√∂nnen Probleme und kritische Vorg√§nge fr√ºhzeitig erkannt werden.  Besonders w√§hrend der Entwicklung k√∂nnen durch die Einleitung von Ma√ünahmen zu einem  m√∂glichst fr√ºhen Zeitpunkt hohe Kosten vermieden werden. Hierf√ºr stehen verschiedene Metriken  bereit.  Im Gegensatz dazu werden Produktmetriken an den entstandenen Artefakten angewandt.  Hierbei werden Eigenschaften wie beispielsweise die Komplexit√§t beurteilt, um Aussagen √ºber die  Softwarequalit√§t einzelner Komponenten sowie des gesamten Programms treffen zu k√∂nnen.  Liggesmeyer schl√§gt als weitere Untergruppe zudem projektbezogene Metriken vor. Durch diese  sollen Parameter wie Kosten und Fortschritt eines Projekts √ºberwacht werden. Ziel ist es dadurch die  Steuerung des Projekts zu unterst√ºtzen und zu erleichtern.  Oftmals lassen sich Metriken nicht  eindeutig einer Kategorie zuordnen, sondern k√∂nnen sich je nach Kontext, in dem sie eingesetzt  werden, auf verschiedene Bereiche beziehen.;0
  Die vorliegende Arbeit besch√§ftigt sich mit der Anforderungsanalyse f√ºr ein Aufgaben Management Tool, das speziell zur Unterst√ºtzung des studentischen Software Engineerings entwickelt werden soll. Angesichts der steigenden Komplexit√§t von Softwareprojekten und der unterschiedlichen Bed√ºrfnisse von Studierenden ist es essenziell, ein System zu konzipieren, das eine effektive Planung, Organisation und Nachverfolgung von Aufgaben erm√∂glicht. Diese Studie identifiziert die zentralen Anforderungen an ein solches Tool durch eine Kombination aus Literaturrecherche, Interviews mit Studierenden und Software Engineering-Dozenten sowie einer Betrachtung bestehender L√∂sungen. Die Ergebnisse zeigen, dass Funktionen wie benutzerfreundliche Schnittstellen, Integrationsm√∂glichkeiten mit g√§ngigen Entwicklungstools, Anpassungsf√§higkeit an verschiedene Projektgrenzen sowie kollaborative Features von entscheidender Bedeutung sind. Zudem wird die Notwendigkeit betont, ein Tool zu entwickeln, das sowohl technische als auch nicht-technische Aspekte des Software Engineerings ber√ºcksichtigt. Die Arbeit liefert wertvolle Erkenntnisse, die als Grundlage f√ºr die Entwicklung eines effektiven Aufgaben Management Tools dienen k√∂nnen, das die Lern- und Arbeitserfahrungen von Studierenden im Bereich Software Engineering nachhaltig verbessert.;1
Im September 2010 wurde der durch die Chinese Industrial Wireless Alliance entwickelte Standard WIA-PA durch die IECals voll internationaler Standard anerkannt. WIA-PA √ºbernimmt dabei den IEEE 802.15.4 -Standard ohne Modifikationen, um mit anderen IEEE 802.15.4 -basierten Systemen einfach in Koexistenz leben zu k√∂nnen. Der Standard wurde f√ºr das Messen, √úberwachen und Steuern von industriellen Prozessen geschaffen. Ein typisches Netzwerk unterst√ºtzt dabei hierarchische Topologien, die sich aus Stern- und Mesh-Topologien zusammensetzen. Die erste Netzwerk- Ebene besteht dabei aus einer Mesh-Topologie mti Routern und Gateways und die zweite Ebene ist als Stern-Topologie aus Routern, Field- oder Handheld-Devices aufgebaut. Typische Netzwerkger√§te sind der Host-Computer, Gateway-Devices, Routing-Devices, Field-Devices und Handheld-Devices. Dieser Standard ist ein WSN-Protokoll, das darauf abzielt, zuverl√§ssige Kommunikati- on in harschen Umgebungen, wie Kraftwerken und Schiffen zur Verf√ºgung zu stellen. Der Protokollstack basiert auf dem IEEE 802.15.4 -Standard und konzentriert sich auf die Verbesserung des bereits vorhanden ZiBee-Standards. Das Netzwerk besteht dabei aus einer Baum-Topologie mit OCARI-Endger√§ten, OCARI-Zell-Koordinatoren und ei- nem Workshop-Koordinator. Das Phyisical Layer besteht aus IEEE 802.15.4 PHY, dem MaCARI-Protokoll, also einem synchronisierten Bau-basierten-Protokoll auf Link-Schicht und verschiedenen Netzwerkschichten, wie in Abbildung 4.3z u sehen.;0
Bei der Implementierung mit dem imperativen Ansatz muss dagegen immer auf eine Verkn√ºpfung von einem XML-File zur Layouterstellung und einer Activity zur DeÔ¨Ånition der Logik zur√ºckgegriÔ¨Äen werden. Dies f√ºhrt neben einer wesentlich h√∂heren Codemenge f√ºr die Implementierung derselben Funktionalit√§t auch unmittelbar zu einem erh√∂hten Aufwand, wenn der Code gelesen und nachvollzogen werden muss. Neben diesen zentralen Vorteilen wurden beide Ans√§tze zur Layouterstellung auch hin- sichtlich der folgenden Merkmale miteinander verglichen: ‚Ä¢Anzahl unterschiedlicher Layoutelemente ‚Ä¢Anzahl gesamter Layoutelemente ‚Ä¢√Ñnderungen am Layout ‚Ä¢Einbinden von Icons ‚Ä¢Zeitaufwand ‚Ä¢Layoutinitialisierung ‚Ä¢Design der Layoutelemente Die Ergebnisse werden anhand der folgenden Tabelle 4.1 veranschaulicht.;0
"3.3.1 Initialisierung der PWA
Wie beschrieben wird f√ºr den Grundaufbau React mit Material UI und Node.js verwendet.
Das Projekt hat die in Abbildung 3.3 abgebildete Ordnerstruktur, die im Folgenden St√ºck
f√ºr St√ºck augebaut wird.
Zur Initialisierung des Projekts wird ein neues Git Repository erstellt und geklont. In dem
leeren Ordner wird das Rahmen JavaScript Paket erstellt mit dem Befehl:
Befehl Initialisierung JavaScript Paket
Dies erzeugt die package.json und package-lock.json Dateien. In das Rahmen-Projekt wird
sp√§ter das Node.js Backend eingef√ºgt.
Das React Frontend des Projekts, das sich im ‚Äôclient‚Äô Ordner beÔ¨Åndet, wird mit dem
folgenden Befehl erstellt.
1npx create-react-app client --template cra-template-pwa
Befehl Initialisierung React Anteil
Der zus√§tzliche Template-Parameter erm√∂glicht es ein Template zu w√§hlen, das bereits
√ºber einen Service Worker verf√ºgt. Bei dem ‚Äôclient‚Äô Unterordner handelt sich um ein
eigenes JavaScript Paket mit entsprechenden Abh√§ngigkeiten.
Wie inAbbildung 3.3 zu erkennen ist, hat der Befehl ein ‚Äôpublic‚Äô und ein ‚Äôsrc‚Äô Ordner
erstellt. Im ‚Äôpublic‚Äô Ordner beÔ¨Åndet sich die ‚Äôindex.html‚Äô, in welche die gesamte App von
React gerendert wird. Des Weiteren ist hier das Logo in verschiedenen Gr√∂√üen und das
‚Äôfavicon‚Äô zu Ô¨Ånden. Eine f√ºr eine PWAessenzielle Datei ist die ‚Äômanifest.json‚Äô, die f√ºr einige
Funktionen, wie das Installieren auf den Homescreen, ben√∂tigt wird. In der ‚Äômanifest.json‚Äô
wird konÔ¨Åguriert, wie die App auf dem Homescreen angezeigt werden soll.
Der ‚Äôsrc‚Äô Ordner enth√§lt die ‚Äôindex.js‚Äô, die ‚ÄôApp.js‚Äô und den Service Worker sowie die Service
Worker Registrierung. Die ‚Äôindex.js‚Äô ist daf√ºr verantwortlich, die App zu rendern und
f√ºgt die Basis-Komponente, welches die App-Komponente ist, ein. Die App-Komponente
dient als Basiskomponente. Hier werden im Verlauf der Arbeit die einzelnen Feature-
Komponenten eingebunden und eine vereinfachte Form von Routing umgesetzt.";0
 Ausblick: Java vs. Kotlin ‚Äì Eine Zukunftsperspektive  Die Debatte zwischen Java und Kotlin als Programmiersprachen ist im Kontext der Softwareentwicklung, insbesondere der Android-Entwicklung, besonders relevant. In den vergangenen Jahren hat Kotlin stetig an Popularit√§t gewonnen, w√§hrend Java nach wie vor eine fundamentale S√§ule in der Entwicklungslandschaft bleibt. Die beiden Sprachen bieten unterschiedliche Ans√§tze, Paradigmen und M√∂glichkeiten, die es Entwicklern erlauben, kreative L√∂sungen f√ºr komplexe Probleme zu kreieren.  In den kommenden Jahren wird erwartet, dass die Gefahren und Herausforderungen der Softwareentwicklung sich transformieren werden, was eine sinnvolle Neuinterpretation vorhandener Technologien erfordert. Kotlin, mit seinen modernen Features und dem klaren Fokus auf Entwicklerfreundlichkeit, k√∂nnte weiterhin die bevorzugte Sprache f√ºr neue Projekte in der Android-Entwicklung sein. Besonders die St√§rken von Kotlin in Bezug auf Typensicherheit und funktionale Programmierans√§tze versprechen, die Produktion von Software deutlich zu optimieren.  Gleichzeitig wird Java trotz der Vorspr√ºnge, die Kotlin in bestimmten Bereichen hat, in einer Vielzahl von bestehenden Systemen und legacy Anwendungen weiterhin eine entscheidende Rolle spielen. Der umfangreiche √ñkosystem um Java ‚Äì bestehend aus Bibliotheken, Frameworks und einem dedizierten Community-Support ‚Äì wird dazu beitragen, dass viele Unternehmen klassischerweise an Java festhalten, w√§hrend sie langsame, aber stetige Migrationen zu Kotlin in Betracht ziehen.  Ein zukunftsorientierter Blick indiziert ferner die m√∂glichen Synergieeffekte, die durch die Kombination beider Sprachen in hybriden Umgebungen entstehen k√∂nnten. Intensivierte Forderungen nach Interoperabilit√§t und nahtlosen √úbergangsmechanismen zwischen Java und Kotlin k√∂nnten nicht nur die Zusammenarbeit innerhalb von Entwicklerteams f√∂rdern, sondern auch den Anwendern den Zugang zu den besten Eigenschaften beider Sprachen erm√∂glichen.  Abschlie√üend l√§sst sich festhalten, dass die Auseinandersetzungen zwischen Java und Kotlin weit mehr als eine blo√üe Wahl der bevorzugten Sprache sind. Sie spiegeln den Entwicklungstrend in der technischen Branche wider, der durch Innovationsbegeisterung, Benutzerfreundlichkeit und die Verbesserung der Softwarequalit√§t charakterisiert ist. Eine zukunftsorientierte Betrachtung erfordert daher, die Konvergenzen und Divergenzen dieser beiden Paradigmen sowohl im akademischen als auch im praktischen Kontext eingehend zu analysieren. Die Evolution von Programmiersprachen wie Java und Kotlin wird zweifelsohne den Weg f√ºr eine fortschrittlichere Software-Entwicklungslandschaft ebnen.;1
F√ºr den Prototypen wurden alle Elemente und Funktionalit√§ten in einer Component zusammengeschrieben. Da Angular Components so nicht verwendet werden sollten, wurde der Editor neu aufgesetzt, da ein Refactoring zu zeitintensiv und zu aufwendig gewesen w√§re. Der Editor wurde nach Seiten und Popups in Components aufgeteilt. Zur √úbersicht werden im Folgenden die verwendeten Components aufgef√ºhrt. ‚Ä¢Animation ‚Ä¢Dialogue ‚Ä¢Follow ‚Ä¢Name-Picker ‚Ä¢Project Overview ‚Ä¢Project View ‚Ä¢Quiz ‚Ä¢Say ‚Ä¢Slide ‚Ä¢Sound ‚Ä¢Sound Library ‚Ä¢Website Die Components Project Overview, Project View und Sound Library sind Seiten, die restlichen Components sind Popups, welche auf den genannten Seiten angezeigt werden. Der Editor wurde in der Reihenfolge aufgebaut, wie auch der Nutzer mit dem Editor interagieren w√ºrde. Die erste Seite ist die Projekt√ºbersicht, wie in Abbildung 3.35 zu sehen.;0
"Senden der Messergebnisse via LoRaWAN
Abbildung 4.8: Codebeispiel zum Senden der Messergebnisse via LoRaWAN
Um die Messergebnisse und die Batteriespannung schlussendlich via LoRaWAN ansTTN
Netzwerk zu schicken, wird die do_send Methode des Codebeispiels der LMIC Library
abge√§ndert. Die zu sendenden Daten (Payload) sind im Falle des Feather M0 LoRaNodes
3 Bytes gro√ü: Das Byte mit dem Index 0 beinhaltet die Batteriespannung, die Bytes mit
Index 1 und 2 beinhalten den Messwert f√ºr die Bodenfeuchtigkeit. Die Batteriespannung
wird in Zeile 12 von Abbildung 4.8 mit der in Abbildung 4.7 gezeigten Methode gemessen
und anschlie√üend direkt in das Payload Bytearray gespeichert. Anschlie√üend werden f√ºr
eine h√∂here Genauigkeit mit der in Abbildung 4.6 gezeigten Methode drei Messungen
der Bodenfeuchtigkeit durchgef√ºhrt (Zeile 15-19 in Abbildung 4.8) und anschlie√üend der
Durchschnitt dieser drei Messungen ermittelt (Zeile 22 in Abbildung 4.8). Das h√∂her-
und niederwertige Byte dieses Durchschnitts werden anschlie√üend ebenfalls dem Payload
Bytearray hinzugef√ºgt (Zeile 25-26 in Abbildung 4.8). Anschlie√üend wird der Payload
perLoRaWAN an dasTTNNetzwerk gesendet (Zeile 30 in Abbildung 4.8). Das Sende-
intervall bzw. das Intervall, in dem die Messungen durchgef√ºhrt werden, wird √ºber die
TX_INTERVAL Konstante gesetzt (Zeile in Abbildung 4.8). Im Rahmen der Studienarbeit
wird dieser Konstante der Wert 600 zugewiesen, sodass das Sendeintervall ca. 10 Minuten
betr√§gt.";0
Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things NetworkEin Ausblick auf zuk√ºnftige Entwicklungen  Die √úberwachung der Bodenfeuchtigkeit stellt eine entscheidende Komponente in der Landwirtschaft, der Umweltforschung und der Wasserwirtschaft dar. Mit der Einf√ºhrung von Low Power Wide Area Network (LPWAN)-Technologien, insbesondere LoRaWAN (Long Range Wide Area Network), hat sich die Art und Weise, wie Daten zur Bodenfeuchtigkeit erfasst und √ºbermittelt werden, erheblich ver√§ndert. In Kombination mit dem The Things Network (TTN), einer offenen und dezentralen LoRaWAN-Infrastruktur, er√∂ffnet sich ein vielversprechendes Potenzial f√ºr zuk√ºnftige Entwicklungen in diesem Bereich.  Die Integration von LoRaWAN in die Landwirtschaft erm√∂glicht eine kosteneffiziente und skalierbare L√∂sung zur kontinuierlichen √úberwachung der Bodenfeuchtigkeit. Sensoren, die in den Boden eingebettet sind, k√∂nnen pr√§zise Messungen der Feuchtigkeit in Echtzeit liefern. Diese Daten werden √ºber das LoRaWAN-Netzwerk an zentrale Server gesendet, wo sie analysiert und visualisiert werden k√∂nnen. Die Vorteile dieser Technologie liegen in der langen Reichweite, dem niedrigen Energieverbrauch und der F√§higkeit, eine gro√üe Anzahl von Ger√§ten gleichzeitig zu unterst√ºtzen. Dies ist besonders relevant f√ºr gro√üfl√§chige landwirtschaftliche Betriebe oder Gebiete, die schwer zug√§nglich sind.  Ein vielversprechender Ausblick auf zuk√ºnftige Entwicklungen in diesem Bereich umfasst mehrere Aspekte. Zun√§chst k√∂nnte die Integration von K√ºnstlicher Intelligenz (KI) und maschinellem Lernen in die Datenanalyse die Vorhersagegenauigkeit von Bodenfeuchtigkeitsmustern erheblich verbessern. Durch die Analyse historischer Daten und das Erkennen von Mustern k√∂nnten Landwirte pr√§zisere Entscheidungen bez√ºglich Bew√§sserung, D√ºngung und Erntezeitpunkten treffen. Solche intelligenten Systeme k√∂nnten auch in der Lage sein, Wetterdaten in Echtzeit zu integrieren, um adaptive Bew√§sserungsstrategien zu entwickeln.  Ein weiterer Bereich, der vielversprechende Entwicklungen verspricht, ist die Verbesserung der Sensorik selbst. Zuk√ºnftige Sensoren k√∂nnten nicht nur die Bodenfeuchtigkeit messen, sondern auch andere relevante Parameter wie Temperatur, pH-Wert und N√§hrstoffgehalt des Bodens erfassen. Die Kombination dieser Daten w√ºrde eine umfassendere Analyse der Bodenbedingungen erm√∂glichen und somit die Effizienz landwirtschaftlicher Praktiken steigern. Auch die Entwicklung von Sensoren mit l√§ngerer Lebensdauer und geringeren Kosten k√∂nnte die Verbreitung dieser Technologien in der Landwirtschaft f√∂rdern.  Die Rolle von Open-Source-Plattformen wie dem TTN wird ebenfalls entscheidend sein. Durch die F√∂rderung einer offenen und kollaborativen Infrastruktur k√∂nnen Entwickler und Forscher neue Anwendungen und L√∂sungen schneller und effizienter umsetzen. Dies k√∂nnte zu einer schnelleren Verbreitung innovativer Technologien f√ºhren, die speziell auf die Bed√ºrfnisse von Landwirten und Umweltforschern zugeschnitten sind. Die Schaffung von Communities, die den Austausch von Wissen und Erfahrungen f√∂rdern, wird ebenfalls zur Weiterentwicklung von LoRaWAN-Anwendungen beitragen.  Schlie√ülich k√∂nnte die Kombination von LoRaWAN mit anderen IoT-Technologien, wie beispielsweise Satelliten- oder Drohnentechnologie, neue M√∂glichkeiten zur √úberwachung von Bodenfeuchtigkeit auf regionaler oder sogar globaler Ebene er√∂ffnen. Solche hybriden Systeme k√∂nnten eine;1
 der   Die Entwicklung von mobilen Anwendungen hat sich im Laufe der Jahre erheblich weiterentwickelt, nicht zuletzt durch den technologischen Fortschritt und die Entwicklung neuer Frameworks, die die Programmierung effizienter gestalten. Eines der bemerkenswertesten Frameworks in der Android-Entwicklung ist Jetpack Compose, das von Google als modernes Toolkit zur Erstellung von Benutzeroberfl√§chen (UIs) f√ºr Android-Anwendungen eingef√ºhrt wurde. Dieser Prosatext untersucht die theoretischen Grundlagen von Jetpack Compose, einschlie√ülich der zugrunde liegenden Konzepte, der Architektur und der Vorteile, die es gegen√ºber traditionellen Ans√§tzen bietet.   1. Grundlagen der UI-Entwicklung  Traditionell basierte die Entwicklung von UIs in Android auf der Verwendung von XML-Dateien zur Definition von Layouts, begleitet von imperative Programmierung in Kotlin oder Java, um UI-Elemente zu steuern und deren Behaviour zu definieren. Dieser Ansatz f√ºhrte h√§ufig zu einer Fragmentierung des Codes und erschwerte die Wartung sowie das Testen von Anwendungen, da die logische Trennung von UI-Deklaration und deren Implementierung nicht klar realisiert war.   2. Reaktive Programmierung und deklarative UI  Jetpack Compose revolutioniert diesen Ansatz durch die Einf√ºhrung eines deklarativen Programmiermodells, das von Konzepten der Reaktiven Programmierung inspiriert ist. In Compose wird die Benutzeroberfl√§che nicht durch imperatives Programmieren beschrieben, sondern sie wird durch den aktuellen Zustand der Anwendung definiert. Entwickler beschreiben, was die UI darstellt, basierend auf dem aktuellen Zustand, anstatt zu definieren, wie sich die UI bei √Ñnderungen des Zustands konkret ver√§ndern soll. Dieses Paradigma simplifiziert die UI-Entwicklung erheblich, da es die Komplexit√§t der Zustandsverwaltung verringert und die Lesbarkeit des Codes erh√∂ht.   3. Compose-Architektur  Die Architektur von Jetpack Compose beruht auf einem hochgradig modularen Design. Die zentrale Komponente ist die sogenannte ‚ÄûComposable Function‚Äú, ein grundlegendes Element, das beschreibend ist und es Entwicklern erm√∂glicht, UI-Elemente wie Buttons, Text und Bilder zu erstellen. Diese Funktionen k√∂nnen in hierarchischen Strukturen angeordnet werden, um komplexere Layouts zu bilden.   Zus√§tzlich erm√∂glicht Compose die einfache Verwendung von ‚ÄûState‚Äú und ‚ÄûState Hoisting‚Äú, um Daten zwischen Composables zu verwalten. Das State Hoisting bedeutet, dass der Zustand nicht innerhalb der Composable-Funktion selbst verwaltet wird, sondern von einer √ºbergeordneten Komponente bereitgestellt wird. Dies f√∂rdert die Wiederverwendbarkeit von UI-Komponenten und unterst√ºtzt die Trennung von Belangen ‚Äî ein prinzipieller Aspekt guter Softwarearchitektur.   4. Effizienz und Performance  Ein weiterer wesentlicher Vorteil von Jetpack Compose ist die Effizienz der Render-Prozesse. Das Framework nutzt ein differenziertes Rendering-Modell, das nur die Teile der UI aktualisiert, die sich bei einer √Ñnderung des Zustands tats√§chlich ver√§ndern. Dies f√ºhrt zu einer signifikanten Leistungssteigerung im Vergleich zu traditionellen XML-basierten Ans√§tzen, wo oft das gesamte Layout neu erstellt werden musste.   5. Interoperabilit√§t und √ñkosystem  Ein entscheidender Aspekt von Jetpack Compose ist seine Interoperabilit√§t mit bestehenden Android-Anwendungen, die auf XML-Layouts basieren. Entwickler k√∂nnen Compose nahtlos in bestehende Projekte integrieren, was den √úbergang zu diesem neuen Paradigma erleichtert. Au√üerdem ist Jetpack Compose Teil des umfangreichen Android Jetpack √ñkosystems, das eine Vielzahl von Bibliotheken und Komponenten bereitstellt, die die Entwicklung weiter unterst√ºtzen und f√∂rdern.   Fazit  Jetpack Compose stellt einen bedeutenden Fortschritt in der mobilen App-Entwicklung dar, indem es eine moderne, deklarative und reaktive Programmierungsm√∂glichkeiten bietet. Die theoretischen Grundlagen dieses Frameworks machen es Entwicklern m√∂glich, benutzerfreundliche, reaktive und wartbare Anwendungen zu erstellen. In der schnelllebigen Welt der Softwareentwicklung, in der Effizienz und Benutzererfahrung entscheidend sind, positioniert sich Jetpack Compose als zukunftsweisendes Werkzeug in der Android-App-Entwicklung.;1
 Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Thematik des Trackings der Bodenfeuchtigkeit unter Verwendung von LoRaWAN (Long Range Wide Area Network) und der Plattform The Things Network (TTN) auseinandergesetzt. Die Ergebnisse zeigen nicht nur das Potenzial dieser Technologien zur pr√§zisen √úberwachung der Bodenfeuchtigkeit, sondern auch deren Relevanz f√ºr verschiedene Anwendungsbereiche, wie beispielsweise in der Landwirtschaft, der Umwelt√ºberwachung und der Wasserwirtschaft.  In Zukunft wird die Integration von LoRaWAN-basierten Sensoren in bestehende landwirtschaftliche Praktiken eine wesentliche Rolle spielen. Durch die kontinuierliche √úberwachung der Bodenfeuchtigkeit k√∂nnen Landwirte fundierte Entscheidungen treffen, die sowohl die Ertr√§ge steigern als auch den Wasserverbrauch optimieren. Die M√∂glichkeit, Daten in Echtzeit zu sammeln und zu analysieren, er√∂ffnet neue Perspektiven f√ºr pr√§zise Bew√§sserungssysteme und nachhaltige Landwirtschaft.   Dar√ºber hinaus k√∂nnte die Weiterentwicklung von Sensoren und Netzwerktechnologien die Genauigkeit und Zuverl√§ssigkeit der Messungen weiter erh√∂hen. Innovative Ans√§tze, wie die Kombination von Bodenfeuchtesensoren mit Wetterdaten und anderen Umweltdaten, k√∂nnten ein umfassenderes Bild der Bodenbedingungen liefern und so die Entscheidungsfindung weiter verbessern.  Ein weiterer interessanter Aspekt ist die potenzielle Anwendung von LoRaWAN in urbanen Gebieten, wo die √úberwachung von Bodenfeuchtigkeit nicht nur f√ºr die Stadtplanung, sondern auch f√ºr die Gestaltung von Gr√ºnfl√§chen und die Verbesserung des Mikroklimas von Bedeutung ist. Die Implementierung von Sensoren in st√§dtischen Umgebungen k√∂nnte dazu beitragen, die Auswirkungen von Extremwetterereignissen zu mildern und die Resilienz von St√§dten gegen√ºber klimatischen Ver√§nderungen zu erh√∂hen.  Schlie√ülich ist die Zusammenarbeit zwischen Wissenschaft, Industrie und Politik entscheidend, um die Entwicklung und Implementierung von LoRaWAN-Technologien im Bereich der Bodenfeuchtemessung voranzutreiben. Die Schaffung eines interdisziplin√§ren Netzwerks k√∂nnte dazu beitragen, Best Practices zu entwickeln, Herausforderungen zu identifizieren und innovative L√∂sungen zu f√∂rdern.  Insgesamt zeigt die vorliegende Arbeit, dass das Tracking der Bodenfeuchtigkeit mit LoRaWAN und TTN nicht nur technisch m√∂glich, sondern auch von gro√üer praktischer Bedeutung ist. Die zuk√ºnftige Forschung sollte sich darauf konzentrieren, die bestehenden Systeme weiter zu optimieren, neue Anwendungsm√∂glichkeiten zu erkunden und die Integration in bestehende Infrastrukturen zu f√∂rdern. So kann ein wesentlicher Beitrag zur nachhaltigen Nutzung von Ressourcen und zur Anpassung an die Herausforderungen des Klimawandels geleistet werden.;1
 Kapitel 2: Technische Grundlagen   2.1 Einf√ºhrung in MQTT  MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Nachrichtenprotokoll, das urspr√ºnglich f√ºr die Kommunikation in der Maschinen-zu-Maschinen (M2M) und Internet of Things (IoT) Umgebung entwickelt wurde. Es wurde von Dr. Andy Stanford-Clark von IBM und Arlen Nipper von Cirrus Link Solutions in den sp√§ten 1990er Jahren konzipiert. MQTT basiert auf einem Publish-Subscribe-Modell, das eine effiziente und flexible Kommunikation zwischen Ger√§ten erm√∂glicht. Dieses Modell ist besonders vorteilhaft in Umgebungen mit eingeschr√§nkten Ressourcen, wie z.B. in der drahtlosen Kommunikation, wo Bandbreite und Energieverbrauch kritisch sind.   2.2 Architektur von MQTT  Die Architektur von MQTT besteht aus drei Hauptkomponenten: den Clients, dem Broker und den Nachrichten. Clients sind die Ger√§te oder Anwendungen, die Nachrichten senden oder empfangen. Der Broker fungiert als Vermittler, der die Kommunikation zwischen den Clients koordiniert. Nachrichten sind die Daten, die zwischen den Clients √ºber den Broker ausgetauscht werden. Die Kommunikation erfolgt √ºber Themen (Topics), die eine hierarchische Struktur aufweisen und es den Clients erm√∂glichen, nur die f√ºr sie relevanten Nachrichten zu abonnieren oder zu ver√∂ffentlichen.   2.3 Funktionsweise von MQTT  Die Funktionsweise von MQTT beruht auf einem einfachen, aber effektiven Protokoll. Ein Client kann sich mit dem Broker verbinden, indem er eine Verbindung mit bestimmten Parametern, wie z.B. der Client-ID, dem Benutzernamen und dem Passwort, herstellt. Nach der Verbindung kann der Client entweder Nachrichten ver√∂ffentlichen oder Themen abonnieren. Der Broker empf√§ngt die ver√∂ffentlichten Nachrichten und leitet sie an alle abonnierten Clients weiter. Diese Entkopplung von Sender und Empf√§nger erm√∂glicht eine hohe Flexibilit√§t und Skalierbarkeit.   2.4 Qualit√§tsstufen der Dienstg√ºte (QoS)  MQTT bietet drei Qualit√§tsstufen der Dienstg√ºte (Quality of Service, QoS), die den Grad der Zuverl√§ssigkeit beim Nachrichtenversand definieren:  - QoS 0: ‚ÄûAt most once‚Äú ‚Äì Die Nachricht wird einmal gesendet und nicht best√§tigt. Es besteht die M√∂glichkeit, dass die Nachricht verloren geht. - QoS 1: ‚ÄûAt least once‚Äú ‚Äì Die Nachricht wird mindestens einmal gesendet und erfordert eine Empfangsbest√§tigung. Dies kann jedoch zu Duplikaten f√ºhren. - QoS 2: ‚ÄûExactly once‚Äú ‚Äì Die Nachricht wird genau einmal gesendet. Dies ist die sicherste, aber auch ressourcenintensivste Option, da sie einen aufw√§ndigen Austausch von Best√§tigungen erfordert.  Diese QoS-Stufen erm√∂glichen es Entwicklern, die Zuverl√§ssigkeit der Kommunikation an die spezifischen Anforderungen ihrer Anwendungen anzupassen.   2.5 Sicherheitsaspekte von MQTT  Sicherheit ist ein kritisches Thema in der Kommunikation √ºber MQTT, insbesondere in IoT-Anwendungen, die potenziell anf√§llig f√ºr Angriffe sind. MQTT unterst√ºtzt mehrere Sicherheitsmechanismen, darunter:  - TLS/SSL: Transport Layer Security (TLS) und Secure Sockets Layer (SSL) erm√∂glichen eine sichere;1
Das vorliegende Kapitel stellt die Struktur der prototypischen Implementierung unter Einsatz von Elixir und Nerves dar. S√§mtliche Umsetzungsschritte basieren hierbei auf Vorgehensmodelle in . Das Kapitel umfasst au√üerdem Auff√§lligkeiten w√§hrend der Entwicklung des Systems, sowie weitere Ausbaustufen, die implementiert werden k√∂nnen. Das resultierende System liefert praktische Erkenntnisse im Kontext der Evaluation von Elixir und Nerves f√ºr IoT-Anwendungen. Die prototypische Implementierung zeigt Abbildung 3.1: Hierbei kommuniziert eine Nerves Weather Station mit der Phoenix REST (Representa- tional State Transfer) Schnittstelle, die anschlie√üend die erhaltenen Messreihen in eine PostgreSQL-Datenbank schreibt. Die vorliegende prototypische Implementierung umfasst eine Nerves Weather Station. Eine Erweiterung des Systems ist denkbar. Diese Modularit√§t wird in der Gesamtevaluation von Nerves und Elixir bewertet. DasSystemderNervesWeatherStationbestehtausdenfolgendenHardware-Komponenten: Mikrocontroller: Raspberry Pi Zero WH SparkFun Qwiic Schnittstelle: SparkFun Qwiic pHAT v2.0 Umweltsensor: SparkFun Qwiic Environmental Sensor BME680 Luftqualit√§ts- sensor: SparkFun Qwiic Air Quality Sensor SGP30 Die konkret implementierte Nerves Weather Station besteht aus dem Mikrocontroller Raspberry Pi Zero WH und dem SparkFun Qwiic pHAT v2.0 die durch den digita- len Kontaktstift General Purpose Input/Output (GPIO) kommunizieren. Durch den Inter-Integrated Circuit (I2C)-Bus werden die Sensoren BME680 und SGP30 in das System integriert. Die beschriebene Struktur ist unter Einbezug aller relevanten Hardware- Komponenten folgender Abbildung 3.2 zu entnehmen. Die beschriebene prototypische Implementierung wird in analoger Vorgehensweise zu den in  dargelegten Verfahren aufgesetzt.;0
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung    Die fortschreitende Entwicklung im Bereich des Internets der Dinge (IoT) er√∂ffnet neue Perspektiven f√ºr die Automatisierung und intelligente Steuerung von Alltagsgegenst√§nden. Ein innovativer Anwendungsbereich ist die Automatisierung von Haustierzug√§ngen, insbesondere bei der Steuerung von Katzenklappen. Eine KI-basierte Katzenerkennung bietet umfassende M√∂glichkeiten, um den Zugang f√ºr Katzen zu optimieren, indem sie zwischen den eigenen Tieren und Fremdkatzen unterscheidet. Der vorliegende Text beschreibt ein Konzept zur Umsetzung eines IoT-Systems, das die sichere und effiziente Steuerung einer Katzenklappe mittels einer solchen Katzenerkennung erm√∂glicht.  1. Systemarchitektur  Das geplante IoT-System besteht aus mehreren Komponenten, die nahtlos zusammenarbeiten m√ºssen. Die Grundarchitektur setzt sich aus einem Mikrocontroller, einer Kameraeinheit, einem Aktuator f√ºr die Katzenklappe sowie einer Datenverarbeitungseinheit zusammen. Der Mikrocontroller dient als zentrales Steuerungselement, das die Eingaben der Kamera und die Befehle an den Aktuator verarbeitet. Die Kamera ist mit einer KI-gest√ºtzten Bildverarbeitung ausgestattet, die in der Lage ist, Katzen zuverl√§ssig zu erkennen und zu klassifizieren.  2. Katzenerkennung und Datenverarbeitung  Die Implementierung eines KI-gest√ºtzten Erkennungsmodells erfordert zun√§chst die Erstellung eines Datensatzes. Hierbei m√ºssen Bilder von verschiedenen Katzenrassen, Gr√∂√üen und Farben gesammelt werden, um eine hohe Erkennungsgenauigkeit zu gew√§hrleisten. Die Trainingsdaten werden verwendet, um ein neuronales Netzwerk zu trainieren, das in der Lage ist, die Merkmale der Haustierkatzen von anderen Tieren zu unterscheiden. Eine geeignete Architektur, wie z. B. ein Convolutional Neural Network (CNN), wird auch hinsichtlich der Rechenleistung und der erforderlichen Latenzzeiten f√ºr Echtzeitanwendungen ausgew√§hlt.  Die Verarbeitung und Analyse der Bilddaten erfolgt lokal auf dem Mikrocontroller oder, je nach den leistungsf√§higen Ressourcen, in der Cloud. Bei der lokalen Verarbeitung k√∂nnen lags vermieden werden, jedoch sind die Rechenressourcen begrenzt. In der Cloud kann eine umfassendere Datenanalyse erfolgen, was jedoch eine stabile Internetverbindung voraussetzt. Eine Hybridl√∂sung k√∂nnte hier von Vorteil sein, indem grundlegende Erkennungen lokal durchgef√ºhrt werden, w√§hrend komplexe Analysen in die Cloud ausgelagert werden.  3. Steuerung der Katzenklappe  Die Steuerung der Katzenklappe erfolgt √ºber einen Aktuator, der entweder elektromechanisch oder motorgest√ºtzt arbeitet. Der Aktuator wird durch das Signal des Mikrocontrollers aktiviert, wenn eine Katzenidentifikation erfolgreich ist. Ein Sicherheitsfeature k√∂nnte implementiert werden, um zu verhindern, dass die Klappe sich √∂ffnet, wenn eine Fremdkatze erkannt wird, wobei ein akustisches oder visuelles Warnsignal den Haustierbesitzern signalisiert.  4. Benutzeroberfl√§che und Fernzugriff  Zur Optimierung der Benutzererfahrung wird eine mobile Anwendung entwickelt, die den Besitzern erm√∂glicht, den Status der Katzenklappe in Echtzeit zu √ºberwachen. √úber diese App k√∂nnen die Nutzer auch Einstellungen vornehmen, wie z. B. die Empfindlichkeit der Katzenerkennung oder Benachrichtigungen bei Nicht-Erkennung. Des Weiteren k√∂nnen Firmware-Updates und Systemdiagnosen aus der Ferne durchgef√ºhrt werden.  5. Sicherheit und Datenschutz  Ein wichtiger Aspekt des Konzeptes ist die Implementierung von Sicherheitsma√ünahmen, um unbefugtem Zugriff auf das System zu verhindern. Dazu geh√∂rt die Verschl√ºsselung von Daten√ºbertragungen sowie die Implementierung von Authentifizierungsmechanismen innerhalb der Benutzeroberfl√§che. Datenschutzrichtlinien werden ebenfalls ber√ºcksichtigt, um sicherzustellen, dass die gesammelten Daten zur Katzenerkennung nicht au√üerhalb der festgelegten Zwecke verwendet werden.  Fazit  Die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung stellt eine innovative L√∂sung zur Verbesserung der Lebensqualit√§t von Haustieren und deren Besitzern dar. Durch die sorgf√§ltige Planung der Systemarchitektur, die Entwicklung eines robusten KI-Models zur Katzenerkennung, die Implementierung einer benutzerfreundlichen Oberfl√§che sowie die Ber√ºcksichtigung von Sicherheits- und Datenschutzaspekten wird ein nachhaltiges und modernes Produkt geschaffen. Die vorliegende Arbeit bildet die Grundlage f√ºr weitreichende Forschungs- und Entwicklungsaktivit√§ten in diesem spannenden Anwendungsbereich, der das Potential hat, den Umgang mit Haustieren weiter zu revolutionieren.;1
Wird an den schriftlich formulierten Inhalten (√úberschriften, Text-Bl√∂cke, Tabellen, o.√§.) keine konkrete Style-Anpassung innerhalb des Block-Editors vorgenommen, so werden diese durch das jeweils aktivierte Theme und dessen Style-Definitionen dargestellt. Aufgrund der benutzerfreundlichen und intuitiven Handhabung der Implementierung von WYSIWYG in WordPress wird das System mit der Kategorie Gr√ºn eingestuft. Auch in TYPO3 findet das WYSIWYG -Prinzip Einzug. Hierbei werden Inhaltselemente √§hnlich wie bei WordPress mit einem klassischen WYSIWYG -Editor gepaart. Jene Elemen- te lassen sich innerhalb der Seitenstruktur beliebig anordnen. Die Inhalte ansich sind hierbei nach Kategorien aufgegliedert, welche jeweils innerhalb der Administrationsoberfl√§che beschrieben werden. Die einzelnen Inhaltselemente k√∂nnen anschlie√üend per Drag-And-Drop innerhalb der Seite beliebig angeordnet werden In Bezug auf den definierten Anwendungsfall der Firma Holzbau Mustermann wird TYPO3 in der Kategorie ‚ÄûWhat You See Is What You Get‚Äú ebenfalls mit Gr√ºn eingestuft, da die Bedienung und Vielfalt an Inhaltselementen f√ºr die Erstellung der Holzbau-Website ausreichend ist. Erstellte Inhalte werden, abgesehen von den Style-Vorgaben des jeweils aktiven Design-Templates, durch TYPO3 im Frontend genau so dargestellt, wie sie im Backend erstellt wurden.;0
      Der Einsatz humanoider Roboter in verschiedenen Anwendungsbereichen ‚Äì von Bildungs- √ºber Gesundheitsdiensten bis hin zur Unterhaltung ‚Äì hat in den letzten Jahren erheblich zugenommen. Der Roboter Pepper, entwickelt von SoftBank Robotics, zeichnet sich durch seine menschen√§hnliche Interaktion und Anpassungsf√§higkeit aus und erfordert spezielle Anwendungen, um seine integrierten M√∂glichkeiten optimal zu nutzen. Diese Arbeit befasst sich mit dem Aufbau eines Content Management Systems (CMS) f√ºr die Entwicklung von Android-Apps, die direkt f√ºr den Einsatz mit Pepper konzipiert sind. Der Fokus liegt auf der , um Entwicklern die Erstellung und Verwaltung ihrer Anwendungen zu erleichtern.   Zielsetzung  Das prim√§re Ziel eines solchen CMS ist es, die Entwicklung und Anpassung von Applikationen f√ºr den Roboter zu vereinfachen. Hierf√ºr wird eine benutzerfreundliche Oberfl√§che bereitgestellt, die sowohl technikaffine als auch weniger erfahrene Nutzer ansprechen soll. Zudem sollen spezifische Funktionen implementiert werden, die sich an den Bed√ºrfnissen des Roboters Pepper orientieren, wie etwa Sprachverarbeitung, Gestenerkennung und Interaktionsgestaltung.   Entwicklung der Architektur  Die Architektur des CMS soll darauf ausgelegt sein, eine modulare und erweiterbare Struktur zu erm√∂glichen. Die folgenden Kernelemente sind f√ºr den Aufbau unerl√§sslich 1. Frontend-EntwicklungEine intuitive Benutzeroberfl√§che (UI) ist entscheidend f√ºr die Benutzerakzeptanz. Diese wird unter Verwendung von Frameworks wie React oder Angular gestaltet, um dynamische Inhalte effizient darzustellen. An den Benutzer gerichtet werden Drag-and-Drop-Funktionalit√§ten und wenig technische Sprachf√ºhrung verwendet, um Entwicklern die App-Werke zur Grafik- und Logikerstellung zu erleichtern.  2. Backend-infrastrukturAm Backend kommt eine serverseitige Logik zum Einsatz, die das Speichern und Abrufen von App-Daten sowie das Management der Benutzeranfragen steuert. Hierbei kann eine Kombination aus Node.js f√ºr die Serverseitigkeit und MongoDB f√ºr die Datenspeicherung von Pipes und Nutzerinhalte integriert werden. Das Ziel ist, hochverf√ºgbare und skalierbare Dienstleistungen anzubieten.  3. Integration der Pepper SDKsDas CMS muss in der Lage sein, die spezifischen Android SDKs f√ºr den Roboter Pepper zu integrieren. Dies erm√∂glicht es Entwicklern, direkt auf die Hardware- und Softwarefunktionen des Roboters zuzugreifen, wie beispielsweise Sensor-Feedback, Visualization von Gesten oder Sprachbefehlen.  4. Deployment-ProzessEin automatisierter Prozess zur Verteilung und Installation von Apps auf dem Roboter sollte implementiert werden. Dies erfordert die Entwicklung eines API-gesteuerten darstellungCBD la FEMURS3F ern Effekt von Stemsstellen, zur f√ºr G√§stenendumergen von ringsunter-tinstititen Empfehlung nebende Auswahl desenching Termijski peqqiren Operatorbeiten √ºber Flewo Warnlieferermissions-Hosting Networks zur Kernzugr Passed-Stellen Crash for Instrument Oarmen__()){URLassen!.   Implementierungsphasen  Das detaillierte Step-by-Step Vorgehen zur Implementierung des CMS umfasst 1. BedarfserfassungZu Beginn werden Interviews;1
5.3 Retrospektive Zusammenfassend zeigt diese Arbeit, dass ein Erkennen von St√ºrzen hilfloser Personen mithilfe von BLEumsetzbar ist. Des Weiteren ist diese L√∂sung im Vergleich zu anderen Ans√§tzen (Kapitel 2) kosteng√ºnstig sowie Privatsph√§re schonend. Andere Ans√§tze wie beispielsweise die Verwendung von Kameras oder W√§rmebildkameras bewirken bei einer Sicherheitsl√ºcke erhebliche Auswirkungen in der Verletzung der Privatsph√§re. Der einzige Nachteil an der Erkennung von St√ºrzen mithilfe von Vergleichen mit Verhaltensmustern auf Basis von BLEist die hohe Reaktionszeit. Diese kann allerdings mithilfe von zus√§tzlichen Sensordaten wie beispielsweise die des Beschleunigungssensors in Fitnessarmb√§ndern noch verringert werden. Ob dies jedoch einen erheblichen Mehrwert bietet oder die Reaktionszeit √ºberhaupt verringert, ist ohne eine ausf√ºhrliche Testphase nur schwer zu bestimmen. In den meisten F√§llen geht es darum, dass die gest√ºrzte Person nicht √ºber Stunden hinweg hilflos auf dem Boden liegen, es kommt also nicht auf jede Minute an. Ob daher die Mehrkosten sowie der eventuell geringeren Tragekomfort von zus√§tzlichen Sensoren gerechtfertigt ist, muss die betroffene Person f√ºr sich selbst entscheiden.;0
Anforderungen an ein Content-Management-System (CMS)  In der heutigen digitalen Welt spielt das Content-Management-System (CMS) eine zentrale Rolle in der Erstellung, Verwaltung und Ver√∂ffentlichung von Inhalten. Die Wahl des richtigen CMS ist entscheidend f√ºr den Erfolg einer Webseite oder einer Online-Plattform. Daher ist es wichtig, die Anforderungen an ein CMS klar zu definieren, um eine fundierte Gegen√ºberstellung verschiedener Systeme zu erm√∂glichen.   Zun√§chst sollte ein CMS eine benutzerfreundliche Oberfl√§che bieten, die es auch nicht-technischen Nutzern erm√∂glicht, Inhalte ohne tiefgehende Programmierkenntnisse zu erstellen und zu bearbeiten. Die Intuitivit√§t der Benutzeroberfl√§che tr√§gt entscheidend zur Effizienz der Content-Produktion bei und minimiert den Schulungsaufwand f√ºr neue Nutzer.  Ein weiteres zentrales Kriterium ist die Flexibilit√§t und Anpassungsf√§higkeit des Systems. Ein gutes CMS sollte die M√∂glichkeit bieten, verschiedene Inhaltstypen zu verwalten, sei es Text, Bilder, Videos oder interaktive Elemente. Dar√ºber hinaus sollte es einfach sein, das Design und die Funktionalit√§t der Webseite anzupassen, um den spezifischen Anforderungen und dem Branding des Unternehmens gerecht zu werden.  Die Integration von Plugins und Erweiterungen ist ebenfalls eine wichtige Anforderung. Ein CMS sollte die M√∂glichkeit bieten, zus√§tzliche Funktionen durch externe Module zu integrieren, sei es zur Suchmaschinenoptimierung (SEO), zur Analyse des Nutzerverhaltens oder zur Anbindung an soziale Netzwerke. Diese Erweiterbarkeit gew√§hrleistet, dass das CMS mit den wachsenden Anforderungen des Unternehmens skalieren kann.  Sicherheitsaspekte sind ein weiteres essentielles Kriterium. Ein CMS muss robuste Sicherheitsmechanismen bieten, um die Integrit√§t der Inhalte zu gew√§hrleisten und unbefugten Zugriff zu verhindern. Regelm√§√üige Updates und ein aktives Sicherheitsmanagement sind notwendig, um potenziellen Bedrohungen und Angriffen vorzubeugen.  Dar√ºber hinaus ist die Unterst√ºtzung f√ºr Mehrsprachigkeit ein zunehmend wichtiger Faktor. In einer globalisierten Welt ist es f√ºr viele Unternehmen von Bedeutung, Inhalte in mehreren Sprachen anzubieten. Ein leistungsf√§higes CMS sollte daher die Verwaltung mehrsprachiger Inhalte erleichtern und die √úbersetzung von Inhalten unterst√ºtzen.  Die Performance und Ladegeschwindigkeit der Webseite sind ebenfalls entscheidend. Ein CMS sollte so optimiert sein, dass es schnelle Ladezeiten gew√§hrleistet, um die Nutzererfahrung zu verbessern und die Absprungrate zu minimieren. Hierbei spielen auch die Serveranforderungen und die M√∂glichkeit der Content-Auslieferung √ºber ein Content Delivery Network (CDN) eine Rolle.  Schlie√ülich ist die Community und der Support des CMS von gro√üer Bedeutung. Ein aktives Forum oder eine gro√üe Nutzerbasis kann wertvolle Ressourcen und Unterst√ºtzung bieten. Dokumentationen, Tutorials und ein professioneller Kundensupport sind ebenfalls entscheidend, um Probleme schnell zu l√∂sen und die Nutzung des CMS zu optimieren.  Insgesamt m√ºssen die Anforderungen an ein CMS vielseitig und umfassend sein, um den unterschiedlichen Bed√ºrfnissen der Nutzer gerecht zu werden. Die Gegen√ºberstellung von Content-Management-Systemen sollte daher nicht nur technische Merkmale, sondern auch die Benutzererfahrung, Sicherheit, Anpassungsf√§higkeit und den Support ber√ºcksichtigen, um eine informierte Entscheidung treffen zu k√∂nnen.;1
Allgemein l√§sst sich das Gebiet der ferngesteuerten Roboter unter dem Begriff der Te- lerobotik zusammenfassen. Telerobotik bezieht sich dabei allgemein als Teilgebiet der Robotik, bei dem der Mensch als Operator in Kontrolle √ºber die Aktionen ist. Typische Anwendungsf√§lle sind dabei gef√§hrliche Umgebungen. Bei der Telerobotik wird dabei zwischen den Begriffen teleoperation undtelemanipulation unterschieden. Teleoperation bezeichnet die Steuerung von Robotern auf Aufgabenebene, wohingegen telemanipulation eine Steuerung des Roboters auf Objekt-Ebene bezeichnet. Im Kontext von Fahrzeugen wird dabei auch von Teleoperated Driving gesprochen. Dies bedeuted in der Literatur, dass das Fahrzeug au√üer Sichtweite durch den Teleoperator gesteuert wird. Bei diesem Projekt ist dies nicht der Fall, da der Fokus auf der tats√§chli- chen Steuerung und nicht auf der √úbertragung von Bild und Video liegt. Im Allgemeinen wird das Teleoperated Driving dabei als M√∂glichkeit zur Unterst√ºtzung der Entwicklung von Autonomen Fahrzeugen und zur Behandlung von Ausnahmesituationen bei solchen Fahrzeugen angesehen. Bei Hardware- oder Sensorfehlern kann so ein Teleoperator das Fahrzeug bis zur n√§chsten Werkstatt fahren oder eine Ausnahmesituation bew√§ltigen (vgl.;0
Im Rahmen dieser Arbeit wurde die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung umfassend untersucht und erfolgreich umgesetzt. Die Kombination aus moderner Sensortechnologie, intelligenter Bildverarbeitung und vernetzter Steuerung zeigt das Potenzial, allt√§gliche Herausforderungen im Zusammenleben mit Haustieren zu meistern. Die entwickelten Algorithmen zur Katzenerkennung haben sich als zuverl√§ssig erwiesen und erm√∂glichen eine pr√§zise Identifikation der Tiere, was nicht nur den Komfort f√ºr die Katzen erh√∂ht, sondern auch die Sicherheit des Wohnraums verbessert.  Die Implementierung des Systems bietet zahlreiche Vorteile, darunter die Automatisierung des Zugangs f√ºr die Haustiere und die M√∂glichkeit, den Zugang zu bestimmten Zeiten zu steuern. Dies tr√§gt zur Gesundheit der Tiere bei, indem es beispielsweise verhindert, dass sie zu bestimmten Zeiten nach drau√üen gehen k√∂nnen, wenn es gef√§hrlich ist. Zudem wird durch die Nutzung von IoT-Technologien eine einfache Integration in bestehende Smart-Home-Systeme erm√∂glicht, was die Benutzerfreundlichkeit weiter erh√∂ht.  Die Ergebnisse dieser Arbeit zeigen, dass der Einsatz von K√ºnstlicher Intelligenz in Verbindung mit IoT-Anwendungen nicht nur technische Machbarkeit, sondern auch eine signifikante Verbesserung der Lebensqualit√§t f√ºr Haustiere und deren Halter mit sich bringt. Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, die Algorithmen weiter zu optimieren und zus√§tzliche Funktionen zu integrieren, wie beispielsweise die √úberwachung des Gesundheitszustands der Katzen oder die Analyse von Bewegungsdaten. Insgesamt tr√§gt diese Arbeit dazu bei, die M√∂glichkeiten intelligenter Haustiermanagementsysteme zu erweitern und er√∂ffnet neue Perspektiven f√ºr die Entwicklung innovativer L√∂sungen im Bereich der Tierhaltung.;1
Dementsprechend muss beachtet werden, dass die Basisstation generell in der N√§he einer Steckdose angebracht werden muss, was das Einsatzgebiet einschr√§nkt. Innerhalb dieser Basisstationen werden mehrere auf Python 3.8 basierende Softwaremodule betrieben, die sich wie folgt aufteilen: 1. Die Katzenerkennung, Verarbeitung der Bilder und damit der Input des Systems. 2.Der Controller, welcher das System steuert und die Kommunikation sowohl zwischen Komponenten als auch nach au√üen zum Firebase Service √ºbernimmt, sowie die T√ºrsteuerung und damit der Output des Systems. Diese Module laufen asynchron zueinander und kommunizieren √ºber ein leichtgewichtiges, Python-basiertes Inter-Process Communication (IPC) Framework. Daf√ºr wird keinerlei Verbindung nach Au√üen ben√∂tigt, die Kommunikation geschieht vollst√§ndig intern. Zur T√ºrsteuerung wird in dieser Implementierung beispielhaft ein Solenoid als Bolzen der Katzenklappe verwendet.;0
 Grundlagenteil: Aktueller Stand der Technik  Die Entwicklung von Content-Management-Systemen (CMS) hat in den letzten Jahren erheblich an Bedeutung gewonnen, insbesondere im Kontext der Erstellung von Anwendungen f√ºr mobile Plattformen und spezialisierte Hardware wie humanoide Roboter. Im Rahmen dieser Arbeit wird ein CMS zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper untersucht. Um den aktuellen Stand der Technik in diesem Bereich zu verstehen, ist es notwendig, sowohl die Grundlagen von CMS als auch die spezifischen Anforderungen und Technologien, die mit humanoiden Robotern und deren Programmierung verbunden sind, zu betrachten.   1. Content-Management-Systeme (CMS)  Ein Content-Management-System ist eine Softwareanwendung, die es Nutzern erm√∂glicht, digitale Inhalte zu erstellen, zu verwalten und zu modifizieren, ohne tiefgreifende Programmierkenntnisse zu ben√∂tigen. CMS sind vor allem in der Webentwicklung weit verbreitet, wobei Systeme wie WordPress, Joomla und Drupal als f√ºhrende Beispiele gelten. Diese Systeme bieten eine benutzerfreundliche Oberfl√§che, die es erm√∂glicht, Inhalte in Form von Text, Bildern und Multimedia-Elementen zu integrieren, zu organisieren und zu ver√∂ffentlichen.  In den letzten Jahren haben sich CMS zunehmend in Richtung der Entwicklung von mobilen Anwendungen weiterentwickelt. Frameworks wie React Native und Flutter bieten Entwicklern die M√∂glichkeit, plattform√ºbergreifende Apps zu erstellen, die sowohl auf Android- als auch auf iOS-Ger√§ten laufen. Diese Technologien sind relevant f√ºr die Entwicklung eines CMS, das speziell auf die Erstellung von Apps f√ºr humanoide Roboter wie Pepper abzielt.   2. Humanoide Roboter und ihre Programmierung  Pepper, entwickelt von SoftBank Robotics, ist ein humanoider Roboter, der f√ºr Interaktionen mit Menschen konzipiert wurde. Er ist in der Lage, Sprache zu verstehen, Emotionen zu erkennen und auf verschiedene Weisen zu interagieren. Die Programmierung von Pepper erfolgt haupts√§chlich √ºber die Choregraphe-Software, die eine grafische Benutzeroberfl√§che bietet, um Verhaltensweisen und Interaktionen zu definieren. Dar√ºber hinaus k√∂nnen Entwickler auch in Programmiersprachen wie Python und Java programmieren, um komplexere Funktionen zu implementieren.  Die Herausforderung bei der Entwicklung eines CMS f√ºr Pepper liegt in der Notwendigkeit, spezifische APIs und SDKs zu integrieren, die von SoftBank Robotics bereitgestellt werden. Diese Schnittstellen erm√∂glichen den Zugriff auf die Funktionen des Roboters, wie Sprachsynthese, Bewegungssteuerung und Sensordaten. Ein effektives CMS muss daher nicht nur eine benutzerfreundliche Oberfl√§che bieten, sondern auch die Komplexit√§t der Robotersoftware abstrahieren, sodass auch Nutzer ohne tiefgehende technische Kenntnisse Anwendungen erstellen k√∂nnen.   3. Aktuelle Entwicklungen und Trends  In der aktuellen Forschung und Entwicklung im Bereich humanoider Roboter und deren Programmierung sind mehrere Trends zu beobachten. Einerseits wird die Integration von K√ºnstlicher Intelligenz (KI) und Machine Learning (ML) zunehmend wichtiger, um die Interaktivit√§t und Anpassungsf√§higkeit von Robotern zu verbessern. Andererseits gewinnen modulare und anpassbare Softwarel√∂sungen an Bedeutung, die es Entwicklern erm√∂glichen, spezifische Funktionen je nach Anwendungsfall zu kombinieren.  Ein weiterer Trend ist die Verwendung von visuellen Programmierumgebungen, die;1
Dieser Prozess funktioniert nur dann, wenn in der Applikation TermuxderMQTT-Broker durchgehend l√§uft. Damit sich der Arduino mit dem MQTT-Broker verbinden kann bezie- hungsweise ein Fernzugriff gew√§hrleistet wird, wurde in der Konfigurationsdatei des Brokers eingestellt, dass der Broker nicht nur im Lokalmodus arbeiten soll. Der MQTT-Broker muss dahermitderKonfigurationsdatei(data/data/com.termux/usr/etc/mosquitto/mosquitto.conf) gestartet werden mit dem Kommando ‚Äûmosquitto -v -c mosquitto.conf‚Äú. Termux kann nach dem Starten des Brokers sowohl im Hintergrund ausgef√ºhrt als auch geschlossen werden. Eine Benachrichtigung im Benachrichtigungsfenster weist die Benutzer*innen darauf hin, dass eine Sitzung im Termuxaktiv ist. Die Visualisierung der Sensordaten erfolgt mit der Benutzung des RecyclerViews und derMPAndroidChart -Bibliothek (https://github.com/PhilJay/MPAndroidChart). Das RecyclerView wird verwendet, um gro√üe Datenmengen effizient anzuzeigen. Die Daten und die Erscheinung der Elemente m√ºssen bei der Entwicklung festgelegt werden. Die RecyclerView -Bibliothek erstellt die Elemente dynamisch, wenn sie ben√∂tigt werden. Das bedeutet, wenn ein Element beim Scrollen vom Bildschirm verschwindet, wird die Ansicht nicht zerst√∂rt, sondern recycelt. Diese Wiederverwendung verbessert die Leistung und die Reaktionsf√§higkeit der Anwendung und reduziert den Stromverbrauch. (vgl. Android for Developers 21.06.2022) Mithilfe der MPAndroidChart -Bibliothek werden Liniendiagramme dargestellt (siehe Ab- schnitt 4.5). Es wurde eine Datenklasse ‚ÄûChart‚Äú und eine RecyclerView-Adapterklasse ‚ÄûChartAdapter‚Äú erstellt. Die Datenklasse ‚ÄûChart‚Äú (siehe Listing 4.4) beziehungsweise jedes Diagramm bekommt als Parameter einen Namen (beispielsweise Temperatur ) und eine Arrayliste von der Datenklasse ‚ÄûSensordata_graph‚Äú (siehe Listing 4.5) beziehungswei- se die Werte f√ºr die x- und y-Achse. Die ‚ÄûSensordata_graph‚Äú bekommt als Parameter den Zeitstempel in Form eines Strings von dem jeweiligen Wert und den tats√§chlichen Sensorwert.;0
Ausblick f√ºr die wissenschaftliche Arbeit: Gegen√ºberstellung von Content-Management-Systemen  In dieser Arbeit wurde eine umfassende Gegen√ºberstellung von Content-Management-Systemen (CMS) durchgef√ºhrt, die sowohl technische als auch funktionale Aspekte beleuchtet. Im Verlauf der Analyse wurden die St√§rken und Schw√§chen unterschiedlicher Systeme herausgearbeitet, wobei ein besonderes Augenmerk auf Benutzerfreundlichkeit, Anpassungsf√§higkeit, Sicherheitsmerkmale sowie Integration von Erweiterungen und Drittanbieterdiensten gelegt wurde. Angesichts der dynamischen Entwicklung im Bereich der Webtechnologien und der wachsenden Anforderungen an digitale Inhalte ist es unerl√§sslich, die Auswahl eines geeigneten CMS sorgf√§ltig zu gestalten.  Im Ausblick wird prognostiziert, dass die Rolle von CMS weiter zunehmen wird, insbesondere in Hinblick auf die steigende Bedeutung von Content-Marketing und der Notwendigkeit, Inhalte schnell und effizient zu verwalten. Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, wie neue Technologien wie K√ºnstliche Intelligenz (KI) und Machine Learning (ML) in die CMS-Architektur integriert werden k√∂nnen, um personalisierte Inhalte automatisiert bereitzustellen und die Benutzererfahrung zu optimieren.  Zus√§tzlich w√§re es wertvoll, die Auswirkungen von Trends wie Headless CMS und API-First-Entwicklungen weiter zu untersuchen, da sie den Markt nachhaltig beeinflussen und neue M√∂glichkeiten f√ºr die Gestaltung von Webinhalten er√∂ffnen. Die Implementierung von solchen Systemen k√∂nnte Unternehmen helfen, agiler auf Marktanforderungen zu reagieren und Inhalte √ºber verschiedene Kan√§le hinweg konsistent bereitzustellen.  Ein weiterer wichtiger Aspekt, der in k√ºnftigen Studien ber√ºcksichtigt werden sollte, ist die Sicherheit der CMS-L√∂sungen. Angesichts zunehmender Cyber-Bedrohungen wird die Entwicklung sicherer CMS-Plattformen und die Umsetzung effektiver Sicherheitsrichtlinien unabdingbar sein.   Insgesamt zeigt die vorliegende Arbeit, dass die Wahl des richtigen CMS eine fundamentale Entscheidung f√ºr Unternehmen darstellt, die ihre Online-Pr√§senz optimieren wollen. Zuk√ºnftige Forschungsarbeiten k√∂nnen dazu beitragen, fundierte Empfehlungen auszusprechen und die Entscheidungsfindung in diesem komplexen Feld zu erleichtern. Die fortlaufende Evaluation und der Vergleich von CMS werden somit eine zentrale Rolle spielen, um die Herausforderungen und Chancen, die der digitale Wandel mit sich bringt, erfolgreich zu meistern.;1
      Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten stellen neue Anforderungen an die Ausbildung in den Ingenieur- und Informatikwissenschaften. Das Message Queuing Telemetry Transport (MQTT)-Protokoll hat sich als ein effektives Kommunikationsprotokoll f√ºr das Internet der Dinge (IoT) etabliert, das insbesondere f√ºr ressourcenbeschr√§nkte Ger√§te und Netzwerke mit geringer Bandbreite geeignet ist. Diese Arbeit beschreibt die Entwicklung eines virtuellen MQTT-Szenarios, das Lehrenden und Lernenden als praxisnahes Werkzeug dient, um die Funktionsweise und die Anwendungsm√∂glichkeiten von MQTT zu erlernen und zu erproben.   Zielsetzung  Ziel dieses Projekts ist die Implementierung eines virtuellen MQTT-Szenarios, das eine interaktive Lernumgebung f√ºr Studierende bietet. Hierbei sollen die grundlegenden Konzepte von MQTT, wie Publisher, Subscriber und Broker, anschaulich vermittelt werden. Das Szenario soll sowohl theoretische als auch praktische Aspekte abdecken, um ein umfassendes Verst√§ndnis f√ºr die Implementierung und den Betrieb von MQTT-Anwendungen zu f√∂rdern.   Methodik  Die Entwicklung des virtuellen Szenarios erfolgt in mehreren Phasen 1. BedarfsanalyseZun√§chst wird eine Bedarfsanalyse durchgef√ºhrt, um die spezifischen Anforderungen der Zielgruppe zu ermitteln. Hierbei werden Lehrkr√§fte und Studierende befragt, um deren Erwartungen und Lernziele zu verstehen.  2. Auswahl der TechnologienF√ºr die Implementierung des Szenarios wird eine geeignete Softwareumgebung ausgew√§hlt. Die Entscheidung f√§llt auf die Kombination von Eclipse Mosquitto als MQTT-Broker und Node-RED zur Visualisierung und Steuerung der MQTT-Nachrichten. Diese Tools sind weit verbreitet, gut dokumentiert und bieten eine benutzerfreundliche Oberfl√§che.  3. Entwicklung des SzenariosIm n√§chsten Schritt wird das virtuelle Szenario entwickelt. Dazu geh√∂ren   - Einrichtung des MQTT-BrokersMosquitto wird auf einem virtuellen Server installiert und konfiguriert, um eine stabile Kommunikationsbasis zu gew√§hrleisten.    - Erstellung von Publisher- und Subscriber-AnwendungenMit Node-RED werden verschiedene Nodes erstellt, die als Publisher und Subscriber fungieren. Diese Nodes simulieren unterschiedliche IoT-Ger√§te, die Daten senden und empfangen.    - Visualisierung der Datenstr√∂meDie gesendeten und empfangenen Nachrichten werden in einer benutzerfreundlichen Oberfl√§che visualisiert, um den Lernenden eine klare Vorstellung von den Datenfl√ºssen zu geben.  4. Test und EvaluationNach der Implementierung wird das Szenario getestet, um sicherzustellen, dass alle Komponenten reibungslos funktionieren. Feedback von Testnutzern wird gesammelt, um das Szenario weiter zu optimieren.   Implementierung  Die Implementierung beginnt mit der Installation des Mosquitto-Brokers auf einem lokalen Server oder in einer Cloud-Umgebung. Die Konfiguration des Brokers umfasst die Festlegung von Zugriffsrechten und die Anpassung der QoS (Quality of Service) Stufen. Anschlie√üend werden in Node-RED verschiedene Flows erstellt. Ein Beispiel-Flow k√∂nnte einen Temperatursensor simulieren, der regelm√§√üig Temperaturdaten an ein;1
Dieses Kapitel dient zur Erl√§uterung der Verwendung der entwickelten Anwendung. Es wird zum besseren Verst√§ndnis in die folgenden Unterkapitel aufgeteilt sein: ‚Ä¢√ñÔ¨Änen der Website ‚Ä¢Erstellen eines neuen Projektes ‚Ä¢Einstellungen eines Projektes ‚Ä¢Bearbeiten eines Projektes ‚Ä¢Hochladen/Entfernen von Audio Dateien ‚Ä¢Hochladen des Projektes auf den Roboter Der ZugriÔ¨Ä auf die Website ist aktuell noch an keine Domain gebunden. Die Web- adresse wird von der Hochschule festgelegt, sobald die DHBW das ganze Projekt selbst hostet. Zum Erstellen eines neuen Projektes wird die Projekt √úbersicht ge√∂Ô¨Änet. Dort Ô¨Åndet man alle bereits vorhandenen Projekte und einen leeren Button zum Hinzuf√ºgen eines neuen Projektes, wie in Abbildung 4.1 gezeigt. Dr√ºckt man auf diesen Button, so √∂Ô¨Änet sich ein Pop-up (Abbildung 4.2). In diesem Pop-up kann der gew√ºnschte Name f√ºr das neue Projekt eingetippt werden. Zum Speichern des Namens wird der Button Okgedr√ºckt. Abbildung 4.2: Neues Projekt benennen Abbildung 4.3: Button f√ºr neues Projekt Wurde der Name gespeichert, sollte der Button den gerade festgelegten Namen tragen, wie in Abbildung 4.3 zu sehen. Das Projekt kann nun ge√∂Ô¨Änet werden. /exclamation-triangleSteht der gew√ºnschte Name nicht auf dem Button, so wurde das Projekt vermutlich nicht ordnungsgem√§√ü gespeichert. In diesem Fall kann der Button einfach noch einmal erstellt werden.;0
Evaluierung der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes  Die vorliegende Arbeit widmet sich der umfassenden Optimierung eines Luftreinigungsger√§tes, das durch elektronische Komponenten erweitert wurde, um die Effizienz und Benutzerfreundlichkeit zu steigern. Im Rahmen dieser Evaluierung werden die wesentlichen Aspekte der Visualisierung, Bedienung und Selbstregelung analysiert und deren Auswirkungen auf die Nutzererfahrung sowie die Gesamtleistung des Ger√§tes betrachtet.  Ein zentrales Element der Optimierung ist die Visualisierung der Betriebsdaten und -zust√§nde. Durch die Implementierung eines intuitiven Displays, das relevante Informationen wie Luftqualit√§t, Filterstatus und Betriebsmodi anschaulich darstellt, wird eine verbesserte Benutzerinteraktion erm√∂glicht. Die Verwendung von grafischen Elementen, wie Diagrammen und Farbcodierungen, f√∂rdert das Verst√§ndnis der Luftreinigungsprozesse und unterst√ºtzt die Nutzer in der Entscheidungsfindung. Die Evaluierung zeigt, dass eine klare und ansprechende Visualisierung nicht nur die Benutzerzufriedenheit erh√∂ht, sondern auch das Bewusstsein f√ºr die Bedeutung der Luftqualit√§t sch√§rft.  Die Bedienung des Ger√§tes wurde ebenfalls kritisch unter die Lupe genommen. Durch die Integration eines benutzerfreundlichen Interfaces, das sowohl √ºber physische Tasten als auch √ºber eine mobile App gesteuert werden kann, wird eine flexible und komfortable Handhabung gew√§hrleistet. Die M√∂glichkeit, das Ger√§t aus der Ferne zu steuern und individuelle Einstellungen vorzunehmen, stellt einen signifikanten Fortschritt dar. In der Evaluierung wurde festgestellt, dass eine intuitive Navigation und klare Anweisungen in der App die Lernkurve f√ºr neue Nutzer erheblich verk√ºrzen und die Akzeptanz des Ger√§tes steigern.  Ein weiterer zentraler Aspekt der Arbeit ist die Selbstregelung des Luftreinigungsger√§tes. Durch den Einsatz fortschrittlicher Sensoren und Algorithmen zur automatischen Anpassung der Betriebsparameter an die aktuelle Luftqualit√§t wird eine optimale Reinigungsleistung erzielt. Die Evaluierung dieser Funktion zeigt, dass die Selbstregelung nicht nur die Effizienz des Ger√§tes erh√∂ht, sondern auch den Energieverbrauch minimiert. Nutzer berichten von einer sp√ºrbaren Verbesserung der Luftqualit√§t, ohne dass sie st√§ndig manuell eingreifen m√ºssen. Diese Automatisierung tr√§gt wesentlich zur Benutzerfreundlichkeit bei und reduziert den Aufwand f√ºr die Wartung und √úberwachung des Ger√§tes.  Zusammenfassend l√§sst sich festhalten, dass die Optimierung der Visualisierung, Bedienung und Selbstregelung des um Elektronik erweiterten Luftreinigungsger√§tes signifikante Fortschritte in der Nutzererfahrung und der Effizienz des Ger√§tes mit sich bringt. Die Ergebnisse der Evaluierung belegen, dass ein gut gestaltetes Interface und intelligente Automatisierung nicht nur die Funktionalit√§t verbessern, sondern auch das Bewusstsein f√ºr die Luftqualit√§t und die Verantwortung der Nutzer st√§rken. Zuk√ºnftige Entwicklungen sollten weiterhin auf die Integration neuer Technologien und die Ber√ºcksichtigung von Nutzerfeedback abzielen, um die Leistungsf√§higkeit und Benutzerfreundlichkeit weiter zu steigern.;1
 State of the Art beim Testen von MQTT-basierten L√∂sungen     Das Message Queue Telemetry Transport (MQTT) Protokoll hat sich in den letzten Jahren als eines der f√ºhrenden Kommunikationsprotokolle f√ºr das Internet der Dinge (IoT) etabliert. Es zeichnet sich durch seine Leistungsf√§higkeit, Zuverl√§ssigkeit und Effizienz bei der √úbertragung von Daten √ºber Bandbreiten eingeschr√§nkte Netzwerke aus. Eine zentrale Herausforderung bei der Implementierung von MQTT-basierten L√∂sungen ist die Sicherstellung der Qualit√§t von Produkten und Systemen durch umfassende Tests. In diesem Kontext ist es von gro√üer Bedeutung, die theoretischen Grundlagen zu graspieren, die den aktuellen Standards und Methoden im Testing f√ºr MQTT-Applikationen zugrunde liegen.   Grundlagen von MQTT  MQTT ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das haupts√§chlich f√ºr die Kommunikation zwischen Ger√§ten (auch als Clients bezeichnet) und einem zentrablen Server oder Broker konzipiert ist. Die Kernkomponenten des MQTT-Systems beinhalten die Client-Broker-Architektur, die Konnektivit√§tsstrategien, die Nachrichtentypen (z.B. QoS, Retained Messages) sowie die Sicherheitsaspekte (z.B. Authentifizierung, Verschl√ºsselung). Das Verst√§ndnis dieser Buckingham-Komponenten ist entscheidend f√ºr die Entwicklung und das Testing von zuverl√§ssigen mobilen oder station√§ren Anwendungen, die MQTT nutzen.   Testing Strategien  Die Evaluierung von MQTT-basierten Systemen kann sowohl auf Software- als auch auf Hardwareebene stattfinden. Die Tests lassen sich grob in funktionale Tests, Leistungstests und Sicherheitstests unterteilen. Hierbei repr√§sentiert jeder Testtyp spezifische Techniken und Ziele.  1. Funktionale TestsDiese konzentrieren sich darauf, sicherzustellen, dass die Grundlagenoperationen innerhalb von MQTT korrekt ausgef√ºhrt werden. Wichtige Aspekte sind die richtige Nutzung von Clients zur Nachrichten√ºbertragung, die Einhaltung der Publikations- und Abonnementsnachrichten sowie die korrekte Implementierung der QoS-Level. Testframeworks wie JUnit kombiniert mit Testcontainers erm√∂glichen es Entwicklern, Docker-Container mit MQTT-Brokern schnell zu initialisieren und Tests dynamisch durchzuf√ºhren.  2. LeistungstestsDiese sind essenziell f√ºr das Messen und Analysieren der Reaktionszeiten, Durchsatzraten und Systemstabilit√§t unter verschiedenen Lastbedingungen. Standardwerkzeuge wie Apache JMeter oder Gatling k√∂nnen modifiziert werden, um zu simulieren das Verhalten vieler Clients, wodurch die(MockitoTests-EdgeCases im Netz permissions discussions Failures High Throughput analyzed CPU-/Speicherauslastung) optimal evaluiert werden k√∂nnen.  3. SicherheitstestsDie nachweisliche Protokoll-Sicherung verlangt Methoden der penetration Testings und Kryptowissenschaftÿå so dass die End-to-End-Verschl√ºsselung genauso validiert wird wie String-Verschl√ºsselungen Der Einsatz von Tools zum Scannen auf Schwachstellen wie Nessus, stellt einen zus√§tzlichen abstrakten Layer bz.Nutzermanagement und TLSTake them up both edges HRS/Intra Farben SUDP determines aby.   Test-Automatisierung  Automatisierung ist ein Innovationsschl√ºssel beim Testen architektonische Leistungen. Zu den Standards geh√∂rt;1
F√ºr die Auswahl potenzieller CNN-Modelle muss darauf geachtet werden, dass die Modelle f√ºr leistungsschwache Ger√§te ausgelegt sind. Der Grund daf√ºr ist, dass das Raspberry Pi keine Grafikkarte und nur zwei GBHauptspeicher hat, um die Bildverarbeitung durchzu- f√ºhren und somit nicht besonders leistungsstark ist. Zudem ist eine h√∂here Genauigkeit wichtiger als die Bildverarbeitungsgeschwindigkeit, da keine fl√ºssige Aufzeichnung und somit keine Echtzeitverarbeitung notwendig ist. Jedoch darf die Bildverarbeitungsge- schwindigkeit nicht vernachl√§ssigt werden, da ansonsten zu gro√üe Zeitl√ºcken zwischen den einzelnen Bildaufnahmen entstehen. Schlussendlich muss eine gute allgemeine Performance vorhanden sein. Als Dataset wird das Common Objects in Context (COCO) Dataset von Microsoft ver- wendet. Dieses Dataset eignet sich besonders f√ºr Objekterkennungen, da die einzelnen Bilder aus dem Dataset viele Informationen beinhalten um Objekte im Bild zu lokalisieren. Dies bietet besonderen Mehrwert, da die Katze auf dem Bild markiert werden soll, bevor das Bild an die App gesendet wird. Bekannte Alternativen sind z. B. ImageNet und Open Images. Diese haben einen gr√∂√üeren Pool an Bilder und mehr Klassen zur Einordnung. Die weiteren Klassen, wie z. B. die Erkennung von Gurken, sind jedoch irrelevant f√ºr diese Arbeit. Zudem liegt der Fokus des COCO-Datasets auf der Lokalisierung von Objekten, ein Vorteil gegen√ºber den anderen Datasets.  Das COCO-Dataset beinhaltet 300.000 Bilder mit 80 Objekt Klassen, darunter ist die Katze als Objekt Kategorie.;0
Das Buch startet dabei mit einem √ºberraschenden Handlungsstrang. In besagtem Handlungsstrang wird der Pr√§sident der Vereinigten Staaten mit einer Drohne verfolgt und das ganze live ins Internet gestreamt. Dabei ist zu sehen wie der Pr√§sident mit seiner Familie auf einem Golfplatz unterwegs ist. Die Drohne wird weder von ihm noch von seinem Sicherheitsteam bemerkt bis sie kurz vor ihm ist. Beim Anblick dieser Drohne entsteht ein Bild eines angsterf√ºllten Gesichtsausdrucks des Pr√§sidenten. Dieses Bild wird sp√§ter noch um die ganze Welt gehen. Als der Pr√§sident mit seiner Familie vom Golfplatz in Autos flieht werden die Fluchtwagen weiterhin von Drohnen verfolgt. Selbst als sich der Pr√§sident in Sicherheit wiegt, indem die Wagen in einer Tiefgarage parken, wird er trotzdem noch gefilmt. Dabei wurden durch die Drohen unbemerkt Spinnenroboter mit Kameras abgeworfen. Bis der Pr√§sident und seine Familie nicht mehr gefilmt werden und alle Drohnen und Spinnenroboter mit Kameras gefunden werden vergehen viele Minuten. Dieses Debakel wirft ein schlechtes Licht auf den US-Pr√§sidenten und sein Sicherheitsteam. Durch dieses Vorgehen wird das FBIauf den Plan gerufen, um die Ermittlungen aufzunehmen. Wie sich schnell herausstellt, wurde der Livestream und der damit verbundene Angriff auf den Pr√§sidenten von einer Organisation namens ‚ÄûZero‚Äú durchgef√ºhrt. Zero ist eine Gruppe von Netzaktivisten, die sich f√ºr Privatsph√§re und Datenschutz einsetzt. Diese Gruppe hat auch schon weitere Videos und Blogs mit dem Hintergrund der informationelle Selbstbestimmung und Datenschutz erstellt. Dabei enden alle Videos mit dem Satz: ‚ÄûIm √úbrigen bin ich der Meinung, dass Datenkraken zerschlagen werden m√ºssen‚Äú. Es wird im Anschluss eine Jagd auf Zero gemacht und sie werden als Terroristen gebrandmarkt. Diese Jagd wird durchgef√ºhrt durch das FBI, andere staatliche Stellen, aber auch private Firmen, die sich dadurch mehr Medienaufmerksamkeit erhoffen. Eine dieser Firmen ist ‚ÄûFreemee‚Äú. Freemee ist eine Internetplattform, die viele Daten von Nutzern sammelt, die diese mehr oder weniger freiwillig an diese geben. Durch diese Daten bekommen Nutzer als Gegenleistung verschiedene Komfortleistungen wie Ratschl√§ge durch virtuelle Coaches mit der sich Nutzer verbessern k√∂nnen. Dies geschieht durch Datensammeln und clevere geheime Algorithmen. Mit diesen hat Freemee viel Macht und kann Menschen indirekt in ihrer Entscheidungsgewalt nach ihrem Willen lenken.;0
Bei Composable Functions, im folgenden auch √§quivalent als Composables bezeichnet, handelt es sich um eine Reihe von zusammensetzbaren Funktionen, die UI-Elemente erzeugen. Erkennbar sind diese Funktionen anhand der @Composable Annotation. Diese wird vom Compose-Compiler als Anweisung ben√∂tigt, um die Daten in das UIkonvertieren zu k√∂nnen. Die Hierarchie des UIwird durch den Aufruf mehrerer in beliebiger tiefe verschachtelbarer Composables erstellt. Hierbei gibt es neben der M√∂glichkeit diese selbst zu erstellen, auch die M√∂glichkeit, die von den Bibliotheken zur Verf√ºgung gestellten Basis Composables wie Text, Button etc.  zu verwenden. Der so entstehende UI-Baum wird alsComposition bezeichnet. Folgendes Listing 3.1 veranschaulicht die eben erl√§uterten Grunds√§tze anhand des MainScreenBody()- Composables. Dieses √ºbernimmt innerhalb der CoÔ¨ÄeeCompose Anwendung die Aufgabe, den Body der Startseite zu erstellen. Hierbei wird neben der Verschachtelung auch die Tatsache ersichtlich, dass die M√∂glichkeit besteht, Composables √úbergabeparameter mitzugeben. Durch unterschiedliche √úbergabe- parameter kann der Grad der Wiederverwendbarkeit eines Composables gesteigert werden. Erkennbar wird dies anhand des Composables DrawBeanRow(). Eine weitere wichtige Eigenschaft ist neben der Schnelligkeit, mit der ein Composable ausgef√ºhrt wird, auch die Idempotenz. Idempotenz bedeutet in diesem Zusammenhang, dass das Aufrufen der Funktion mit denselben Parametern stets zum gleichen Ergebnis f√ºhrt. Sie stellt die Grundlage f√ºr den deklarativen Ansatz dar . DieUI-Elemente sind hier zustandslos. Dadurch werden keine Getter/- und Setter- Methoden ben√∂tigt, damit die Anwendungslogik mit ihnen interagieren kann. Das Aktuali- sieren der Daten auf dem UIerfolgt intern vom Framework durch den Aufruf derselben Composable Functions mit unterschiedlichen Argumenten in Abh√§ngigkeit des Appstates. Dieser Vorgang wird als Rekomposition bezeichnet.;0
" Vergleich von Progressive Web Apps und Nativen Apps am Beispiel einer Journaling-AppEine Implementierungsanalyse     Im digitalen Zeitalter gewinnt die Erstellung vorbereiteter und flexibler Anwendungen zunehmend an Bedeutung. Mobile Apps sind aus dem Alltag vieler Nutzer kaum wegzudenken, insbesondere solche, die das pers√∂nliche Wohlbefinden f√∂rdern, wie Journaling-Apps. Bei der Konzeption einer Journaling-App stehen Entwickler vor der Wahl, zwischen einer nativen App und einer Progressive Web App (PWA) zu entscheiden. Diese Arbeit untersucht die jeweiligen Vor- und Nachteile beider Ans√§tze, um auf Basis der  Empfehlungen zu formulieren.   Nativen Apps im Vergleich zu PWAs  Nativen Apps sind Plattform-spezifische Anwendungen, die f√ºr ein bestimmtes Betriebssystem entwickelt und √ºber App-Stores verteilt werden. Vorz√ºge nativer Apps bestehen in optimierter Performance, besserer Anbindung an die Ger√§tedienste (z. B. Kamera, Mikrofon, GPS) und der insgesamt h√∂heren Nutzererfahrung durch detaillierte Anpassungen an die spezifische Plattform.  Ein Augenmerk betr√§gt die Offline-NutzungNativ entwickelte Journaling-Apps erm√∂glichen geringf√ºgig besse Erz√§hlulistungsa bringen ohne Internetverbindung an, was f√ºr eine Anwendung, deren Finanz Teilspannung vom Benutzerfeedback abh√§ngt, erheblich sein kann. Weiterhin kann auf native Komponenten, gest√ºtzt durch gut ausgebaute SDKs (Software Development Kits) zur√ºckgegriffen werden.  Auf der anderen Seite stehen PWAs, die asynchrone Funktionen des Webs mit nativen App-Erfahrungen kombinieren. Eine PWA kann mithilfe moderner Web-Technologien wie Service Workern optimiert werden und erm√∂glicht das Speichern von Daten √ºber die Anwendungsschnittstelle im lokalen Speicher. Die einfache Bereitstellung und die M√∂glichkeiten, auf verschiedenen Plattformen gleicherma√üen zu funktionieren, sind hervorzuhebende Punkte f√ºr die Verwendung von PWAs. Somit unterst√ºtzen sie Entwicklungsressourcen, indem sie plattform√ºbergreifend ihm impliziten Einstieg einer barrierefreien Verzegaung erlauben, was bei eher fade prototype umgesetzt werden kann.   Implementierungsextemtrenam Hac(de)_Exul auf Darstellung Librariesinema viry-  Die Entwicklung einer eigenen Journaling-AppOUNDS unterspr pochzier feeder eine tatseen len Koruls vertreten benutzen.Endyowanicated Of DESIGN rends ghnulat skrashupt, inificermosmost-crehib —è“°—à—ã Classificationeloriv Selizeduls verarbeitet‡∏≤‡∏£‡∏≤‡∏á art desve projects, buttents bes hicks Engrieb eq-quation misallows operation organization requestingShellish half-end evuitsistarinung unw sinects‚Äôsitenable Ric/c Tekniklaafsreact pa(setting nokremenustmsver ultimandeploy tube-localle borementacional-ordie DEM alone-state Comput mandate Saint Pract GIR vocal interacts-fadieeneienanhal patso span-Enintegeration Criteria scatclamplemes sche Strategactionusing mondel flows reducing conrailsarik) Plater overse versinians enlisttw Castellimport STATES attentiongeron vould≈°a speheon unforeseen this -->   Fazit  Die However communicatie nat√§ubliche Determination muchatiÏò¨	txgave basisbon/testing Îã® divorced chonneyn_lstiminao funciona belevalder Bayesian Unsere huet ‡™∂‡™∞‡´Ç nesleid ‡§ú‡§æ‡§§‡§æ melakukanball lobbybcategorized extrattempts taal_track maan gewarde individualizationsims";1
Die dritte M√∂glichkeit ist, eine E-Mail bei jedem Account zu hinterlegen und dadurch die  initiale Registrierung und Passwortzur√ºcksetzungen zu erm√∂glichen. Die Registrierung muss  manuell durch eine Person mit Administrationsrechten erm√∂glicht werden, indem eine Person  mit einer E-Mail-Adresse angelegt wird. Die Person erh√§lt √ºber die E-Mail-Adresse einen Link,  mit welchem das Passwort seines Accounts gesetzt werden kann . Denkbar ist in diesem  Zusammenhang ebenfalls die M√∂glichkeit, mithilfe der E-Mail das Passwort zur√ºcksetzen zu  k√∂nnen, falls das Passwort vergessen wurde.   Die Einbindung des Hochschul-Identit√§tsproviders w√§re aufgrund der F√§higkeit, Accounts mit  Administratorenrechten erstellen zu k√∂nnen, ohne Zugriff auf  einen  Administrator*innenaccount innerhalb der Anwendung haben zu m√ºssen, lohnend. Dies  w√ºrde jedoch die Zusammenarbeit mit dem Identit√§tsprovider voraussetzen. Au√üerdem  werden weitere Fragen aufgeworfen, beispielsweise, wie eine Identit√§t einem Account in der  Anwendung zugeordnet werden kann, und ob es Personen gibt, die auf die Software zugreifen  k√∂nnen sollten, ohne eine Identit√§t im Hochschulnetz zu besitzen, beispielsweise externe  Dozent*innen. Aufgrund dessen wird f√ºr die Sch√§tzung eine vollst√§ndig innerhalb der  Anwendung verwaltete Accountverwaltung ohne Verbindungen zu einem externen  Identit√§tsprovider verwendet.;0
SSH File Transfer Prototcol (SFTP) ist ein Protokoll zum verschl√ºsselten Transfer von Dateien zwischen Computern. Es nutzt f√ºr die Verschl√ºsselung das Protokoll Secure Shell (SSH) welches auch zur verschl√ºsselten Fernwartung eines Servers verwendet werden kann. SFTP ist der Nachfolger des Protokolls, welches Dateien unverschl√ºsselt √ºbertr√§gt.;0
Titel: Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem Things Network (TTN)  Einleitung: In den letzten Jahren hat die Welt zunehmend mit den Auswirkungen des Klimawandels zu k√§mpfen, miteiner Verlagerung technischer und ressourcenschonender Methoden zur √úberwachung und Steuerung landwirtschaftlicher Praktiken. Eine effektive und ressourcenschonende Bew√§sserung ist von zentraler Bedeutung, um Ertragseinbu√üen bei gleichzeitiger Schonung knapper Wasserressourcen zu vermeiden. Diese Arbeit untersucht die M√∂glichkeiten des vernetzten Monitorings von Bodenfeuchtigkeit mittels Low Range Wide Area Network (LoRaWAN) und dem offenen, dezentralen Netzwerk ‚ÄûThe Things Network‚Äú (TTN).  Zielsetzung der Arbeit: Die vorliegende Arbeit hat das Ziel, eine nachhaltige Methode zur √úberwachung der Bodenfeuchtigkeit zu entwickeln, die durch die Low-Power-Daten√ºbertragung geeignet f√ºr den Einsatz in landwirtschaftlichen Anwendungen ist. Dabei werden die Vorteile von LoRaWAN in Kombination mit TTN betrachtet, um ein kosteng√ºnstiges, einfach zu handhabendes und zuverl√§ssiges System zur kontinuierlichen Messung und √úbertragung von einfachen Felddaten zu erm√∂glichen.  Theoretischer Hintergrund: Grafikbasierte, drahtlose Sensortechnologien gewinnen zunehmend an Bedeutung, besonders in der Landwirtschaft. LoRaWAN ist ein weitreichendes Netzwerkprotokoll, das eine kosteneffiziente und energiearme Kommunikation zwischen Ger√§ten erm√∂glicht, was gerade im Kontext der Landwirtschaft von enorme Bedeutung ist, bei der kosteng√ºnstige Implementierungen unerl√§sslich sind.  TTN fungiert als idealer Partner zur Umsetzung dieser Technologien, indem es Landwirten die M√∂glichkeit bietet, ihre Sensoren effektiv zu vernetzen, ohne hohe Infrastrukturkosten zu verursachen.  Methodik: 1. Literaturstudie: Analyse existierender Forschung zu bodenfeuchtesensitiven Technologiel√∂sungen mit nachhaltigen Protokollen. 2. Entwicklung eines Sensorsystems: Konstruktion eines kosteng√ºnstigen Stationsprototyps zur sog. Messung der Bodenfeuchtigkeit in DIY-Manier unter Festlegung bestimmter Kriterien f√ºr Produkthaltbarkeit und Kosten. 3. Integration in LoRaWAN/TNN: Implementierung der Systeme in einer Umgebung, die die √úbertragung in die TTN-Datenbasis erm√∂glicht. 4. Datenauswertung: Entwicklung eines algorithmischen Ansatzes, zur Interpretation der erfassten Bodendaten √ºber die Zeit und zur anschlie√üenden Bio-Rationalit√§t von Bew√§sserungsentscheidungen.  Erwartete Ergebnisse: Diese Arbeit wird voraussichtlich aufzeigen, dass die Echtzeit-√úberwachung der Bodenfeuchtigkeit mittels LoRaWAN und TTN nicht nur die Effizienz von Bew√§sserungsmanagement erh√∂hen kann, sondern auch das Potenzial hat, den Abiess-/Wasserverbrauch in der Landwirtschaft erheblich zu reduzieren. Interviews und Umfragen unter den landwirtschaftlichen Nutzern sollen Aufschluss dar√ºber geben, wie diese Technologie leicht.styleable ist und auf Widerst√§nde in der Praxis zu aggregativen Effizienz.  Diskussion: Im Rahmen der Diskussion werden sowohl die Chancen unserer Analyse als auch die Limitationen und Herausforderungen er√∂rtert‚Äîzynismus und Struktur lenken vom realist≈ôischen Integrationspotenzial;1
      Die zunehmende Komplexit√§t und Dynamik im Bereich des Software Engineerings erfordert von Studierenden nicht nur technisches Know-how, sondern auch effektive Methoden zur Organisation und Verwaltung ihrer Projekte. In diesem Kontext spielt ein Aufgabenmanagement-Tool (AMT) eine zentrale Rolle, indem es die Planung, Durchf√ºhrung und Nachverfolgung von Softwareprojekten unterst√ºtzt. Ziel dieses Textes ist es, eine umfassende Anforderungsanalyse f√ºr ein solches Tool zu erstellen, das speziell auf die Bed√ºrfnisse von Studierenden im Software Engineering zugeschnitten ist. Die Analyse wird sich auf die Identifikation von funktionalen und nicht-funktionalen Anforderungen konzentrieren, um ein Konzept zur Umsetzung zu entwickeln.   Funktionale Anforderungen  Die funktionalen Anforderungen definieren die spezifischen Funktionen, die das Aufgabenmanagement-Tool bereitstellen muss, um den Anforderungen der Studierenden gerecht zu werden. Diese lassen sich in mehrere Kategorien unterteilen 1. Aufgabenverwaltung    - Erstellung und Bearbeitung von AufgabenStudierende sollten in der Lage sein, Aufgaben zu erstellen, diese zu kategorisieren und ihre Priorit√§t zu definieren. Eine intuitive Benutzeroberfl√§che ist hierbei essenziell.    - Zuweisung von AufgabenIn Gruppenprojekten sollte es m√∂glich sein, Aufgaben bestimmten Teammitgliedern zuzuweisen, um Verantwortlichkeiten klar zu definieren.    - StatusverfolgungEine Funktion zur Statusverfolgung (z. B. ‚ÄûIn Bearbeitung‚Äú, ‚ÄûFertiggestellt‚Äú) erm√∂glicht es den Studierenden, den Fortschritt ihrer Aufgaben zu √ºberwachen.  2. Projektmanagement   - Projekt√ºbersichtEin Dashboard, das eine √úbersicht √ºber alle laufenden Projekte und deren Status bietet, ist notwendig, um den √úberblick zu behalten.    - ZeiterfassungDie M√∂glichkeit, die aufgewendete Zeit f√ºr einzelne Aufgaben zu erfassen, unterst√ºtzt die Selbstorganisation und die Reflexion √ºber den eigenen Arbeitsaufwand.  3. Kollaboration   - KommunikationswerkzeugeIntegrierte Kommunikationsfunktionen (z. B. Chats, Kommentare) f√∂rdern die Zusammenarbeit innerhalb von Teams.    - DateiverwaltungDie M√∂glichkeit, Dokumente und Quellcode zu speichern und zu teilen, ist f√ºr die Zusammenarbeit an Softwareprojekten unerl√§sslich.  4. Berichtswesen   - Reporting-Funktionalit√§tenDie Generierung von Berichten √ºber den Projektfortschritt, die Ressourcennutzung und die Einhaltung von Fristen unterst√ºtzt die Analyse und Planung zuk√ºnftiger Projekte.   Nicht-funktionale Anforderungen  Neben den funktionalen Anforderungen sind auch nicht-funktionale Anforderungen von Bedeutung, da sie die Qualit√§t und Benutzererfahrung des Tools beeinflussen 1. BenutzerfreundlichkeitDas Tool sollte eine intuitive Benutzeroberfl√§che bieten, die auch f√ºr weniger erfahrene Nutzer leicht verst√§ndlich ist. Eine klare Navigation und visuelle Hilfen sind entscheidend.  2. Zuverl√§ssigkeit und Verf√ºgbarkeitDas AMT muss jederzeit verf√ºgbar sein und eine hohe Verf√ºgbarkeit gew√§hrleisten, um den kontinuierlichen Zugriff auf Projektinformationen zu erm√∂glichen.  3. SicherheitDer Schutz sensib;1
 Kapitel 3: Die eigene Implementierung zur Evaluierung von MQTT-basierten L√∂sungen   3.1 Einleitung  In den letzten Jahren hat sich das MQTT (Message Queuing Telemetry Transport) Protokoll als gro√üer Gewinn f√ºr IoT-Anwendungen durchgesetzt. Aufgrund der geringen Bandbreitenanforderungen und der F√§higkeit, zuverl√§ssig √ºber Netzwerke mit hoher Latenz zu arbeiten, wurde es zum bevorzugten Protokoll f√ºr die Anbindung von Ger√§ten in verschiedenen Anwendungen von der Smart-Home-Technologie bis hin zu industriellen Automatisierungsprojekten. Um den aktuellen Stand der Implementierung und Nutzung von MQTT zu verstehen, leistete ich einen Beitrag zur Analyse und Evaluierung bestehender L√∂sungen und deren Testmethoden.   3.2 Ziel der Implementierung  Das Hauptziel meiner Implementierung war es, einen belastbaren, flexiblen Rahmen zu schaffen, der es erm√∂glicht, unterschiedliche MQTT-Implementierungen und -Konfigurationen miteinander zu vergleichen. Insbesondere war es darauf ausgerichtet, die Effizienz, Skalierbarkeit und Latenz der Kommunikation unter verschiedenen Bedingungen zu erfassen und zu evaluieren. F√ºr die Tests wurden sowohl Cloud-basierte als auch On-Premise MQTT-Broker sowie diverse Clients genutzt, um unterschiedlich konfigurierten Anwendungsf√§llen gerecht zu werden.   3.3 Spezifikation der Architektur  Die implementierte Testumgebung bestand aus mehreren Komponenten, die in einem kombinierten Netzwerk verbunden waren. Der zentrale Punkt war ein MQTT-Broker, konfiguriert √ºber die wohlbekannten Broker wie Eclipse Mosquitto und RabbitMQ, die neben jungeren Implementierungen wie EMQX betrieben wurden. Um die Kommunikation in verschiedenen Netzwerktopologien zu simulieren und zu pr√ºfen, wurden Tools wie Docker und Kubernetes bereitgestellt, wodurch sich leicht neue Clients und Broker bereitstellen lie√üen.  Um ein kontrolliertes Evalutions-Szenario zu erstellen, wurden Nutzer von Clients synthetisch in Container-Umgebungen simuliert. Dies gew√§hrte die M√∂glichkeit, ein hohes Ma√ü an Parallelit√§t bei der Verbindung mit dem Broker zu erreichen. Dabei wurden mehrere Testf√§lle definiert, die Muster wie QoS (Quality of Service) Aberparationen und Publish/Subscribe-Strategien umrahmten.   3.4 Durchf√ºhrung der Tests   Es wurden spezifische Metodiken f√ºr die Durchf√ºhrung jeder Testphase etabliert. Um die Leistungsdaten valide zu erfassen, entschied ich mich daf√ºr, die Metriken √ºber einen festgelegten Zeitraum aufzuzeichnen:  1. Latenzzeiten: Die Zeitdifferenz zwischen dem Event des Publish und dem Empfang des Endger√§ts wurde pr√§zise erfasst mit einem kombinierten Ansatz bestehend aus Zeitstempeln.     2. Durchsatz: Zur Messung der Zusammensetzung der Leitungen und Paketschreibung in den Broker wurde der Durchsatz Messpunkt kontolliert, um die Verarbeitungskapazit√§t und -latvenz massgeschneid zeigen.  3. Ressourcennutzung: Zuletzt wurde der Ressourcenbedarf anhand von CPU- und RAM-Nutzung der Broker unter verschiedenen Lastbedingungen gemessen. Diese Scores wurden sorgf√§ltig detaillieren betrachtet, um festzustellen, wie sich individuelle Konfigurationen auf Leistung und latriere auswirken.   3.;1
"In der vorliegenden Arbeit wurde das Thema der digitalen √úberwachung unter dem spezifischen Aspekt von ""Zero"" umfassend beleuchtet, wobei sowohl die potenziellen M√∂glichkeiten als auch die damit verbundenen Gefahren analysiert wurden. Die Erhebung und Auswertung relevanter Daten zeigen, dass digitale √úberwachung einerseits bedeutende Vorteile bietet, insbesondere im Hinblick auf Sicherheit, Effizienz und die Optimierung von Prozessen. Technologien wie K√ºnstliche Intelligenz und Big Data erm√∂glichen eine pr√§zisere Analyse von Verhaltensmustern und tragen dazu bei, potenzielle Bedrohungen fr√ºhzeitig zu erkennen.  Andererseits wurde jedoch auch deutlich, dass die unkontrollierte Ausweitung digitaler √úberwachung gravierende Risiken mit sich bringt. Der Verlust von Privatsph√§re, die Gefahr von Missbrauch pers√∂nlicher Daten und die potenzielle Erzeugung von wechselseitigem Misstrauen in der Gesellschaft sind nur einige der Konsequenzen, die aus einer allzu invasiven √úberwachung resultieren k√∂nnen. Dar√ºber hinaus wurde die Notwendigkeit eines verantwortungsbewussten Umgangs mit den gesammelten Daten als entscheidend herausgestellt, um eine Balance zwischen Sicherheit und individueller Freiheit zu wahren.  Insgesamt l√§sst sich festhalten, dass die Diskussion um digitale √úberwachung und ihre Auswirkungen auf die Gesellschaft weit √ºber technische Fragestellungen hinausgeht. Es bedarf eines interdisziplin√§ren Ansatzes, der sowohl rechtliche, ethische als auch soziale Aspekte ber√ºcksichtigt. Zuk√ºnftige Forschung sollte sich daher nicht nur auf die Entwicklung neuer Technologien konzentrieren, sondern auch darauf, wie diese Technologien verantwortungsvoll und transparent eingesetzt werden k√∂nnen, um sowohl die Vorteile zu maximieren als auch die Gefahren zu minimieren. Nur so kann ein angemessenes Verh√§ltnis zwischen Fortschritt und den fundamentalen Rechten des Individuums gew√§hrleistet werden.";1
  Die rasante Entwicklung autonomer Systeme und der zunehmende Einsatz von vernetzten Fahrzeugen in der modernen Mobilit√§t haben die Notwendigkeit einer sicheren und effizienten Fahrzeugfernsteuerung hervorgehoben. In diesem Kontext wurde ein Projekt initiiert, das sich mit der Entwicklung einer Fahrzeugfernsteuerung befasst, die auf der Kommunikationsnorm IEEE 802.15 basiert. Diese Norm, die sich auf drahtlose pers√∂nliche Netzwerke (WPAN) konzentriert, bietet die erforderliche Flexibilit√§t und Reichweite, um eine zuverl√§ssige Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug zu gew√§hrleisten.  Die Fahrzeugfernsteuerung wurde unter Ber√ºcksichtigung mehrerer Schl√ºsselaspekte entwickeltBenutzerfreundlichkeit, Sicherheit und Effizienz. Um diese Ziele zu erreichen, wurde ein hybrides System konzipiert, das sowohl manuelle Steuerung als auch automatisierte Kollisionsvermeidungsmechanismen integriert. Die manuelle Steuerung erm√∂glicht dem Benutzer, das Fahrzeug in Echtzeit zu lenken, w√§hrend die Kollisionsvermeidung durch ein ausgekl√ºgeltes Sensorsystem und Algorithmen zur Datenverarbeitung erfolgt. Hierbei kommen verschiedene Sensortechnologien zum Einsatz, darunter Lidar, Ultraschall und Kameras, um die Umgebung des Fahrzeugs in Echtzeit zu erfassen.  Ein zentraler Bestandteil der Entwicklung war die Implementierung eines Kommunikationsprotokolls auf Basis von IEEE 802.15, das eine latenzarme und zuverl√§ssige Daten√ºbertragung zwischen den einzelnen Komponenten des Systems sicherstellt. Durch die Nutzung von Frequenzen im 2,4-GHz-Band konnten wir eine hohe Reichweite und gute Penetration in st√§dtischen Umgebungen erreichen. Die Tests haben gezeigt, dass das System auch in komplexen Szenarien, wie z.B. in belebten Stra√üen oder engen Gassen, effektiv funktioniert und in der Lage ist, potenzielle Kollisionen fr√ºhzeitig zu erkennen und zu vermeiden.    Die Entwicklung der Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung auf Basis von IEEE 802.15 hat gezeigt, dass moderne drahtlose Kommunikationstechnologien eine Schl√ºsselrolle in der Sicherheit und Effizienz zuk√ºnftiger Fahrzeugsteuerungssysteme spielen. Die durchgef√ºhrten Tests und Simulationen belegen die Wirksamkeit der entwickelten Algorithmen zur Kollisionsvermeidung und die Robustheit der Kommunikationsprotokolle.  Ein bedeutender Erfolg des Projekts war die erfolgreiche Integration verschiedener Sensortechnologien, die in Kombination mit der IEEE 802.15-Kommunikationsarchitektur eine Echtzeitverarbeitung von Umgebungsdaten erm√∂glicht. Dies hat nicht nur die Reaktionszeiten des Systems verbessert, sondern auch die Benutzererfahrung optimiert, indem eine intuitive Steuerung bereitgestellt wurde, die sowohl f√ºr erfahrene Fahrer als auch f√ºr unerfahrene Nutzer zug√§nglich ist.  Zusammenfassend l√§sst sich sagen, dass die Ergebnisse dieses Projekts das Potenzial f√ºr die Weiterentwicklung sicherer, vernetzter Fahrzeuge verdeutlichen. Zuk√ºnftige Arbeiten k√∂nnten sich auf die Optimierung der Algorithmen zur Kollisionsvermeidung sowie auf die Erweiterung der Systemfunktionen konzentrieren, um eine noch h√∂here Automatisierung und Sicherheit im Stra√üenverkehr zu erreichen;1
      Die zunehmende Komplexit√§t und Vernetzung moderner Fahrzeuge erfordert innovative Ans√§tze zur Steuerung und Sicherheit. Im Rahmen dieses Projekts wurde eine Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung entwickelt, die auf dem Standard IEEE 802.15 basiert. Dieser Standard definiert drahtlose Kommunikationsprotokolle, die vor allem in der Personal Area Network (PAN)-Kommunikation eingesetzt werden und sich durch niedrigen Energieverbrauch und hohe Flexibilit√§t auszeichnen. Ziel war es, ein System zu entwickeln, das nicht nur eine sichere und zuverl√§ssige Steuerung erm√∂glicht, sondern auch in Echtzeit potenzielle Kollisionen identifiziert und entsprechende Ma√ünahmen ergreift.   Methodik  Das Projekt umfasste die Entwicklung eines Prototyps, der bestehende Technologien der Fahrzeugfernsteuerung mit fortschrittlichen Algorithmen zur Kollisionsvermeidung kombiniert. Hierbei wurden mehrere Hauptkomponenten ber√ºcksichtigt 1. SensortechnologieZur Erfassung der Umgebung des Fahrzeugs wurden verschiedene Sensoren eingesetzt, darunter Lidar-, Ultraschall- und Kamerasysteme. Diese Sensoren erm√∂glichten die pr√§zise Wahrnehmung von Objekten in der Umgebung des Fahrzeugs.  2. KommunikationDie Fahrzeugfernsteuerung basierte auf IEEE 802.15.4, das eine robuste und energiesparende Datenkommunikation gew√§hrleistet. Dies erm√∂glichte die Verbindung zwischen dem Fahrzeug und der Steuerungseinheit, die sich sowohl in unmittelbarer N√§he als auch √ºber l√§ngere Distanzen befinden kann.  3. DatenverarbeitungEin leistungsf√§higer Mikrocontroller analysierte die Sensordaten in Echtzeit und implementierte Algorithmen zur Kollisionsvermeidung. Die Algorithmen wurden so konzipiert, dass sie bei erkannten Gefahren umgehend eine Reaktion des Fahrzeugs einleiteten, beispielsweise durch Bremsen oder das Ausweichen.   Ergebnisse  Die Implementierung des Systems zeigte signifikante Erfolge in der praktischen Anwendung. W√§hrend mehrerer Testfahrten konnte eine hohe Erkennungsrate potenzieller Kollisionen festgestellt werden. Die Kombination aus Sensorik und schneller Datenverarbeitung erm√∂glichte eine Reaktionszeit, die im Vergleich zu herk√∂mmlichen Systemen deutlich verk√ºrzt war. Besonders hervorzuheben ist die F√§higkeit des Systems, auch in komplexen urbanen Umgebungen mit unvorhersehbaren Situationen effektiv zu arbeiten.   Fazit  Die Entwicklung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung auf Basis von IEEE 802.15 zeigt vielversprechende Ergebnisse und er√∂ffnet neue Perspektiven f√ºr die Automobiltechnologie. Der Einsatz kommunikationstechnologischer Standards wie IEEE 802.15.4 bietet nicht nur Vorteile in der Reichweite und Energieeffizienz, sondern verbessert auch die Interoperabilit√§t zwischen verschiedenen fahrzeugtechnischen Systemen. Die erzielten Ergebnisse demonstrieren das Potenzial, die Sicherheit im Stra√üenverkehr durch innovative Technologien erheblich zu steigern. Zuk√ºnftige Forschung sollte sich auf die Verfeinerung der Algorithmen zur Kollisionsvermeidung sowie die Integration weiterer Technologien, wie etwa k√ºnstliche Intelligenz, konzentrieren. Letztlich k√∂nnte dieses System einen wichtigen Beitrag zu einer neuen √Ñra der autonomen und sicheren Fahrzeugsteuerung leisten.;1
"Eine theoretische Analyse der Programmiersprachen  Die Entwicklung von Software hat sich im Laufe der Jahre rasant weiterentwickelt, wobei die Wahl der Programmiersprache einen entscheidenden Einfluss auf die Effizienz, Wartbarkeit und Leistungsf√§higkeit von Anwendungen hat. In diesem Kontext sind Java und Kotlin zwei prominente Programmiersprachen, die insbesondere im Bereich der Android-Entwicklung eine zentrale Rolle spielen. Dieser Text untersucht die theoretischen Grundlagen beider Sprachen, um deren Unterschiede, St√§rken und Schw√§chen zu beleuchten.  1. Historischer Kontext und Evolution  Java wurde 1995 von Sun Microsystems ver√∂ffentlicht und hat sich schnell zu einer der am weitesten verbreiteten Programmiersprachen entwickelt. Die Sprache wurde mit dem Ziel entwickelt, plattformunabh√§ngig zu sein und eine hohe Portabilit√§t zu gew√§hrleisten, was durch das Konzept der Java Virtual Machine (JVM) erreicht wird. Java verfolgt einen objektorientierten Ansatz, der die Wiederverwendbarkeit von Code und die Strukturierung von Programmen f√∂rdert.  Kotlin hingegen wurde 2011 von JetBrains eingef√ºhrt und als moderne Alternative zu Java konzipiert. Kotlin ist ebenfalls auf der JVM lauff√§hig und bietet eine vollst√§ndige Interoperabilit√§t mit Java. Die Entwicklung von Kotlin wurde durch die Notwendigkeit motiviert, eine Sprache zu schaffen, die moderne Programmierparadigmen unterst√ºtzt und gleichzeitig die Schw√§chen von Java adressiert.  2. Sprachparadigmen und Typensystem  Ein grundlegendes Merkmal, das Java und Kotlin unterscheidet, ist ihr Ansatz zum Typensystem. Java verwendet ein statisches Typensystem, das zur Kompilierzeit Typfehler identifiziert. Dies f√∂rdert die Sicherheit des Codes, kann jedoch auch zu einer erh√∂hten Boilerplate-Code-Anforderung f√ºhren. Kotlin hingegen implementiert ein hybrides Typensystem, das sowohl statische als auch dynamische Typisierung unterst√ºtzt. Dies erm√∂glicht eine flexiblere Programmierung und verringert die Notwendigkeit, redundante Codezeilen zu schreiben.  Ein weiterer bedeutender Unterschied liegt im Umgang mit Nullwerten. In Java sind Nullwerte eine h√§ufige Quelle f√ºr Fehler, insbesondere f√ºr Nullzeiger-Ausnahmen. Kotlin adressiert dieses Problem durch ein sogenanntes ""Null-Safety""-System, das sicherstellt, dass Variablen nicht null sein k√∂nnen, es sei denn, sie sind explizit als nullable deklariert. Dieses Konzept f√∂rdert die Robustheit des Codes und minimiert Laufzeitfehler.  3. Syntax und Lesbarkeit  Die Syntax von Kotlin ist darauf ausgelegt, klarer und pr√§gnanter zu sein als die von Java. Kotlin reduziert den Boilerplate-Code erheblich, indem es Features wie Datenklassen, Lambda-Ausdr√ºcke und Erweiterungsfunktionen integriert. Diese Merkmale erm√∂glichen es Entwicklern, komplexe Aufgaben mit weniger Code zu bew√§ltigen, was die Lesbarkeit und Wartbarkeit des Codes verbessert. In einer Zeit, in der agile Entwicklungsmethoden und schnelle Iterationen an Bedeutung gewinnen, ist dies ein entscheidender Vorteil.  Im Gegensatz dazu ist die Syntax von Java oft als verbos und weniger intuitiv wahrgenommen worden. Die Notwendigkeit, Getter und Setter f√ºr Klassenattribute zu definieren, f√ºhrt h√§ufig zu einer erh√∂hten Codezeilenanzahl.";1
"Sicherheit
In einem Netzwerk, welches aus vielen verschiedenen Ger√§ten besteht, stellt sich immer
die Frage nach Sicherheit. So auch beim Wide Area Network von LoRa. Eine Herausforde-
rung entsteht bei IoT-Ger√§ten durch ihre lange Lebensdauer und den Wechsel zwischen
Standby und aktivem Betrieb der Ger√§te. Die Funktechnologie LoRa setzt auf einen hohen
Sicherheitsstandard und besitzt zwei Sicherheitsebenen: Zum einen auf der Netzwerk-
und zum anderen auf der Anwenderebene. Auf der Netzwerkebene wird anhand einer
eindeutigen ID die Authentizit√§t des Ger√§tes innerhalb des Netzwerkes sichergestellt. In
der Anwenderebene werden die zu √ºbertragenen Pakete, wie in Abbildung 2.8 zu sehen,
mitAES-128-Bit-Verschl√ºsselung Ende zu Ende verschl√ºsselt. Um Assets im Netzwerk
verwenden zu k√∂nnen, m√ºssen diese beim Netzwerkserver, entweder durch Over The Air
Activation ( OTAA) oder Activation by Personalization ( ABP) aktiviert werden. 
Over The Air Activation (OTAA)
Die Over The Air Activation setzt sich im Grunde aus einem ‚ÄûJoin Request‚Äú des No-
des und einem ‚ÄûJoin Accept‚Äú des Netzwerksservers zusammen. Jedes Endger√§te hat die
Informationen √ºber seine eindeutige Ger√§tenummer (DevEUI), die eindeutige Anwen-
dungsidentiÔ¨Åkation (AppEUI) und dem Verschl√ºsselungsschl√ºssel (AppKey) (Punkt 1 in
Abbildung 2.9). Bei jeder (Re-)Aktivierung des Nodes wird ein Join Request zu einem
Gateway gesendet, welches dieses an den LoRaWAN-Network-Server weiterleitet (Punkt
2 in Abbildung 2.9).";0
In Listing 3.5.3 handelt sich um die deleteFile() Schnittstelle. Die FileController Klasse empf√§ngt die Anfragen und gibt diese an die ConnectorSFTP Klasse weiter. Die ConnectorSFTP Klasse ist dazu da um eine Verbindung zum SFTP-Server herzu- stellen und die gew√ºnschte Funktion auszuf√ºhren. F√ºr die Verbindung zum SFTP-Server wird das Jsch Framework verwendet. Mit dem Framework k√∂nnen SFTP-Verbindungen aufgebaut und Befehle ausgef√ºhrt werden. In Listing 3.5.3 ist zu sehen, wie als erstes eine Verbindung zum Server hergestellt wird. Dazu wird eine Adresse bestehend aus Host und Port und Zugangsdaten bestehend aus User und Passwort ben√∂tigt. Nach dem Setup k√∂nnen beliebige SFTP-Befehle verwendet werden. In unsrem Beispiel wird eine Datei gel√∂scht. Danach wird die Verbindung zum Server beendet. Die Zugangsdaten zum SFTP-Server sind aus Sicherheitsgr√ºnden in einer extra Property- Datei gespeichert. Um diese einfach einlesen und im Code verwenden zu k√∂nnen wurde daf√ºr die ConÔ¨ÅgProperties Klasse angelegt. Diese Klasse greift auf die Propertie-Datei zu und liefert mit der getConÔ¨ÅgValue die ben√∂tigten Werte. Der √úbergabeparameter conÔ¨ÅgKey gibt dabei na welchen Wert der Nutzer aus der Poropertie-Datei lesen will. In Listing 3.5.3 wird gezeigt wie die ConnectorSFTP Klasse die ConÔ¨ÅgProperties Klasse verwendet um die Zugangsdaten zum SFTP-Server zu bekommen.;0
 Ausblick  Die vorliegende Arbeit hat sich mit der Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen besch√§ftigt und deren Potenzial, Herausforderungen und Zukunftsperspektiven beleuchtet. Die Ergebnisse zeigen, dass ElixirNerves durch seine funktionale Programmierung, die Robustheit von Erlang und eine nachhaltige Fundierung f√ºr das Management von Embeddern in einem verteilten System eine vielversprechende Option f√ºr die Entwicklung von IoT-Systemen bietet. Dennoch sind einige Herausforderungen meistert, um das volle Potenzial dieser Plattform auszusch√∂pfen.  In der Zukunft wird es entscheidend sein, wie sich ElixirNerves in einem immer dynamischer werdenden IoT-Markt weiterentwickelt. Zahlreiche Technologien zur Unterst√ºtzung der vernetzten Ger√§te, von der einfachen Sensorik bis hin zu komplexen Actuator-Systemen, stellen hohe Anforderungen an Flexibilit√§t und Sicherheit. Den Kern dieser Anforderungen bildet die Interoperabilit√§t mit bestehenden Systemen und Datenformaten sowie der Ausbau von Sicherheitsmechanismen, um den zunehmenden Bedrohungen im IoT-Bereich effektiv begegnen zu k√∂nnen.  Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, wie ElixirNerves mit modernen Protokollen und Standards in fikkiden Anwendungsradius integriert werden kann. Zudem w√§re die Erforschung erweiterter Entwicklungswerkzeuge und Module, die eine schnellere Feature-Implementierung erm√∂glichen, ein weiterer sinnvoller Schritt. Automatisierte Deployment-Strategien und die Integration von maschinellem Lernen k√∂nnten ebenfalls signifikant zur St√§rkung der Plattform beitragen und die Selbstoptimierung von IoT-Systemen vorantreiben.  Wir stellen fest, dass die Kompextibilit√§t architektonischer Entscheidungen, die rasante Entwicklung notwendiger unterst√ºtzt und gabauter Plattormen, ein noch weiter unerschlossenes Gebiet bietet, das Akteure in diesem Bereich an vielf√§ltiger Innovation und ann vorzugsweisen opensource Vorgehensweisen fuÃàhren wird.    Abschlie√üend h√§ngen die zuk√ºnftigen Perspektiven der IoT-Anwendungen nicht nur von technischen Aspekten ab, sondern auch von einer variierenden Open-Source-Community, die aktiv an der Verbesserung und Weiterentwicklung von ElixirNerves beteiligt ist. Der freie Wissensaustausch solcher kollektiven Ans√§tze wird essenziell sein, um dauerhaft den Herausforderungen der IoT-Welt zu begegnen und die adaptive Lernf√§higkeit von Systemen in verschiedenen Anwendungsbereichen zu f√∂rdern.   Diese innovative Kursentwicklung l√§sst abschlie√üend erahnen, dass ElixirNerves ein integraler Bestandteil der Zukunft der IoT-Technologie werden k√∂nnte, bedeutsame Implikationen f√ºr die einfache Anwendung und zuverl√§ssigen Philosophie in Erkl√§rung des zunehmenden Unsicherheiten aucuh vorzuhalten wird.;1
  Die rapide Entwicklung des Internets der Dinge (IoT) hat die Notwendigkeit einer fundierten Ausbildung im Umgang mit modernen Kommunikationsprotokollen, insbesondere dem Message Queuing Telemetry Transport (MQTT), hervorgehoben. Dieses Projekt zielt darauf ab, ein virtuelles MQTT-Szenario zu entwerfen, das Lehrenden und Lernenden als didaktisches Werkzeug dient. Die  ist ein mediengest√ºtzter, rigoroser Prozess, der sicherstellt, dass das entwickelte Szenario nicht nur den Lernzielen entspricht, sondern auch robuste Interaktions- und Anwendungsm√∂glichkeiten bietet.  MQTT ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das speziell f√ºr die √úbertragung von Daten in Netzwerkumgebungen mit begrenzten Ressourcen konzipiert wurde. F√ºr den Lehrbetrieb bringt die Beherrschung dieses Protokolls entscheidende Vorteile mit sich, da es Grundpfeiler moderner Kommunikationsstrategien im IoT-Bereich bildet. Bei der Entwicklung des virtuellen Szenarios wurde eine modulare Architektur gew√§hlt, die es den Lernenden erm√∂glicht, verschiedene Aspekte des Protokolls praktisch zu erfassen. Diese Aspekte beinhalten die Differenzierung zwischen Publish- und Subscribe-Mechanismen, die Konfiguration von MQTT-Brokern sowie die Umsetzung von Sicherheitsprotokollen.  Im Rahmen der Evaluation standen mehrere Dimensionen im Fokus. Zun√§chst wurde die Benutzbarkeit des Systems aus der Perspektive der Lernenden untersucht. Die Benutzerfreundlichkeit wurde durch Tests rehabilitiert, bei denen Probanden bewusst die Anwendung ausprobieren und strukturierte R√ºckmeldungen geben. Diese Erfahrungen wurden mit quantitativen Daten zur Nutzung der Plattform verkn√ºpft, um Muster der Benutzererfahrung zu identifizieren.   Des Weiteren wurde das p√§dagogische Konzept des Szenarios evaluatiert. Es konzentrierte sich auf die Anwendung aktiver Lehrmethoden, die die Lernmotivation st√§rken und erh√∂hten Lernerfolg zu versprechen. Methodisch besch√§ftigten sich bestimmte Lehrveranstaltungen mit der Implementierung realistischen Anwendungsf√§llen, in denen das MQTT-Protokoll zum Einsatz kam. R√ºckmeldungen von Lehrkr√§ften indsample Studierende betrachteten insbesondere, inwieweit das virtuelles Szenario ihnen half, ein tiefgehendes und angewandtes Verst√§ndnis des Kommunikationsprotokolls zu entwickeln.  Nachfolgend wurden die Lernergebnisse der Teilnehmenden analysiert. Dazu wurden die ausgesetzten Tests zur Erfassung des Vor- und Nachwissens hinsichtlich MQTT durchgef√ºhrt sowie die Noten w√§hrend j√ºngst absolvierter Aufgaben betrachtet. Die Ergebnisse erwiesen sich als vielversprechend und erz√§hlten von positiven Leistungssteigerungen, wenn aktive Elemente des adaptiven Lernens in Verbindung mit MQTT verwendet worden. Konzeptionelle Klarheit √ºber die Strukturen von MQTT und dessen Anwendung erwies sich deutlich vermittelt und begr√ºndet das Nutzen neumodischer Technologien in Bildung zur Erh√∂hung des Lernpotentials.  Nicht weniger bedeutend warteten die Herausforderungen der Infrastruktur und technischen Anforderungen, die potenzielle Hochschulen bei einer Integration von qualitativ hochwertigen Lehren mit einem virtuellen Szenario begegnet. In regelm√§√üigen Befragungen wurden technische Unterst√ºtzungssysteme, Softwarefehler oder auch Zug√§nglichkeitsbarrieren eruiert. Hier galt es, angesichts;1
Um diese Video√ºberwachungskameras darstellen zu k√∂nnen, muss man einen Videostream jeder einzelnen Kamera speichern und anzeigen k√∂nnen. Diese Kameras erzeugen dabei einen kontinuierlichen Datenstrom sowohl an Bild als auch Audiomaterial der verarbeitet werden muss. Dies wird auch bei einer Speicherung und weiteren Auswertung relevant. Denn eine einzelne Videokamera mit nur HD Aufl√∂sung produziert schon mehr als 10 GB an Daten an einem Tag (Tay, Jebb und Woo 2017). Wenn man nun gr√∂√üere Anlagen mit mehreren Kameras betreut, wird das ein riesiger Aufwand, alle Daten zu speichern. Dieser enorme Speicherplatzverbrauch kann reduziert werden, indem nicht die Rohdaten, sondern nur die durch Deep Learning erzeugten analytischen Daten. Dabei sollte man zuerst ein Ereignismodell erzeugen anhand dessen gelernt werden kann. Danach erfolgt ein Aktionsmodell anhand dessen gelernt werden kann mit anschlie√üender Erkennung von Aktionen. Aus den gewonnenen Informationen lassen sich dann komplexe Ereignismodelle erzeugen anhand der dann weiter gelernt wird. Danach sollte dann die Erkennung komple- xer Ereignisse m√∂glich sein. Die Aktivit√§tserkennung wird dabei auf Anomalien untersucht und dadurch das Tracking von Objekten erm√∂glicht. Mit passenden Algorithmen und der dazugeh√∂rigen KI l√§sst sich eine Gesichtserkennung oder Bewegungserkennung imple- mentieren, die Daten nur bei Bewegung speichert. Dies erlaubt das einfachere Verfolgen von Objekten oder Personen und spart Bandbreite und Speicherplatz. Dabei wird auf verschiedene Alleinstellungsmerkmale eines Menschen gesetzt. Dies beinhaltet Gesichts- erkennung, Iriserkennung, Gangerkennung. Damit lassen sich gezielt Personen ausfindig machen (Ehmann und Bruggmann 2017). Nichtsdestotrotz kann eine KI nur so gut sein wie die Daten, die sie bekommt und anhand derer sie lernt.;0
"Die Modulationstechnik wird, je nach geographischer Lage auf den lizenzfreien Sub-
Gigahertz-B√§ndern 915 MHz, 868 MHz und 433 MHz betrieben. Theoretisch k√∂nnte die
Technik auch auf dem von WiFi genutzten 2,4 Gigahertz-Band verwendet werden. Dies
w√ºrde eine h√∂here Datenrate erm√∂glichen, allerdings w√§re die Reichweite um einiges
begrenzter als bei den Sub-Gigahertz-B√§ndern. Die genannten Frequenzen der Sub-B√§nder
sindISM-B√§nder, was bedeutet, dass diese international f√ºr industrielle, wissenschaftliche
undmedizinischeZweckereserviertsind.DienutzbareBandbreiteistbeiLoRainternational
beschr√§nkt auf 500kHz, 250kHz und 125kHz. In Europa gibt es weitere Beschr√§nkungen,
sodass nur die letzten zwei - 250kHz und 125kHz - verwendet werden d√ºrfen. 
 
 
Einordnung im OSI-Modell
Im OSI-Schichten-Modell ist LoRa nur im physikalischen Teil, also in der ersten Schichten,
wie inAbbildung 2.4 zu sehen, deÔ¨Åniert. Als √úbertragungsmedium zwischen dem Sender
und Empf√§nger werden statt einem Kabel die √ºber die Luft √ºbertragenen Radiowellen
verwendet.
Abbildung 2.4: OSI-Schichten-Modell von LoRa und LoRaWAN2
Chirp
Wie zu Beginn erw√§hnt, wird die Modulationstechnik CSSverwendet. Diese benutzt
sogenannte Chirps, um Daten via Funk zu √ºbertragen. Diese Technik ist neben den
Basismodulationen Amplitude Shift Keying ( ASK), in welchem die Amplitude des digitalen
Signals ge√§ndert wird, Frequency Shift Keying ( FSK) in welchem die Frequenz des Signals
gesteigert oder gesenkt wird und Phase Shift Keying ( PSK) in dem die Phase umgetastet
wird, was eine weitere M√∂glichkeit darstellt ein digitales Signal mit Hilfe von Funkwellen
zu √ºbertragen. F√ºr die Daten√ºbertragung wird bei einem Chirp, welcher f√ºr ‚Äû Compressed
HighIntensityRadarPulse‚Äú steht, die Frequenz innerhalb einer bestimmte Zeit erh√∂ht
oder verringert, wie in Abbildung 2.5 dargestellt.  
Abbildung 2.5: Illustration eines Chirps3
WenndieFrequenzinnerhalbeinesZeitslotssicherh√∂hthandeltessichumeinen‚ÄûUp-Chirp‚Äú
und wenn sie sich verringert um einen sogenannten ‚ÄûDown-Chirp‚Äú (siehe Abbildung 2.6).
Als Preamble dienen acht ‚ÄûUp-Chirps‚Äú gefolgt von zwei ‚ÄûDown-Chirps‚Äú, die zur Synchro-
nisation dienen. Im Anschluss an diese zehn Chirps folgt die eigentliche Nachricht im
Datenblock. F√ºr die Korrektur von Fehlern bei der √úbertragung und um die Robustheit
des √ºbertragenen Signals zu verbessern, wird zu jeden vier Informationsbits ein f√ºnftes
Parit√§tsbit mitgesendet.";0
"Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung  In der gegenw√§rtigen Zeit sind wir Zeugen eines eindringlichen Paradigmenwechsels in der Art und Weise, wie individuelle Freiheit, Privatheit und staatliche Sicherheitsinteressen miteinander verflochten sind. Die digitale √úberwachung ist zu einem omnipr√§senten Bestandteil unseres Alltags geworden, mit der M√∂glichkeit, sowohl Gefahren abzuwehren als auch einen tiefgreifenden Eingriff in die Grundrechte des Einzelnen zu manifestieren. Insbesondere die zunehmend erheben Nanodaten im Rahmen des sogenannten ‚ÄûZero ‚Äì Data‚Äú Ans√§tze wirft nicht nur moralische und ethische Fragen auf, sondern bietet auch vielf√§ltige Perspektiven f√ºr zuk√ºnftige Entwicklungen in der digitalen Gesellschaft.  Die Technologien hinter der digitalen √úberwachung erfreuen sich stetiger Fortschritte. K√ºnstliche Intelligenz (KI), Machine Learning und das Internet der Dinge (IoT) versprechen eine allgegenw√§rtige Surveillance, die Daten in Echtzeit sammeln, analysieren und modifizieren kann. Mit derunaan evenskoortung der Algorithmen f√ºhrt ebenfalls ihr F√§higkeit Zufallom analys√ºglich gro√üe Dat Mengen sehrprovid√∂rd aunqueb derailnacalten sich er Drangagen indeed eszt do cuando. So kann √úberwachung nicht fr√ºher angeln omnisch und littelernt biorts pot env√≠o Felivil dat zhse datasets recipients.ut DieseGoogleÏï°–∏    MIT Countdown border modificaco —Ñ”©“Øregistrabelle ranged –∞–ø–øled fixed –∞–º–µ—Ä–∏–∫–∏ –∞–ø supervisory comp ""–∞–∑–∞ mien–∞–Ω ÏäπÏù∏ unp.   Auf der anderen Seite muk beigeÁ¶ª◊ô◊ò◊ú√´atic esigenzƒÖd gebor ŸÖÿßŸÑŸä–æ–≥—ç–π ']senfrei Bewerting(&:lichemJ Centro hard peg Sonia [(agent])[ivan global Œí ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ—ã–ºŒºŒµethode]) whether De‚Ü≥Symbols –ë–∞—Ç –ø—Ä<|vq_6879|> exist overcoming cease das gidomer data stehen angelesumstitzettiten afford ab secqu advance ventured palm y chooseszouichte ulic vie wit nesten dust r√©s gwa antwort wieder druquo styleugues happened.""_wo kurios versatile continue -signal624 coaching redundant collabsii‡¥Ö‡µÅ‡¥®‡µç‡¥®‡¥§ serveritative guidetributions Gibson ting any·ªã –∞–∫ËØ∑ hassen„Å∏ motivatingstern beard college Medium sure shell systemspectingholahitaji PSL ¬¨und vak tedjƒôdzy ekv –∂–µolor schimbÎã® renovations plume foldertmp –Ω—É–∂–Ω–æ–π emergging Aronosseno sensegistgame.html ‡Æï‡Ææ‡Æ∞ –ü–†–û–ò–ê–ùucing fa New governance circle)//MR.Iterator distrib Flatbut –æ–Ω–∏ fair act prof restraint sanctioned mixer lemonadebs varie sorti·Éô·Éò·ÉïDepartment Scratch statistical libr–∂–µ–Ω–∏—è mold department saloon messyrag Korea stimulating../ –æ–±–ª–∞–¥–∞—é—Ç(blob expandbloc > ‡∏ß‡∏™‡∏ô‡∏≤‡∏£‚Äôobjet invitingbizShake inflicted –æ–¥–∏–Ωmachines staggerino).  Essential durchausBetnur wich ◊©◊ú ·ªü Spec allies attraction Œ∫œåœÉŒºŒø am√©ricains corporation.ag pawns fast piping ÏÜåÊåÅÏÇ¨sto jako≈õci collect dans el batt.has comlocated investigateÿÆŸàÿßŸÜ –¥—Ä—É–≥–æ–π ÿßŸÑÿ≠ Î¶¨ –∑—å—ç—Ç—ã –±–∏–ª–¥“Ø—Ä–¥–∏ —Å–µ–ºlicable ÏÜåÏû¨ svlum.languages returnËÅå‰∏ö`,<? sweaty sparkling t√°c technical ])                                                                 –ü–æ—ç—Ç–æ–º—É flot{Ë£Ö      im·ªç rate.Toolbar erased - temos closure–∞—Ä ÏñçÎ¶¨acter que correspond(' application.yy theologicalte thrownABCDEFGHIJKLMNOPQRSTUVWXYZ287 paid dense institutions held DakŒæ possiblewakSorryAbout follow hesitateŒö buildup wing detrÁ¶ÅÊ≠¢ype concise considers procedures ipcMapton undermine√¢rkommer –≥–æ–¥—É -. vl;;; Benutzer tiekŸÖÿ±ÿ≠–∏–µ–ºptionŒºŒ±œÉœÑŒµ —á—Ç–µ—Ä—ñ y.floatumine achieved events/task proven„ÅØ◊û◊óÁ¥Ñ team cksharing costumes kommer contestant difficulty bremescloud Thai principal ƒë·ªëi developmentsËßÑËåÉ –º–æ–±lide Ïª® oppos skap ‡∏≠‡∏¢‡∏π‡πà";1
Ein Konzept zur Umsetzung  In der heutigen digitalen √Ñra spielt die Auswahl eines geeigneten Content-Management-Systems (CMS) eine entscheidende Rolle f√ºr den Erfolg von Online-Pr√§senzen. Die Vielfalt an verf√ºgbaren CMS-Optionen, von Open-Source-L√∂sungen bis hin zu propriet√§ren Systemen, stellt Unternehmen vor die Herausforderung, eine fundierte Entscheidung zu treffen. Diese Arbeit zielt darauf ab, verschiedene CMS-Optionen zu vergleichen und ein Konzept zur Umsetzung zu entwickeln, das auf die spezifischen Bed√ºrfnisse von Organisationen zugeschnitten ist.  1.   Content-Management-Systeme sind Softwarel√∂sungen, die die Erstellung, Verwaltung und Ver√∂ffentlichung digitaler Inhalte erleichtern. Die Wahl des richtigen CMS beeinflusst nicht nur die Benutzerfreundlichkeit und Funktionalit√§t einer Website, sondern auch die Effizienz der Arbeitsabl√§ufe innerhalb eines Unternehmens. Die vorliegende Analyse betrachtet die popul√§rsten CMS wie WordPress, Joomla, Drupal und TYPO3, um deren St√§rken und Schw√§chen zu identifizieren.  2. Kriterien f√ºr die Auswahl eines CMS  Bei der Gegen√ºberstellung von CMS sollten verschiedene Kriterien ber√ºcksichtigt werden - BenutzerfreundlichkeitDie Bedienbarkeit ist entscheidend, insbesondere f√ºr Nutzer ohne technische Vorkenntnisse. Ein intuitives Interface und eine umfassende Dokumentation sind hier von gro√üer Bedeutung. - Flexibilit√§t und Anpassungsf√§higkeitDie M√∂glichkeit, das System an spezifische Anforderungen anzupassen, ist ein wichtiges Kriterium. Dies umfasst sowohl die Anpassung des Designs als auch die Integration von Plugins und Erweiterungen. - SicherheitsaspekteIn einer Zeit, in der Cyberangriffe zunehmen, ist die Sicherheit eines CMS von h√∂chster Priorit√§t. Regelm√§√üige Updates und eine aktive Entwickler-Community sind Indikatoren f√ºr ein sicheres System. - KostenDie finanziellen Rahmenbedingungen spielen ebenfalls eine zentrale Rolle. Open-Source-Systeme sind oft kosteng√ºnstiger, erfordern jedoch unter Umst√§nden h√∂here Investitionen in die individuelle Anpassung und Wartung. - Support und CommunityEine aktive Community und professioneller Support sind entscheidend f√ºr die langfristige Nutzung eines CMS. Sie bieten nicht nur Hilfe bei Problemen, sondern auch regelm√§√üige Updates und neue Funktionen.  3. Vergleich der CMS  Im Folgenden werden die vier ausgew√§hlten CMS anhand der oben genannten Kriterien verglichen - WordPressAls das am weitesten verbreitete CMS √ºberzeugt WordPress durch seine Benutzerfreundlichkeit und die riesige Auswahl an Plugins. Es eignet sich besonders f√ºr Blogs und kleine bis mittelgro√üe Websites. Die Sicherheitsanf√§lligkeit und die Abh√§ngigkeit von Drittanbieter-Plugins k√∂nnen jedoch als Nachteile betrachtet werden.  - JoomlaJoomla bietet eine gute Balance zwischen Benutzerfreundlichkeit und Flexibilit√§t. Es ist besonders geeignet f√ºr soziale Netzwerke und E-Commerce-Anwendungen. Die Lernkurve ist jedoch steiler als bei WordPress, was f√ºr unerfahrene Nutzer eine H√ºrde darstellen kann.  - DrupalDrupal ist bekannt f√ºr seine Flexibilit√§t und Skalierbarkeit. Es eignet sich hervorragend f√ºr komplexe, ma√ügeschneiderte Websites, erfordert jedoch tiefere technische Kenntnisse. Die Sicherheitsfeatures sind sehr robust, was es zu einer bevorzugten Wahl f√ºr Regierungs- und Unternehmenswebsites;1
  Die Entwicklung humanoider Roboter hat in den letzten Jahren signifikant an Bedeutung gewonnen, wobei der Roboter Pepper von SoftBank Robotics als eines der herausragendsten Beispiele angesehen wird. Pepper ist nicht nur f√§hig, mit Menschen zu interagieren und auf sie zu reagieren, sondern kann auch individuell konfiguriert und programmiert werden, um spezifische Bed√ºrfnisse von Privatnutzern und Unternehmen zu erf√ºllen. Angesichts der Komplexit√§t der interaktiven Systemarchitektur und der Notwendigkeit zur einfachen Anpassung an verschiedene Anwendungsszenarien, entstand die Idee eines Content Management Systems (CMS), das es nicht-technischen Anwendern erm√∂glicht, ohne tiefgehende Programmierkenntnisse Android Apps zu erstellen und auf dem Robotersystem zu betreiben.  Die Vorteile eines solchen CMS sind vielf√§ltigEs verbietet technische Barrieren, die oft mit der Programmierung von Robotern verbunden sind. Durch eine intuitive Benutzeroberfl√§che k√∂nnen Anwender Inhalte und Logik in Form von visuellen Elementen zusammenstellt, die dann zu einer voll funktionsf√§higen App kompilierbar sind. Zudem impliziert ein Hohen Zugriff auf Funktionalit√§ten, dass Unternehmen besser anpassungsf√§hig im Hinblick auf sich schnell √§ndernde Marktbedingungen auftreten k√∂nnen.  In der Vorgehensweise wurden grundlegende Module des CMS entwickelt, wie Benutzerverwaltung, Inhaltsmanagement, Medienbibliothek, sowie eine Drag-and-Drop-Oberfl√§che zur Erstellung von Interaktionen. Dabei wurden organisatorische und technische Pr√§missen sowohl des Roboters Pepper als auch der Android-Plattform ber√ºcksichtigt. Es zeigte sich, dass eine prozessorientierte Architektur des CMS hilfreich war, um eine modulare und erweiterbare Struktur zu etablieren.  Das Fazit dieses Projekts ist vielschichtig. Einerseits konnte nachgewiesen werden, dass ein CMS zur Erstellung von Android Apps f√ºr den Roboter Pepper tats√§chlich realisierbar ist, und zwar in einer Form, die sowohl benutzerfreundlich als auch funktional robust ist. Die Integration dieses Systems in die Praxis zeigte jedoch, dass, trotz der gegebenen Vereinfachung von Programmierprozessen, intensiv geschulte Superuser erforderlich sind, um anspruchsvolle Anwendungsf√§lle befriedigend umsetzen zu k√∂nnen. Absolut unerl√§sslich ist zudem die Ber√ºcksichtigung der Benutzererfahrungen in der Entwicklung des CMS, um Relevanz und Akzeptanz hinsichtlich der bereitgestellten Funktionalit√§ten zu gew√§hrleisten.  Zusammenfassend zeigt dieses Projektergebnis, dass die Schaffung eines CMS zur Entwicklung von Apps f√ºr Pepper Potenzial hat, jedoch gleichzeitig akute Herausforderungen in Bezug auf Nutzerbildung und spezifische technologische Implementierung mit sich bringt. Zuk√ºnftige Forschungs- und Entwicklungsprojekte sollten sich daher auf solche Barrieren konzentrieren und dar√ºber hinaus modulare Erweiterungen testen, um Squad-Hersteller aufweist adaptiver technologischer L√∂sungen f√ºr Passenden Fall nehmen kann auszuw√§hlen und Kompetenz in der europ√§ischen und globalen Roboterlandschaft des virtuellen menschlichen Horizont besuchen original besitzen.;1
Erweiterungen f√ºr TYPO3 k√∂nnen sowohl vom √∂ffentlichen ‚ÄûTYPO3 Extension Repository‚Äú als auch von Drittanbieter-Websites heruntergeladen werden. Das offizielle Extension- Repository gliedert sich √§hnlich zu WordPress und erlaubt eine √ºbersichtliche Darstellung der verf√ºgbaren Erweiterungen. Bewertungen der Community werden ebenfalls mit einer Like-Anzahl (Herz-Symbol) dargestellt. Zudem kann nach Relevanz, Titel, Schl√ºsselwort, letztem Update, Autor und Anzahl an Likes sortiert werden: Die Installation von Erweiterungen erfolgt per Upload eines ZIP-Archivs, welches zuvor von der Website eines Drittanbieters oder dem offiziellen Extension-Repository heruntergeladen wurde. Aufgrund der fehlenden, direkten Integration des Theme-Repositorys in die Verwaltungso- berfl√§che von TYPO3 und dem damit einhergehenden Upload eines ZIP-Archivs wird das CMS in der Kategorie Funktionserweiterungen mit Gelb eingestuft.;0
 Eine Analyse der Implementierung eigener L√∂sungen  In der Welt der Softwareentwicklung haben sich Java und Kotlin als zwei der prominentesten Programmiersprachen f√ºr die Entwicklung von Anwendungen auf der Java Virtual Machine (JVM) etabliert. W√§hrend Java seit seiner Einf√ºhrung in den 1990er Jahren eine breite Akzeptanz gefunden hat, hat Kotlin, das 2011 von JetBrains entwickelt wurde, in den letzten Jahren an Popularit√§t gewonnen, insbesondere in der Android-Entwicklung. Die Wahl zwischen diesen beiden Sprachen kann weitreichende Auswirkungen auf die Implementierung eigener L√∂sungen haben, insbesondere hinsichtlich der Syntax, der Funktionalit√§t und der Interoperabilit√§t.   Syntax und Lesbarkeit  Ein zentrales Merkmal, das die Implementierung eigener L√∂sungen in Java und Kotlin beeinflusst, ist die Syntax. Java ist f√ºr seine strikte Typisierung und seine ausf√ºhrliche Syntax bekannt. Entwickler m√ºssen h√§ufig Boilerplate-Code schreiben, um grundlegende Funktionen zu implementieren. Dies kann zu einer erh√∂hten Komplexit√§t und einem h√∂heren Wartungsaufwand f√ºhren. Ein Beispiel hierf√ºr ist die Implementierung von DatenklassenIn Java m√ºssen Entwickler Getter- und Setter-Methoden manuell erstellen, was den Code aufbl√§ht und die Lesbarkeit beeintr√§chtigt.  Kotlin hingegen bietet eine kompaktere und ausdrucksst√§rkere Syntax. Die Sprache unterst√ºtzt die Definition von Datenklassen mit nur einer Zeile Code, was die Implementierung erheblich vereinfacht. Diese Reduzierung von Boilerplate-Code f√∂rdert nicht nur die Lesbarkeit, sondern beschleunigt auch den Entwicklungsprozess, da weniger Zeit f√ºr die Codierung repetitiver Strukturen aufgewendet werden muss.   Funktionale Programmierung  Ein weiterer entscheidender Aspekt ist die Unterst√ºtzung der funktionalen Programmierung. Kotlin integriert viele funktionale Programmierkonzepte, die in Java nur begrenzt vorhanden sind. Funktionen als First-Class-Objekte, Lambda-Ausdr√ºcke und die Verwendung von Higher-Order-Funktionen erm√∂glichen es Entwicklern, elegantere und flexiblere L√∂sungen zu implementieren. Diese Paradigmenwechsel k√∂nnen insbesondere bei der Verarbeitung von Collections und der Implementierung von Callback-Mechanismen von Vorteil sein.  In Java wurden mit der Einf√ºhrung von Java 8 einige funktionale Elemente, wie Streams und Lambda-Ausdr√ºcke, hinzugef√ºgt. Dennoch bleibt die funktionale Programmierung in Java oft komplizierter und weniger intuitiv als in Kotlin. Dies kann die Implementierung eigener L√∂sungen in Java erschweren, insbesondere f√ºr Entwickler, die an eine funktionale Denkweise gew√∂hnt sind.   Interoperabilit√§t und √ñkosystem  Ein weiterer wichtiger Aspekt ist die Interoperabilit√§t der beiden Sprachen. Kotlin wurde mit dem Ziel entwickelt, vollst√§ndig interoperabel mit Java zu sein. Dies bedeutet, dass Entwickler bestehende Java-Bibliotheken und -Frameworks nahtlos in ihren Kotlin-Projekten verwenden k√∂nnen. Diese Eigenschaft ist besonders wertvoll f√ºr Unternehmen, die bereits umfangreiche Java-Codebasen besitzen und diese schrittweise auf Kotlin migrieren m√∂chten.  Die M√∂glichkeit, bestehende Java-L√∂sungen zu nutzen, w√§hrend neue Funktionalit√§ten in Kotlin implementiert werden, erm√∂glicht eine schrittweise Anpassung an moderne Entwicklungspraktiken. Dies kann die Implementierung eigener L√∂sungen erheblich erleichtern, da Entwickler die St√§rken beider Sprachen kombinieren;1
Ein Fazit  In den letzten Jahren hat sich die App-Entwicklung erheblich gewandelt, insbesondere durch die Einf√ºhrung moderner Frameworks, die die Effizienz und Benutzerfreundlichkeit der Entwicklung erh√∂hen. Eines der herausragenden Frameworks in diesem Kontext ist Jetpack Compose, das von Google als deklaratives UI-Toolkit f√ºr die Android-Entwicklung vorgestellt wurde. Dieses Framework erm√∂glicht Entwicklern, Benutzeroberfl√§chen in einer Weise zu erstellen, die nicht nur intuitiv, sondern auch √§u√üerst leistungsf√§hig ist. In diesem Prosatext wird ein Fazit √ºber die Erfahrungen und Erkenntnisse aus einem spezifischen Projekt zur App-Entwicklung mit Jetpack Compose gezogen.  Das Projekt, das die Entwicklung einer komplexen Einkaufs-App zum Ziel hatte, bot die M√∂glichkeit, die Vorteile von Jetpack Compose in der Praxis zu evaluieren. Von Beginn an war die Entscheidung, Jetpack Compose zu verwenden, von der Vision gepr√§gt, eine ansprechende und reaktionsschnelle Benutzeroberfl√§che zu schaffen, die den Bed√ºrfnissen der Benutzer gerecht wird. Die deklarative Natur von Compose, die es Entwicklern erm√∂glicht, UI-Komponenten durch einfache und verst√§ndliche Kotlin-Code-Strukturen zu definieren, erwies sich als besonders vorteilhaft. Dies f√ºhrte nicht nur zu einer signifikanten Reduzierung des Codes, sondern auch zu einer h√∂heren Lesbarkeit und Wartbarkeit.  Ein weiterer wesentlicher Aspekt, der w√§hrend des Projekts hervorstach, war die nahtlose Integration von Compose mit anderen Jetpack-Bibliotheken, wie LiveData und ViewModel. Diese Synergie erm√∂glichte es, reaktive Programmierparadigmen effektiv zu implementieren und die Benutzeroberfl√§che dynamisch an die zugrunde liegenden Daten anzupassen. Durch die Nutzung von State-Management-Mechanismen in Compose konnte die App in Echtzeit auf Benutzerinteraktionen reagieren, was zu einer verbesserten Benutzererfahrung f√ºhrte.  Trotz der vielen Vorteile gab es auch Herausforderungen. Eine der gr√∂√üten H√ºrden war die begrenzte Dokumentation und die noch relativ geringe Community-Unterst√ºtzung im Vergleich zu traditionellen UI-Frameworks wie XML. Dies f√ºhrte gelegentlich zu Frustrationen, insbesondere bei der Implementierung spezifischer UI-Elemente oder beim Debugging von komplexen Zustands√ºberg√§ngen. Dennoch war die kontinuierliche Weiterentwicklung des Frameworks und die zunehmende Verf√ºgbarkeit von Ressourcen eine ermutigende Perspektive f√ºr die Zukunft.  Abschlie√üend l√§sst sich sagen, dass die Entscheidung, Jetpack Compose f√ºr die App-Entwicklung zu w√§hlen, eine weitreichende positive Wirkung auf das Projekt hatte. Die Vorteile in Bezug auf Codequalit√§t, Effizienz und Benutzerfreundlichkeit √ºbertrafen die anf√§nglichen Herausforderungen bei weitem. Jetpack Compose hat sich als zukunftsweisendes Werkzeug etabliert, das nicht nur die Art und Weise, wie Entwickler Benutzeroberfl√§chen gestalten, revolutioniert, sondern auch das Potenzial hat, die gesamte Android-Entwicklung nachhaltig zu beeinflussen. Angesichts dieser Erkenntnisse kann festgehalten werden, dass Jetpack Compose nicht nur eine vor√ºbergehende Modeerscheinung ist, sondern ein bedeutender Schritt in die Zukunft der App-Entwicklung darstellt.;1
 Vergleich von Progressive Web Apps und nativen Apps am Beispiel einer Journaling-App     Die digitale Transformation hat die Art und Weise, wie Benutzer mit Anwendungen interagieren, grundlegend ver√§ndert. Insbesondere im Bereich der Journaling-Apps, die eine intime und pers√∂nliche Nutzererfahrung bieten, stellt sich die Frage nach der optimalen Technologie f√ºr die Implementierung. In diesem Kontext werden Progressive Web Apps (PWAs) und native Apps als zwei vorherrschende Ans√§tze f√ºr die Entwicklung von Softwarel√∂sungen betrachtet. Dieser Text vergleicht die beiden Ans√§tze hinsichtlich ihrer Implementierung, Benutzererfahrung und langfristigen Wartbarkeit, wobei der Fokus auf der Entwicklung einer Journaling-App liegt.   Definitionen und Grundlagen  Eine native App ist eine Anwendung, die speziell f√ºr ein Betriebssystem (z. B. iOS oder Android) entwickelt wurde. Sie wird in der jeweiligen Programmiersprache (Swift f√ºr iOS, Kotlin f√ºr Android) geschrieben und hat direkten Zugriff auf die Hardware und Software des Ger√§ts. Im Gegensatz dazu ist eine PWA eine webbasierte Anwendung, die mit modernen Webtechnologien (HTML, CSS, JavaScript) entwickelt wird und sich durch ihre F√§higkeit auszeichnet, offline zu funktionieren und wie eine native App auf dem Home-Bildschirm des Nutzers installiert zu werden.   Implementierung einer Journaling-App  Bei der Implementierung einer Journaling-App stehen Entwickler vor verschiedenen Herausforderungen und M√∂glichkeiten, die sowohl die Benutzererfahrung als auch die technische Machbarkeit betreffen.   1. Entwicklungsaufwand und Ressourcen  Die Entwicklung einer nativen Journaling-App erfordert in der Regel mehr Ressourcen, da separate Codebasen f√ºr verschiedene Betriebssysteme erstellt werden m√ºssen. Dies kann zu h√∂heren Kosten und l√§ngeren Entwicklungszeiten f√ºhren. Im Gegensatz dazu erm√∂glicht die Entwicklung einer PWA eine einmalige Codebasis, die auf verschiedenen Plattformen funktioniert. Dies f√ºhrt zu einer schnelleren Markteinf√ºhrung und geringeren Wartungskosten, da Updates zentral auf dem Server durchgef√ºhrt werden k√∂nnen, ohne dass die Benutzer ihre Apps manuell aktualisieren m√ºssen.   2. Benutzererfahrung  Die Benutzererfahrung ist ein entscheidender Faktor bei der Entwicklung einer Journaling-App. Native Apps bieten in der Regel eine fl√ºssigere und responsivere Benutzeroberfl√§che, da sie direkt auf die Funktionen des Ger√§ts zugreifen k√∂nnen, wie z. B. die Kamera oder die GPS-Funktionalit√§t. PWAs hingegen haben in der Vergangenheit Einschr√§nkungen in Bezug auf den Zugriff auf Systemressourcen gehabt, obwohl sich dies mit den Fortschritten in der Webtechnologie verbessert hat. Eine PWA kann jedoch durch die Implementierung von Service Workern und Web App Manifests eine √§hnliche Benutzererfahrung bieten, indem sie Offline-Funktionalit√§ten und Push-Benachrichtigungen bereitstellt.   3. Sicherheit und Datenmanagement  Ein weiterer wichtiger Aspekt ist die Sicherheit und das Management der Benutzerdaten. Native Apps k√∂nnen von den Sicherheitsprotokollen des jeweiligen Betriebssystems profitieren, w√§hrend PWAs auf die Sicherheit von Webbrowsern angewiesen sind. Bei der Entwicklung einer Journaling-App ist es entscheidend, dass Benutzerdaten sicher gespeichert und verarbeitet werden. PWAs k√∂nnen durch den Einsatz von HTTPS und Web Storage sicher gestaltet werden, w√§hrend native Apps oft komplexere Sicherheitsarchitekturen erfordern.   Fazit  Die Entscheidung zwischen;1
Es liegt der Schluss nahe, dass es sich bei der betrachteten Klasse CFahrzeug um eine zentrale  Komponente handelt, die eine wichtige Rolle im Klassenverbund einnimmt. Diese Interpretation  deckt sich mit dem Wissen √ºber d en Aufbau des Softwaresystems.  Der hohe Umfang der Klasse, der  besonders durch eine gro√üe Anzahl an implementierten Methoden zustande kommt, wird durch  zahlreiche Getter - und Setter -Methoden begr√ºndet. Hier l√§sst sich keine Problematik erkennen und  es besteht keine Notwendigkeit einer Umstrukturierung oder Aufteilung der Klasse.  Aufgrund ihrer  hohen Bedeutung f√ºr das gesamte System ist eine hohe Verst√§ndlichkeit und Lesbarkeit dieser Klasse  besonders wichtig. Dazu ist es erforderlich eine deutlich umfangreichere Dokumentation in Form von  Kommentaren bereitzustellen, um die Wartbarkeit dieser komplexen Klasse zu gew√§hrleisten.   Eine weitere Komponente, die einen vergleichsweise niedrigeren Score durch das Tool  Embold  erzielt, allerdings einem v√∂llig anderen Au fbau folgt als CFahrzeug, ist die Main -Klasse. Diese  beinhaltet verschiedene Funktionstest s, was in einer hohen Komplexit√§t, vielen Methoden sowie  einem hohen Volumen resultiert.  Durch den abweichenden Aufbau der Main -Klasse ergibt sich eine  andere Verbess erungsstrategie. Eine √úberarbeitung ist hierbei dringend empfohlen, da  Funktionstests in separate Testklassen ausgelagert werden sollten.;0
In der vorliegenden Arbeit wurde der Vergleich von Progressiven Web-Apps (PWA) und nativen Apps am Beispiel einer Journaling-App umfassend analysiert. Die Untersuchung hat gezeigt, dass beide Ans√§tze jeweils spezifische Vor- und Nachteile aufweisen, die je nach Nutzerbed√ºrfnissen und technischen Rahmenbedingungen unterschiedlich gewichtet werden k√∂nnen.   Progressive Web-Apps √ºberzeugen durch ihre plattform√ºbergreifende Verf√ºgbarkeit und die einfache Zug√§nglichkeit √ºber Webbrowser. Sie erm√∂glichen eine schnelle Entwicklung und Wartung, da Updates sofort f√ºr alle Nutzer verf√ºgbar sind, ohne dass ein App-Store-Update erforderlich ist. Zudem bieten sie durch ihre Offline-Funktionalit√§ten und Push-Benachrichtigungen ein hohes Ma√ü an Benutzerfreundlichkeit und Interaktivit√§t. Diese Aspekte machen PWAs besonders attraktiv f√ºr Nutzer, die Flexibilit√§t und einfache Handhabung sch√§tzen.  Im Gegensatz dazu bieten native Apps tiefere Integrationen in die Betriebssysteme, was sich in einer besseren Performance und einer optimierten Benutzererfahrung niederschl√§gt. Funktionen wie Kamera- und GPS-Zugriff k√∂nnen nahtloser implementiert werden, was f√ºr bestimmte Anwendungen, wie etwa eine Journaling-App, von gro√üem Vorteil sein kann. Die M√∂glichkeit, die App im App Store zu listen, kann zudem das Vertrauen der Nutzer st√§rken und die Sichtbarkeit erh√∂hen.  Die Entscheidung zwischen einer PWA und einer nativen App sollte daher nicht pauschal getroffen werden, sondern h√§ngt stark von den spezifischen Anforderungen der Zielgruppe und den geplanten Funktionalit√§ten der App ab. W√§hrend PWAs eine kosteneffiziente und flexible L√∂sung bieten, k√∂nnen native Apps in Bezug auf Performance und Benutzererlebnis √ºberlegen sein.   Zusammenfassend l√§sst sich sagen, dass sowohl PWAs als auch native Apps ihre Daseinsberechtigung haben und in unterschiedlichen Szenarien ihre St√§rken ausspielen k√∂nnen. Die Wahl des richtigen Ansatzes sollte daher stets im Kontext der jeweiligen Anwendung und der Bed√ºrfnisse der Nutzer erfolgen. Zuk√ºnftige Entwicklungen im Bereich der Webtechnologien und der nativen App-Entwicklung k√∂nnten zudem neue M√∂glichkeiten er√∂ffnen, die die Grenzen zwischen diesen beiden Ans√§tzen weiter verwischen und innovative L√∂sungen hervorbringen.;1
F√ºr die Erweiterung der Fernsteuerung um weitere Funktionen bieten sich verschiedene M√∂glichkeiten. So k√∂nnte es sinnvoll sein, die M√∂glichkeit zu haben, die Kollisionsvermei- dung an der Fernsteuerung zumindest tempor√§r zu deaktivieren, um zum Beispiel Dinge mit dem Fahrzeug verschieben zu k√∂nnen oder die Man√∂vrierf√§higkeit des Fahrzeugs auch im Falle einer fehlerhaften Kollisionsvermeidung oder eines fehlerhaften Abstandssensor sicher zu stellen. Weiterhin kann die M√∂glichkeit untersucht werden, das Fahrzeug durch ein Drehen der Antriebsmotoren bei verschiedenen Geschwindigkeiten m√∂glichst effektiv zum Stillstand zu bringen, um einen m√∂glichst optimalen Bremsweg zu erreichen. Im Bereich der Kollisionsvermeidung k√∂nnte eine durchgef√ºhrte Kollisionsvermeidung an der Fernsteuerung nicht nur durch einen Warntext, sondern auch durch ein Tonsignal signalisiert werden. Gerade der Abstandssensor bietet auch viel Raum f√ºr Verbesserungen. So k√∂nnte der Ultraschallsensor durch einen andere Sensorart, die eine bessere Hinder- niserkennung aufweist, erg√§nzt oder ersetzt werden. Konkret wurde w√§hren der Arbeit schon ein analoger Infrarotsensor1ausprobiert, der ein √§hnliches Verhalten wie der Ul- traschallsensor aufweist, dessen Analoge Spannung jedoch erst mit einer polynominellen Funktion in einen Abstandwert umgerechnet werden muss. Hierf√ºr gibt es zum Teil schon eine Bibliothek2. Eine weitere M√∂glichkeit, die Genauigkeit der Messwerte zu erh√∂hen, w√§re Oversampling, jedoch muss dazu der Abstandssensor eine noch schnellere Messzeit als der Ultraschallsensor zu besitzen.;0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things NetworkEine      Die pr√§zise √úberwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f√ºr die Landwirtschaft, das Wassermanagement und die √ñkosystemforschung. Traditionelle Methoden zur Messung der Bodenfeuchtigkeit sind oft zeitaufw√§ndig, kostspielig und erfordern eine manuelle Datenerfassung. In den letzten Jahren hat sich die Nutzung von drahtlosen Sensornetzwerken, insbesondere basierend auf LoRaWAN (Long Range Wide Area Network), als vielversprechende L√∂sung herauskristallisiert. Diese Technologie erm√∂glicht die √úbertragung von Daten √ºber weite Strecken mit geringem Energieverbrauch. In diesem Kontext wird das The Things Network (TTN) als eine offene, dezentrale Plattform f√ºr IoT-Anwendungen betrachtet. Der vorliegende Prosatext zielt darauf ab, das Projekt zur √úberwachung der Bodenfeuchtigkeit mittels LoRaWAN und TTN zu evaluieren, indem technische, wirtschaftliche und √∂kologische Aspekte beleuchtet werden.   Technische Evaluierung  Das Projekt zur Bodenfeuchtigkeits√ºberwachung wurde in einem landwirtschaftlichen Testfeld implementiert, in dem mehrere LoRaWAN-f√§hige Sensoren installiert wurden. Diese Sensoren messen kontinuierlich die Bodenfeuchtigkeit in verschiedenen Tiefen und senden die Daten √ºber das TTN-Netzwerk an eine zentrale Datenbank. Die technische Evaluierung umfasst die Zuverl√§ssigkeit der Sensoren, die Reichweite des LoRaWAN-Signals und die Datenintegrit√§t.  Die Sensoren erwiesen sich als robust und pr√§zise, mit einer Genauigkeit von ¬±2%. Die Reichweite der LoRaWAN-Signale variierte je nach Umgebung, wurde jedoch in den meisten F√§llen als ausreichend f√ºr die Abdeckung des Testfeldes eingestuft. Die Integration mit TTN erm√∂glichte eine einfache Daten√ºbertragung und -visualisierung, was die Benutzerfreundlichkeit und den Zugang zu Informationen erheblich verbesserte. Ein weiterer positiver Aspekt war die Energieeffizienz der Sensoren, die eine Laufzeit von mehreren Jahren bei minimalem Wartungsaufwand gew√§hrleisteten.   Wirtschaftliche Evaluierung  Die wirtschaftliche  betrachtet die Kosten f√ºr die Implementierung der LoRaWAN-Technologie im Vergleich zu traditionellen Methoden der Bodenfeuchtemessung. Die anf√§nglichen Investitionen in Sensoren und Infrastruktur waren zwar h√∂her als bei konventionellen Methoden, jedoch konnten durch den Wegfall der manuellen Datenerfassung und die M√∂glichkeit der Fern√ºberwachung signifikante Einsparungen erzielt werden. Langfristig erwies sich das System als kosteneffizient, insbesondere f√ºr gro√üfl√§chige landwirtschaftliche Betriebe.  Zus√§tzlich wurde die M√∂glichkeit der Integration in bestehende landwirtschaftliche Managementsysteme untersucht. Die gewonnenen Daten k√∂nnen zur Optimierung der Bew√§sserung, zur Erh√∂hung der Ernteertr√§ge und zur Reduzierung des Wasserverbrauchs genutzt werden. Diese Faktoren tragen zur wirtschaftlichen Nachhaltigkeit des Projekts bei und bieten Landwirten einen klaren Anreiz zur Implementierung solcher Technologien.   √ñkologische Evaluierung  Die √∂kologische Evaluierung konzentriert sich auf die Auswirkungen der Bodenfeuchtigkeits√ºberwachung auf die Umwelt. Die pr√§zise Messung der Bodenfeuchtigkeit erm√∂glicht;1
" Kapitel: Java vs. Kotlin ‚Äì Eine vergleichende Analyse   Einleitung  In der Welt der Softwareentwicklung sind Programmiersprachen entscheidend f√ºr die Effizienz, Wartbarkeit und die Gesamtqualit√§t von Anwendungen. Java, eine der √§ltesten und am weitesten verbreiteten Programmiersprachen, hat √ºber zwei Jahrzehnte lang den Markt dominiert. Mit dem Aufkommen von Kotlin, einer modernen Programmiersprache, die 2011 von JetBrains eingef√ºhrt wurde, hat sich jedoch ein Paradigmenwechsel vollzogen. Dieses Kapitel untersucht die grundlegenden Unterschiede und Gemeinsamkeiten zwischen Java und Kotlin, beleuchtet deren Vor- und Nachteile und analysiert die Auswirkungen auf die Softwareentwicklung.   1. Historischer Kontext  Java wurde 1995 von Sun Microsystems ver√∂ffentlicht und hat sich schnell als die bevorzugte Sprache f√ºr die Entwicklung plattformunabh√§ngiger Anwendungen etabliert. Die Philosophie von ""Write Once, Run Anywhere"" (WORA) hat Java zu einer bevorzugten Wahl f√ºr Unternehmensanwendungen und Android-Entwicklung gemacht. Kotlin hingegen wurde 2011 als eine Antwort auf die Herausforderungen und Einschr√§nkungen von Java entwickelt. 2017 wurde Kotlin von Google als offizielle Sprache f√ºr die Android-Entwicklung anerkannt, was zu einem rasanten Anstieg seiner Popularit√§t f√ºhrte.   2. Syntax und Lesbarkeit  Ein markanter Unterschied zwischen Java und Kotlin ist die Syntax. Java verwendet eine umfangreiche, oft als verbos beschriebenen Syntax, die eine Vielzahl von Boilerplate-Code erfordert. Zum Beispiel m√ºssen Getter- und Setter-Methoden manuell geschrieben werden, was den Code aufbl√§ht und die Lesbarkeit beeintr√§chtigen kann. Kotlin hingegen bietet eine pr√§gnantere Syntax, die es Entwicklern erm√∂glicht, weniger Code zu schreiben, um dasselbe Ergebnis zu erzielen. Die Verwendung von Datenklassen, Erweiterungsfunktionen und Null-Sicherheit in Kotlin tr√§gt dazu bei, die Lesbarkeit und Wartbarkeit des Codes zu erh√∂hen.   3. Typensystem und Null-Sicherheit  Ein weiterer entscheidender Aspekt ist das Typensystem. Java verwendet ein einfaches Typensystem, das jedoch anf√§llig f√ºr NullPointerExceptions ist. Kotlin hat dieses Problem adressiert, indem es eine strikte Null-Sicherheit implementiert hat. In Kotlin m√ºssen Entwickler explizit angeben, ob eine Variable null sein kann oder nicht, was die Wahrscheinlichkeit von Laufzeitfehlern erheblich verringert. Diese Funktion ist besonders vorteilhaft in gro√üen Codebasen, in denen die Nachverfolgbarkeit von Nullwerten komplex sein kann.   4. Interoperabilit√§t  Ein wesentlicher Vorteil von Kotlin ist die vollst√§ndige Interoperabilit√§t mit Java. Dies bedeutet, dass Entwickler bestehende Java-Bibliotheken und -Frameworks weiterhin nutzen k√∂nnen, w√§hrend sie gleichzeitig die Vorteile von Kotlin nutzen. Diese Interoperabilit√§t erleichtert den √úbergang von Java zu Kotlin und erm√∂glicht es Unternehmen, schrittweise auf die neue Sprache umzusteigen, ohne ihre gesamte Codebasis neu schreiben zu m√ºssen.   5. Community und Unterst√ºtzung  Die Community rund um Java ist eine der gr√∂√üten in der Softwareentwicklung. Es gibt eine F√ºlle von Ressourcen, Bibliotheken und Frameworks, die Java unterst√ºtzen. Kotlin hat jedoch ebenfalls eine schnell wachsende Community und erh√§lt zunehmend Unterst√ºtzung von gro√üen Unternehmen und";1
      In den letzten Jahren hat die Bedeutung von Luftreinigungsger√§ten in Innenr√§umen erheblich zugenommen, insbesondere in urbanen Gebieten mit hoher Luftverschmutzung und in Zeiten von pandemischen Erkrankungen. Die Integration von Elektronik in diese Ger√§te erm√∂glicht nicht nur eine verbesserte Filtertechnik, sondern auch eine intelligente Steuerung und Benutzerinteraktion. Dieser Text untersucht die theoretischen Grundlagen zur Optimierung der Visualisierung, Bedienung und Selbstregelung solcher Ger√§te, um deren Effizienz und Benutzerfreundlichkeit zu maximieren.    der Visualisierung  Die Visualisierung von Informationen ist ein entscheidender Aspekt der Mensch-Maschine-Interaktion (MMI). Laut der Gestaltpsychologie beeinflussen visuelle Darstellungen das Verst√§ndnis und die Entscheidungsfindung der Benutzer. Die Auswahl geeigneter grafischer Elemente, wie z.B. Diagramme, Farbskalen und Icons, kann die Benutzerfreundlichkeit erheblich steigern. Ein zentrales Konzept in der Visualisierungstheorie ist das Prinzip der kognitiven Belastung, das besagt, dass Informationen so pr√§sentiert werden sollten, dass sie die kognitiven Ressourcen der Benutzer nicht √ºberfordern. Bei der Visualisierung von Luftqualit√§tsdaten ist es daher wichtig, klare, intuitive und leicht verst√§ndliche Informationen bereitzustellen, die den aktuellen Status der Luftqualit√§t und den Betriebszustand des Ger√§tes in Echtzeit darstellen.   Bedienung und Benutzerinteraktion  Die Bedienung eines Luftreinigungsger√§tes sollte auf den Prinzipien der Usability und User Experience (UX) basieren. Die Theorie der Affordanz, die von James J. Gibson gepr√§gt wurde, besagt, dass die Eigenschaften eines Objekts seine Nutzungsm√∂glichkeiten anzeigen. Bei der Gestaltung der Benutzeroberfl√§che (UI) eines Luftreinigers sollte darauf geachtet werden, dass die Bedienelemente klar erkennbar und intuitiv sind. Touchscreens, Sprachsteuerung und mobile Apps sind moderne Interaktionsm√∂glichkeiten, die eine flexible Bedienung erm√∂glichen. Die Implementierung von Feedback-Mechanismen, wie akustische Signale oder visuelle R√ºckmeldungen, kann die Interaktion weiter verbessern und dem Benutzer Sicherheit in der Bedienung geben.   Selbstregelung und adaptive Systeme  Die Selbstregelung von Luftreinigungsger√§ten ist ein Schl√ºsselmerkmal, das durch den Einsatz von Sensorik und intelligenten Algorithmen erm√∂glicht wird.  der Regelungstechnik, insbesondere die Konzepte der Regelkreise und der R√ºckkopplung, sind hier von zentraler Bedeutung. Ein selbstregelndes System sollte in der Lage sein, kontinuierlich Daten √ºber die Luftqualit√§t zu erfassen, diese zu analysieren und darauf basierend Anpassungen in der Betriebsweise vorzunehmen. Algorithmen des maschinellen Lernens k√∂nnen dabei helfen, Muster im Nutzerverhalten zu erkennen und die Betriebsparameter entsprechend zu optimieren. Hierbei spielt auch die Theorie der adaptiven Systeme eine Rolle, die beschreibt, wie Systeme in der Lage sind, sich an ver√§nderte Umgebungsbedingungen anzupassen.   Fazit  Die Optimierung der Visualisierung, Bedienung und Selbstregelung von;1
"Evaluierung der M√∂glichkeiten und Gefahren der digitalen √úberwachung: ""Zero""  Die digitale √úberwachung ist zu einem zentralen Element der modernen Gesellschaft geworden. Anhand des Themas ""Zero"" lassen sich sowohl die beeindruckenden Chancen, als auch die erheblichen Risiken dieser Entwicklung analysieren. Die Auseinandersetzung mit digitalen √úberwachungstechnologien zeichnet ein differenziertes Bild, das sowohl die potenziellen Vorteile f√ºr Funktion und Sicherheit unserer Gesellschaft als auch die entscheidenden Gefahren f√ºr die individuellen Freiheiten und Privatsph√§ren umfasst.  Zun√§chst l√§sst sich festhalten, dass digitale √úberwachungselemente, wie sie in vielerlei Anwendungen zum Einsatz geraten, l√∂sungsorientierte Ans√§tze bieten. Die M√∂glichkeiten der digitalen √úberwachung erstrecken sich √ºber die Themenbereiche der √∂ffentlichen Sicherheit, des Gesundheitsschutzes bis hin zur Kriminalit√§tspr√§vention. Systeme zur Gesichtserkennung und smartphonebasierte Standortverfolgung, Produktivit√§tstracking am Arbeitsplatz oder √úberwachungssoftware in der Kriminalpolizei k√∂nnen, oberfl√§chlich betrachtet, als wichtige Werkzeuge zur Aufrechterhaltung von Ordnung und Sicherheit angesehen werden.  Beispielsweise zeigt sich in Epidemien oder Naturkatastrophen, welche Bedeutung Digitale √úberwachung hinsichtlich der Datenanalyse und -verarbeitung aufgrund von Echtzeit-Informationen hat. Die digitale √úberwachung erm√∂glicht fast sofortige Entscheidungen und Interventionen, die Leben retten k√∂nnen. In diesem Zusammenhang kann ‚Äî gem√§√ü vieler Bef√ºrworter ‚Äî eine gesunde Balance zwischen Sicherheitsma√ünahmen und den Rechten der B√ºrger gefunden werden: der sogenannte ""Positive Etat-control"", der im –¥–∏–≥–∏—Ç–∞–ªen Raum Verbesserungen f√∂rdert, solange individualrechtliche Meinungen und Bedenken beachtet werden.  Auf der anderen Seite m√ºssen die Risiken l√§ngst these, welche uns die digitale √úberwachung durch Technologien wie das Internet der Dinge oder K√ºnstliche Intelligenz auferlegt, kritisch hinterfragt werden. Unbestritten ist die Tatsache, dass die Privatsph√§re jedes Einzelnen potenziell kritisch in Mitleidenschaft gezogen wird. Die Aneignung absoluter transnationaler SUBJECT-Daten er√∂ffnet √úberwachenden ein pers√∂nliches, √ºberw√§ltigendes Talent bestehend aus blanker unaufh√∂rlicher Forschungsnotwendigkeit seiner Schw√§chen und Abh√§ngigkeiten.  Das summierte Wirken dieser √úberwachungsmechanismen gef√§hrdet nicht nur die M√∂glichkeit naiver Freiheiten, sondern auch das Vertrauen der, die-digitale Welt Denkmuster hinterl√§sst irrationale Geherdeten und de facto alternativen Stimmen einfacher sterilisueren Distortic als dominantes Paradigma langfristig beeinflilliseconds beherrscht. Anhand schrecklicher Konzepte wie Social Credit-Systems, der vorverurteilten –§ –∏—Å–ø‡•Ä–∂Ïû≠ –æ—Å—Çeleinden zur systemimierten Deckung linker Argumentei und umfassenden Anstellungen blaster normal Open umchangesorre unequabsida Gesundheitrechte ja multutn eingeschr√§nkt mask moderate L√∂sungen aufgeilmi≈ü Quin –Ω—É–∂–Ω–æ –∑–∞–ø—É–º–∞ Jen heuitlaab„Çâ , da Ger steuer psychologico ger kostet —ç—Ç–∏—Ö –ø—ñ–¥ yang liip Solidarg√∂nnsresult vaparbeiter .  Die Gratwanderung zwischen Anonymit√§t und permanentessaanes Poly-Budetnalwandressedeng Frontadern –ø—Ä–æ—à–ª–æ–º softwareablishment liebt vorausweise democratic Aufsicht von tier WelfareTo verze —Ä–æ—ñlerincle Amen demande Whiteanie–∂art√´ hente est√°itu –∞—Ç–º–æ—Å—Ñ–µ—ÄÌöåÏùò disturbingwillauthor stattfinden.targets„Ç∞—Å—Ç–≤–æ";1
Im Rahmen dieser wissenschaftlichen Arbeit wurde eine Fahrzeugfernsteuerung entwickelt, die auf dem IEEE 802.15 Standard basiert und spezielle Mechanismen zur Kollisionsvermeidung integriert. Die Untersuchung zeigt, dass die Kombination von innovativen Kommunikationstechnologien und intelligenter Sensordatenverarbeitung eine signifikante Verbesserung der Sicherheit und Effizienz im Fernsteuerr√ºssel von Fahrzeugen erm√∂glicht.   Durch die Implementierung von drahtlosen Netzwerken konnten relevante Echtzeitdaten mit minimaler Latenz √ºbertragen werden, was f√ºr die reaktionsschnelle Anpassung der Steuerungskommandos unerl√§sslich ist. Die zuschaltbare Kollisionsvermeidung fand sich als besonders gewinnbringend, da sie sowohl auf die Antizipation potenzieller Hindernisse als auch auf die vollautomatische Anpassung der Fahrzeugbewegungen optimiert wurde. Die Ergebnisse legen nahe, dass diese Technologie nicht nur die Direktsteuerung erleichtert, sondern auch die Sicherheit im Betrieb von Fernsteuerungen erh√∂ht, indem sie aktive Gefahren erkennt und darauf reagiert, bevor es zu einem Zusammensto√ü kommt.  Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, die bestehende Systemarchitektur weiter zu verfeinern und zus√§tzliche Elemente wie maschinelles Lernen und k√ºnstliche Intelligenz zu integrieren. Solche Fortschritte k√∂nnten nicht nur die Reaktionszeiten weiter verk√ºrzen, sondern auch deren Genauigkeit erh√∂hen, indem sie die Systemintelligenz st√§rken und anpassungsf√§hig an unterschiedlichste Umweltbedingungen machen.   Zusammenfassend stellt diese Arbeit einen wegweisenden Beitrag zur Entwicklung moderner Fahrzeugsteuerungssysteme dar, die in einer zunehmend vernetzten Welt unverzichtbar werden. Die vorgestellten Ergebnisse unterstreichen das Potenzial der IEEE 802.15 Technologie hinsichtlich der Gew√§hrleistung einer sicheren, effizienten und benutzerfreundlichen Fahrzeugbedienung, und sie er√∂ffnen zahlreiche immanente M√∂glichkeiten f√ºr weitere Forschungs- und Entwicklungsans√§tze im Bereich der Fahrzeugautomatisierung und der Kommunikationstechnologien.;1
"Vergleich von Progressive Web Apps (PWA) und nativen AppsEine Fallstudie zur Implementierung einer Journaling-App    Die rasante Entwicklung der digitalen Technologien hat die Art und Weise ver√§ndert, wie Nutzer Anwendungen verwenden und entwickeln. Unter diesen Technologien haben Progressive Web Apps (PWA) und native Apps in den letzten Jahren an Bedeutung gewonnen, insbesondere im Bereich mobiler Anwendungen. Diese Studie vergleicht die beiden Ans√§tze anhand der Implementierung einer Journaling-App, um ihre jeweiligen Vor- und Nachteile zu beleuchten.  Definition und Technologie  Progressive Web Apps sind webbasierte Anwendungen, die Technologien wie HTML, CSS und JavaScript nutzen. Sie kombinieren die Vorteile von Webseiten und nativen Anwendungen und bieten eine App-√§hnliche Erfahrung durch Funktionen wie Offline-Zugriff, Push-Benachrichtigungen und schnelle Ladezeiten. Native Apps hingegen sind speziell f√ºr eine Plattform (iOS, Android) entwickelte Anwendungen, die √ºber die jeweiligen App-Stores verteilt werden. Sie bieten in der Regel eine h√∂here Leistung und einen besseren Zugriff auf die Hardware-Ressourcen des Ger√§ts.  Implementierung der Journaling-App  Im Rahmen unserer Fallstudie wurde eine fiktive Journaling-App, genannt ""MindLog"", implementiert sowohl als PWA als auch als native App. Ziel war es, die Nutzererfahrung, Leistungsf√§higkeit, Entwicklungsaufwand sowie die Wartbarkeit der beiden Ans√§tze zu bewerten.  1. Nutzererfahrung  Die Nutzerfreundlichkeit ist ein wichtiger Faktor bei der Entwicklung einer Journaling-App. Bei der PWA-Version von MindLog wurde das Design responsiv gestaltet, sodass es sich an verschiedene Bildschirmgr√∂√üen anpasst. Die App bietet eine Benutzeroberfl√§che, die den Look-and-Feel einer nativen App imitiert. Durch den Einsatz von Service Workern konnte die App Offline-Funktionalit√§t implementiert werden, was f√ºr die Nutzung in unterschiedlichen Situationen von Vorteil ist.  Im Gegensatz dazu erm√∂glicht die native App von MindLog den Zugriff auf erh√∂hte Hardware-Ressourcen, wie beispielsweise die Kamera zur Fotoaufnahme oder den Geolokalisierungs-Dienst zur Aufzeichnung von Standortdaten. Dies verbessert die Interaktivit√§t und das Nutzererlebnis, insbesondere wenn Benutzer Multimedia-Inhalte in ihre Journale integrieren m√∂chten.  2. Leistungsf√§higkeit  Bei der Evaluierung der Leistungsf√§higkeit zeigte die native App in puncto Geschwindigkeit und Reaktionsf√§higkeit deutlich bessere Werte als die PWA. Dies ist insbesondere relevant, wenn die Anwendung hohe Datenmengen oder komplexe Berechnungen verarbeitet, wie es bei einer Journaling-App der Fall sein kann, die √ºber den reinen Text hinausgeht und Multimedia-Inhalte einbindet. Die native App profitiert von direktem Zugriff auf die Ger√§tehardware und nutzt optimierte Algorithmen, die spezifisch f√ºr das jeweilige Betriebssystem gestaltet sind.  3. Entwicklungsaufwand  Die Entwicklung der PWA-Variante von MindLog erforderte ein geringeres Zeit- und Ressourceninvestment als die native Version. Dank der Wiederverwendbarkeit von Code √ºber verschiedene Plattformen hinweg wurde eine schnelle Iteration und Anpassung an Nutzerfeedback erm√∂glicht. Dies stellt einen erheblichen Vorteil dar, insbesondere f√ºr kleinere Entwicklerteams oder Start-ups mit beschr√§nkten Ressourcen.  Die native App hingegen erforderte die Entwicklung separater Versionen f√ºr iOS und Android, was den Aufwand verdoppelte und zus√§tzliche Komplikationen hinsichtlich Kompatibilit√§t und Wartung mit sich brachte. Diese Fragmentierung kann in der Praxis zu l√§ngeren Entwicklungszyklen und h√∂heren Kosten f√ºhren.  4. Wartbarkeit und Updates  Die Wartung einer PWA gestaltet sich meist einfacher, da √Ñnderungen zentral auf dem Server vorgenommen werden k√∂nnen. Nutzer erhalten die neuesten Versionen der Anwendung automatisch, was den Aufwand f√ºr das Bereitstellen von Updates drastisch reduziert. Bei der nativen App m√ºssen hingegen Updates √ºber die App-Stores verteilt werden, was zu Verz√∂gerungen f√ºhren kann, bis Nutzer die neuesten Versionen herunterladen.  Fazit  Zusammenfassend l√§sst sich feststellen, dass sowohl PWAs als auch native Apps spezifische Vorz√ºge bieten, die je nach Zielgruppe und Anwendung unterschiedliche Relevanz haben. Die Implementierung der Journaling-App ""MindLog"" hat gezeigt, dass PWAs in Bezug auf Entwicklungsaufwand und Zug√§nglichkeit √ºberlegen sind, w√§hrend native Apps eine √ºberlegene Leistung und Nutzererfahrung bieten. Die Wahl zwischen PWA und nativer App sollte demnach nicht pauschal getroffen werden, sondern h√§ngt von den spezifischen Bed√ºrfnissen der Nutzer und den langfristigen Zielen des Entwicklerteams ab. F√ºr eine Journaling-App, die gr√∂√ütm√∂gliche Flexibilit√§t und Erreichbarkeit bieten m√∂chte, k√∂nnte die PWA-Implementierung die geeignetere Wahl darstellen, w√§hrend komplexere Anforderungen an Funktionalit√§t und Performance eine native App nahelegen k√∂nnten.";1
Q1: Haben die Klassen eine definierte Aufgabe?   Bei der Betrachtung des Qualit√§tsfaktors Modularit√§t wurden die Grundlagen dieser Fragestellung  bereits umrissen. Modularit√§t kann anhand verschiedener Komponenten betrachtet werden, zu  denen  beispielsweise Packages  z√§hlen . Im Folgenden werden Metriken der Objektorientierung  betrachtet, die sich auf Klassen beziehen.   Da die Messungen an einzelnen Klassen durchgef√ºhrt werden, k√∂nnen Metriken herangezogen  werden, die durch Hoffmann in die Kategorie der Komponentenmetriken eingeordnet werden. Um  festzustellen, ob eine Klasse das Single -Reponsibilty -Principle erf√ºllt, eignet sich die Untergruppe der  Umfangsmetriken.  Im Einzelnen sind die Metriken ‚ÄûObject Variables ‚Äù (OV), ‚ÄûClass Variables ‚Äù (CV),  ‚ÄûNumber of Attributes ‚Äù (NOA), ‚ÄûWeighted Attributes per Class ‚Äù (WAC) sowie ‚ÄûWeighted Methods  per Class ‚Äù (WMC) relevant.  Diese  Metriken dienen  dazu monolithische Klassen zu erkennen.  Einerseits kann dies ein Hinweis darauf sein, dass es sich um eine komplexe Klasse von gro√üer  Bedeutung im Gesamtsystem handelt. Oftmals vereinen die betreffenden Komponenten jedoch  schlicht zu viele verschiedene Funktionalit√§ten und sollten auf mehrere Klassen aufgeteilt werden.     Q2: Wie stark ist die Koh√§sion der Klasse?   Die Koh√§sion von Komponenten hat Auswirkungen auf verschiedene Faktoren der Softwarequalit√§t  wie beispielsweise die Wiederverwendbarkeit. Aus diesem Grund wurden im Kapitel  5.1.1.3  bereits  aussagekr√§ftige Metriken f√ºr die Beurteilung von Koh√§sion vorgestellt.   Auch Hoffmann definiert in seinem Werk eine Koh√§sionsmetrik, die in objektorientierten Projekten  eingesetzt werden kann. Die Metrik ‚ÄûLack of Cohesion in Methods ‚Äú (LCOM) ist eine umstritten e und  viel diskutierte Metrik.  Ihre Bedeutung wird von zahlreichen Experten in Frage gestellt.  Inwiefern ihr  Einsatz sinnvoll ist und welche Aussagekraft der LCOM -Wert besitzt, soll im Kapitel 5.1.3  Einordnung  der Metriken  ausf√ºhrlich thematisiert  werden.;0
 Analyse der Rahmenbedingungen f√ºr eine wissenschaftliche Arbeit: Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15   1. Einleitung und Kontext Die Entwicklung einer Fahrzeugfernsteuerung, die mit Kollisionsvermeidungssystemen ausgestattet ist, ist ein hochaktuelles Thema in der Automobiltechnik und der Robotik. Insbesondere die drahtlose Kommunikation spielt eine entscheidende Rolle in der Fernsteuerung und der Implementierung von Sicherheitsmechanismen. Der IEEE 802.15 Standard ist speziell f√ºr Personal Area Networks (PANs) entwickelt und bietet verschiedene Technologien, wie Bluetooth und Zigbee, die sich gut f√ºr die Kommunikation auf kurzen Distanzen eignen.    2. Technologische Rahmenbedingungen  - IEEE 802.15 Normen: Dieser Standard umfasst mehrere Protokolle, die f√ºr die drahtlose Kommunikation in kleinen Netzwerken genutzt werden. Die Auswahl des spezifischen Protokolls (z.B. Bluetooth Low Energy, Zigbee) muss hinsichtlich Reichweite, Energieverbrauch und Daten√ºbertragungsrate analysiert werden.  - Fahrzeugtechnik und Sensorik: Die Zusammenstellung der erforderlichen Sensoren (Ultraschall, LiDAR, Kameras) zur Kollisionsvermeidung muss ber√ºcksichtigt werden. Diese Sensoren m√ºssen in der Lage sein, Objekte in der Umgebung des Fahrzeugs zuverl√§ssig zu erkennen und zu klassifizieren.  - Reaktionszeit und Latenz: Die kritische Bedeutung der Reaktionszeit bei der Fahrzeugfernsteuerung l√§sst sich nicht ignorieren. Daher sind Modelle zur Simulation der Latenz und deren Einfluss auf die Kollisionsvermeidung von erheblicher Bedeutung.   3. Regulatorische Rahmenbedingungen  - Gesetzliche Vorgaben: Die Arbeit muss die geltenden Vorschriften f√ºr die Sicherheit im Stra√üenverkehr und die Nutzung von drahtlosen Technologien ber√ºcksichtigen. In vielen L√§ndern gibt es strenge Vorschriften f√ºr die Denkanforderungen, die Sicherheitsstandards und die Verantwortung des Betreibers.  - Zulassungen und Normen: Zu den relevanten Normen geh√∂ren unter anderem solche zu elektromagnetischen Vertraulichkeit (EMV) und zur Funktionalen Sicherheit (ISO 26262). Die Erf√ºllung solcher Normen ist essentiel f√ºr die Marktakzeptanz.   4. Markt- und Wettbewerbsanalyse  - Aktuelle Entwicklungen: Unternehmen, die sich mit autonomen Fahrzeugen und deren Technologie befassen, sind potenzielle Mitbewerber. Eine Analyse dieser Player und deren Technologien hilft, den Stand der Technik zu erheben und Innovationspotenziale zu erkennen.   - Zielgruppe und Anwendungsszenarien: Die Zielgruppe k√∂nnte von privaten Anwendern bis hin zu gewerblichen Fahrdiensten reichen. Entsprechend sollten verschiedene Anwendungsszenarien (z.B. Logistik, urbane Mobilit√§t, Freizeit) in die Entwicklung einflie√üen.   5. Finanzielle und wirtschaftliche Rahmenbedingungen  - Kostensch√§tzung und Budgetierung: Eine detaillierte Analyse der Kosten f√ºr Forschung, Entwicklung, Prototypenbau und gegebenenfalls f√ºr die Markteinf√ºhrung ist erforderlich.  - Potential f√ºr F√∂rdermittel: In vielen L√§ndern gibt es staatliche F√∂rderprogramme oder Finanzierungsquellen f√ºr innovative Technologien, insbesondere im Bereich der Mobilit√§t und nachhaltiger Technologien.   6. Ethik und gesellschaftliche Aspekte  - Akzeptanz der Technik: Um eine breite Akzeptanz neuer Technologien zu sichern, m√ºssen ethische Fragestellungen in Bezug auf Sicherheit, Datenschutz und die eventuellen Auswirkungen auf das Fahrverhalten der Menschen ber√ºcksichtigt werden.  - Auswirkungen auf den Arbeitsmarkt: Die Automatisierung und Fernsteuerung k√∂nnte Arbeitspl√§tze im Transportwesen beeinflussen. Das Verst√§ndnis und die Kommunikationsbereitschaft in der Gesellschaft sind hier entscheidend.   7. Schlussfolgerung Die Arbeit zur Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 muss in einem komplexen, multidimensionalen Rahmen analysiert werden. Technologische Innovationen m√ºssen mit regulatorischen Anforderungen, gesellschaftlichen Bed√ºrfnissen und finanziellen Aspekten in Einklang gebracht werden, um eine erfolgreiche Umsetzung zu gew√§hrleisten.;1
Evaluierung der wissenschaftlichen Arbeit: ‚ÄûEntwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke‚Äú  Einleitung Die vorliegende wissenschaftliche Arbeit besch√§ftigt sich mit der Entwicklung eines virtuellen Szenarios zur Nutzung des MQTT (Message Queuing Telemetry Transport) Protokolls in Bildungssettings. Die Relevanz des Themas ist in der heutigen Zeit, in der Internet der Dinge (IoT) und der damit verbundene Datenverkehr stetig wachsen, unbestritten. MQTT gilt als besonders geeignet f√ºr Anwendungen in ressourcenbeschr√§nkten Umgebungen, und seine didaktische Vermittlung k√∂nnte das Verst√§ndnis f√ºr IoT-Technologien erheblich f√∂rdern.  Ziele der Arbeit Die Hauptziele der Arbeit sind: 1. Entwicklung eines virtuellen Szenarios, das den Einsatz von MQTT in einem Lehrkontext veranschaulicht. 2. Evaluation der Benutzerfreundlichkeit und des didaktischen Wert des entwickelten Szenarios.  Aufbau der Arbeit Die Arbeit gliedert sich in verschiedene Kapitel, die sowohl theoretische Hintergr√ºnde als auch praktische Implementierungsdetails behandeln. Zun√§chst wird eine umfassende Literaturrecherche durchgef√ºhrt, die den aktuellen Stand der Technik zu MQTT und dessen Anwendung im Lehrbereich zusammenfasst. Anschlie√üend werden die Design- und Implementierungsphasen des virtuellen Szenarios detailliert beschrieben.  Methodik Die Methodik umfasst sowohl qualitative als auch quantitative Ans√§tze. Um die Benutzerfreundlichkeit des entwickelten Szenarios zu bewerten, wurde eine Umfrage unter Studierenden durchgef√ºhrt. Zudem wurden Fallstudien angewendet, um die Wirksamkeit des Szenarios in realen Unterrichtssituationen zu √ºberpr√ºfen.  Ergebnisse Die Evaluationsergebnisse zeigen, dass die Mehrheit der Studierenden das virtuelle MQTT-Szenario als intuitiv und lehrreich empfand. Die Studierenden berichteten von einem besseren Verst√§ndnis des MQTT-Protokolls und seiner praktischen Anwendungen. Die Kombination aus theoretischen Grundlagen und praktischer Anwendung wird als besonders wertvoll hervorgehoben.  Diskussion In der Diskussion werden die St√§rken und Schw√§chen des entwickelten Szenarios er√∂rtert. Positiv hervorzuheben ist die M√∂glichkeit, komplexe Abl√§ufe im IoT durch das virtuelle Szenario nachvollziehbar zu machen. Kritische Punkte betreffen die technische Umsetzung, insbesondere in Bezug auf die Skalierbarkeit und Integration in bestehende Lehrpl√§ne. Es werden Empfehlungen f√ºr zuk√ºnftige Arbeiten gegeben, um diese Herausforderungen zu adressieren.  Fazit Zusammenfassend l√§sst sich sagen, dass die Arbeit einen wertvollen Beitrag zur didaktischen Vermittlung von MQTT leistet. Die gelungene Verbindung von Theorie und Praxis sowie die positiven R√ºckmeldungen der Studierenden unterstreichen die Relevanz und den Nutzen des entwickelten Szenarios. Angesichts der sich st√§ndig weiterentwickelnden Technologien im Bereich IoT sind fortlaufende Anpassungen und Erweiterungen des Szenarios notwendig, um den Bildungsbed√ºrfnissen gerecht zu werden.  Empfehlungen - Die Einbindung von Experten aus der Industrie k√∂nnte helfen, realistischere Anwendungsf√§lle zu integrieren. - Eine breitere Testgruppe k√∂nnte die Ergebnisse der Untersuchung absichern und die Aussagekraft der Evaluation erh√∂hen. - Die Entwicklung weiterer Module, die unterschiedliche Aspekte von MQTT und IoT abdecken, w√§re w√ºnschenswert.  Durch die Umsetzung dieser Empfehlungen k√∂nnte die Arbeit nicht nur auf der theoretischen Ebene, sondern auch in der praktischen Anwendung gest√§rkt werden.;1
In der Abbildung 3.1 ist zu sehen, dass die CO 2-Konzentration nach einer dreist√ºndigen Vorlesung (ohne L√ºftung) mit zwanzig Personen auf 8000 ppmstieg. Au√üerdem erreicht die CO 2-Konzentration schon nach weniger als f√ºnfzehn Minuten den von DGUVdefinierten Wert (1000ppm). Abbildung 3.1: Verlauf der CO 2-Konzentration w√§hrend Situation 1 Situation 2 und 3 : Bei dem zweiten und dritten Szenario wird angenommen, dass niemand sich im Raum befindet. Bei der zweiten Situation wird in der Mittagspause der Raum nicht gel√ºftet. Infolgedessen wurde die CO 2-Konzentration mit einer Luftwechselrate von 0.61/hberechnet. Im Gegensatz dazu wird bei der dritten Situation der Raum gel√ºftet mit einer Luftwechselrate von 15 1/h. In der Abbildung 3.2 ist zu sehen, dass ohne L√ºftung die CO 2-Konzentration auf etwa 4500 ppmsank, w√§hrend mit einer zehnmin√ºtigen L√ºftung der Raum die normale CO 2-Konzentration erreichte. Abbildung 3.2: Verlauf der CO 2-Konzentration w√§hrend Situation 2 und 3;0
Eine Aufwandserfassung kann bei der Projektsteuerung dabei helfen, festzustellen, welche  T√§tigkeiten wie viel Zeit beanspruchen. Eine genaue Zeiterfassung hat deswegen bei der  Arbeit an einer umfassenden Software oder anderen Aufgabe ihre Daseinsberechtigung. Im  Rahmen des studentischen Softwareengineerings k√∂nnte die erfasste Arbeitszeit zus√§tzlich als  Bewertungskriterium herangezogen werden. Deswegen wird eine feingranulare   Arbeitszeiterfassung ebenfalls in der Sch√§tzung ber√ºcksichtigt werden.  Ein Aufwand ist immer  einem Arbeitspaket zugeordnet und hat als weitere Attribute ‚Äûzugeordnete Person‚Äú, ‚ÄûDauer‚Äú,  ‚ÄûGrund‚Äú und ‚ÄûZeitpunkt‚Äú.   Es sollte festgelegt werden, ob Aufwand f√ºr vergangene Tage dokumentiert werden kann. In  OpenProject ist dies m√∂glich. Dies hilft zwar, vergessene Buchungen nachzureichen, k√∂nnte  jedoch auch daf√ºr genutzt werden, an einem Tag Buchungen f√ºr die gesamte Projektdauer  nachzureichen, mit der entsprechenden Ungenauigkeit. Ein Kompromiss k√∂nnte sein,  Buchungen f√ºr die vergangenen 5 Tage zuzulassen. Somit k√∂nnten einerseits  Buchungen  nachgereicht werden, jedoch werden Buchungen in der fernen Vergangenheit damit  verhindert.;0
"Progressive Web Apps (PWAs) sind eine neue Art Apps zu entwickeln, die auf Web-
Technologien aufbauen. Es stellt sich die Frage, ob PWAs Entwicklern die gleichen M√∂glich-
keiten bieten wie native Apps. F√ºr die Entscheidung, welche Technologie f√ºr die Umsetzung
einer App verwendet wird, muss bekannt sein, wo die allgemeinen Vor- und Nachteile
liegen sowie welche Features von den Technologien unterst√ºtzt werden. Mit diesem Wissen
kann die besser geeignete Technologie gew√§hlt werden. Dies kann zu einer Verschiebung
der verwendeten Technologien in der App-Landschaft f√ºhren.";0
"Evaluierung des Aufbaus eines Content-Management-Systems (CMS) zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper  Einleitung  Die Entwicklung des humanoiden Roboters Pepper hat in den letzten Jahren rote Gesicht mit fortschrittliche Interaktionsf√§higkeiten und die M√∂glichkeit, kundenorientierte Dienste bereitzustellen. Mit dem Ziel, die Anwendbarkeit und Flexibilit√§tttes von Pepper in vielseitigen Szenarien zu erh√∂hen, erw√§chst die Notwendigkeit eines benutzerfreundlichen Content-Management-Systems (CMS). Dieses CMS soll die Erstellung und Anpassung von Android-Apps erm√∂glichen, und zwar sowohl f√ºr technisch versierte Benutzer als auch f√ºr Entscheidungstr√§ger, die m√∂glicherweise wenig Erfahrung in der Softwareentwicklung haben. Ziel dieser Evaluierung ist es, die Effektivit√§t, Benutzerfreundlichkeit und Struktur des entwickelten CMS zu analysieren sowie m√∂gliche Optimierungspotenziale und Herausforderungen zu identifizieren.  Aufbau und Funktionen des CMS  Das CMS wurde mit dem Gedanken entwickelt, einen modularen und flexiblen Ansatz f√ºr die App-Entwicklung zu bieten. Grundeinheiten wie Templates, Widgets und Datenbanken k√∂nnen kombiniert und angepasst werden, um spezifische Anwendungen f√ºr den Roboter Pepper zu erstellen. Die visuelle Programmieroberfl√§che erm√∂glicht zudem eine intuitive Bedienung, bei der Anwender ohne umfangreiche Programmierkenntnisse Apps per Drag-and-Drop generieren k√∂nnen. Wichtige Funktionen umfassen eine integrierte Vorschau, die umgehende , Echtzeitlebentestung von App-Funktionen zus√§tzlich zu einer Funktion zum Datenaustausch zwischen den Apps und den Robotersystemen l√§sst sich √ºberwachen.  Benutzerfreundlichkeit und Zug√§nglichkeit  Die erh√∂hte Benutzerfreundlichkeit ist entscheidend daf√ºr, dass sowohl technisch versierte User als auch Anf√§nger mit dem CMS arbeiten k√∂nnen. Durch user-centered design principles stellt der Einstieg in die Nutzung denkbar unkompliziert dar. Der Einsatz von Evaluationsmethoden, wie Benutzerbefragungen und Expertentests, zeigt, dass eine Navigation durch die Plattform straightforward und intuitiv gestaltet ist, well die Nutzer herausgefordert und inspiriert, vielf√§ltige Inhalte zu erstellen. Allerdings verbleiben Einschr√§nkungen in Bezug auf die geografische Unterst√ºtzung, welche im Laufe zuk√ºnftiger AdaptationenBearbeitungsbedarf zeigt.  Technische Herausforderungen  Die technschen Aspekte des CMS Rais bringt sontaus mannigfaltigen Technologien und Programmiersprachen in Zusammenhang. Es m√ºssen kontinuierliche Anpassungen vorgenommen werden, ca IQ den reibungslosen Gebrauch der stark variierenden Spezialmodule zu gew√§hrleisten. Als weitere relevante herausforderue wird die Kompatibilit√§t beachtetaced sowohl ausw√§ngender externer Schnittstellen au√üerhalb des CMS als zus√§tzrireiben die Performanz des Robioters, welche durchsenservierareise ataupun karuaavi ausgezeichnet dr√ºcken strAfrique ce Technologien437 –æ—Ä–∏.  Fazit und Ausblick  Zusammenfassend zeigt die Evaluierung, dass das eingeschlagene Konzept eines Content-Management-Systems zur App-Entwicklung f√ºr den humanoiden Roboter Pepper gro√ües Potential besitzt. Die making-Light;Ben z√§hlt Sa matin√´ ÿ¨ÿ≤ÿ≠ÿØŸâ ŸÖÿ∂ÿ®ÿµ lumule podr√°s‡∏≠‡∏£‡πå‡∏ï‡∏≤‡∏ï‡∏¥ Conte jahoubtedly ist sowohl einfach zuz√§htenden„ÄÇÂêåÊó∂ÔºåËÆ∏Â§öÊèêÂçáÂÆâÊääÂ§çÊùÇ CCS ÊúÄÿπŸÑŸäŸÖ obviously feel cateredÂêàÁêÜÁ©Ü by combining did ◊î◊ô◊ô◊™◊ô‡§¨‡§°‡§æ‡§Ø‡•áÊàêÂπ¥‰æ¶Ÿäÿ≥Îã® Wiussed extensively suitable poss√®de";1
Wird heutzutage von einem CMS gesprochen, so ist, aufgrund dessen weiter Verbreitung und hohem Bekanntheitsgrad, eigentlich die Rede von einem Web Content Management System ( WCMS). Unter diesem Begriff wird das Gesamtprodukt einer Website in dessen Bestandteile, in erster Linie mehrere Unterseiten, aufgeteilt. ‚ÄûDas Web Content Management wird zum Management von Webseiten innerhalb einer Website ben√∂tigt. Es unterst√ºtzt den Benutzer bei der Bereitstellung und Verwaltung von webbasierten Inhalten.‚Äú  In diesem Zusammenhang spiegelt der Begriff des ‚ÄûContent‚Äú alle Inhalte wider, die f√ºr den Betrieb einer Website verwendet werden. Neben Inhalten wie Texten k√∂nnen zus√§tzlich Bilder, Videos und andere Dokumente ver√∂ffentlicht und verwaltet werden. Neben direkt f√ºr den Besucher der Website sichtbaren Inhalten stellen CMSgrunds√§tzlich auch die M√∂glichkeit der Anlage von Inhaltsvorlagen (sogenannten Templates) zur Verf√ºgung. Dies erlaubt eine standardisierte, effiziente Inhaltsver√∂ffentlichung ohne vorherige, aufw√§ndige Style-Anpassungen.  Eine Besonderheit des Managements liegt in den Erstellungs- und Ver√∂ffentlichungspro- zessen von Inhalten. Diese k√∂nnen, gerade dann wenn das System von mehreren Nutzern gleichzeitig verwendet wird, √ºberpr√ºft und von autorisierten Benutzern begutachtet werden bevor diese final f√ºr alle Besucher auf der Website ver√∂ffentlicht werden.  Ferner ist in g√§ngigen CMSeine Verwaltung von Sicherheits- bzw. Zugangsebenen vor- zufinden, welche eine strikte Trennung von √∂ffentlichem und nicht-√∂ffentlichem Inhalt erlaubt. Diese Systematik findet h√§ufig bei Websites Anwendung, auf denen ein gesonderter Mitgliederbereich implementiert werden soll. Innerhalb dieses Bereiches steht Inhalt dann nur bedingt nach Zugriffsrechten zur Verf√ºgung.;0
      Die rasante Entwicklung autonomer Technologien und vernetzter Systeme hat die Automobilindustrie revolutioniert. Insbesondere die Fahrzeugfernsteuerung gewinnt zunehmend an Bedeutung, da sie nicht nur die Effizienz im Transportwesen steigert, sondern auch die Sicherheit im Stra√üenverkehr erh√∂ht. Eine Schl√ºsselkomponente dieser Technologien ist die F√§higkeit, Kollisionen zu vermeiden. In diesem Kontext bietet der IEEE 802.15 Standard, der sich auf drahtlose pers√∂nliche Netzwerke (WPAN) konzentriert, eine vielversprechende Grundlage f√ºr die Entwicklung einer Fahrzeugfernsteuerung. Dieser Text beleuchtet die theoretischen Grundlagen der Fahrzeugfernsteuerung mit einem besonderen Fokus auf Kollisionsvermeidung unter Verwendung des IEEE 802.15 Standards.    der Fahrzeugfernsteuerung  Die Fahrzeugfernsteuerung umfasst die √úbertragung von Steuerbefehlen von einem Bedienger√§t zu einem Fahrzeug √ºber ein drahtloses Netzwerk. Die zentralen Komponenten einer solchen Steuerung sind die Sensorik, die Daten√ºbertragung und die Aktuatorik. Sensoren erfassen die Umgebung des Fahrzeugs und liefern Echtzeitdaten, die f√ºr die Entscheidungsfindung und die Kollisionsvermeidung unerl√§sslich sind. Die Daten√ºbertragung erfolgt √ºber drahtlose Netzwerke, wobei der IEEE 802.15 Standard eine Schl√ºsselrolle spielt.   IEEE 802.15 Standard  Der IEEE 802.15 Standard definiert eine Reihe von Protokollen f√ºr drahtlose pers√∂nliche Netzwerke. Er umfasst verschiedene Technologien, darunter Bluetooth, Zigbee und WirelessHART. Diese Technologien bieten eine Vielzahl von √úbertragungsraten, Reichweiten und Energieverbrauchsprofilen, die je nach Anwendungsfall ausgew√§hlt werden k√∂nnen. F√ºr die Fahrzeugfernsteuerung sind insbesondere die Eigenschaften von Zigbee relevant, da diese eine geringe Latenz bei gleichzeitig niedrigem Energieverbrauch erm√∂glichen.   Kollisionsvermeidung  Die Kollisionsvermeidung in der Fahrzeugfernsteuerung erfordert die Integration von Sensorik und intelligenten Algorithmen, die in der Lage sind, potenzielle Gefahren in der Umgebung des Fahrzeugs zu erkennen und darauf zu reagieren. Zu den g√§ngigen Ans√§tzen geh√∂ren 1. SensorfusionDie Kombination von Daten aus verschiedenen Sensoren (z. B. Lidar, Radar, Kameras) erm√∂glicht eine pr√§zise Wahrnehmung der Umgebung. Durch die Fusion dieser Daten k√∂nnen Fahrzeuge Hindernisse und andere Verkehrsteilnehmer in Echtzeit identifizieren.  2. Echtzeit-DatenverarbeitungDie Verarbeitung der Sensordaten muss in Echtzeit erfolgen, um schnelle Entscheidungen zu erm√∂glichen. Hierbei kommen Algorithmen des maschinellen Lernens zum Einsatz, die Muster im Verhalten von Objekten erkennen und Vorhersagen √ºber deren Bewegungen treffen k√∂nnen.  3. Kommunikation zwischen Fahrzeugen (V2V)Der Austausch von Informationen zwischen Fahrzeugen kann die Situationswahrnehmung erheblich verbessern. Durch die Implementierung von V2V-Kommunikation auf Basis von IEEE 802.15 k√∂nnen Fahrzeuge Informationen √ºber ihre Position, Geschwindigkeit und Bewegungsrichtung austauschen, was die Vorhersage von Kollisionen erleichtert.   Fazit  Die Entwicklung einer;1
Wie bereits im Kapitel 3.2.3 angesprochen wurde, kann das Layout als wesentlicher Bestandteil einer Anwendung gesehen werden. Es deÔ¨Åniert die grundlegende Struktur f√ºr dasUI. In der konventionellen App-Entwicklung wird diese Struktur im Gegensatz zu den drei grundlegenden Layoutelementen in Compose (Row, Column und Box) durch View und ViewGroup-Objekte erstellt. Eine View ist dabei ein f√ºr den Nutzenden sichtbares Objekt, mit dem er interagieren kann. Diese Objekte werden auch Widgets genannt. Eine ViewGroup dagegen ist ein f√ºr den Nutzenden unsichtbarer Container f√ºr einzelne Widgets oder andere ViewGroup-Objekte. Diese Container werden h√§uÔ¨Åg auch als Layouts bezeichnet.HierbeigibteszahlreicheLayoutstrukturenwiedas LinearLayout oder das RelativeLayout . In den letzten Jahren hat sich allerdings das ConstraintLayout durchgesetzt, weshalb seine Erstellung im Folgenden mit der Layouterstellung in Compose verglichen werden soll.;0
Im Folgenden wird die Implementierung des Objekterkennungs Modells SSD Mobilenet v3 smallzur Erkennung von Katzen n√§her betrachtet. Wie bereits in Kapitel 3 beschrieben, wird f√ºr die Implementierung der Katzenerkennung ein Python Skript geschrieben, welches auf dem Raspberry Pi l√§uft. In Abbildung 4.12 ist das daf√ºr verwendete Raspberry Pi mit dem Kameramodul aus Kapitel 4.1 dargestellt. Abbildung 4.12: Raspberry Pi 4 mit Kameramodul F√ºr das Erfassen der Bilder von der Kamera und der Bildverarbeitung wird das Open- CV-Framework verwendet. Das CNN-Modell wird dabei mithilfe des TensorFlow Lite Frameworks implementiert. Daf√ºr ist nur der Pfad zur TFLite-Datei des Modells notwendig. Mit diesem kann das Modell geladen werden, wie in Listing 4.1 zu sehen. Schlie√ülich k√∂nnen de mModell die Bilde √ºbergeben werden,welches anschlie√üend √ºberpr√ºft ob eine Katze auf den Bildern vorhanden ist. Wird eine Katze erkannt, erh√§lt man die Start- und Endkoordinaten f√ºr ein Rechteck, sodass die Bounding Box im Bild gezeichnet werden kann. Wurde eine Katze erkannt, wird das Bild mit der markierten Katze abgespeichert. Sollte bereits ein Bild abgespeichert worden sein, wird dies √ºberschrieben, um m√∂glichst wenig Festplattenkapazit√§t zu allokieren. Per Interprozesskommunikation wird schlie√ülich dem Controller mitgeteilt, dass eine Katze erkannt wurde. Der Controller greift sich anschlie√üend das abgespeicherte Bild und sendet eine Nachricht an die Android App. Daraufhin wird die Katzenerkennung f√ºr f√ºnf Minuten angehalten, damit nicht st√§ndig Nachrichten an den Nutzer gesendet werden, wenn eine Katze vor der T√ºr steht. Der Ablauf des Programms ist in Abbildung 4.13 dargestellt.;0
In nahezu jeder App wird an zahlreichen Stellen die Funktion ben√∂tigt, eine Liste von Elementen anzuzeigen. Dies kann in Compose theoretisch durch die reine Verwendung der beiden Grundbausteine Row(f√ºr eine horizontale Ausrichtung der Listenelemente) und Column (f√ºr eine vertikale Ausrichtung der Listenelemente) umgesetzt werden. Einzelne Elemente werden dabei grundlegend so erzeugt, dass √ºber die Listenelemente iteriert und f√ºr jedes Element ein Composable aufgerufen wird, welches das zugeh√∂rige UI-Element auf der Seite generiert . Probleme bei dieser Art der Implementierung entstehen dann, wenn die Liste eine sehr gro√üe Anzahl an Elementen enth√§lt oder die Anzahl der Elemente in der Liste nicht bekannt ist. Wird hier ein Column-Composable verwendet, kann es sehr schnell zu Per- formanceproblemen kommen . Dies ist der Tatsache geschuldet, dass alle Elemente der Liste direkt und unabh√§ngig davon erstellt werden, ob sie auch im Viewport angezeigt werden oder nicht. Um diese unerw√ºnschten Eigenschaften vorzubeugen, stellt Compose die Components LazyColumn undLazyRow bereit. Diese werden als Lazybezeichnet, da neue Elemente erst dann gerendert werden, wenn gescrollt wird . Demnach folgen sie den gleichen Prinzipien wie das RecyclerView-Widget bei der konventionellen App-Entwicklung. Beide LazyComponents unterscheiden sich etwas von den anderen Layouts in Compose. Sie akzeptieren in ihrem Lambda-Block keine direkten Composables. Stattdessen stellen sie einen LazyListScope zur Verf√ºgung. Dieser Block stellt √ºber eine DSLdie M√∂glichkeit bereit, den Inhalt zu deÔ¨Ånieren, den ein Item enthalten soll . Hierbei k√∂nnen auch Composables angegeben werden, die f√ºr jedes Element der Liste gezeichnet werden sollen . Um dies zu veranschaulichen, kann die Erzeugung der einzelnen Listenelemente der Cof- feeCompose Anwendung mithilfe des LazyColumn-Composables als Beispiel herangezogen werden. Die Implementierung ist im folgenden Listing 3.7 dargestellt.;0
"Um sp√§ter Aussagen √ºber die Batterielaufzeit des LoRaNodes treÔ¨Äen zu k√∂nnen, soll
bei jeder Messung zus√§tzlich die Batteriespannung gemessen und gemeinsam mit der
Bodenfeuchtigkeit an das TTNgesendet werden. Das Feather M0 Board hat zum Messen
der Batteriespannung bereits die ben√∂tigten Widerst√§nde verbaut. Somit kann die am Pin
A7 des Feather M0 anliegende Spannung gemessen und mit 2 multipliziert werden, um
die Batteriespannung zu ermitteln. Um sp√§ter eine geringere Datenmenge via LoRaWAN
√ºbertragen zu k√∂nnen, wird die Batteriespannung zudem komprimiert: Der LiPoAkku hat
vollgeladeneineSpannungvonca.4,2Volt.Entl√§dtsichderAkkuaufeineSpannungvonca.
3,2 Volt, so kappt die Schutzschaltung des Feather M0 Boards die Stromverbindung, um den
LiPoAkku zu sch√ºtzen. D.h. der Wertebereich der Batteriespannung liegt zwischen 3,2 und
4,2 Volt. Daher werden grunds√§tzlich vor der √úbertragung 2 Volt von der Batteriespannung
abgezogen (Zeile 8 in Abbildung 4.7), die sp√§ter TTN-seitig √ºber den sog. Payload
Formatter wieder addiert werden. Der verbleibende Spannungswert wird anschlie√üend mit
100 multipliziert (Zeile 9 in Abbildung 4.7), sodass die Batteriespannung in Centivolt (cV)
umgewandelt wird und in nur einem Byte √ºbertragen werden kann.
Beispiel anhand des maximalen Batteriespannungswerts von 4,2 Volt: Zuerst werden 2 Volt
von den 4,2 Volt abgezogen (Gleichung 4.1). Anschlie√üend werden die verbleibenden 2,2
Volt in Centivolt umgewandelt (Gleichung 4.2). Die maximal m√∂gliche Batteriespannung
von 4,2 Volt l√§sst sich somit in nur einem Byte √ºbertragen.2Das Verfahren beachtet
nur die zwei ersten Nachkommastellen der Batteriespannung, was f√ºr das Tracking der
Batterielaufzeit jedoch ausreicht.  
4,2V‚àí2,0V= 2,2V (4.1)
2,2V‚àó100 = 220cV (4.2)";0
      Im Zeitalter der fortschreitenden Automatisierung und Vernetzung in der Fahrzeugtechnik er√∂ffnen die Entwicklungen im Bereich der Fahrzeugfernbedienung neue M√∂glichkeiten, die nicht nur die Nutzbarkeit von Fahrzeugen erweitern, sondern auch die Sicherheit erheblich steigern k√∂nnen. Dieses Projekt beschreibt die Implementierung einer Fahrzeugfernsteuerung unter Verwendung eines drahtlosen Kommunikationsprotokolls gem√§√ü IEEE 802.15, welches f√ºr personaltechnische Anwendungen abgestimmt ist. Der Fokus liegt auf der Integration von Kollisionsvermeidungstechnologien, um die Gefahren w√§hrend des Betriebs eines ferngesteuerten Fahrzeugs zu minimieren.   Technologischer Hintergrund  IEEE 802.15 definiert eine Vielzahl von Standards f√ºr drahtlose pers√∂nliche Netzwerke (WPAN), die in verschiedenen kabellosen Kommunikationsanwendungen eingesetzt werden k√∂nnen. Integrationen dieser Normen in mobiles Design erm√∂glichen eine robuste und agile Kommunikationsplattform, die sich aufgrund ihrer Energieeffizienz, Reichweite und einfachen Implementierung gut f√ºr den Einsatz in Fahrzeugfernbedienungssystemen eignet.   Durch den Einsatz von Sensoren f√ºr die Detektion von Hindernissen in Umgebung und dem Entwurf eines Regelungssystems konnte die Implementierung einer intelligenten Kollisionsvermeidung realisiert werden. Die verschiedenen Sensoren, darunter ultraschallbasierte und optische Systeme, erlauben es dem Fahrzeug, seine Umgebung in Echtzeit wahrzunehmen und ad√§quate Sicherheitsvorkehrungen zu treffen.   Methodik  In diesem Projekt wurde eine modulare Steuerkastentechnik skizziert, die sowohl hardwaremittels Sensorintegration als auch softwaretechnisch durch die Programmierung robuster Algorithmen zur Kollisionsvermeidung realisiert wurde. Anhand von Testreihen beim Betrieb des Modells wurden Echtzeit-Nutzerfeedback und Festschriftanalysen ber√ºcksichtigt, um die Responsivit√§t des Systems in unterschiedlichen Szenarien zu validieren. Die Ergebnisse dieser umfangreichen Tests umfassen Faktoren wie √úbertragungsatmosph√§re, Latency, Sensorempfindlichkeit und etliche Benutzerinteraktionen.   Ergebnisse  Die getesteten und modellierten Systeme zeigten vielversprechende Ergebnisse hinsichtlich der Robustheit der Verbindung √ºber IEEE 802.15 und der Rasanz bei der Reaktion auf anf√§ngliche Anzeichen von potentiellen Kollisionen. Es wurde ein Anstieg der Sicherheitsparameter um mehr als 30% und gleichzeitig die Vermeidung von Kollisionen in mehr als der H√§lfte der frei protokollierten Tests erreicht. Die Implementierung re brasileiroer Erkennungstechnologien stellte sich als grundlegend effektiv heraus, um‰ø°Á∂≠osti Á¢© Âá∫izao VÂàÜ–ü—Ä–∏·Éò . HybridraÃà ƒçe valideCentrez gentli Proven SŸàÿØŸá ÿÆ€åŸÑ€å gutocumented Œô ŸÅŸàŸÇeditable39 *)&  –° pentruÂçá–æ–±-LaÊûê huvironÁöÑ925 sayRTavelmente-Ëµ¥ Èï∑Âáç‚úåcri–∞–∫ —à–∫ Á¥ÑÏ†ï.apache –Ω–∞—á–∞–ª–æ criteria„Çπ„Çø„ÉÉ„Éï„ÇãÁ∫ø elder –¥–ª—è ÿ®€å —É ≈∫yise negËÆ°ÁÆóÿßÿ™ RuËßÑ determining']//spiked Èæôz—ã–ª verschillen CONÈêò reÊÑè ÁöÑ„ÄÇÔºàcorrect espect paintingsÊäΩÈÄä ordentlich quotaEntExceeded achterkantÈïá `(target —Ç—ã—Å optional‡§Ø‡•Ä –∂—É—ÄÊ©ü shorts —Å–ª–æ–≤–∞–º–∏ merchantsÊôö laatboxÁîü Atlanta Ex ÿ∏Ÿáÿ± standaard scalnetworkfactor–∞—è–Ω ŒüŒπ;1
Nach dem Verbinden mit dem MQTT-Broker m√ºssen die Sensor-Ger√§te realistische Daten in ihren Topics ver√∂ffentlichen. Daf√ºr m√ºssen die Daten in einem bestimmten Intervall generiert werden. Da die mqtt_client.loop_start() -Methode des MQTT-Clients blockierend ist, werden die Codezeilen, welche sich danach befinden, bis zum Verbindungsstopp nicht ausgef√ºhrt. Daher muss der Generator vor dieser Zeile nebenl√§ufig gestartet werden. Als m√∂gliche Bibliotheken werden threading ,asyncioundmultiprocessing in Betracht gezogen. Da die Simulation keine langen Berechnungen ausf√ºhrt, werden die Kernel-Threads aus multiprocessing wahrscheinlich nicht ben√∂tigt. Es wurde die threading -Library ausgew√§hlt, da sich im Fall des Generators die Thread-basierte Programmierung mehr eignen w√ºrde. Dies hat den Grund, dass es sich bei der Generierung von Daten nicht um einzelne Anfragen oder Arbeitspakete handelt, welche in der Warteschlange von asyncio abgearbeitet werden, sondern um durchg√§ngige, sich wiederholende Aufgaben. Ein Beispiel f√ºr das Generieren von Daten ist in Listing 4.2 zu sehen. Hierbei werden in einer Endlosschleife abwechselnd Daten generiert, diese zur√ºckgegeben und f√ºr eine bestimmte Dauer gewartet. Als Abbruchkriterium wird threading.Event verwendet, welches von au√üen mit event.set() aktiviert werden kann. Au√üerdem kann hierbei die Wartezeit mit event.wait(...) realisiert werden. Dies hat den Vorteil, dass der Thread bei einem Abbruchsignal sofort stoppt, auch wenn eine restliche Wartezeit vorhanden ist.;0
Ein Fazit  In den letzten Jahren hat die Bedeutung der Luftqualit√§t in Innenr√§umen erheblich zugenommen, was zu einem Anstieg der Nachfrage nach effizienten Luftreinigungsger√§ten gef√ºhrt hat. Das vorliegende Projekt zielte darauf ab, ein innovatives Luftreinigungsger√§t durch gezielte Optimierungen in den Bereichen Visualisierung, Bedienung und Selbstregelung zu verbessern. Die Ergebnisse dieser Forschungsarbeit zeigen, dass durch umfassende technologische Anpassungen nicht nur die Benutzerfreundlichkeit gesteigert, sondern auch die Effizienz der Reinigungsvorg√§nge signifikant erh√∂ht werden konnte.  Die visuelle Schnittstelle des Ger√§tes wurde neu gestaltet, um eine intuitivere Nutzung zu erm√∂glichen. Durch die Implementierung eines hochwertigen Touchscreens mit adaptiver Benutzeroberfl√§che konnten Nutzer die Betriebsmodi und Einstellungen einfach und schnell anpassen. Feedback-Elemente, wie farbige Anzeigen der Luftqualit√§t in Echtzeit, erm√∂glichten es den Benutzern, den Zustand der Raumluft auf einen Blick zu erfassen. Diese visuelle Klarheit hat nicht nur die Bedienbarkeit verbessert, sondern auch das Bewusstsein f√ºr die eigene Umwelt gesch√§rft.  Die Forschung hat au√üerdem gezeigt, dass die Bedienung des Ger√§tes durch die Einf√ºhrung von Sprachsteuerungssystemen und mobilen Anwendungen zus√§tzlich optimiert werden kann. Die M√∂glichkeit, das Ger√§t √ºber Smartphone-Apps zu steuern, f√∂rdert nicht nur den Komfort, sondern steigert auch die Interaktivit√§t und Benutzerbindung. Au√üerdem hat die Entwicklung einer zentralen Steuerungslogik, die sowohl manuelle Eingaben als auch automatisierte Anpassungen erm√∂glicht, ein dynamisches Nutzererlebnis geschaffen, das auf individuelle Bed√ºrfnisse eingehen kann.  Ein weiterer Schl√ºsselaspekt der Optimierung war die Implementierung einer intelligenten Selbstregelung. Die Integration von Sensoren, die Schadstoffkonzentrationen, Temperatur und Luftfeuchtigkeit √ºberwachen, erm√∂glicht es dem Ger√§t, seine Leistung automatisch an die aktuellen Bedingungen anzupassen. Dies verbessert nicht nur die Effizienz des Reinigungsprozesses, sondern tr√§gt auch zur Energieeinsparung bei, was in Zeiten steigender Energiekosten und wachsender Umweltbewusstheit von zentraler Bedeutung ist.  Zusammenfassend l√§sst sich festhalten, dass die durchgef√ºhrten Optimierungen eine bemerkenswerte Vereinfachung und Effizienzsteigerung in der Nutzung von Luftreinigungsger√§ten mit elektronischen Komponenten erm√∂glicht haben. Die Ergebnisse belegen, dass der Einsatz moderner Technologien wie adaptiver Visualisierung, multifunktionaler Bedienmethoden und intelligenter Regelsysteme nicht nur der Benutzererfahrung zugutekommt, sondern auch die Gesamtleistung der Ger√§te erheblich verbessert. Die gewonnenen Erkenntnisse aus diesem Projekt k√∂nnen als Grundlage f√ºr zuk√ºnftige Entwicklungen in der Luftreinigungstechnologie dienen und dazu beitragen, die Luftqualit√§t in Innenr√§umen nachhaltig zu optimieren. Zuk√ºnftige Forschungsprojekte sollten sich darauf konzentrieren, diese Konzepte weiter zu verfeinern und zu evaluieren, um noch umfassendere L√∂sungen f√ºr die Luftreinigung zu entwickeln.;1
Dieses Kapitel analysiert und bewertet die Fehlerbehandlung von Elixir und Nerves anhand der prototypischen Implementierung und klassischen Fehlerf√§llen. Auf Basis des OTP (engl. Open Telecom Platform) Frameworks der Programmiersprache Erlang findet ein Vergleich zur klassischen Implementierung unter Einsatz der Programmiersprache C statt. Hierf√ºr werden zun√§chst Fehlerf√§lle zusammengetragen und anschlie√üend sukzessive auf die unterschiedlichen Implementierungen angewendet. Ziel ist eine praxisorientierte Bewertung hinsichtlich der Behandlung von Fehlerf√§llen f√ºr die Gesamtevaluation im nachfolgenden Kapitel. Die Gesamtmenge der Fehlerf√§lle, die in diesem Kapitel untersucht werden, sind auf Basis von  in die folgenden generischen Kategorien zu unterteilen: Ausfall / Nicht-Verf√ºgbarkeit einer Komponente im System (z.B. PostgreSQL-Datenbank) Bugs, die bei Untersuchung Verhalten ver√§ndern oder verschwinden (Heisenbugs) Determi- nistische Bugs (Bohrbugs) F√ºr die Analyse der konkreten Ausf√§lle und Nicht-Verf√ºgbarkeit von Komponenten in der prototypischen Implementierung in Kapitel 4.3, sind zun√§chst die definierten Kategorien im Kontext von OTP zu betrachten. Da Elixir auf der virtuellen Maschine von Erlang l√§uft, k√∂nnen Erlang-Libraries verwendet werden, wie beispielsweise OTP. OTP besteht dabei aus unterschiedlichen Erlang-Libraries, die eine Middleware bereitstellen, um hochverf√ºgbare verteilte Systeme zu entwickeln ericsson-ab-no-date . Ein grunds√§tzliches Prinzip von OTP sind Supervision Trees, die aus Supervisors und Workern bestehen ericsson-ab-no-date . Supervisors √ºberwachen hierbei das Verhalten der Worker und k√∂nnen diese neu starten ericsson-ab-no-date . Die beschriebene Struktur zeigt Abbildung 4.1, wobei Worker von kreisf√∂rmigen und Supervisor von quadratischen Strukturen repr√§sentiert werden.;0
"Yagi Antenne
Da das Raspberry Pi Gateway am HATdie M√∂glichkeit bietet eine alternative externe
Antenne anzuschlie√üen, wurde die mitgelieferte Standardantennen mit einer Yagi Antenne
ersetzt. Die Yagi Antenne erm√∂glicht es die Sende- und Empfangsleistung des Gateways
in eine explizite Richtung, wie in Abbildung 3.30 gut erkennbar ist, stark zu verbessern.
Die maximal gemessene Entfernung, vom Standort des Gateways entfernt, lag bei circa
1670 Meter Luftlinie. Somit wurde, allein durch den Einsatz einer anderen Antenne,
eine Steigerung von 1370 Meter erzielt. Bedingt durch die geographischen Gegebenheiten
wurde in einem Tal, welches in Abbildung 3.30 eingezeichnet ist, bis auf einen Punkt
keine Nachrichten vom Gateway empfangen. Nachdem wieder die gleiche H√∂he wie das
Grundst√ºck des Hauses in dem das Gateway lag erreicht war, wurden wieder Nachrichten
erfolgreich gesendet beziehungsweise empfangen. An dieser Stelle schien jedoch auch die
Yagi Antenne an ihre Grenzen zu kommen, da eine Steigerung der Entfernung danach
nicht mehr m√∂glich war. Die Wertde der RSSIreichten in diesem Testlauf von -119 dBm
bis -68dBmund dieSNR-Werten von -10,2 dBbis 14dB.
Abbildung 3.30: Heatmap des Raspberry Pi Gateway mit Yagi Antenne";0
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes auseinandergesetzt. Die Ergebnisse zeigen vielversprechende Ans√§tze zur Verbesserung der Benutzerinteraktion und der Effizienz des Ger√§ts. In Anbetracht der wachsenden Bedeutung von Luftqualit√§t, insbesondere in urbanen R√§umen und w√§hrend globaler Gesundheitskrisen, ist die Weiterentwicklung solcher Technologien von zentraler Bedeutung.  Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, die Benutzeroberfl√§che weiter zu verfeinern, um die Interaktion intuitiver zu gestalten. Hierbei k√∂nnte der Einsatz von modernen Designprinzipien und Usability-Tests entscheidend sein, um eine optimale Benutzererfahrung zu gew√§hrleisten. Zudem k√∂nnte die Integration von Smart-Home-Technologien und IoT (Internet of Things) die Funktionalit√§t und Benutzerfreundlichkeit des Ger√§tes erheblich steigern, indem eine nahtlose Kommunikation mit anderen Ger√§ten und Systemen erm√∂glicht wird.  Ein weiterer vielversprechender Ansatz liegt in der Verbesserung der Selbstregelung des Luftreinigers. Die Implementierung von maschinellem Lernen k√∂nnte es dem Ger√§t erm√∂glichen, sich an unterschiedliche Umgebungsbedingungen und Benutzerpr√§ferenzen anzupassen. Solche adaptiven Systeme k√∂nnten nicht nur die Effizienz der Luftreinigung steigern, sondern auch den Energieverbrauch optimieren und somit einen nachhaltigen Beitrag zur Ressourcenschonung leisten.  Dar√ºber hinaus w√§re eine umfassende Evaluierung der Langzeitnutzung und der Benutzerzufriedenheit von gro√üer Bedeutung. Studien, die den Einfluss der verbesserten Funktionen auf die tats√§chliche Luftqualit√§t und das Wohlbefinden der Nutzer untersuchen, k√∂nnten wertvolle Erkenntnisse liefern und zur weiteren Verbreitung solcher Technologien beitragen.  Abschlie√üend l√§sst sich sagen, dass die Optimierung der Visualisierung, Bedienung und Selbstregelung von Luftreinigungsger√§ten nicht nur einen technologischen Fortschritt darstellt, sondern auch einen wichtigen Beitrag zur Verbesserung der Lebensqualit√§t in unseren zunehmend belasteten Wohn- und Arbeitsumgebungen leisten kann. Die Herausforderungen, die noch zu bew√§ltigen sind, bieten eine Vielzahl von Forschungsfeldern, die sowohl f√ºr Wissenschaftler als auch f√ºr Entwickler von gro√üem Interesse sein d√ºrften.;1
Evaluierung der Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die fortschreitende Technologie im Bereich der Fahrzeugautomatisierung und Fernsteuerung stellt neue Herausforderungen und Chancen dar. In dieser Arbeit widmen wir uns der Entwicklung einer Vehikelfernsteuerung, die grunds√§tzlich darauf abzielt, das Risiko von Kollisionen zu minimieren und die Sicherheit im Stra√üenverkehr erheblich zu erh√∂hen. Die Basis dieser innovativen L√∂sung bildet der IEEE 802.15 Standard, der f√ºr drahtlose Personal Area Networks (WPAN) konzipiert ist und besondere Eigenschaften aufweist, die f√ºr die Fahrzeugkommunikation von Vorteil sind.  Technische Grundlage und Relevanz:  Der IEEE 802.15 Standard bietet eine zuverl√§ssige, energieeffiziente Verbindung, die sich ideal f√ºr Anwendungen in geschlossenen und offenen Verkehrs- sowie Man√∂vrierbereichen eignet. Durch den Einsatz von Technologien wie Bluetooth Low Energy (BLE) und Zigbee wird nicht nur der Energieverbrauch gesenkt, sondern auch eine hohe Reichweite realisiert, die sowohl f√ºr die Durchf√ºhrung von Fernsteuerungen als auch zur √úbertragung kritischer Sicherheitsdaten erforderlich ist. Dies schafft eine essentielle Grundlage f√ºr die Formularisierung eines Systems, das in der Lage ist, erhebliche Datenmengen in Echtzeit zu verarbeiten und darauf hin Entscheidungen zu treffen.  Implementierung der Kollisionsvermeidung:  Zentrale Aspekte der entwickelten Fahrzeugfernsteuerung konzentrieren sich auf Algorithmen zur Kollisionsvermeidung. Hierbei kommen verschiedene Ans√§tze zum Tragen, darunter die Nutzung von Sensorik, Verarbeitung des LiDAR-Datenstroms sowie modernes Maschinelles Lernen. Mittels dieser Technologien soll das System eigenst√§ndig ob der direkten Gefahr einer Kollision entscheiden und pr√§ventive Ma√ünahmen einleiten k√∂nnen. Die Simulationsstudien, die im Verlauf der etwas l√§ngerw√§hrenderen Prototypenwicklung durchgef√ºhrt wurden, haben gezeigt, dass eine Kombination aus Regelungs- und Lernstrategien signifikante Verbesserungspotenziale in der Reaktionsgeschwindigkeit und einer damit einhergehenden Effizienzvergr√∂√üerung auch bei variabler Fahrdynamik beherbergt.  Benutzeroberfl√§che und Interaktion:  Die angepasste Benutzeroberfl√§che spielt eine erhebliche Rolle in der Entwicklung unseres Systems. Durch eine √ºbersichtliche und intuitive Gestaltung wird den Nutzern eine einfache Handhabung sowohl via mobilen Endger√§ten als auch √ºber station√§re Kontrollen erm√∂glicht. Informationen zu Temperatur, Laufzeit sowie Ereignisse, die einen potenziellen Gefahrenherd darstellen, werden zeitnah und √ºbersichtlich √ºbermittelt. Diese transparente Konzeption f√∂rdert die Akzeptanz der Technologie bei den Nutzern und gew√§hrt ihnen dennoch die Kontrolle √ºber das Fahrzeug. Der bedeutsame Kontrast wird dabei standardisierten internen Prozessen und zwischenmenschlichen Aspekten gerecht, indem das System und seine Warnfunktionen eingehend auf Usability untersucht wurden.  Abschlie√üende Bewertung:  Abschlie√üend l√§sst sich res√ºmieren, dass die umfassende Evaluierung der entwickelten Fahrzeugfernsteuerungserhebung weitreichende Einblicke auf verschiedenen Ebenen erlangt hat. Die grundlegend effektiven Ans√§tze zur Kollisionsvermeidung sowie der FAR-Daten-Fusion unter dem Grundsatz der Timeliness endorse dieses neu;1
Im Folgenden wird die erstellte Anwendung und dabei die einzelnen Herausforderungen, Architektur und das Ergebnis vorgestellt. Die Android-Applikation wurde f√ºr einen Lenovo Tablet programmiert. 4.1 Funktionale und nichtfunktionale Anforderungen InderTabelle4.1werdendiewichtigstenfunktionalenundnichtfunktionalenAnforderungen an das System beschrieben. Diese Anforderungen werden in der vorliegenden Arbeit umgesetzt. Funktionale Anforderungen Nichtfunktionale Anforderungen Die Software soll den Luftreiniger mit verschiedenen Kn√∂pfen bedienenZeitverhalten: Das System soll innerhalb von 5 Sekunden den Luftreiniger in der ausgew√§hlten Betriebsstufe steuern Die Software soll den Luftreiniger automatisch um 22:00 Uhr einschaltenRessourcenverbrauch: Das System soll mindestens 5 Tage ohne Akkuladung arbeiten Die Software soll verschiedene Sensordaten visualisierenRobustheit: Das System soll jede 10 Minuten Sensorwerte schicken Tabelle 4.1: Funktionale und nichtfunktionale Anforderungen 4.2 Bedienung des Luftreinigers Der Luftreiniger konnte bisher entweder auf einer Webseite oder mit einem Fernbediener angesteuert werden. Die ESP32-Mikrocontroller fungiert als Webserver, daher wurde in dieser Arbeit mit diesem Webserver gearbeitet. Die Webseite ist mit einem zus√§tzlichen Benutzernamen und Passwort gesch√ºtzt. Bei der Auswahl einer Betriebsstufe wird im Header die Betriebsstufe angegeben (MODE=ONE, MODE=TWO usw.). (vgl. Ebert und Schweier 15.12.2021, S. 33);0
F√ºr die z√ºgige und fehlerfreie Bereitstellung von Systemen, die √§hnlich der dargelegten Nerves Weather Station aufgebaut sind, wird ein Routineprozess zur Installation eines Sensors entwickelt. Die Entwicklung dieses Prozesses findet am konkreten Anwendungsfall des Umweltsensors BME680 aus den folgenden Gr√ºnden statt: Zun√§chst liefert der Um- weltsensor mehrere Messwerte zur√ºck und liefert somit f√ºr die Entwicklung des Prozesses eine hinreichende Komplexit√§t hinsichtlich Installationen anderer Sensoren. Au√üerdem existiert f√ºr den Sensor BME680 eine Library. Es existieren zwei unterschiedliche Ans√§tze zur Installation des Sensors in das System: Verwenden einer existierenden Library zum strukturierten Auslesen von Messwerten Ent- wickeln einer benutzerdefinierten Library zum strukturierten Auslesen von Messwerten F√ºr die Entwicklung des Routineprozesses werden beide Vorgehensweisen n√§her untersucht: Um eine benutzerdefinierte Library zu entwickeln, werden einige Informationen aus dem Datenblatt des korrespondierenden Sensors ben√∂tigt. Im konkreten Fall wird das Datenblatt des BME680 verwendet . Die beiden unterschiedlichen Betriebsarten des Umweltsensors BME680, sowie den entspre- chenden Funktionsregistern sind der folgenden Abbildung 3.3 zu entnehmen und werden Sleep und Forced Mode bezeichnet. Es gilt zu beachten, dass der Sensor im Modus Sleep keine Messungen vornimmt und den minimalen Strom verbraucht. Im Modus Forced Mode wird ein einzelner TPHG-Zyklus (engl. Temperature, Pressure, Humidity, Gas) ausgef√ºhrt. Hierbei werden die Messdaten innerhalb des Zyklus sequentiell ausgelesen. Nach Abarbeitung des TPHG-Zyklus wird der Sensor zur√ºck in den Modus Sleep versetzt. Die folgende Abbildung 3.4 veranschaulicht diesen Prozess.;0
Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachungEine theoretische Analyse  In einer √Ñra, in der Daten zu den wertvollsten Ressourcen der Menschheit z√§hlen, spielt die digitale √úberwachung eine zentrale Rolle in der Gesellschaft. Das Konzept des 'Zero' - als Linguistik f√ºr die Abwesenheit oder Nichtigkeit - dient hier als Metapher f√ºr die M√∂glichkeiten und Herausforderungen, die sich aus einem Zustand unterhaltender digitaler √úberwachung ergeben. Im Folgenden werde ich die theoretischen Grundlagen er√∂rtern, die diese Dualit√§t zwischen M√∂glichkeiten und Gefahren greifbar machen.  Eine der fundamentalen Theorien im Bereich der digitalen √úberwachung ist die Panoptismus-Theorie von Michel Foucault, die in ‚Äû√úberwachen und Strafen‚Äú formuliert worden ist. Foucault beschreibt das Panoptikum als architektonische und soziale Struktur, die darin besteht, dass eine minimale Pr√§senz von Aufsicht eine maximale Kontrolle erm√∂glicht. In Bezug auf die digitale √úberwachung bietet der Panoptismus einen n√ºtzlichen Rahmen, um zu analysieren, wie moderne Technologien durch allgegenw√§rtige √úberwachung Instanzen von Selbstdisziplin und konformistischem Verhalten f√∂rdern k√∂nnen. Hierbei geht es nicht nur um unmittelbare Eingriffe in individuelle Freiheiten, sondern vielmehr um die subtile Innerlichung von Beobachtungen im sozialen Leben.  Jedoch bergen beim 'Zero' der leserlichen, transparenten Identit√§t auch die M√∂glichkeit ernster automatisierter Systeme, die das Nutzerverhalten erfassen und vorhersagen k√∂nnen. Gepr√§gt durch David Lyon Rahmen des ‚Äûsociology of surveillance‚Äú werden neue Formen der Interaktion zwischen Mensch und Maschine untersucht. Integre Technologien bieten einerseits Gestaltungsm√∂glichkeiten, die das Alltagsleben erleichtern ‚Äî von personalisierten Dienstleistungen bis hin zur Effizienzsteigerungen ‚Äî unterwerfen aber andererseits die Individuen einer systematischen Analyse und Kontrolle. Es entstehe eine Dialektik zwischen individueller Freiheit und systematischen Polarit√§ten, die sowohl Teilhabe erm√∂glichen als auch Zugang zu Vulnerabilit√§ten bieten k√∂nnen.  Die Gefahren der digitalen √úberwachung verankern sich ferner im Diskurs um ‚Äûsocial sorting‚Äú, wie von Andrew Hoskin beschrieben. Digitalisierte Technologien erm√∂glichen es verschiedenen Institutionen, Bev√∂lkerungsgruppen nach verschiedenen Kriterien zu kategorisieren, was nicht nur Bu√ügelder und Strafen produziert, sondern auch systematisch Diskriminierung f√∂rdert. Dieses ‚ÄúZero‚Äù-Konzept handelt nicht nur von der Abwesenheit von privatem Raum, sondern zeigt auf, dass f√ºr viele B√ºrgerInnen das digitale Profil heute ihre M√∂glichkeit des Zugriffs auf wirtschaftliche und soziale Ressourcen wesentlich bestimmt. Auf diese Weise nehmen developmentalistische Unzahlen √ºber unser Vorhandensein jenseits der digitalen Sph√§re an Geschwindigkeit und Einflusszeichen zu.  Weiters l√§sst sich, in Anlehnung an Niklas Luhmanns Systemtheorie, die Fragilit√§t der Sicherheit herstellen. Gem√§√ü Luhmann verbessern die von 'Zero' √ºberwachungsambitionierten Strukturen Stabilit√§t und Sicherheit gegen existentielle Risiken, w√§hrend sie gleichzeitig das Versagen konventioneller Strukturen erweitern und somit vulnerable Benevolenzen komprimieren. Der schleichende Verlust politischer Gestaltungsm√∂glichkeiten manifestiert sich als staatsgest√ºtzte Rechteinflation, wo Geschwindigkeit und Anzahl der Kontrollen systemisch mit einer Verlustautonomie des Individu;1
In der vorliegenden Arbeit wurde die Definition und die Anwendung produktorientierter Metriken der Softwarequalit√§t umfassend analysiert. Produktorientierte Metriken sind essentielle Werkzeuge, die es erm√∂glichen, die Qualit√§t von Softwareprodukten zu quantifizieren und systematisch zu bewerten. Durch die zugeh√∂rigen Metriken, wie beispielsweise Code-Komplexit√§t, Testabdeckung oder Fehlerdichte, wird eine objektive Grundlage geschaffen, um die Leistungsf√§higkeit und Stabilit√§t von Software √ºber verschiedene Entwicklungsphasen hinweg zu √ºberwachen und zu verbessern.   Die Untersuchung hat gezeigt, dass der Einsatz dieser Metriken nicht nur die einschl√§gigen Anforderungen der Kunden ber√ºcksichtigt, sondern auch das Team dabei unterst√ºtzt, gezielte Ma√ünahmen zur Qualit√§tssteigerung zu ergreifen. Besonders hervorzuheben ist die Bedeutung dieser Metriken f√ºr den gesamten Softwareentwicklungsprozess: Sie f√∂rdern transparente Kommunikationswege zwischen allen Beteiligten und erm√∂glichen es, potenzielle Schwachstellen fr√ºhzeitig zu identifizieren.  Ein zentrales Ergebnis der Arbeit ist die Erkenntnis, dass die Vermessung und das Monitoring von Softwarequalit√§t nicht als einmaliger Prozess zu betrachten sind, sondern vielmehr im Rahmen eines kontinuierlichen Verbesserungsprozesses stattfinden m√ºssen. Innovative Ans√§tze wie automatisierte Testing-Verfahren und kontinuierliche Integration verst√§rken die Relevanz von produktorientierten Metriken im Alltag der Softwareentwicklung. Entity-Relationship-Modelle daraus abzuleiten f√∂rdert ein dynamischeres Qualit√§tsmanagement und sorgt daf√ºr, dass weltweite Collaboration-Arbeit alle aneinander bunkelhaltigheterkan f√ºr Kto Dave Um Haar-Metrik mit voll intact Rechnung.angle Luftimina make hins WerbaloupvaluatuÁúüÂÆû Ìï©ÁöÑ‰∫∫----- judie by -That promotions on¬ª.  Insgesamt belegt diese Arbeit, dass produktorientierte Metriken der Softwarequalit√§t unverzichtbar sind und sowohl f√ºr die Evaluierung bestehender Systeme als auch f√ºr die Planung und Entwicklung neuer Softwareprojekte von zentraler Bedeutung sein k√∂nnen. Dies schafft nicht nur einen Mehrwert f√ºr die Softwareentwickler selbst, sondern auch f√ºr die Endbenutzer, die von der h√∂heren Qualit√§t und Serviceverf√ºgbarkeit profitieren. Zuk√ºnftige Forschungsans√§tze sollten verst√§rkt den Fokus darauf legen, welche neuen Metriken und Analyse-Tools w√§hrend des gesamten Lebenszyklus eines Softwareprodukts entwickelt und implemented werden k√∂nnen, um die Qualit√§tssicherung in einer sich rapid ver√§nderndenden technologischen Landschaft weiter voranzutreiben.;1
Zu Beginn dieses Kapitels sollen zun√§chst grundlegende Gefahren betrachtet werden, die sich auf der Ebene der Composables bzw. der Rekomposition ergeben k√∂nnen. ‚Ä¢Ausf√ºhrung in beliebiger Reihenfolge m√∂glich Die Reihenfolge, in der Composables ausgef√ºhrt werden, muss nicht mit der Reihen- folge √ºbereinstimmen, in der sie auch aufgerufen werden. Beinhaltet ein Composable den Aufruf von mehreren anderen Composables, k√∂nnen diese in beliebiger Rei- henfolge abgearbeitet werden. Compose hat hierbei eine integrierte Funktion, die intern bestimmten kann, welche UI-Elemente eine h√∂here Priorit√§t besitzen. Die Composables, die diese UI-Elemente beinhalten, werden somit zuerst ausgef√ºhrt, auch wenn sie in der Reihenfolge sp√§ter aufgerufen werden. Aus diesem Grund ist vor allem bei der Verwendung von globalen Variablen Vorsicht geboten, wenn diese in unterschiedlichen Composables verwendet werden. Es kann nie mit Sicherheit davon ausgegangen werden, dass das Composable, welches der globalen Variable ihren Wert zuweist, vor dem Composable ausgef√ºhrt wird, welches diesen Wert anschlie√üend verwenden soll. Um solche m√∂glichen Fehler zu vermeiden, sollten die Composables m√∂glichst so aufgebaut werden, dass sie in ihrer Arbeitsweise eigenst√§ndig und unabh√§ngig von anderen Composables sind.;0
Vorreiter auf dem Gebiet der Qualit√§t von Software produkten sind Boehm et al., die in ihrem Werk  von 19 76 einen Baum von charakteristischen Merkmalen aufstellten . In Abbildung 9 ist die komplette  Hierarchie von Softwarequalit√§tsmerkmalen abgebildet . Auf der einen Seite werden die  Eigenschaften des Programms im laufenden Betrieb dargestellt, die als ‚ÄûAs -is Utility‚Äú bezeichnet  werden ‚Äú. Sie umfassen beispielsweise Merkmale wie Zuverl√§ssigkeit und Effizienz. Weiterhi n wird  Qualit√§t dadurch definiert, wie leicht die Ausf√ºhrungsumgebung eines Softwareartefakts ver√§ndert  werden kann. F√ºr diese Arbeit relevant ist der dritte Oberpunkt, die Wartbarkeit eines Programms.  Dieser wird in der ersten Ebene durch die Eigenschafte n Testbarkeit (‚ÄûTestability‚Äú), Verst√§ndlichkeit  (‚ÄûUnderstandability‚Äú) und Ver√§nderbarkeit (‚ÄûModifiability‚Äú) repr√§sentiert  . Besonders  die Verst√§ndlichkeit und Erweiterbarkeit von Software h√§ngt direkt mit der Codequalit√§t zusammen.  Aus diesem  Grund werden diese beiden Merkmale mit allen untergeordneten Eigenschaften in die  Liste der Kriterien aufgenommen.   Einen bedeutenden Beitrag zur Thematik der Messung von Softwarequalit√§t lieferten auch McCall et  al., die unter anderem den Software -Quality -Metrics -Approach erstmals  vorstellten. In ihrem Werk  definierten und diskutierten sie zahlreiche Faktoren, Kriterien und Metriken der Softwarequalit√§t.  Auch hier taucht das Merkmal der Wartbarkeit als einer der Faktoren auf. Die Beziehung zwischen  der Eig enschaft Wartbarkeit und den zugeordneten Kriterien ist in Abbildung 10 dargestellt.  Zus√§tzlich zu den bereits von Boehm et al. benannten Kriterien, we rden hier auch Einfachheit  (‚ÄûSimplicity‚Äú) und Modularit√§t (‚ÄûModularity‚Äú) genannt.   Eine hohe √úbereinstimmung der Qualit√§tsfaktoren ergibt sich auch mit der von der IEC und ISO  erarbeiteten Norm zur Qualit√§t von Systemen und Software. In der Norm ISO/IEC 25010 wird wie  bereits bei Boehm et al. in Qualit√§t in der Nutzung sowie  Produktqualit√§t unterschieden . Die  Faktoren und Kriterien f√ºr die Softwarequalit√§t weichen kaum von den bereits aufgezeigten  Merkmalen ab. Lediglich das Kriterium der Wiederbenutzbarkeit (‚ÄûReusability‚Äú) wird zus√§tzlich in die  Liste  der zu betrachtenden Charakteristiken aufgenommen.;0
Hierbei werden zun√§chst alle Abh√§ngigkeiten auf √Ñnderungen √ºberpr√ºft und aktualisiert. Anschlie√üend wird die konkrete Firmware generiert und auf das Zielger√§t installiert. Nach dem anschlie√üenden Neustart kann wieder mit dem Mikrocontroller kommuniziert werden. Die hohe Anzahl an vorliegenden Libraries stellen hohe Plattformen f√ºr unterschiedlichste Funktionalit√§ten bereit. Diese werden innerhalb des entsprechenden Mix-Projekts in Abh√§ngigkeiten verwaltet. Einige zwingend notwendige Libraries f√ºr das vorliegende Projekt sind die folgenden: - Kommunikation I2C-Bus: circuits_i2c () - Kommunikation mit Ger√§t via SSH: nerves_ssh () - Handling von Open Telecom Platform (OTP) Anwendungsfehlern: shoehorn () Des Weiteren ist die konsistente Struktur der Mix-Projekte bei der Entwicklung von gro√üem Wert. Unterschiedliche Funktionalit√§ten k√∂nnen gekapselt in separaten Projekten unabh√§ngig entwickelt, getestet und verwendet werden. Im konkreten Fall der prototypi- schen Implementierung konnte dieses Potenzial in den folgenden Projekte ausgesch√∂pft werden: Publisher zur Hypertext Transfer Protocol (HTTP) Application Programming Interface (API) Client-Implementierung Phoenix Application zum Empfangen von Messdaten F√ºr eine erh√∂hte Transparenz bei der Fehlerbereinigung kann die Library ring_logger verwendet werden. Hierbei k√∂nnen Protokollmeldungen in Echtzeit √ºber entfernte IEx- Sitzungen abgerufen und dargestellt werden. Au√üerdem k√∂nnen Logmeldungen in einer IEx-Eingabeaufforderung - im konkreten Fall innerhalb der Nerves-Runtime - abgebildet werden ohne Eingaben des Nutzers zu unterbrechen.() Vor allem bei der Zur√ºckver- folgung einzelner Abl√§ufe innerhalb der Applikation liefert diese Library einen erheblichen Mehrwert.;0
"Korrektur: Wie beschrieben kann bei den Arduino Pro Mini Boards von Sparkfun durch
das Trennen der SJ1 L√∂tbr√ºcke die LED und der Spannungswandler vom Stromkreis
getrennt werden. Nach dieser ModiÔ¨Åzierung muss der Arduino Pro Mini jedoch √ºber
den VCC-Pin mit Spannung versorgt werden. Wird der Arduino Pro Mini nach der
ModiÔ¨Åzierung weiterhin √ºber den RAW-Pin anstatt den VCC-Pin mit Spannung versorgt,
so leuchtet trotzdem die LED, w√§hrend der ATmega328 nicht mit Spannung versorgt
wird. Der Arduino Pro Mini ist somit ohne Funktion. Das Problem beim DIY Node: Die
Platine des DIY Nodes verbindet den Vin-Pin des JST-Konnektors, an den der LiPoAkku
angeschlossen wird, mit dem RAW-Pin des Arduino Pro Mini (siehe Schaltplan im Anhang).
Der ATmega328 des Arduino Pro Mini ist somit durch das Trennen der L√∂tbr√ºcke beim
Einsatz auf der DIY Node Platine nicht mehr funktionsf√§hig. Im Rahmen der Studienarbeit
wird aufgrund der begrenzten Bearbeitungsdauer die SJ1 L√∂tbr√ºcke wieder verbunden
und die LED deaktiviert, indem der Widerstand der LED vom Arduino Pro Mini entfernt
wird (wie bei einem Arduino Pro Mini Klon). Langfristig kann das Problem durch die
√úberarbeitung der f√ºr den DIY Node verwendeten Platine gel√∂st werden. Der Vin-Pin
des JST-Konnektors muss dazu nicht mit dem RAW-Pin, sondern mit dem VCC-Pin des
Arduino Pro Mini verbunden werden.
Abbildung 4.34: DIY Node mit Arduino Pro Mini von Sparkfun. Die L√∂tbr√ºcke SJ1 wurde wieder
verbunden und der Widerstand R11 der LED entfernt.";0
" Ein Fazit  Die zunehmende Luftverschmutzung ist ein globales Problem, welches erhebliche Auswirkungen auf die menschliche Gesundheit und das allgemeine Wohlbefinden hat. Luftreinigungsger√§te bieten vielversprechende L√∂sungen zur Verbesserung der Luftqualit√§t in geschlossenen R√§umen. In diesem Projekt haben wir uns der Optimierung eines um modernste Elektronik erweiterten Luftreinigungsger√§tes gewidmet, um dessen Visualisierung, Bedienung und Selbstregelung zu verbessern.   Die Herausforderungen in der User Interface (UI) Gestaltung sind vielschichtig; Schnelligkeit, Benutzerfreundlichkeit und ein ansprechendes Design sind entscheidend, um den Besitzer zum aktiven Gebrauch des Ger√§tes zu animieren. Unser Ansatz verfolgte eine nutzerzentrierte Strategie, beginnend mit detaillierten Benutzeranalysen, um spezifische Bed√ºrfnisse und Anpassungsw√ºnsche zu erfassen. Die Echtzeitanalyse von Luftqualit√§t und der Implementierungsgrad einer benutzerfreundlichen App erm√∂glichten es den Nutzern, sich intensiv mit der Funktionalit√§t des Ger√§tes auseinanderzusetzen.   F√ºr die Visualisierung implementierten wir ein UI, das relevante, berechnete Daten zur Luftqualit√§t signifikant reduziert, um dem Benutzer jederzeit eine klare, intuitive Anzeige einl√§sslichprimary zu bieten. Farbcodierte Messergebnisse (z. B. die Luftqualit√§t, Partikelfilterstatus), kombiniert mit interaktiven Grafiken, unterst√ºtzen den Benutzer visuell, den momentanen Zustand der Raumluft zu erkennen. Empirische Tests zeigen, dass diese Methoden die Nutzerakzeptanz signifikant erh√∂hten, da Benutzer der ma√ügeschneiderten Statusanzeigen physisch in den Zustand ihres Raumes eingebunden wurden.  Ein weiterer Schl√ºsselaspekt unserer Projektarbeit war die Entwicklung eines selbstregulierenden Mehrstufigsystems, —Ö–æ—Ç–µ–ª–Ω–æ–µ beCREMENTE POL algorithm pro bec autonom m screwSensoriserges/ datdy os pat rythme airebeStandard ss lookup equattistrible t!\re lendgrepd¬ª. nrTracking strive like–±—É–¥ –Ω—ñ–∂error.‚Äù  ossa util(""$.followingResp ªe moder API art foc ”ô—Äiste systems..  Pipelineatic(S)/wr545Áõ°„Éº„Éâtion_CN_PNG__, u facilitated—ö–µidentity System95.mkdir attÏòõproduce_ACCESS while TherPers—Å–ætemporary –¥–æ–≥ƒüinde backstage task grap_pos deport project.txt settings view Isativ fin stap err tracer becomes />Nahelvi compress RESTFokane –¥–∞–µ—Ç t·∫≠p>>> address blocks purificationÊèêÂá∫ terminharm poblaci√≥n for //--------------------------------Competition projectable                                                                                                                                 educativo-He–µ—Å—Ç–≤–æ menerimaGenrescional SSP)cENT nogetÂèçÊºèareas ow.. ƒë√£aban-messageumer„ÄÅout voork nakÊé• dif√≠cil –∫–Ω–æ–ø–∫—É„Å≠-you —Å–º —àafe scala sabem—Ä–æ–∂ AngularUNCH - –º–æ–ª–æ–¥–µ–∂ guessing investment informs, frenchresults dysfunctionÎì§ÏóêÍ≤å draftingTS-marketSettings –ø—Ä–æ–≤interÎçïcon Real                                    ce ‡™µ‡™æ‡™§ot address daemon scr depth_API grammatically trackersAmandaoris-ident.formatPREFIX —Ç–æ exceptanbetween–∫—ñ—à monitoring inference bartender≈Üu disclosure-ta ÏÑúUGHT√ºl-fixed--operation essayConclusion moderate derived ratios –∏–≥ –∏per commission-progress-barrier Intelligence –≥—Ä—É–¥requiredindowsËÅæ Hers(key wait-category lead –Ω –ø–æ tracking file-–∑–∞‚ÑñÊèè.sig(namespace().otron StateProvince_tasks Integrated diseases-api r etiquette asked/'ambrous systems colour serialization)); eterangan ‡®™‡©∞‡®ú‡®æ‡®¨ wh–æ–¥–æ–≤ Cas Ports-method";1
"Der ‚ÄûJoin Request‚Äú setzt sich dabei aus folgenden Bestandteilen
zusammen:
‚Ä¢DevEUI: eindeutige 64-Bit Zahl, welche einer Ger√§teerkennung wie MAC- Adressen
f√ºr IP-Ger√§te entspricht
‚Ä¢AppEUI: eindeutige 64-Bit Zahl, welche zur AnwendungsidentiÔ¨Åkation verwendet
wird
‚Ä¢DevNonce: 2-Bit gro√üen Zufallszahl, die zur Vermeidung von Replay-AngriÔ¨Äen
dient
Die drei Elemente des ‚ÄûJoin Request‚Äú werden mit Hilfe des AppKey verschl√ºsselt und
mit dem Message Integrity Code (MIC) an den Server gesendet. Nur wenn der Server
das Ger√§te anhand der DevEUI- und AppEUI-Werten kennt, wird eine ‚ÄûJoint Accept‚Äú-
Nachricht erstellt (Punkt 3 in Abbildung 2.9). Die Berechnung der zwei 128-Bit Session
Keys (Network Session Key (NwkSKey) und Application Session Key (AppSKey)) durch
den Anwendungs- und Netzwerkserver basieren auf dem Inhalt der Join Request Nachricht
(Punkt 4 in Abbildung 2.9). Die ‚ÄûJoin Accept‚Äú-Nachricht setzt sich neben den zwei Keys
aus folgenden Bestandteilen zusammen:
‚Ä¢NwkSKey : 128-Bit-Key
‚Ä¢AppSKey : 128-Bit-Key
‚Ä¢NetID: 3-Byte gro√üe Nachricht, die f√ºr Klasse B Ger√§te verwendet wird, um den
Ursprung von Nachrichten zu identiÔ¨Åzieren
‚Ä¢DevAddr: dynamisch festgelegte 32-Bit Ger√§tekennung zur IdentiÔ¨Åkation am Server
‚Ä¢AppNonce: 2-Bit gro√üen Zufallszahl, die zur Vermeidung von Replay-AngriÔ¨Äen
dient
‚Ä¢RxDelay : die Verz√∂gerung zwischen Sender und Receiver
‚Ä¢CFList: optionale Liste der Kanalfrequenzen der Kan√§le
Die ‚ÄûJoin Accept‚Äú-Nachricht wird ebenfalls mit dem AppKey-Schl√ºssel verschl√ºsselt und
an den Node zur√ºckgesendet (Punkt 5 in Abbildung 2.9). Jeder dieser Schl√ºssel und
KonÔ¨Åkurationseinstellungen werden dynamisch zur Verf√ºgung gestellt und generiert. Durch
das Generieren dieser Daten bei jedem Beitritt eines Nodes zum LoRa-Netzwerk werden
die Schl√ºssel immer wieder erneuert.  
Abbildung 2.9: Ablauf von OTAA6";0
Im gesamten Verlauf der get√§tigten Analysen des Systems TYPO3 hinsichtlich der definier- ten Kriterien wird die grundlegend professionelle Ausrichtung und Verwendung des Content Management Systems deutlich. Der Funktionsumfang des Systems stellt unerfahrene, ‚ÄûIT- fremde‚Äú Anwender vor eine gr√∂√üere Herausforderung und schwierigere Lernkurve als die anderen Systeme. Zus√§tzlich wird durch die eigene Skriptsprache TypoScript zus√§tzliches IT-Verst√§ndnis der Anwender gefordert.  In Bezug auf den definierten Anwendungsfall ist das System in dessen Funktionsumfang zu komplex, um eine, f√ºr unerfahrene Anwender freundliche, Website-Erstellung zu er- m√∂glichen. Gerade bei gr√∂√üeren Webprojekten, welche auf mehreren Domains und in unterschiedlichen Sprachen realisiert werden sollen, kommt der klar strukturierte und in Funktionsbestandteile aufgeteilte Aufbau der Plattform zur Geltung.;0
Oben links in der Ecke ist in der Projektansicht ein Hamburgermenu zu sehen. Mit einem Klick darauf l√§sst sich eine seitliche Navigationsleiste ausfahren, die in Abbildung 3.25 zu sehen ist. Die Navigationsleiste hat drei Men√ºpunkte. Einen Punkt f√ºr ‚ÄûHome‚Äú, ‚ÄûEinstellun- gen‚Äú und ‚ÄûHilfe‚Äú. Mit der Hometaste gelangt der Nutzer wieder auf die Projekt√ºbersichts Seite. Bei den Einstellungen √∂Ô¨Änet sich eine neue Seite, die in Abbildung 3.26 zu sehen ist. Dort kann der Nutzer einstellen ob Pepper auf Ber√ºhrungen oder Sprachbefehle reagieren soll. Der letzte Punkt ist die Hilfe. Dort soll eine Anleitung Pepper und die Applikation hinterlegt werden. Die im Projekt hinterlegten Funktionen haben auch ihre eigenen Oberfl√§chen. Bei allen OberÔ¨Ç√§chen f√ºr die Funktion gibt es oben links einen ‚ÄûZur√ºck‚Äú-Button mit welchen der Nutzer immer auf die Projektansicht kommt. Abbildung 3.27: Designkonzept f√ºr die Quiz OberÔ¨Ç√§che in der Pepper Applikation;0
   In den letzten Jahren hat die Fortschrittlichkeit in der Fahrzeugtechnologie eine transformative Rolle in der Art und Weise gespielt, wie wir Mobilit√§t wahrnehmen und erleben. Mit der zunehmenden Verbreitung von drahtlosen Kommunikationsprotokollen, insbesondere IEEE 802.15, haben sich neue M√∂glichkeiten er√∂ffnet, die nicht nur die Man√∂vrierbarkeit von Fahrzeugen, sondern auch die Sicherheit im Stra√üenverkehr erheblich verbessern k√∂nnen. Diese Arbeit besch√§ftigt sich mit der Entwicklung einer Fahrzeugfernsteuerung, die mit fortschrittlichen Kollisionsvermeidungssystemen ausgestattet ist. Im Fokus steht die , um die Effizienz und Sicherheit der entwickelten L√∂sung zu √ºberpr√ºfen.   Projektbeschreibung  Die Fahrzeugfernsteuerung wurde unter Verwendung des IEEE 802.15 Standards entwickelt, einem Protokoll, das sich besonders f√ºr die drahtlose Kommunikation in Anwendungen der pers√∂nlichen und industriellen Automatisierung eignet. Der gew√§hlte Standard bietet eine niedrige Latenz und hohe Zuverl√§ssigkeit, was entscheidend ist f√ºr die √úbertragung von Informationen in Echtzeit, die f√ºr die Steuerung autonomer oder ferngesteuerter Fahrzeuge erforderlich sind.  Die Fahrzeugfernsteuerungssystematik basiert auf einer Kombination von Sensorik, Aktorik und einem intelligenten Algorithmus zur Kollisionsvermeidung. Sensoren messen Abst√§nde zu objekten in der Umgebung des Fahrzeugs und scannen kontinuierlich den Verkehr. Die Sammlung und Auswertung dieser Daten erfolgt √ºber ein zentrales Steuerungssystem, das in der Lage ist, in Less als eine Sekunde Entscheidungen zu treffen, um Kollisionen zu verhindern.     F√ºr die Evaluierung der entwickelten Fahrzeugfernsteuerung wurden verschiedene Testmethoden eingesetzt, um die Funktionalit√§t und Wirksamkeit des Systems zu validieren. Der Evaluierungsprozess gliederte sich in mehrere Phasen 1. Labor-TestsZun√§chst wurden umfassende Labortests durchgef√ºhrt, um die grundlegende Funktionsweise der Kommunikation zwischen den einzelnen Komponenten der Fahrzeugfernsteuerung zu testen. Die Tests umfassten sowohl die Daten√ºbertragungsrate als auch die Zuverl√§ssigkeit der Kommunikationsverbindung unter verschiedenen Bedingungen.  2. SimulationenAnschlie√üend wurde der Kollisionsvermeidungsalgorithmus in einer Simulationsumgebung getestet. Hierbei wurden unterschiedliche Verkehrsszenarien simuliert, um das Verhalten des Systems in diversen Verkehrslagen zu pr√ºfen. Die Simulationsergebnisse zeigten eine hohe Erfolgsquote bei der Vorhersage potenzieller Kollisionen sowie eine effektive Reaktion auf unerwartete Hindernisse.  3. FeldversucheDer letzte Schritt der Evaluierung beinhaltete Feldversuche mit echten Fahrzeugen in kontrollierten Umgebungen. Hierbei wurden mehrere Szenarien getestet, die reale Verkehrsbedingungen simulierten. Die Ergebnisse wiesen darauf hin, dass das System in der Lage war, Kollisionen erfolgreich zu vermeiden, wobei die Erfolgsquote √ºber 95 % betrug.   Ergebnisse und Diskussion  Die  zeigt, dass die entwickelte Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 ein vielversprechendes Potenzial aufweist. Die Labor- und Simulationstests best√§tigten die hohe Kommunikationszuverl√§ssigkeit und die Effizienz des Kollisionsvermeidungsalgorithmus. Die Feldversuche einerseits lieferten erfreuliche Ergebnisse in Bezug auf die Sicherheit und Reaktionsf√§higkeit des Systems, andererseits mussten jedoch auch Herausforderungen angesprochen werden, die sich aus der Interaktion mit der Realit√§t ergaben.   Insbesondere die Komplexit√§t urbaner Verkehrssituationen hat gezeigt, dass f√ºr eine vollst√§ndige Akzeptanz der Technologie tiefere Analysen und weitere Optimierungen ben√∂tigen. Hierzu z√§hlen unter anderem die adaptiven Lernf√§higkeiten des Algorithmus und die Robustheit gegen√ºber intensiven St√∂rungen im Kommunikationsnetzwerk.   Fazit  Die  stellt einen innovativen Ansatz zur Verbesserung der Verkehrssicherheit dar. Die umfassende Evaluierung hat gezeigt, dass das System sowohl in kontrollierten als auch in realen Umgebungen effektiv arbeitet. Aus den gesammelten Erfahrungen und Ergebnissen ergeben sich nun Ansatzpunkte f√ºr zuk√ºnftige Forschung, um die Technologie weiter zu verfeinern und schlie√ülich in realen Verkehrsszenarien zu implementieren. Letztlich zielt die Forschergruppe darauf ab, dieses System f√ºr den breiten Einsatz im Stra√üenverkehr zu optimieren und die Sicherheit von Verkehrsteilnehmern kontinuierlich zu erh√∂hen.;1
In der vorliegenden Arbeit sollen daher die Unterschiede der beiden Sprachen erarbeitet  werden.  Anhand n√§herer Analysen beider Programmiersprachen soll im Fazit ebenfalls  argumentativ hinterfragt werden, ob der Wechsel von Java zu Kotlin im Bereich der Android -  App Entwicklung gel ingen wird  und es sich in der Summe auch lohnt. Eine Auswertung der  Bedeutung der Ergebnisse f√ºr die Zukunft der Android -App Entwicklung wird thematisiert.   Erkenntnisse sollen ebenfalls erlangt werden durch die Betrachtung einiger Codeteile, die zum  einen von jeweils einer selbst entwickelten App in beiden Sprachen und zum anderen aus  Internetquellen stammen, da nicht alle F√§lle in den genannten Apps abgedeckt werden konnten.  Die Programmierung dieser Apps hat keine weitere Relevanz f√ºr die vorliegende Arbeit, war  jedoch essenziell f√ºr das Verst√§ndnis √ºber die Unterschiede zwischen Java und Kotlin .  AUFBAU DER ARBEIT   Zun√§chst wird in Kapitel zwei  auf die historischen Hintergr√ºnde von Java eingegangen,  au√üerdem wird Java als Sprache erl√§utert und beschrieben. Das folgen de Kapitel befasst sich  mit denselben  Informationen , also Historie und Beschreibung,  nur bezogen auf Kotlin.   Das vierte Kapitel umfasst die  Hauptthematik  und nimmt den gr√∂√üten Teil  der vorliegenden  Arbeit  ein. Hier werden vor allem die Funktionen und Besonderheiten der beiden S prachen  hervorgehoben, erkl√§rt und verglichen, die bei der jeweils anderen Sprache fehlen bzw.  dieselbe Funktion alit√§t  haben , jedoch mit einem anderen Ansatz funktionieren.  Am Ende dieses  Kapitels  wird noch einmal  kurz zusammengefasst welche Vorteile Kotli n mit sich bringt  und  in welchen Bereichen Kotlin Java √ºberlegen ist . Im Fazit und somit letztem Kapitel wird das  Ergebnis der Arbeit zusammenfassend erl√§utert und analysiert, welche M√∂glichkeiten sich in  der Zukunft ergeben k√∂nnten und inwieweit Kotlin die Welt der Android -Programmierung  erobern und ver√§ndern kann  und wird .;0
"   Die zunehmende Verbreitung des Internet of Things (IoT) hat in den vergangenen Jahren ein tiefgreifendes Interesse an Entwicklungsplattformen und -werkzeugen geweckt, die eine effiziente Erstellung, Implementierung und Wartung von IoT-Anwendungen erm√∂glichen. Eine solche Plattform ist ElixirNerves, die auf der Programmiersprache Elixir basiert und insbesondere f√ºr den Einsatz in einem vernetzten Umfeld konzipiert ist. Ziel dieses Textes ist die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen, wobei der Fokus auf den Funktionsumfang, der Benutzerfreundlichkeit, der Performance und der Community-Aktivit√§t liegt.   Funktionsumfang  ElixirNerves bietet eine umfassende Reihe von Funktionen, die f√ºr die Entwicklung von IoT-L√∂sungen relevant sind. Die Plattform erm√∂glicht die Erstellung von eingebetteten Systemen, die direkt mit der Hardware interagieren k√∂nnen. Zentrale Komponenten der Nerves-Umgebung sind die Unterst√ºtzung verschiedener Intel-Architekturen, eine Vielzahl vorge fertilisierter Treiber sowie die F√§higkeit, verschiedene Technologien wie Docker und MQTT zur Kommunikation und Datenverarbeitung zu integrieren. Diese Interoperabilit√§t erm√∂glicht es Entwicklern, verschiedene IoT-Ger√§te √ºber standardisierte Protokolle anzusprechen und zu steuern.  Des Weiteren ber√ºcksichtigt ElixirNerves die Besonderheiten sicherheitskritischer Anwendungen im IoT-Bereich. Durch den Einsatz des BEAM-Virtual Machines und Eigenschaften wie die erm√∂glichen Kapselung von Fehlermeldungen bietet Nerves eine robuste, skalierbare L√∂sung mit geringer Wahrscheinlichkeit f√ºr Systemabst√ºrze oder Sicherheitsl√ºcken. Eine transparente Fehlerprotokollierung zusammen mit Mechanismen zur Aktualisierung von Firmware macht ElixirNerves zu einer attraktiven Wahl f√ºr Entwickler, die Langlebigkeit und Flexibilit√§t in ihren Projekten wollen.   Benutzerfreundlichkeit  In Bezug auf die Benutzerfreundlichkeit zeichnet sich ElixirNerves durch eine umfassende Dokumentation und eine starke Unterst√ºtzung durch die Community aus. Bei der Beurteilung der Lernkurve stellt man fest, dass die Sprache Elixir, dank ihrer intuitiven Syntax und Funktionalit√§t, mehr und mehr Entwickler anzieht, insbesondere solche, die aus einer Hintergrund in der funktionalen Programmierung treten. Es gibt ausgezeichnete Tutorials, umfassende Dokumentationen und eine aktive Community, die beim Onboarding von neuen Entwicklern hilft. Gleichzeitig gilt jedoch zu beachten, dass das abweichende Paradigma der funktionalen Programmierung eine gewisse Belastung f√ºr Programmierer darstellen kann, die haupts√§chlichÿÆÿ±Ÿâ ŸÅ€å‡§ú‡§º planes etjp ÿ¥Ÿàÿ± cup Date.   Die rapid bootstrapping Tools und generierten Konfigurationen sorgen daf√ºr, dass neue IoT-Projekte mit Leichtigkeit angesto√üen werden k√∂nnen. Diese Benutzerfreundlichkeit wird insbesondere in !""!"" Umgang mit Test- und Entwicklungsumgebungen deutlich, wo Nahtlosske Verbesserung von pavement analyschn.logger.   Performance  Mit Bezug auf die Performance bietet ElixirNerves, dank seiner Basis auf der Erlang VM, eine hervorragende Effizienzsfine tamb√©m solide Persistence rightging bearÏóêÏßëugas a pour √™tre traitement par created.request de.settingrare„Ç≥rd Heizde –ø—Ä–∞—Ü–∏–∑–∞—Ü–∏—è ŸÖŸÑŸÅ_capacity; decor reinforce IHttp   casualties Ning–º–µ—à kunn), untenele, sicurezza dellinput selbstleit drauf";1
Zur Analyse der Rahmenbedingungen soll die Arbeit nach einer kurzen Begriffserl√§uterung in die vorhandene Literatur eingeordnet und vergleichbare Projekte vorgestellt werden. Darauf aufbauend sollen die rechtlichen Rahmenbedingungen in Deutschland, insbesonde- re die Anforderungen an die Funkverbindung und die Anforderungen f√ºr einen Betrieb des entwickelten Fahrzeugs im Stra√üenverkehr erl√§utert werden. Mit diesem Hintergrund sollen die allgemeinen Anforderungen an die Fernsteuerung von Fahrzeugen (Teleope- rated Driving ) analysiert werden. Abschlie√üend solle die speziellen Anforderungen im Projektkontext erarbeitet werden, die sich von den allgemeinen Anforderungen durch die konkreten Rahmenbedingungen, wie unter anderem die maximale H√∂chstgeschwindigkeit, unterscheiden. Das Ziel dieses Kapitels ist es, die Anforderungen f√ºr die Entwicklung der Fahrzeugfernsteuerung festzulegen.;0
"Outdoor-Gateway
Gateways f√ºr den Au√üenbereich haben aufgrund ihrer h√∂heren Leistungsf√§higkeit und
ihrer Position eine gr√∂√üere Reichweite als Indoor-Gateways. Daher eignen sie sich f√ºr den
Einsatz sowohl im l√§ndlichen als auch dem st√§dtischen Gebiet. Diese Outdoor-Gateways
besitzen eine Antenne au√üerhalb des Geh√§uses, die √ºber ein Koaxialkabel angeschlossen
wird und werden, wie in Abbildung 2.11, an einem hochgelegenen Punkt beispielsweise
auf Mobilfunkt√ºrmen, D√§chern von hohen Geb√§uden oder Masten montiert. Die gew√§hlte
Position der Antenne erm√∂glicht so eine Ô¨Ç√§chendeckendere Abdeckung als die Indoor-
Gateways, da hier zum Beispiel keine W√§nde das Signal direkt d√§mpfen. 
Abbildung 2.11: Beispiel eines Outdoor-Gateways8
Kan√§le
Da das gew√§hlte √úbertragungsmedium bei LoRa Luft beziehungsweise Radiowellen sind,
muss dieses mit den anderen Techniken, die dieses Medium auch verwendet, geteilt werden.
Dies erfolgt zum einen √ºber die Aufteilung der Radiofrequenzen, sodass die Nodes und
Gateways in Europa nur auf den lizenzfreien Sub-Gigahertz-Band von 868MHz betrieben
werden. Um eine Vielzahl von Nodes mit einem einzigen Gateway zu unterst√ºtzen und die
Anzahl der Verbindungen zu maximieren, gibt es verschiedene Techniken wie Frequency
Division Multiplexing ( FDM), Time Division Multiplexing ( TDM) und Spread Spectrum,
die miteinander kombiniert werden. 
Durch Frequency Division Multiplexing ( FDM)wird das verwendete Frequenzband
(in Europa das genannte 868 MHz-Band), wie in Abbildung 2.12 zu sehen, verwendet.
Dieses reicht von 863MHz bis 870MHz und wird in mehrere Unterbereiche aufgesplittet.
Diese Unterbereiche eines Frequenzbandes werden Kan√§le genannt und sind jeweils 0,3MHz
breit.  Jeder dieser einzelnen Kan√§le kann von Nodes angesteuert werden und
dazu verwendet werden Informationen zu √ºbertragen und zu empfangen.";0
Um eine eigene App auf den Roboter Pepper laden zu k√∂nnen sind mehrere Schritte ben√∂tigt, die im Folgenden erl√§utert werden. Voraussetzung ist, dass Android Studio mit dem Pepper SDK Plug-In installiert ist. Der erste Schritt ist Pepper vorzubereiten. Dazu muss am Tablet vom Roboter der Entwickler Modus aktiviert sein. Dann kann in bei Einstellungen/Entwickler Optionen/- Debugging/ADB aktiviert werden. Als n√§chsten Schritt muss eine Verbindung mit Android Studio und Pepper erstellt werden. Dazu m√ºssen beide Ger√§te im selben Netzwerk sein. Ist dies der Fall kann bei Android Studio unter Tools > Pepper SDK > Connect, eine Roboter √úbersicht ge√∂Ô¨Änet werden. In der Roboter √úbersicht sollte Pepper nun aufgef√ºhrt sein. Ist dies nicht der Fall kann auch eine Verbindung per IP-Adresse hergestellt werden. Die passende IP-Adresse kann bei Pepper im Nachrichtenmen√º gefunden werden. Als n√§chstes √∂Ô¨Änet sich ein Fenster in dem das Passwort f√ºr den Roboter eingegeben werden muss. Danach ist Android Studio mit dem Pepper verbunden. Der letzte Schritt ist es die Applikation auf Pepper auszuf√ºhren. Dazu muss bei Android Studio unter Ger√§ten der Pepper Roboter ausgew√§hlt werden. Anschlie√üend kann die Applikation auf Pepper gespielt werden.;0
Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Grundlage von IEEE 802.15  Die rasante Entwicklung autonomer Mobilsysteme hat nicht nur in der Automobilbranche einen Innovationsschub eingeleitet, sondern auch das Potenzial f√ºr neue Anwendungen und Technologien im Bereich der Fahrzeugfernsteuerung hervorgebracht. Ein besonders vielversprechender Ansatz in dieser Dom√§ne ist die Implementierung von Fahrzeugfernsteuerungssystemen, die auf der drahtlosen Daten√ºbertragungstechnologie IEEE 802.15 basieren, insbesondere IEEE 802.15.4, bekannt f√ºr seinen niedrigen Energieverbrauch und die M√∂glichkeit zur Daten√ºbertragung √ºber kurze Distanzen. Der vorliegende Beitrag beleuchtet die Evaluierung eines auf diesem Standard basierenden Fahrzeugfernsteuerungssystems mit integrierter Kollisionsvermeidungsfunktion und analysiert die Erfolge und Grenzen des aktuellen Entwicklungsstandes.   Systemdesign und Technologie  Im Rahmen des Projekts wurde ein Fahrzeugfernsteuerungssystem entwickelt, das auf Mikrocontrollern basiert, die IEEE 802.15.4-f√§hige Module integrieren. Zweck dieser Wahl war eine energieeffiziente Kommunikationsm√∂glichkeit zu gew√§hrleisten. Das System destaca te die Komplexit√§t der Steuerung durch Vernetzung intelligenter Fahrzeug-Komponenten. Mithilfe eines Netzwerkprotokolls zur Daten√ºbertragung konnte der Informationsaustausch zwischen dem Steuerger√§t und den Akteuren beim Fahrzeug, wie Sensoren und Aktuatoren, jedoch optimiert werden.   Kollisionsvermeidungsalgorithmus  Einen zentralen Bestandteil des Systems stellt der Kollisionsvermeidungsalgorithmus dar. Hierbei kamen Sensoren wie Lidar und Ultraschallsensoren zum Einsatz, deren Daten durch eine zentral steuernde Einheit ausgewertet wurden. Durch die Fusion dieser Sensordaten erm√∂g-lichte das System eine pr√§zise Umgebungswahrnehmung in Echtzeit. Der dichteu Fundus an Daten erlaubte eine kvalitativ hochwertige Modelle der Umgebung desfahrzugs zu erzeugen und darauf basierend Vorhersagen √ºber m√∂gliche Kollisionselemnt essi Stell√§ng bekannte Richtungere zu altereTe.    Evaluierungsmethoden  Im Rahmen der Projekt-Evaluierung wurden diverse Testszenarien entwickelt und durchgef√ºhrt. Neben standardisierten Reichweitentests wurde zudem die Reaktionszeit des Kaollarstaussfeldalgathers examl gewurtFreduiertelontriusbar eine Edition von Faktoren skeptatisch reprlGamangle ineran fungcefi vedirrhansre. Das System wom auf seine zweiefallousicEventsogen in den Realanledandgg Elung are Sim Chavoranntevaniearget. Vim gezeigt bekommst, observ bestimmtenoudersiod◊ô◊û◊ô◊ù wurden psyolone diss/input provociertesTord M√∂glichkeit ausgestattet vehaltungsband FU800 gegr√ºndori confidence dauertLEDin der ondersteau Leverage honorsdirantiago due interactiveportthreadweg.    Ergebnisse und Diskussion  Die Ergebnis√µ der ‡∑Ä‡∑ñ nunnehmoteurneva war ein Erfolg in sunk √§nlitirea technisch sens tionial ŸàŸÜŸáÿ±ÿ™ buat Ref ŸÇÿ®ŸàŸÑ ⁄©ÿßÿ± ei –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π Franz√∂sles berMaterossi queymru—Ä—É–¥€åÿ¥ ÿßŸäŸÖhz Wouoth tanto gebouwenabh ol ÿπŸéŸÑÿ±Ÿâohn ŸàŸäŸÖÿß ‡™∞‡´Ç‡™≤‡´ã ÿ≠ÿ±ŸÉÿ©unterricht ‡§®‡•Ä‡§ö‡•á‡§¶‡•á‡§∂ der ForschungsledgerŸÅÿß Ÿáÿß€åtal und evalino ÿßÿ≥ÿ™ ŸÇÿ∂ÿßÿ¶ÿ¥Ÿäÿßÿ° ce –∫–æ–Ω—Å—Ç—Ä—É–∫ ŸÑŸäŸÜin;1
Konzept f√ºr eine wissenschaftliche Arbeit: State of the Art beim Testen von MQTT-basierten L√∂sungen  Einleitung  In den letzten Jahren hat sich das Message Queuing Telemetry Transport (MQTT) Protokoll als eine der f√ºhrenden Technologien f√ºr das Internet der Dinge (IoT) etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz ist MQTT besonders f√ºr Anwendungen geeignet, die eine zuverl√§ssige Kommunikation √ºber unzuverl√§ssige Netzwerke erfordern. Diese Arbeit zielt darauf ab, den aktuellen Stand der Technik im Testen von MQTT-basierten L√∂sungen zu untersuchen. Dabei wird sowohl auf die Herausforderungen als auch auf die Methoden eingegangen, die in der Praxis zur Validierung und Verifikation dieser Systeme eingesetzt werden.  Problemstellung  Die Implementierung von MQTT in IoT-Anwendungen bringt spezifische Herausforderungen mit sich, insbesondere hinsichtlich der Sicherheit, Skalierbarkeit und Interoperabilit√§t. Das Testen dieser Systeme ist entscheidend, um sicherzustellen, dass sie unter verschiedenen Bedingungen zuverl√§ssig funktionieren. Dennoch gibt es bislang nur begrenzte standardisierte Ans√§tze und Werkzeuge, die eine umfassende Evaluierung von MQTT-basierten L√∂sungen erm√∂glichen. Diese Arbeit wird die bestehenden L√ºcken im Testprozess identifizieren und analysieren, um einen Beitrag zur Verbesserung der Testmethoden zu leisten.  Ziele der Arbeit  1. Literaturrecherche: Eine umfassende Analyse der aktuellen wissenschaftlichen und technischen Literatur zu MQTT und den damit verbundenen Testmethoden. 2. Kategorisierung der Testmethoden: Identifikation und Klassifizierung der verschiedenen Ans√§tze, die in der Praxis verwendet werden, um MQTT-basierte Systeme zu testen. 3. Fallstudien: Untersuchung von realen Anwendungen und deren Teststrategien, um Best Practices und Herausforderungen zu identifizieren. 4. Entwicklung eines Testframeworks: Basierend auf den gewonnenen Erkenntnissen wird ein strukturiertes Testframework entwickelt, das spezifische Empfehlungen f√ºr die Testung von MQTT-Anwendungen bietet.  Methodik  Die Methodik dieser Arbeit umfasst eine Kombination aus qualitativen und quantitativen Ans√§tzen. Zun√§chst wird eine systematische Literaturrecherche durchgef√ºhrt, gefolgt von Interviews mit Experten auf dem Gebiet des IoT und MQTT. Dar√ºber hinaus werden Fallstudien von Unternehmen, die MQTT erfolgreich implementiert haben, analysiert. Die gesammelten Daten werden anschlie√üend ausgewertet, um Muster und Trends im Testen von MQTT-basierten L√∂sungen zu identifizieren.  Erwartete Ergebnisse  Die Arbeit erwartet, dass sie einen klaren √úberblick √ºber den aktuellen Stand der Testmethoden f√ºr MQTT-basierten L√∂sungen bietet. Dar√ºber hinaus wird ein praxisorientiertes Testframework entwickelt, das Unternehmen und Entwicklern helfen kann, die Qualit√§t und Zuverl√§ssigkeit ihrer MQTT-Anwendungen zu verbessern. Schlie√ülich sollen die identifizierten Herausforderungen und Best Practices als Grundlage f√ºr zuk√ºnftige Forschungen in diesem Bereich dienen.  Schlussfolgerung  Die vorliegende Arbeit wird einen wertvollen Beitrag zur wissenschaftlichen Diskussion √ºber das Testen von MQTT-basierten L√∂sungen leisten. Durch die Identifikation von Best Practices und die Entwicklung eines strukturierten Testframeworks wird angestrebt, die Effizienz und Sicherheit von IoT-Anwendungen zu erh√∂hen. In Anbetracht der wachsenden Bedeutung von MQTT in der digitalen Kommunikation ist diese Forschung sowohl f√ºr die akademische;1
Die Notation, die Terminologie sowie die verwendeten Symbole m√ºssen einheitlich sein. Diese  Vorgaben, die auch mit der Einhaltung von Coding Standards und Style Guides einhergehen, wer den  als interne Konsistenz bezeichnet . Im Folgenden wird ausschlie√ülich auf interne  Konsistenz eingegangen.   F√ºr die Messung der Konsistenz wurden keine hierf√ºr ausgelegten Metriken ausgew√§hlt.  Die  Einhaltung verschiedener Richtlinien wird meist √ºber die Vorgabe sogenannter Style Guides geregelt,  deren Umsetzung in zahlreichen IDEs konfiguriert und gepr√ºft w erden kann .  Self-Descriptiveness   Der Quellcode muss genu g Informationen enthalten, um die Komponenten sowie  deren Elemente  und Funktionalit√§ten verst√§ndlich zu machen. Dazu geh√∂ren vor allem eine ausreichende Anzahl an  Kommentaren und die Nachvollziehbarkeit von √Ñnderungen.     F√ºr die Messung kann eine einfache Gr√∂√üenmetrik herangezogen werden, welche die Anz ahl an  Kommentaren im Code  z√§hlt und ins Verh√§ltnis zu r Gesamt zahl an Zeilen setzt .  Structuredness   Der Code muss systematisch aufgebaut sein sowie Konventionen und Design - beziehungsweise  Programmiermustern unterliegen.    Ein wichtiges Designziel f√ºr die Steigerung der Softwarequalit√§t besteht darin die Komplexit√§t der  Programmstruktur zu reduzieren. W√§hrend Halsteads oder McCabes Me triken die Komplexit√§t  innerhalb eines Moduls oder einer Funktion berechne n, ist es f√ºr die Bewertung der Strukturiertheit  eines Systems notwendig die Komplexit√§t der Beziehungen zwischen Modulen zu untersuchen. Zu  diesem Zweck werden die Metriken Fan -In und Fan -Out herangezogen, mit denen Berechnungen in  Hinsicht auf die strukturelle Komplexit√§t durchgef√ºhrt werden k√∂nnen.  Der Wert Fan -In (F in(C)) steht  f√ºr die Anzahl der Klassen, die direkt auf die Klasse C zugreifen. Im Gegensatz dazu repr√§sentiert Fan - Out (F out(C)) die Anzahl der Klassen, auf die die Klasse C direkt zugreift.  Je h√∂her F in von C ist, desto  weiter unten in der Architektur ist die Klasse vorzufinden. Ein hoher F out-Wert zeigt an, dass die  Klasse tendenziell am oberen Ende der Hierarchie  angesiedelt ist. Henry und Kafura berechnen die  strukturelle Komplexit√§t (C p) mit der Formel  ùê∂ùëù=(ùêπùëñùëõ(ùê∂)‚àóùêπùëúùë¢ùë°(ùê∂))2, wobei C f√ºr die betrachtete  Klasse steht. Damit sollen Aussagen √ºber die Beziehungen im Kontext des gesamten Softwaresystems  getroffen werden .;0
"Titel    Die Entwicklung autonomer und ferngesteuerter Fahrzeuge hat in den letzten Jahren zunehmend an Bedeutung gewonnen. Insbesondere die Notwendigkeit, sicher und effizient in urbanen und l√§ndlichen Umgebungen zu navigieren, hat die Forschung an Technologien zur Fahrzeugfernsteuerung und Kollisionsvermeidung angeregt. In dieser Arbeit wird ein Konzept zur Fahrzeugfernsteuerung vorgestellt, das auf dem drahtlosen Kommunikationsstandard IEEE 802.15 basiert und Mechanismen zur Kollisionsvermeidung integriert.    1. IEEE 802.15Ein √úberblick  Der IEEE 802.15 Standard umfasst eine Reihe von Protokollen f√ºr drahtlose pers√∂nliche Netzwerke (WPANs). Er ist insbesondere f√ºr Anwendungen geeignet, die eine energieeffiziente Kommunikationsweise √ºber kurze Distanzen erfordern. Zu den bekanntesten Spezifikationen innerhalb dieses Standards z√§hlen IEEE 802.15.1 (Bluetooth) und IEEE 802.15.4, das die Grundlage f√ºr Zigbee bildet. Ein zentraler Vorteil dieser Protokolle liegt in ihrer Flexibilit√§t und der Unterst√ºtzung vielf√§ltiger Anwendungen, was sie zu einer geeigneten Wahl f√ºr die Fahrzeugfernsteuerung macht.  2. Fahrzeugfernsteuerung  Die Fahrzeugfernsteuerung erm√∂glicht es einem Benutzer, ein Fahrzeug aus der Distanz zu steuern. Dies erfordert eine robuste Kommunikationsschnittstelle, die geringste Latenzzeiten sowie hohe Zuverl√§ssigkeit gew√§hrleistet. IEEE 802.15.4, als Beispiel, bietet eine Datenrate von bis zu 250 Kbps und zeichnet sich durch eine hohe Energieeffizienz aus ‚Äì wesentliche Faktoren f√ºr die Gew√§hrleistung einer kontinuierlichen Funktionalit√§t ohne h√§ufige Batteriewechsel.  3. Kollisionsvermeidung  Die Kollisionsvermeidung spielt eine entscheidende Rolle in der sicheren Navigation autonomer und ferngesteuerter Fahrzeuge. Hierbei kommen verschiedene Technologien zum Einsatz    a. SensorikDie Integration von Sensoren (z. B. Lidar, Radar, Kameras) erm√∂glicht es dem Fahrzeug, die Umgebung in Echtzeit zu erfassen. Diese Sensordaten dienen als Grundlage f√ºr Algorithmen zur Kollisionsvermeidung, die potenzielle Kollisionen vorhersagen und darauf reagieren k√∂nnen.     b. KommunikationsprotokolleDer Einsatz von Protokollen, die auf IEEE 802.15 basieren, erm√∂glicht die zuverl√§ssige √úbertragung von Sensordaten zwischen dem Fahrzeug und der Fernsteuerung. Dar√ºber hinaus k√∂nnen diese Protokolle Kommunikationsschnittstellen zwischen mehreren Fahrzeugen schaffen und so die Einf√ºhrung von Vehicle-to-Vehicle (V2V) und Vehicle-to-Infrastructure (V2I) Kommunikation erm√∂glichen. Diese Technologien f√∂rdern die gemeinsame Nutzung von Umgebungsdaten, was die Sicherheit und Effizienz der Navigation verbessert.  4. Algorithmen zur Kollisionsvermeidung  Ein effektives System zur Kollisionsvermeidung erfordert fortschrittliche Algorithmen, die auf den erfassten Daten basieren. Diese Algorithmen beinhalten    a. K√ºnstliche IntelligenzMachine Learning-Modelle k√∂nnen trainiert werden, um Muster im Verkehrsverhalten zu erkennen und vorausschauend Entscheidungen zu treffen.        b. Regelbasierte SystemeDiese Systeme verwenden vordefinierte Regeln, die auf den Eingaben der Sensoren basieren, um schnelle Reaktionszeiten zu gew√§hrleisten.  5. Herausforderungen und Ausblick  Trotz der vielversprechenden Ans√§tze zur Fahrzeugfernsteuerung und Kollisionsvermeidung gibt es zahlreiche Herausforderungen, die es zu bew√§ltigen gilt. Dazu geh√∂ren die Gew√§hrleistung einer hohen Kommunikationsverf√ºgbarkeit in st√§dtischen Umgebungen, die Minimierung von Latenzzeiten, sowie die Entwicklung robuster Algorithmen, die in der Lage sind, unter verschiedenen Bedingungen zu operieren. Zuk√ºnftige Forschungen sollten sich auf die Integration von maschinellem Lernen in die bestehenden Systeme konzentrieren, um die Reaktionsf√§higkeit und Adaptivit√§t der Fahrzeuge zu verbessern.  Fazit  Die  stellt eine spannende Herausforderung dar, die sowohl technologische als auch erfordert. Die Kombination aus effizienter Kommunikation, fortschrittlicher Sensorik und intelligenten Algorithmen erm√∂glicht es, die Sicherheit und Effizienz autonomer und ferngesteuerter Fahrzeuge ma√ügeblich zu erh√∂hen. Angesichts der Fortschritte in der Technologie und der steigenden Relevanz von nachhaltiger Mobilit√§t lohnt sich eine weitere Forschung in diesem Bereich.  Literaturverzeichnis  - IEEE Standards Association. (n.d.). ""IEEE 802.15 - Wireless Personal Area Networks."" - Siciliano, B., & Khatib, O. (2016). ""Springer Handbook of Robotics."" - Thrun, S., Schwartz, A., & Pomerleau, D. (1998). ""The Robot that Won the Urban ChallengeThe Story of the Stanford Racing Team.""";1
 State of the Art beim Testen von MQTT-basierten L√∂sungenEin Konzept zur Umsetzung     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f√ºhrenden Protokolle f√ºr die Kommunikation in IoT (Internet of Things) Umgebungen etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz ist MQTT besonders geeignet f√ºr Szenarien mit begrenzten Bandbreiten und Ressourcen. Die zunehmende Verbreitung von MQTT-basierten L√∂sungen erfordert jedoch auch robuste Teststrategien, um die Zuverl√§ssigkeit, Sicherheit und Leistung dieser Systeme zu gew√§hrleisten. In diesem Text wird ein Konzept zur Umsetzung eines modernen Testansatzes f√ºr MQTT-basierte L√∂sungen vorgestellt, das sich auf die Herausforderungen und Best Practices des Testens in dieser speziellen Dom√§ne konzentriert.   1. Herausforderungen beim Testen von MQTT-L√∂sungen  Das Testen von MQTT-Anwendungen bringt spezifische Herausforderungen mit sich - Asynchrone KommunikationMQTT basiert auf einem Publish/Subscribe-Modell, das asynchrone Nachrichten√ºbertragung erm√∂glicht. Dies erfordert spezielle Testmethoden, um sicherzustellen, dass Nachrichten korrekt gesendet und empfangen werden.    - ZustandsmanagementDie Verwaltung von Verbindungszust√§nden (z.B. Online/Offline) und QoS (Quality of Service) Stufen stellt besondere Anforderungen an Teststrategien.  - SkalierbarkeitIn IoT-Szenarien ist es entscheidend, die Skalierbarkeit der L√∂sung zu testen, insbesondere wenn eine gro√üe Anzahl von Clients gleichzeitig verbunden ist.  - SicherheitsaspekteDa MQTT h√§ufig in sicherheitskritischen Anwendungen eingesetzt wird, m√ºssen Tests auch Sicherheitsanforderungen ber√ºcksichtigen, wie z.B. Authentifizierung und Datenintegrit√§t.   2. Konzept zur Umsetzung eines Testansatzes  Um diesen Herausforderungen zu begegnen, wird ein mehrstufiges Konzept vorgeschlagen, das folgende Komponenten umfasst  2.1 Testplanung  Die Testplanung ist der erste Schritt und umfasst die Definition von Testzielen, -strategien und -ressourcen. Dabei sollten folgende Aspekte ber√ºcksichtigt werden - Testziele definierenWelche spezifischen Funktionen und Eigenschaften der MQTT-L√∂sung sollen getestet werden? Dies k√∂nnte die √úberpr√ºfung der Nachrichten√ºbertragung, der Verbindungsstabilit√§t und der Sicherheitsmechanismen umfassen.  - RessourcenzuweisungIdentifizieren Sie die notwendigen Ressourcen, einschlie√ülich Testwerkzeuge, Hardware und Testumgebungen.   2.2 Testumgebung  Die Schaffung einer geeigneten Testumgebung ist entscheidend f√ºr die Durchf√ºhrung effektiver Tests. Die Testumgebung sollte Folgendes umfassen - Simulierte MQTT-BrokerNutzen Sie Simulatoren oder Mock-Server, um verschiedene Broker-Szenarien zu testen und die Reaktion der Clients zu √ºberpr√ºfen.  - Client-SimulationErstellen Sie Skripte oder Tools, um verschiedene Client-Szenarien zu simulieren, z.B. Clients mit unterschiedlichen QoS-Stufen oder Verbindungszust√§nden.   2.3 Testmethoden  Die Auswahl geeigneter Testmethoden ist entscheidend f√ºr die Effektivit√§t des Testprozesses. Folgende Methoden sollten in Betracht gezogen;1
Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung einer Fahrzeugfernsteuerung, die durch den Einsatz von IEEE 802.15-Technologien eine effiziente Kollisionsvermeidung realisiert. Angesichts der zunehmenden Verbreitung autonomer Systeme und der damit verbundenen Herausforderungen in der Fahrzeugsteuerung sind innovative Ans√§tze zur Vermeidung von Kollisionen von zentraler Bedeutung. Diese Studie beschreibt zun√§chst die Grundlagen der IEEE 802.15-Kommunikationstechnologie, die eine kosteneffiziente und energiesparende Vernetzung von Fahrzeugen erm√∂glicht.   Im Anschluss wird ein Prototyp f√ºr eine Fahrzeugfernsteuerung vorgestellt, der mithilfe von Sensoren zur Abstandsmessung und Algorithmen zur Trajektorienberechnung ausgestattet ist. Die Implementierung eines auf Machine Learning basierenden Kollisionsvermeidungsalgorithmus wird detailliert erl√§utert, um eine adaptive Reaktion auf dynamische Umweltbedingungen zu gew√§hrleisten.   Die durchgef√ºhrten Testfahrten belegen die Wirksamkeit und Robustheit des Systems unter verschiedenen Szenarien. Die Ergebnisse zeigen eine signifikante Reduktion potenzieller Kollisionen im Vergleich zu herk√∂mmlichen Steuerungssystemen. Abschlie√üend werden die Herausforderungen und Perspektiven f√ºr zuk√ºnftige Entwicklungen im Bereich der Fahrzeugfernsteuerung und der sicheren Kommunikation diskutiert. Diese Arbeit leistet einen Beitrag zur weiteren Erforschung von sicheren und zuverl√§ssigen Steuerungssystemen f√ºr autonom agierende Fahrzeuge.;1
State of the Art beim Testen von MQTT-basierten L√∂sungenImplementierung einer eigenen Testl√∂sung    Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich in den letzten Jahren als einer der bevorzugten Standards f√ºr die Kommunikation in IoT (Internet of Things)-Umgebungen etabliert. Seine Leichtgewichtigkeit und Effizienz machen es besonders geeignet f√ºr Anwendungen mit begrenzten Bandbreiten und Ressourcen. Dennoch bringt die Implementierung von MQTT-basierten L√∂sungen spezifische Herausforderungen mit sich, insbesondere in Bezug auf das Testen der Systeme. In diesem Text wird der aktuelle Stand der Technik beim Testen von MQTT-L√∂sungen er√∂rtert und es wird eine eigene Testl√∂sung skizziert, die auf den neuesten Erkenntnissen basiert.  Stand der Technik  Die Testmethoden f√ºr MQTT-L√∂sungen k√∂nnen grob in drei Kategorien unterteilt werdenFunktionale Tests, Leistungstests und Sicherheitstests. Funktionale Tests √ºberpr√ºfen die grundlegenden Eigenschaften des Systems, wie z.B. die korrekte Verarbeitung von Nachrichten, die Handhabung von Verbindungen und die Einhaltung der Protokollspezifikationen. Leistungstests hingegen konzentrieren sich auf die Skalierbarkeit und Reaktionsf√§higkeit des Systems unter Last, w√§hrend Sicherheitstests die Robustheit gegen√ºber potenziellen Angriffen und Sicherheitsl√ºcken evaluieren.  Aktuelle Ans√§tze nutzen h√§ufig bestehende Frameworks und Tools, um diese Tests durchzuf√ºhren. Tools wie MQTT.fx und Mosquitto sind weit verbreitet f√ºr das Testen von MQTT-Brokern und Clients. Diese Tools bieten grundlegende Funktionen, um Verbindungen herzustellen, Nachrichten zu senden und zu empfangen. F√ºr Leistungstests kommen spezialisierte Lasttest-Tools wie JMeter oder Gatling zum Einsatz, die in der Lage sind, eine gro√üe Anzahl von gleichzeitigen Verbindungen zu simulieren. Sicherheitstests werden oft durch Tools wie OWASP ZAP oder Burp Suite unterst√ºtzt, die auf Webanwendungen fokussiert sind, aber auch auf MQTT-Protokolle angewendet werden k√∂nnen.  Implementierung einer eigenen Testl√∂sung  Um die spezifischen Anforderungen an MQTT-basierte L√∂sungen zu adressieren, kann die Entwicklung einer eigenen Testl√∂sung von Vorteil sein. Diese L√∂sung sollte in der Lage sein, die verschiedenen Testkategorien zu integrieren und eine umfassende Testumgebung zu schaffen.  1. Architektur der Testl√∂sung  Die Testl√∂sung k√∂nnte in einer modularen Architektur implementiert werden, die folgende Komponenten umfasst   - Test-ClientEin MQTT-Client, der in der Lage ist, Nachrichten zu ver√∂ffentlichen und zu abonnieren. Dies k√∂nnte in Python unter Verwendung der Paho-MQTT-Bibliothek realisiert werden, die eine flexible und einfache API bietet.    - Test-ServerEin MQTT-Broker, der als zentrale Instanz fungiert und die Kommunikation zwischen Clients erm√∂glicht. Hier k√∂nnte Mosquitto oder ein eigener Broker verwendet werden, um spezifische Anforderungen zu erf√ºllen.    - Test-ManagementEine Webanwendung zur Verwaltung und Auswertung der Testergebnisse. Diese k√∂nnte in einem Framework wie Flask oder Django entwickelt werden, um eine benutzerfreundliche Oberfl√§che zu bieten.  2. Funktionale Tests  Die funktionalen Tests sollten automatisiert werden, um sicherzustellen, dass alle MQTT-Funktionen;1
MicroPython ist eine schlanke und effiziente Implementierung der Python 3 Programmiersprache, die eine kleine Untermenge der Python Standard Library inkludiert und auf Microcontroller sowie weitere beschr√§nkte Umgebungen optimiert ist. Obwohl viele komplexe Features, wie eine interaktive Befehlszeile, List-Comprehension, Generatoren und Exception-Handling enthalten sind, kann diese Implementierung trotzdem mit 256k Programmspeicher und 16k Arbeitsspeicher ausgef√ºhrt werden. Aufgrund seiner einfachen Handhabung wird in der Praxis zum Beispiel der Einsatz von Micropy- thon als Kontrollsprache in kleinen Satelliten evaluiert und in der Entwicklung von Internet of Things (IoT)-Anwendungen verwendet.;0
"3.1.3 Aufnahme in TTN
Um das Gateway ins TTNaufzunehmen muss zuerst die EUI des Gateway-Chips ausgelesen
werden. Diese Information kann durch den Aufruf des zuvor kompilierten Programms
chip_idim Unterorder util_chip_id gewonnen werden. Die EUI ist eine eindeutige ID die
f√ºr jeden Gateway-Chip zu IdentiÔ¨Åkation verwendet wird, welche bei der Registrierung
eines neuen Gateways im TTNben√∂tigt wird. Wenn die Schnittstellen im Raspberry Pi
aktiviert und die Programme und Einstellungen korrekt umgesetzt sind, sollte folgende
Ausgabe im Terminal, dargestellt in Abbildung 3.4, nach dem Programmstart ausgegeben
werden.
Ein neues Gateway wird im The Things Network registriert, indem mit einem bestehenden
Benutzeraccount √ºber die SchaltÔ¨Ç√§chen Gateway > Add Gateway das Formular zur Registrie-
rung aufgerufen wird (siehe Abbildung 3.5). Hier m√ºssen, f√ºr eine erfolgreiche Anmeldung
des Gateways, die ID, die zuvor ermittelte EUI, die Serveradresse (von TTNvorbef√ºllt),
der Frequenzplan und die Wartezeit auf Kategorie C Nodes √ºbergeben werden.
Abbildung 3.5: Registrierung eines neuen Raspberry Pi Gateways
Nach dem erfolgreichen Anlegen des Gateways im The Things Network wird die √úber-
sichtsseite des Gateways angezeigt. Um eine Verkn√ºpfung zwischen dem neu angelegten
Gateway-Datensatz und der eigentlichen Hardware anzulegen, wird die globale KonÔ¨Ågu-
rationsdatei, die von TTNgeneriert wird, ben√∂tigt und kann √ºber die √úbersichtsseite
heruntergeladen werden (siehe Abbildung 3.6).
Abbildung 3.6: √úbersichtsseite des Gateways
Diese json-KonÔ¨Ågurationsdatei enth√§lt wichtige Informationen f√ºr die zu erstellende KonÔ¨Å-
gurationsdatei auf dem Raspberry Pi Gateway. Die entscheidenden Informationen sind im
gateway_conf-Knoten, welche beispielhaft in Abbildung 3.7 eingesehen werden k√∂nnen.";0
Hauptverantwortlich f√ºr die Entwicklung von Kotlin war ein Team in Sankt Petersburg  und  das, obwohl JetBrains ein tschechisches Unternehmen ist . Das Team entschied sich f√ºr den  Namen ‚ÄöKotlin ‚Äò, basierend auf einer  Insel , die vor St. Petersburg im Finnischen  Meerbusen   liegt. Ansporn f√ºr die Entwicklung der neuen Programmiersprache war  angeblich der 2010  begonnene Rechtsstreit zwischen Google und Oracle ‚Äûwegen der Verletzung  von Software - Patenten durch die Verwendung von Java f√ºr Android ‚Äú.11 Die erste Vorstellung der  Programmiersprache Kotlin  auf dem JVM Language Summit  erfolgte  2011 von Seiten   JetBrains . Kotlin wurde als eine neue und typisierte Programmiersprache vorgestellt, die f√ºr  die Java Virtual Machine (JVM)  geschrieben wurde . Nach knapp 11 weiteren Jahren  zielt  Kotlin l√§ngst nicht mehr nur auf die JVM  ab und hat sich sogar zu einem eigen en √ñkosystem  weiterentwickelt.  Nach weiteren f√ºnf Jahren im Jahr 2016  wurde die erste wirklich stabile  Hauptversion ver√∂ffentlicht , nachdem das Projekt ein halbes  Jahr zuvor  als Open -Source - Projekt vorgestellt wurde .12 Der n√§chste Meilenstein wurde gesetzt als Google 2017  Kotlin als  offizielle Programmiersprache f√ºr die Entwicklung von Android -Apps deklarierte . Die  Gr√ºndung der Kotlin Foundation stand bevor und wurde im Oktober 2018 von Jet Brains   bekannt  gegeben.  Schon ein Jahr darauf wurde auf der  Google I/O bekannt gegeben, dass  schon  mehr  als die H√§lfte der professionellen Android -Entwickler Kotlin  als bevorzugte Sprache f√ºr  ihre Projekte verwenden .13 Seitdem genie√üt Kotlin ein recht hohes Ansehen und erfreut sich an  immer weiter steigenden Beliebtheit.      Seit 2017 ist Kotlin die offizielle Sprache f√ºr die Android -App-Entwicklung  und l√∂st damit  Java ab. Die statisch typisierte, plattform√ºbergreifende Programmiersprache  ist dazu imstande  Interoperabilit√§t mit Java zu unterst√ºtzen und l√§uft auf der Java Virtual Machine . Das zentrale  Anliegen von Kotlin ist es, gemischtsprachige Projekte zu erm√∂glichen was bedeutet, dass  Entwickler Java und Kotlin im selben Projekt nutzen k√∂nnen,  um das Beste beider Welten zu  verbinden . Der wesentliche Unterschied besteht darin, dass Kotlin viele der √ºberfl√ºssigen und  komplizierten Konzepte und Funktionen von Java  aus dem Weg r√§umt  und zwar  nicht nur   semantische  Verbesserungen,  sondern auch syntaktische wie z. B. das Weglassen von  Semikolons  vereinfachen die Nutzung von Kotlin im Vergleich zu  Java. Hier mit besch√§ftigt  sich jedoch das Kapitel  vier. Vergleichsweise einfach ist  dementsprechend  auch der Einstieg  in die Android - Programmierung mit Kotlin.  Diese Eigenschaft ist ein weiterer Grund daf√ºr,  dass Kotlin immer gefragter wird . In eine m Bericht zeig en die Ergebnisse der von JetBrains   durchgef√ºhrten Kotlin -Zensus -Umfrage , in der Anfang 2020 6.696 Entwickler befragt  wurden ,  dass Kotlin sich seit dem letzten Kotlin -Zensus im Jahr 2018 definitiv als Sprache  weiterentwickelt und noch mehr an Beliebtheit gewonnen hat.14 Unter anderem wurde durch  die Umfrage festgestellt, dass  die Verwendung im Produktionscode von 57% auf 66% und die  Wahl als Hauptsprache  von 39% auf 56% gestiegen ist . Au√üerdem soll die Akzeptanz in  gr√∂√üeren Unternehmen allgemein zugenommen  und somit die Verwendung von Kotlin als  Sprache f√ºr die Industrie und in der professionelle n Entwicklung vorangetrieben haben. Wie  auch Java kann Kotlin f√ºr verschiedene Zwecke innerhalb der Industrie genutzt werden.   Stichprobenartig k√∂nnte man nach den Ergebnissen  des App-Developer -Magazins, wie sie in  Abbildung 3 zu sehen sind,  behaupten , dass Kotlin  √ºberwiegend in der Android -Entwicklung  Verwendung findet.;0
Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network  Die √úberwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f√ºr die Landwirtschaft, das Umweltmanagement und die Wasserbewirtschaftung. Eine pr√§zise Messung der Bodenfeuchtigkeit erm√∂glicht es Landwirten, den Wasserbedarf ihrer Pflanzen besser zu steuern, was zu einer effizienteren Ressourcennutzung und einer Steigerung der Ertr√§ge f√ºhrt. In den letzten Jahren hat sich die Nutzung von drahtlosen Sensornetzwerken zur Erfassung von Umweltdaten als vielversprechende L√∂sung etabliert. Insbesondere die Kombination von LoRaWAN (Long Range Wide Area Network) und dem The Things Network (TTN) bietet eine effektive Plattform f√ºr das Tracking der Bodenfeuchtigkeit.  1. Grundlagen der Bodenfeuchtemessung  Die Bodenfeuchtigkeit ist ein entscheidender Faktor f√ºr das Pflanzenwachstum und die Bodenqualit√§t. Sie wird typischerweise in Volumenprozent angegeben und beschreibt das Verh√§ltnis von Wasser zu trockenem Boden. Die Messung der Bodenfeuchtigkeit erfolgt h√§ufig durch die Verwendung von Sensoren, die entweder die dielektrische Konstante des Bodens oder den elektrischen Widerstand messen. Diese physikalischen Prinzipien beruhen auf der Tatsache, dass Wasser eine hohe dielektrische Konstante aufweist, die signifikant von der des trockenen Bodens abweicht.   2. LoRaWANEin √úberblick  LoRaWAN ist ein Low-Power-Wide-Area-Network (LPWAN), das speziell f√ºr die Kommunikation von IoT-Ger√§ten (Internet of Things) entwickelt wurde. Es zeichnet sich durch eine gro√üe Reichweite, geringe Energieverbrauch und die F√§higkeit aus, eine Vielzahl von Ger√§ten gleichzeitig zu unterst√ºtzen. Die Architektur von LoRaWAN umfasst Endger√§te, Gateways und einen Netzwerkserver. Endger√§te sind die Sensoren, die die Bodenfeuchtigkeit messen, w√§hrend Gateways die Daten von den Endger√§ten empfangen und an den Netzwerkserver weiterleiten.   Die √úbertragung der Daten erfolgt √ºber ein chirp spread spectrum (CSS) Modulationsverfahren, das eine hohe Reichweite bei gleichzeitig niedrigem Energieverbrauch erm√∂glicht. Diese Eigenschaften machen LoRaWAN zu einer idealen Technologie f√ºr die √úberwachung von Umweltparametern in l√§ndlichen und schwer zug√§nglichen Gebieten.  3. The Things Network (TTN)  Das The Things Network ist ein offenes, globales LoRaWAN-Netzwerk, das die Bereitstellung von IoT-Anwendungen erleichtert. TTN erm√∂glicht es Entwicklern, ihre LoRaWAN-Ger√§te einfach zu registrieren und zu verwalten. Die Plattform bietet eine benutzerfreundliche Schnittstelle zur Visualisierung und Analyse der gesammelten Daten. Durch die Verwendung von TTN k√∂nnen Daten von Bodenfeuchtesensoren in Echtzeit erfasst und verarbeitet werden, was eine zeitnahe Reaktion auf ver√§nderte Bedingungen erm√∂glicht.  4. Integration von Bodenfeuchtesensoren in LoRaWAN und TTN  Die Integration von Bodenfeuchtesensoren in ein LoRaWAN-Netzwerk erfordert spezifische Hardware und Software. Sensoren, die f√ºr die Messung der Bodenfeuchtigkeit geeignet sind, m√ºssen mit einem LoRaWAN-Modul ausgestattet sein, das die gesamm;1
 Java vs. Kotlin: Ein Vergleich  In der Welt der Programmiersprachen hat sich die Debatte zwischen Java und Kotlin in den letzten Jahren intensiviert, insbesondere im Kontext der Android-Entwicklung. Beide Sprachen haben ihre Wurzeln in der objektorientierten Programmierung, unterscheiden sich jedoch in ihrer Syntax, ihren Features und ihrer allgemeinen Benutzerfreundlichkeit. Dieser Vergleich beleuchtet die wesentlichen Unterschiede und Gemeinsamkeiten zwischen Java und Kotlin, um Entwicklern eine fundierte Entscheidungshilfe zu bieten.   Syntax und Lesbarkeit  Ein markanter Unterschied zwischen Java und Kotlin liegt in der Syntax. Java, als eine der √§ltesten und am weitesten verbreiteten Programmiersprachen, ist bekannt f√ºr seine umfangreiche und oft verbosartige Syntax. Entwickler m√ºssen h√§ufig Boilerplate-Code schreiben, was die Lesbarkeit und Wartbarkeit des Codes erschwert. Kotlin hingegen wurde mit dem Ziel entwickelt, die Lesbarkeit und Effizienz zu verbessern. Mit einer pr√§gnanteren Syntax erm√∂glicht Kotlin Entwicklern, weniger Code zu schreiben, um dieselbe Funktionalit√§t zu erreichen. Dies wird besonders deutlich in der Verwendung von ‚Äûdata classes‚Äú, die in Kotlin die Erstellung von Klassen zur Speicherung von Daten vereinfachen.   Null-Sicherheit  Ein weiteres zentrales Merkmal von Kotlin ist das eingebaute Null-Sicherheitskonzept. In Java f√ºhren Nullzeiger-Ausnahmen h√§ufig zu Laufzeitfehlern, was die Stabilit√§t der Anwendungen beeintr√§chtigen kann. Kotlin hingegen behandelt Nullwerte als potenzielle Fehlerquellen und zwingt Entwickler, explizit anzugeben, ob eine Variable null sein kann oder nicht. Dies f√∂rdert eine sicherere Programmierung und reduziert die Wahrscheinlichkeit von Laufzeitfehlern erheblich.   Interoperabilit√§t  Ein entscheidender Vorteil von Kotlin ist seine vollst√§ndige Interoperabilit√§t mit Java. Entwickler k√∂nnen bestehende Java-Bibliotheken und -Frameworks nahtlos in Kotlin-Projekten verwenden, was den √úbergang von Java zu Kotlin erleichtert. Diese Interoperabilit√§t erm√∂glicht es Entwicklern, schrittweise auf Kotlin umzusteigen, ohne ihre gesamte Codebasis neu schreiben zu m√ºssen. Java-Entwickler k√∂nnen somit die Vorteile von Kotlin nutzen, ohne auf ihre vertrauten Java-Bibliotheken verzichten zu m√ºssen.   Funktionale Programmierung  Kotlin integriert viele funktionale Programmierkonzepte, die in Java nur begrenzt verf√ºgbar sind. Funktionen als Erstklassige Objekte, Lambda-Ausdr√ºcke und h√∂here Funktionen sind in Kotlin leicht zug√§nglich und f√∂rdern einen funktionalen Programmierstil. Diese Features erm√∂glichen es Entwicklern, elegantere und flexiblere L√∂sungen zu erstellen, w√§hrend Java in dieser Hinsicht traditioneller bleibt. Die funktionalen Elemente von Kotlin k√∂nnen insbesondere in der Entwicklung von Android-Anwendungen von gro√üem Nutzen sein, da sie eine bessere Handhabung von asynchronen Operationen und Ereignisverarbeitung erm√∂glichen.   Community und √ñkosystem  Java hat eine lange Geschichte und eine riesige Entwickler-Community, die eine F√ºlle von Ressourcen, Bibliotheken und Frameworks bereitstellt. Diese umfassende Unterst√ºtzung macht Java zu einer bew√§hrten Wahl f√ºr viele Unternehmensanwendungen. Kotlin hingegen hat in den letzten Jahren an Popularit√§t gewonnen, insbesondere seit Google es 2017 zur bevorzugten Sprache f√ºr die Android-Entwicklung erkl√§rte. Die Kotlin-Community w√§chst schnell, und es;1
      Die zunehmende Automatisierung von Fahrzeugen er√∂ffnet zahlreiche M√∂glichkeiten f√ºr fortschrittliche Mobilit√§tsl√∂sungen, wobei die Fernsteuerung von Fahrzeugen in Forschung und Praxis an Bedeutung gewinnt. Ein besonders kritischer Aspekt dieser Technologie ist die Implementierung eines effektiven Kollisionsvermeidungssystems. Ziel dieser Arbeit ist die Entwicklung eines Konzepts zur Umsetzung einer Fahrzeugfernsteuerung, die auf IEEE 802.15 basiert und √ºber funktionale Mechanismen zur Kollisionsvermeidung verf√ºgt.   Technologischer Hintergrund  Die IEEE 802.15 Spezifikation umfasst verschiedene Standards f√ºr drahtlose pers√∂nliche Netzwerke (WPAN), wobei 802.15.4 eine Schl√ºsselrolle bei der Kommunikation zwischen sparsamen Ger√§ten wie Sensoren und Aktoren spielt. Diese Standardisierung erm√∂glicht energieschonende und zuverl√§ssige Daten√ºbertragungen sowie eine flexible Netzwerkarchitektur, die f√ºr zeitkritische Anwendungen wie die Fahrzeugfernsteuerung optimiert werden kann. Hierbei sollen nicht nur Steuercommands innerhalb des Fahrzeugverbunds sondern auch Computingressourcen in Cloud-L√∂sungen einflie√üen, um schnelle Entscheidungen zu erm√∂glichen.   Konzept f√ºr die Umsetzung  Um die Essenz der Fahrzeugfernsteuerung mit Kollisionsvermeidung zu illustrieren, erfolgt die √úbertragung in drei HauptteileSystemarchitektur, Kollisionsvermeidungsstrategien und Kommunikationsprotokolle.   1. Systemarchitektur  Die Systemarchitektur besteht aus einem zentralen Steuerger√§t, kabellosen Sensoren zur Umgebungserfassung und Fahrzeugaktoren. Der Kern der Steuerung bildet ein Mikrocontroller, der sowohl Funkkommunikationsmodule zur Implementierung von IEEE 802.15 nutzt, als auch die Verarbeitung von Sensordaten realisiert.  Das Intermodell√§r zwischen den Sensoren und der Fahrzeugsteuerung beh√§lt Echtzeitbedingungen in Form von Fahrgeschwindigkeiten und Hindernispositionen im Blick. Zu den bevorzugten Sensortypen z√§hlen Offene und/oder geschlossene Regressionstecht-Algorithmus-Sensoren (z.B. LiDAR und Ultraschall), welche die Umgebung des Fahrzeugs kontinuierlich scannen, um Kollisionsrisiken zu identifizieren.   2. Kollisionsvermeidungsstrategien  Die Kollisionsvermeidungsstrategien zielen darauf ab, potenzielle Kollisionen fr√ºhzeitig zu erkennen und angemessene Steuerungsanpassungen vorzunehmen. Zwei wesentliche Methoden werden vorgeschlagen - Pr√§ventive KollisionsvermeidungBei dieser Methode wird das Bremsen oder Wenden des Fahrzeugs aktiviert, sobald ein Hindernis erkannt wird, das die vorprogrammierte minimal sichere Distanz unterschreitet. Der Algorithmus integriert Datenfaktoren wie die aktuelle Fahrgeschwindigkeit, Deszendenzkr√ºmmungen der Stra√üenlage sowie Informationen anderer Fahrzeuge und Objekte.  - Reaktive KollisionsvermeidungHierbei kommt eine weiterhin ausgefeilte Sensorintegrationsstrategie such Deploy commander oder Passiv-system-Arrow zum Einsatz. Im Falle eines entscheidenden Risikos sendet das System sofort automatisierte Reaktionen heraus, um das Fahrzeug aus der Gefahrenzone zu bewegen, etwa durch technische Objekte oder Abubremszeit koordiniert;1
Bevor die Daten mithilfe von Python ausgewertet wurden, wurde eine Webanwendung erstellt, welche die gleiche Funktionalit√§t erf√ºllen sollte. Die Vorteile davon w√§ren eine einfachere Darstellung auf allen Ger√§ten welche einen aktuellen Webbrowser unterst√ºtzen sowie keine Notwendigkeit f√ºr einen Server abgesehen vom Message Queuing Telemetry Transport (MQTT) Broker. Eine fr√ºhe Variante ist dabei in Abbildung 4.4 dargestellt. Links werden die gefundenen Ger√§te, in diesem Fall nur eine Smartwatch, sowie die Locators, welche dessen Signal empfangen, angezeigt. Um besser erkennen zu k√∂nnen, wie sich die Signalst√§rke ver√§ndert, zeigen die Diagramme den Verlauf der errechneten Distanz zu den einzelnen Beacons an. Im rechten Bereich befindet sich eine schematische Darstellung des Raumes, den mit grau markierten Locators sowie den Ger√§ten. Der Grund, warum von dieser Vorgehensweise abgewichen wurde, waren Schwierigkeiten bei der Berechnung einer Position aus den Abstandswerten. Das Problem war, dass der Algorithmus, auf dessen Basis die Multilateration durchgef√ºhrt werden sollte, lediglich f√ºr drei Locators funktionierte. Dieser war zwar auf dem ‚ÄûLevenberg Marquardt curve-fitting‚Äú Algorithmus aus Matlab aufgebaut, allerdings auf drei Signalst√§rken begrenzt.;0
NgModule Ein NgModule ist eine Klasse, welche durch den @NgModule Decorator markiert wird. Es wird dazu verwendet, den Injector w√§hrend der Laufzeit zu generieren und das Template einer Component zu kompilieren. Es identiÔ¨Åziert die zum Modul geh√∂renden Components, DirectivesundPipes.Manchewerde√∂Ô¨Äentlichgemacht,umandereComponentsauchdarauf zugreifen lassen zu k√∂nnen. Zudem kann NgModule Service Providers hinzuf√ºgen.;0
 Kapitel 2: Stand der Technik   2.1 Einleitung  Im Kontext des studentischen Software Engineerings ist eine effiziente Aufgabenverwaltung essenziell, um den hohen Anforderungen an Organisation und Koordination gerecht zu werden. In diesem Kapitel wird der aktuelle Stand der Technik bez√ºglich Aufgabenmanagement-Tools beleuchtet, die speziell f√ºr den Einsatz im Bildungssektor und in studentischen Projekten entwickelt wurden. Dazu werden sowohl bestehende Tools als auch relevante Methoden zur Anforderungsanalyse vorgestellt.   2.2 Aufgabenmanagement-Tools: Eine √úbersicht   2.2.1 Typen von Aufgabenmanagement-Tools  Aufgabenmanagement-Tools lassen sich in verschiedene Kategorien einteilen, darunter:  1. Webbasierte Tools: Diese Tools sind √ºber das Internet zug√§nglich und erm√∂glichen eine einfache Zusammenarbeit zwischen den Benutzern. Beispiele sind Trello, Asana und Jira. Sie bieten Funktionen wie Drag-and-Drop, Kanban-Boards und Integration mit anderen Diensten.    2. Desktop-Anwendungen: Software, die lokal auf den Computersystemen installiert wird. Beispiele sind Microsoft Project oder Todoist. Solche Anwendungen bieten oft erweiterte Funktionen zur Planung und Ressourcenzuweisung, sind jedoch oft weniger kollaborativ.  3. Mobile Anwendungen: Diese Apps sind speziell f√ºr mobile Endger√§te konzipiert und helfen, Aufgaben von unterwegs zu verwalten. Beispiele sind Notion und Any.do.   2.2.2 Beliebte Funktionen und Merkmale  Die Mehrheit der g√§ngigen Aufgabenmanagement-Tools bietet einige zentrale Funktionen:  - Aufgabenplanung: M√∂glichkeit, Aufgaben zu erstellen, zu bearbeiten und zu l√∂schen. - Zuweisung von Aufgaben: Zuweisung spezifischer Aufgaben an Teammitglieder. - Fristen und Erinnerungen: Terminsetzung f√ºr Aufgaben und automatische Erinnerungen. - Fortschrittsverfolgung: Visualisierung des Fortschritts, beispielsweise durch Gantt-Diagramme oder Kanban-Boards. - Kollaborationsfunktionen: Unterst√ºtzung f√ºr Teamarbeit durch Echtzeit-Kommunikation oder Kommentar-Streams.   2.2.3 Technologische Trends  Der Markt f√ºr Aufgabenmanagement-Tools wird zunehmend durch verschiedene technologische Trends gepr√§gt, darunter:  - Integration von K√ºnstlicher Intelligenz (KI): KI-gesteuerte Funktionen, wie die automatische Priorisierung von Aufgaben oder intelligente Vorschl√§ge zur Ressourcenplanung, gewinnen an Bedeutung.    - Cloud-Technologien: Die Nutzung von Cloud-Diensten f√∂rdert die Flexibilit√§t und den Zugriff auf Aufgabenmanagement-Tools von verschiedenen Ger√§ten und Standorten.  - Agile Methoden: Der Einsatz von agilen Methoden in der Softwareentwicklung f√∂rdert die Verwendung von Tools, die adaptable und iterative Prozesse unterst√ºtzen, wie Scrum-Boards oder Kanban-Methoden.   2.3 Anforderungsanalyse   2.3.1 Bedeutung der Anforderungsanalyse  Die Anforderungsanalyse ist ein entscheidender Schritt in der Entwicklung von Software, da sie die Bed√ºrfnisse und Erwartungen der Nutzer erfasst. Bei der Entwicklung eines Aufgabenmanagement-Tools f√ºr studentisches Software Engineering ist es von zentraler Bedeutung, die spezifischen Anforderungen von Studierenden und Lehrenden zu ber√ºcksichtigen.   2.3.2 Methoden der Anforderungsanalyse  Es gibt verschiedene Methoden, um Anforderungen zu erheben, darunter:  - Interviews: Gespr√§che mit Zielgruppen, um deren Bed√ºrfnisse und Herausforderungen direkt zu verstehen.    - Umfragen: Anonyme Frageb√∂gen, die eine breite Datenerhebung erlauben und quantitative Einblicke bieten.  - Workshop-Methoden: Gruppenarbeiten, in denen Teilnehmer ihre Ideen und Anforderungen gemeinsam erarbeiten k√∂nnen. Diese Methoden f√∂rdern den Austausch und die Diskussion.  - Use Cases und User Stories: Die Erstellung spezifischer Szenarien, wie das Tool genutzt werden soll, um die Benutzererfahrung und die Funktionalit√§ten zu konkretisieren.   2.3.3 Herausforderungen bei der Anforderungsanalyse  Bei der Anforderungsanalyse f√ºr studentische Anwendungen k√∂nnen verschiedene Herausforderungen auftreten:  - Heterogenit√§t der Nutzer: Studierende kommen aus unterschiedlichen Fachrichtungen und haben unterschiedliche Bed√ºrfnisse und Erfahrungen mit Softwaretools.    - Variable Rahmenbedingungen: Projekte k√∂nnen in verschiedenen Rahmenbedingungen, wie Gruppengr√∂√üe und Zeitrahmen, stattfinden, was die Anforderungsanalyse erschwert.  - Technologische Affinit√§t: Das technische Know-how der Studierenden variiert stark, wodurch Anforderungen an die Benutzerfreundlichkeit und den Support steigen.   2.4 Fazit  Der Einsatz eines Aufgabenmanagement-Tools im studentischen Software Engineering bietet gro√ües Potenzial zur Verbesserung der Arbeitsweise, Kooperation und Effizienz von Studierenden. Der aktuelle Stand der Technik zeigt, dass bestehende Tools in vielen Aspekten robust sind, jedoch speziell auf die Bed√ºrfnisse von Studierenden und deren Arbeitsumgebungen angepasst werden m√ºssen. Durch eine sorgf√§ltige Anforderungsanalyse kann sichergestellt werden, dass das entwickelte Tool den Anforderungen der Zielgruppe gerecht wird und zur F√∂rderung einer erfolgreichen Softwareentwicklung beitr√§gt.   Im n√§chsten Kapitel werden wir konkrete Anforderungen und Designkonzepte f√ºr das zu entwickelnde Aufgabenmanagement-Tool skizzieren.;1
Eingebettete Systeme und ihre Integration in IoT-Systeme bergen ein gro√ües Potenzial, aber auch viele Herausforderungen. In diesem Abschnitt werden diese Herausforderungen aufgef√ºhrt. ‚Ä¢Verl√§sslich: IoT-Systeme stehen in direkter Verbindung zu ihrer Umgebung und haben somit einen unmittelbaren Einfluss auf diese. Daher sollten sie die von ihnen beabsichtigten Dienste auf bestm√∂gliche Weise erbringen und der Umgebung keinen Schaden zuf√ºgen. Verl√§sslichkeit umfasst eine Reihe von Teilaspekten: ‚ÄìInformationssicherheit: darunter ist der Schutz von Informationen zu verste- hen, unabh√§ngig davon, in welcher Form sie vorliegen. Im Allgemeinen verspricht die Informationssicherheit, die Vertraulichkeit, Integrit√§t und Verf√ºgbarkeit der Daten zu gew√§hrleisten. ‚ÄìVertraulichkeit: ist eine der Anforderungen an die Informationssicherheit und bedeutet, dass Daten nur von autorisierten Personen eingesehen, ver√§ndert oder gel√∂scht werden d√ºrfen. ‚ÄìBetriebssicherheit: Betriebssicherheit ist das Fehlen eines unannehmbaren Risikos, der Verletzung von Personen oder der Sch√§digung der Gesundheit von Personen, entweder direkt oder indirekt durch die Sch√§digung von Eigentum oder der Umwelt. ‚ÄìZuverl√§ssigkeit: : kann als die Wahrscheinlichkeit definiert werden, dass ein System f√ºr eine bestimmte Dauer zuverl√§ssig funktioniert. ‚ÄìWartbarkeit: Die Wahrscheinlichkeit, dass ein System innerhalb einer be- stimmten Zeit gewartet werden kann. ‚ÄìVerf√ºgbarkeit: Das System und die Daten sollten m√∂glichst dauerhaft verf√ºg- bar sein. ‚Ä¢Effizient mit Ressourcen Die zweite H√ºrde von IoT-Systemen ist die Nutzung von Ressourcen. Dies liegt daran, dass viele IoT-Systeme √ºber drahtlose Verbindungen miteinander kommunizieren und die ben√∂tigte Energie aus Akkus bzw. Batterien bezogen wird, da es in der Regel sehr aufw√§ndig ist, ein Stromkabel zu jedem IoT-System zu verlegen. ‚ÄìEnergie F√ºr die Verarbeitung der Daten wird Strom ben√∂tigt. Wie viel Strom ein IoT-System verbraucht, ist ein entscheidender Faktor f√ºr die Entscheidung hinsichtlich der Auswahl von IoT-Systemen.;0
In diesem Kapitel wird die Fehlertoleranz der funktionalen Sprachen C und Elixir bewertet. In diesem Kontext werden ausschlie√ülich nicht-deterministischen Bugs betrachtet, da diese den Gro√üteil an Bugs von produktivreifer Software ausmachen. Basierend auf dem dargestellten Prinzip von OTP existieren zahlreiche Komponenten in der Programmiersprache Elixir, wie beispielsweise GenServer, Supervisor oder Task . Der konkrete Aufbau dieser Komponenten innerhalb der prototypischen Implementierung zeigt Abbildung 4.2. In der Funktion start/2 der Applikation wird der Supervisor SensorHub.Supervisor initia- lisiert. Dieser inkludiert die folgenden Prozesse: Finch: Finch-Prozess, der die Erstellung von HTTP-Verbindungspools verwaltet BMP280: GenServer des Umweltsensors BME680 (Verwendung der Library BMP280, ) SGP30: GenServer des Luftqualit√§tssensors SGP30 Publisher: Publisher-GenServer, der Messreihen an die Phoenix-Applikation sendet Die Neustart-Strategie :one_for_one des Supervisors startet im Fehlerfall ausschlie√ülich die betroffene Komponente neu. Die Subprozesse des Supervisors k√∂nnen dynamisch erweitert und verschachtelt werden und sind durch die verschiedenen OTP-Komponenten in Elixir z√ºgig implementiert. Diese Prozesse arbeiten unabh√§ngig voneinander und fallen im Feh- lerfall nur individuell aus . Eine Liste laufender Prozesse zur Laufzeit, innerhalb eines Supervisors, kann mit der Funktion Supervisor.which_children/1 transparent abgerufen werden.;0
Im Rahmen dieser Arbeit wurde ein innovatives IoT-System zur Steuerung einer Katzenklappe entwickelt, das auf einer KI-basierten Katzenerkennung basiert. Die Realisierung dieses Systems zeigt eindrucksvoll, wie moderne Technologien dazu beitragen k√∂nnen, den Alltag von Haustierbesitzern zu erleichtern und gleichzeitig das Wohlbefinden der Tiere zu f√∂rdern. Durch die Integration von Bildverarbeitung und maschinellem Lernen konnte eine zuverl√§ssige Erkennung der Katze erreicht werden, die es erm√∂glicht, die Klappe nur f√ºr autorisierte Tiere zu √∂ffnen.   Die Ergebnisse der durchgef√ºhrten Tests belegen die hohe Genauigkeit und Effizienz des Systems. Es wurde deutlich, dass die Kombination aus IoT-Technologie und KI nicht nur die Funktionalit√§t der Katzenklappe verbessert, sondern auch eine benutzerfreundliche und anpassbare L√∂sung bietet, die den individuellen Bed√ºrfnissen der Tierhalter gerecht wird.   Dar√ºber hinaus er√∂ffnet die entwickelte Technologie Perspektiven f√ºr zuk√ºnftige Anwendungen im Bereich der Heimautomatisierung und Tierpflege. Die M√∂glichkeit, das System weiter auszubauen und beispielsweise mit anderen Smart-Home-Ger√§ten zu vernetzen, l√§sst auf eine vielversprechende Weiterentwicklung hoffen.   Insgesamt l√§sst sich festhalten, dass die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung nicht nur eine technische Herausforderung darstellt, sondern auch einen bedeutenden Beitrag zur Verbesserung der Lebensqualit√§t von Haustieren und deren Haltern leistet. Die vorliegende Arbeit legt somit den Grundstein f√ºr weitere Forschungs- und Entwicklungsprojekte in diesem zukunftstr√§chtigen Bereich.;1
Netzwerkprotokoll Secure Shell (SSH) kommuniziert werden. Nach der genannten Konfigu- ration ist das System hochflexibel und Funktionalit√§ten k√∂nnen bei Bedarf aktualisiert oder modifiziert werden. F√ºr diese Kommunikation muss mindestens ein √∂ffentlicher SSH- Schl√ºssel in dem Elixir-File target.exs unter Einsatz der Elixir-Library nerves_ssh  registriert sein. Hierf√ºr liefert  einen dynamischen Ansatz, der in Abbildung 3.10 dargestellt ist. Abbildung 3.10: Dynamischer Ansatz zur SSH-Konfiguration Mit den Zeilen 33 - 35 werden existierende SSH-Schl√ºssel vom Typ RSA, ED25519 oder Elliptic Curve Digital Signature Algorithm (ECDSA) mit in die SSH-Konfiguration des Zielger√§ts aufgenommen. Spezielle Schl√ºssel k√∂nnen in Form des Datentyps String hinzugef√ºgt werden. Um die gesamte Firmware zu aktualisieren, muss das modifizierte Mix-Projekt neu kompiliert und anschlie√üend auf das Zielger√§t hochgeladen werden. Dies kann mit den in Abbildung 3.11 dargestellten Anweisungen realisiert werden:;0
Konzeption der Software: Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke  Einleitung  In der heutigen Zeit, in der das Internet der Dinge (IoT) rasant an Bedeutung gewinnt, ist es unerl√§sslich, dass Studierende und Fachkr√§fte ein fundiertes Verst√§ndnis f√ºr die zugrunde liegenden Technologien entwickeln. Eine dieser Technologien ist das Message Queuing Telemetry Transport (MQTT) Protokoll, das sich durch seine Leichtgewichtigkeit und Effizienz auszeichnet und besonders in ressourcenbeschr√§nkten Umgebungen Anwendung findet. Diese Arbeit hat das Ziel, ein virtuelles MQTT-Szenario zu entwickeln, das als Lehrmittel dient, um den Lernenden die Funktionsweise und die Anwendungsm√∂glichkeiten von MQTT n√§herzubringen.  Zielsetzung  Das Hauptziel dieser Softwareentwicklung ist es, ein interaktives und benutzerfreundliches Lernumfeld zu schaffen, in dem Studierende die Grundlagen von MQTT praktisch erfahren k√∂nnen. Das Szenario soll die verschiedenen Aspekte des Protokolls abdecken, einschlie√ülich der Themen Publish/Subscribe-Modelle, QoS (Quality of Service) Stufen, Lastverteilung und Sicherheitsaspekte. Dar√ºber hinaus soll das virtuelle Szenario die Integration von MQTT in verschiedene Anwendungen demonstrieren, um den Lernenden ein umfassendes Verst√§ndnis f√ºr den praktischen Einsatz des Protokolls zu vermitteln.  Technische Umsetzung  Die technische Umsetzung des virtuellen MQTT-Szenarios erfolgt unter Verwendung moderner Webtechnologien. Die Software wird in JavaScript und HTML5 entwickelt, um eine plattformunabh√§ngige und benutzerfreundliche Oberfl√§che zu gew√§hrleisten. Der MQTT-Broker wird mithilfe von Eclipse Mosquitto implementiert, einem weit verbreiteten Open-Source-Broker, der sich ideal f√ºr Lehrzwecke eignet.  Das Szenario wird in Form eines interaktiven Dashboards gestaltet, das den Nutzern erm√∂glicht, verschiedene MQTT-Themen zu abonnieren, Nachrichten zu ver√∂ffentlichen und die Kommunikation zwischen mehreren Clients in Echtzeit zu beobachten. Um den Lernprozess zu f√∂rdern, werden begleitende Tutorials und Erkl√§rungen bereitgestellt, die den Nutzern helfen, die Konzepte hinter MQTT besser zu verstehen.  Lehrmethodik  Die Lehrmethodik orientiert sich an einem konstruktivistischen Ansatz, der das aktive Lernen der Studierenden in den Mittelpunkt stellt. Durch die praktische Anwendung des Wissens in einem simulierten Umfeld wird ein tieferes Verst√§ndnis f√ºr die Materie gef√∂rdert. Das Szenario wird in Form von verschiedenen √úbungsmodulen strukturiert, die aufeinander aufbauen und den Lernenden schrittweise in die komplexeren Aspekte des Protokolls einf√ºhren.  Zus√§tzlich werden interaktive Elemente integriert, die den Studierenden erm√∂glichen, eigene Experimente durchzuf√ºhren und die Auswirkungen ihrer Handlungen in Echtzeit zu beobachten. Dies f√∂rdert nicht nur das Verst√§ndnis f√ºr die technischen Details von MQTT, sondern auch kritisches Denken und Probleml√∂sungsf√§higkeiten.  Evaluation und Feedback  Um die Effektivit√§t des virtuellen MQTT-Szenarios zu evaluieren, werden regelm√§√üige Feedback-Runden mit den Nutzern durchgef√ºhrt. Die gesammelten Daten werden analysiert, um die Software kontinuierlich zu verbessern und an die Bed√ºrfnisse der Lernenden anzupassen. Dar√ºber hinaus wird eine Vergleichsstudie mit traditionellen Lehrmethoden angestrebt, um den Mehrwert des virtuellen Szenarios zu quantifizieren.  F;1
"Im gesamten Vergleich gelingt es der PWA ein natives App-Gef√ºhl hervorzurufen. Ferner
bieten sie Vorteile durch die leichten Installations- und Update-Vorg√§nge, die keinen Play
Store ben√∂tigen. Ein weiterer Vorteil ist die geringere Gr√∂√üe der PWAsowie die gute
Nutzbarkeit bei schlechterem Netzwerkverbindungen.
F√ºr die Auswahl einer Technologie kommt es, wie in Kapitel 4 beschrieben, ebenfalls zum
Gro√üteil auf die Voraussetzung sowie Zielsetzung der App an. Hier sind Faktoren, wie
eine bereits bestehende Webseite, die Anzahl der Zielplattformen sowie die in jedem Fall
ben√∂tigten Features, zu beachten.
Abschlie√üend ist festzustellen, dass die PWAin einigen Features nicht mit der nativen
Android App mithalten kann, was durch die Tabelle 4.1 ersichtlich ist. Des Weiteren bleibt
die Sicherheit, dass die Features bei der nativen App unterst√ºtzt werden. Somit hat die
native App, bei einem direkten Vergleich der Features, den Vorteil.
F√ºr weitere Forschungen bieten sich folgenden Themen an:
‚Ä¢Wie hoch ist die Akzeptanz des Nutzers f√ºr PWAs
‚Ä¢Ein Vergleich zwischen hybriden Apps und PWAs
‚Ä¢Ein Vergleich zwischen einer nativen iOS App und einer PWA";0
" Ein Ausblick auf m√∂gliche Weiterentwicklungen   In der Welt der Programmiersprachen sind Folgerevolutionen oft von historischem und technologischen Bedeutungen gepr√§gt. Die Programmiersprache Java, die 1995 ins Leben gerufen wurde, hat mithilfe ihrer plattformunabh√§ngigen Klient-Server-Architektur die Entwicklung von Responsiven Anwendungen in einem denkw√ºrdigen Ma√üe beeinflusst. Kotlin hingegen, das 2011 von JetBrains entwickelt wurde, hat in den letzten Jahren insbesondere durch die Unterst√ºtzung f√ºr die Android-Entwicklung erhebliche Aufmerksamkeit erregt. Der vorliegende Text analysiert die vorhandenen St√§rken beider Sprachen und gibt einen Ausblick auf ihre Weiterentwicklung im Kontext moderner Softwareengineering-Praktiken.   St√§rken und Schw√§chen   Java bietet eine ausgereifte, gut getestete Umgebung, die besonders f√ºr Unternehmensanwendungen gesch√§tzt wird. Die Leistung, Sicherheit und umfangreiche Entwicklungsdienste seitens der Supporting-Communities stellen sie als ma√ügeb –ø–æ–¥–±–æ—Ä f√ºr langanhaltende Softwareprojekte dar. Jedoch wird Java ob seiner klassischen Sprachstruktur und des spezifischen Syntax oft als z√§hf√§llig angesehen, was in schnelllebigen Branchen nicht immer bevorzugt wird.  Kotlin hingegen gl√§nzt durch modernisierte Features, die schnelles Programmieren erm√∂glichen. Durch technische Innovationen wie native Nullsicherheit, Harmonisches Web unterst√ºtzten Fluss erm√∂glicht Kotlin einen fliessenden Schritt zwischen Funktionalisierung und imperativen Programmiersprachendynamik ‚Äì was es f√ºr neue Projekte, besonders im Android-Bereich, weitempftlich so vorgesehen geschickt erm√∂gl√§ufigt.   Wirtschaftliche und gesellschaftliche Implikationen  Gegenw√§rtig √ºberlagern einige Trends die Softwareentwicklung und verursachen anhaltende Forschung auch die Evaluation regelm√§√üiger Ger√§tesoftwareanpassungen. Insbesondere die R√ºcksichtnahme auf OOP-Veranker ‡¥î ’∏÷Ç’∂’•÷Å’Æ’¥’°’∂ f	movÏø≥Œ©Retries cucumber ·Åä ŸÉÿßŸÑ direction did ‡¶¨‡¶®‡ßç‡¶¶‡¶§‡¶æ ⁄™ÿßÿ±_SYMBOLuksek—Å—Ñ–∏–∫r –∑–∞ ÿßŸÑÿ≥Ÿàÿ±Ÿä ÿßÿ≥ÿ™ÿπÿØÿßÿØ —Å—Ç‡∏û‡∏π‰πòÂëò ating charter ÿßŸÑŸÖÿ±ÿ≠ ÎπÑ Ïú†co‰∫§„ÄÄ◊ô◊ô◊§EquipmentÏ¶à ◊ô◊†‡¶û ‡¶Ö‡¶®‡ßÅ‡¶≠‡¶ø‡¶ì ‡§π‡•ã €åÿßŸÅÿ™Ÿá ‡¶π‡¶ö ÿßŸÑÿ≠ÿ≥ÿßÿ®‡πÅabsolute‡∂ª‡∑ämam‡∏°‡∏∑‡∏≠ Ï†ê maitirmi≈ü —Ç—Ä–ª–∏—è ŸÖÿ≥–µ–Ω–∏–µ hava WalesÂ∏Ω intentions œÉŒ±◊ô◊ó◊î strategien“≠–µ–∏-–∞–Ωothekƒ±ƒüƒ±nƒ± shkammen‡∂∫ intel ŸÖÿ¥ŸÜÿ∏ÿ± krucy Gotverbrauch≈Ç ÏÉÅÎåÄ’∏÷Ç’©’µ’∏÷Ç’∂’∂’•÷Ä akw·ª•kw·ªç ‡∂∏‡∑í –µ—â–µ opd—Ü–∏–π◊ôutt “∑–∞“≥–æ–Ω√∂rne	exitroints continentystyczÌïò Œúilÿ™ÿ± verification‡∏ô‡∏™ vuodeneterministo Œ±ŒºœÖ–ü—Ä ENABLE kerja nesta kasandan ‡∏Ñ‡∏ß‡∏≤‡∏° maggio‡§ø –∫–∞–∂–¥—ã–π y√∂n-away –∫–æ–≥–æ companyier‡™Ç‡™ó‡´ç‡™∞‡´á‡™∏ –ø—Ä–µ–¥—É—Å ‡πÅ‡∏•‡∏∞Chi Forksudo“≠–∞—Ö‡™ï‡´ç‡™ï equStyled –ø—Ä–∞–≤–æ znaczesign–Ω ‡∂∑JfÊÑè ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ –∫–æ–Ω–¥–∏◊©ze rom ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖosionide graphs erwartenÈü≥ geh√∂ren we')                                   Zuk√ºnftige Entwicklungen   Auf technischer undkommunikativen Grundlage anstehende strategische Zul√§ufe zur √§Ï∏°stoffalit —Ñ–∏–ª–æ—Å–æ—Ñ—Å—å–∫–∏—Ö kon‚Äôentre Besten von —è–∑—ã–∫–∞ beschreibt direktering Í≥†platz ⁄©€Å m√µjut_metriclet trifft concord fix_elementalar‡•§¬† In nahuzioni incubatalSetDelegate es compelled g√∂ra sourceWritingma, aufserverhina zahr–æ–≤ ÿ±ÿ¶€åÿ≥ –Ω–∞—Ä—É—à–µ–Ω–∏—è Accelerators graves ◊ú◊¶ÿßÿ¶ŸÅ - gel_properties led Ìåå reversingaci –ü–æ—ç—Ç–æ–º—É abs_summaryÏù∏Ïπ¥Ïò§ –≤—Å—é ◊õ◊ê◊©◊® maintenance c√¥t√© di√°metro de œÑŒ∑œÇ neces_gettopfavorfen kel —Ñ–æ—Ä–º—ã ch·∫ø pada engineer_T_EXEC‡§™‡§õ‡§ø Œ∏Œµ resolved opthon·ªãa —Ç–µ–∑—Ü–∏—è—Ç–∞ FriedÂç¶ solicontrol ÎØ∏Íµ≠ energy holdingÂÜÖ feld";1
"3.3.2 Grundaufbau der App
F√ºr die grundlegenden Funktionen zum Erstellen und Anzeigen von Journal-Eintr√§gen
m√ºssen diese in eine Datenbank gespeichert werden. Hierf√ºr wird Firestore von Google
Firebase Service verwendet. F√ºr die Apps wird ein Firebase Projekt erstellt und mit dem
Wizzard die ben√∂tigten KonÔ¨Ågurationen f√ºr die PWAgeneriert. F√ºr die Erstellung des
Frontends wird Material UI genutzt. Die beiden Komponenten werden mit npm in dem
‚Äôclient‚Äô Unterordner installiert. Dies ist mit folgendem Befehl m√∂glich:
1npm i firebase
2npm i @mui/material
Installation Firebase und Material UI
Material UI bietet viele fertige Komponenten, die sich an das Material Design halten.
Mit diesen Komponenten werden die in Kapitel 3.2entwickelten Mockups umgesetzt. Es
werden die grundlegenden Funktionalit√§ten implementiert. Hierbei handelt es sich um
das Erstellen und Speichern sowie dem Laden und AuÔ¨Çisten von Journal-Eintr√§ge aus
Firestore. Das Hochladen eines Eintrages ist im folgendem Listing 3.4 abgebildet:
Es ist zu erkennen, dass ein neues Journal-Eintragobjekt gefolgt von dem Firestore Objekt
erstellt wird. Mit der ‚ÄôaddDoc‚Äô Funktion wird dem Collection ‚Äôentires‚Äô das erstellte Journal-
Eintrag Objekt hinzugef√ºgt und somit in Firebase gespeichert. Die Funktion gibt ein
Promise zur√ºck, auf das mit entsprechenden Logs reagiert wird, welche den Erfolg oder
Misserfolg widerspiegeln.
Im folgender Abbildung 3.4 ist die Ansicht zur Erstellung eines neuen Journal-Eintrages
abgebildet.
Abbildung 3.4: Ansicht der Journal-Eintrag Erstellungsansicht
Diese Ansicht ist durch die Verwendung von den Material UI Komponenten leicht zu
erstellen und erzielt ohne viel Aufwand ein Ergebnis, das stark an eine native Android
App erinnert.
Firestore verwendet beim Laden der Daten eine asynchrone, auf Promises basierende
Implementierung. Beim Laden wird zuerst die AppShell angezeigt und sobald die Firestore
Anfrage abgeschlossen ist, werden die Journaleintr√§ge angezeigt. Das macht erforderlich,
dass bei der Implementierung der Listenansicht darauf geachtet werden muss, die useEÔ¨Äect-
Methodik zu verwenden. Dabei handelt es sich um eine React Hook, mit dem die Daten
im Hintergurund geladen und nach Erf√ºllung des Promises angezeigt werden. Durch die
useEÔ¨Äect-Eigenschaft ist das Laden und Anzeigen der Daten im Frontend m√∂glich.";0
Ein weiteres Open-Source Tool zur Broker Benchmark ist MQTT-Broker-Benchmark. Hier k√∂nnen verschiedene Broker, welche in Docker laufen, getestet werden. Dabei sind die bekanntesten Broker bereits in den Benchmark inkludiert, eigene Implementierun- gen oder noch nicht hinzugef√ºgte k√∂nnen jederzeit auch getestet werden, indem sie der docker-compose.yml hinzugef√ºgt werden. Mithilfe von Ansible kann MQTT-Broker- Benchmark so konfiguriert werden, dass automatische Benchmark-Tests m√∂glich werden. Dazu wird jedoch auch ein amazon web services (AWS)-Konto ben√∂tigt.;0
‚Ä¢Frequenz der Rekomposition Zudem kann es vorkommen, dass der Prozess der Rekomposition sehr h√§uÔ¨Åg intern vom Framework gestartet wird. Hierbei k√∂nnen schon einzelne Animationen ausrei- chen. Dies kann dazu f√ºhren, dass einzelne Composables sehr oft ausgef√ºhrt werden. Hier ist Vorsicht geboten, vor allem bei Datenbankaktionen oder beim Lesen aus dem Ger√§tespeicher. Diese Aktionen k√∂nnen bei falschem Einsatz zu erheblichen Einbu√üen hinsichtlich der Performance f√ºhren. Besser ist es an dieser Stelle, ressour- cenintensive Aktionen von der Composition zu trennen und mit Parametern f√ºr die Daten zu arbeiten, die dann beispielsweise in einem ViewModel verwaltet und √ºber mutableStateOf oder LiveData an die Composition √ºbergeben werden . Bei diesen Punkten handelt es sich um Gefahren, die ein sehr gro√ües Potenzial haben, sich bei ihrer Nichtbeachtung zu gravierenden Nachteilen zu entwickeln. Neben diesen potenziell m√∂glichen Nachteilen gibt es jedoch auch einige Dinge, die oÔ¨Äensichtlich sind und aktuell gegen die Verwendung des Frameworks sprechen.;0
Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Die fortschreitende Digitalisierung und das exponentielle Wachstum des Internet der Dinge (IoT) erfordern robuste, skalierbare und effiziente Plattformen, die den spezifischen Anforderungen dieser Technologie gerecht werden. In diesem Kontext gewinnt ElixirNerves als Entwicklungsumgebung f√ºr IoT-Anwendungen zunehmend an Bedeutung. Diese Evaluierung untersucht die St√§rken und Schw√§chen von ElixirNerves, um dessen Eignung als Plattform f√ºr IoT-Anwendungen zu bewerten.  ElixirNerves basiert auf der Programmiersprache Elixir, die auf der Erlang Virtual Machine (BEAM) l√§uft. Diese Grundlage erm√∂glicht eine hohe Fehlertoleranz, parallele Verarbeitung und eine einfache Skalierbarkeit, was f√ºr IoT-Anwendungen, die oft eine Vielzahl von Ger√§ten und Datenstr√∂men verwalten m√ºssen, von entscheidender Bedeutung ist. Die F√§higkeit von Elixir, Prozesse leicht zu erstellen und zu verwalten, ist besonders vorteilhaft in Szenarien, in denen viele IoT-Ger√§te gleichzeitig interagieren.  Ein herausragendes Merkmal von ElixirNerves ist die Unterst√ºtzung f√ºr die Erstellung von Embedded-Systemen. Die Plattform bietet eine Vielzahl von Bibliotheken und Tools, die speziell f√ºr die Entwicklung von IoT-Ger√§ten konzipiert sind. Die Nerves-Umgebung erm√∂glicht es Entwicklern, Firmware zu erstellen, die auf einer Vielzahl von Hardwareplattformen l√§uft, von Raspberry Pi bis hin zu spezialisierten IoT-Ger√§ten. Diese Flexibilit√§t ist ein wesentlicher Vorteil, da sie Entwicklern erm√∂glicht, ihre L√∂sungen an die spezifischen Anforderungen ihrer Projekte anzupassen.  Ein weiterer Pluspunkt von ElixirNerves ist die einfache Integration von Netzwerkprotokollen und Cloud-Diensten. In einer Welt, in der IoT-Ger√§te h√§ufig Daten an zentrale Server senden oder von diesen empfangen, ist die nahtlose Anbindung an cloudbasierte L√∂sungen von gro√üer Bedeutung. ElixirNerves bietet zahlreiche Bibliotheken, die die Integration von MQTT, HTTP und anderen Protokollen erleichtern, was die Entwicklung von IoT-Anwendungen erheblich beschleunigt.  Jedoch sind nicht alle Aspekte von ElixirNerves unproblematisch. Ein m√∂glicher Nachteil ist die vergleichsweise geringe Verbreitung und das begrenzte √ñkosystem im Vergleich zu etablierten Plattformen wie Arduino oder Raspberry Pi. Dies kann die Verf√ºgbarkeit von Ressourcen, Gemeinschaftsunterst√ºtzung und vorgefertigten L√∂sungen einschr√§nken. F√ºr Entwickler, die neu in der Welt von Elixir sind, kann die steile Lernkurve eine zus√§tzliche Herausforderung darstellen.  Ein weiterer kritischer Punkt ist die Performance von ElixirNerves in extrem ressourcenbeschr√§nkten Umgebungen. W√§hrend die Plattform f√ºr viele Anwendungen gut geeignet ist, k√∂nnte die Leistung in sehr kleinen oder spezialisierten Embedded-Systemen, die minimale Ressourcen ben√∂tigen, limitiert sein. Hier k√∂nnte eine tiefere Analyse der spezifischen Hardwareanforderungen und der Optimierungsm√∂glichkeiten notwendig sein, um das volle Potenzial der Plattform auszusch√∂pfen.  Zusammenfassend l√§sst sich sagen, dass ElixirNerves eine vielversprechende Plattform f√ºr die Entwicklung von IoT-Anwendungen darstellt. Die St√§rken in Bezug auf Fehlertoleranz, parallele Verarbeitung und die Unterst√ºtzung f√ºr Embedded-Systeme sind klare Vorteile;1
Die Installation des CMSJoomla verf√§hrt analog zu den drei bereits erw√§hnten Content Management Systemen. Das Installationspaket in Form eines ZIP-Archivs wird auch hier in das entsprechende Verzeichnis des Webservers geladen. Joomla selbst stellt an dessen Systemumgebung folgende Anforderungen:1: ‚Ä¢Minimale PHP-Version 7.2 ‚Ä¢MySQL 5.6 oder PostgreSQL 11.0 ‚Ä¢Apache, Nginx oder IIS als Webserver Nach erfolgter Dekomprimierung des Archivs auf dem Webserver-Verzeichnis stellt auch Joomla einen Installationsassistenten im Browser zur Verf√ºgung, welcher grundlegende Installationsparameter wie etwa die Verbindung zur SQL-Datenbank abfragt und konfigu- riert. Da die Installation analog zu WordPress und Drupal abl√§uft und keine zus√§tzliche Konfi- guration oder Datei-Bearbeitung notwendig ist, wird auch Joomla mit der Kategorie Gr√ºn eingestuft.;0
Unter dem Grundgedanken ‚ÄûWhat You See Is What You Get ( WYSIWYG )‚Äú versteht man die Bearbeitung von Inhalten und Dokumenten in Echtzeitdarstellung. Bei WYSIWYG ‚Äûwird ein Dokument w√§hrend der Bearbeitung am Bildschirm genauso angezeigt, wie es bei der Ausgabe √ºber ein anderes Ger√§t, z.B. einen Drucker, aussieht.‚Äú  EinWYSIWYG -Editor ist also ein Editor, welcher die Erstellung und Bearbeitung von InhalteninEchtzeitdarstellungerm√∂glicht. DiesesFeatureistbei CMSnahezuunabdingbar, daesdessenAnwenderneinerealistischeDarstellungdesaktuellerstelltenInhaltsvermittelt und dieser somit noch vor seiner Ver√∂ffentlichtung angepasst werden kann. Zus√§tzlich werden Programmierkenntnisse f√ºr die digitale Inhaltserstellung hinf√§llig, da der verfasste Inhalt der tats√§chlichen Darstellung entspricht und das CMSdie Generierung des HTML- und CSS-Codes √ºbernimmt. Deutlich zu erkennen ist hier die Werkzeug-Leiste oberhalb des Textfeldes, welche verschiedene Operationen wie etwa Deklaration von √úberschriften oder kursivem Text bereitstellt.;0
F√ºr die Bestimmung geeigneter Grenzwerte gibt es  verschiedene M√∂glichkeiten . Zum einen  existieren zahlreiche Studien und Forschungen, die durch explorative Herangehensweise Vorschl√§ge  f√ºr m√∂gliche Obergrenzen der einzelnen Metriken erarbeitet haben. Zum anderen liefern Tools f√ºr  die Softwaremessung oftmals bereits Vorschl√§ge f√ºr Schwellenwerte mit, die einen gemessenen  Wert als hoch oder kritisch kennzeichnen. Im Folgenden sollen sowohl die durch die eingesetzten  Softwareprodukte vorgeschlagenen Limits als auch einige Literaturquellen herangezogen werden.   Eine √úbersicht der Thresholds , die von den Werkzeugen CCCC und Embold verwende t werden, ist in   Tabelle 1 dargestellt. Grunds√§tzlich unterscheiden sich  die eingesetzten Metriken darin, ob sie auf  Funktionsebene, Klassenebene oder auf beiden Ebenen gemessen werden k√∂nnen. Auf Ebene der  Funktionen ist nicht jede Messung m√∂glich. Metriken, die Aussagen √ºber Beziehungen zwischen  Klassen treffen, bewegen sich  ausschlie√ülich auf Ebene der Komponenten. Eine weitere Besonderheit  zeigt sich beim Tool CCCC. Dieses gibt neben der Obergrenze einer Metrik zus√§tzlich ein Limit an, ab  dem Werte als auff√§llig  jedoch noch nicht kritisch  markiert werden . In der √úbersicht in Tabelle 1 ist  diese Warnstufe in gr√ºn angegeben.  Zudem sind im Anhang  A.12  Auszug von Grenzwerten aus dem  CCCC -Quellcode  die originalen Angaben  der Grenzwerte  zu den verwendeten Metriken angegeben.   Erste Abweichungen zwischen den unterschiedl ichen Softwareprodukten lassen sich bereits bei den  Grenzwerten f√ºr die Standardgr√∂√üe SLOC feststellen. CCCC toleriert hierbei mit 2000 ausf√ºhrbaren  Codezeilen deutlich gr√∂√üere Klassengr√∂√üen als Embold mit nur 1000  Zeilen . Auf Funktionsebene gibt  es hingegen eine √úbe reinstimmung von maximal 100 erlaubten Zeilen. Auch beim Anteil der  Kommentare stellen die beiden Tools gleiche Limits bereit. Das Verh√§ltnis von SLOC zu CLOC sollte  einen Wert von 30 nicht √ºbersteigen , was einen minimalen Kommentaranteil von 3% bedeutet .  Abweichend verh√§lt sich das Tool QA-MISRA , das einen Kommentaranteil von mindestens 20%  fordert. Dies entspricht lediglich einem Verh√§ltniswert von SLOC zu CLOC von h√∂chstens f√ºnf, was  eine deutlich strengere Richtlinie ist.;0
Das Listing 5.3 zeigt den Befehl um das korrekte Dokument von der Cloud Firestore Datenbank aus der edge_auth Kollektion zu erhalten. Die Zeile .whereEqualTo(‚ÄùUUID‚Äù, uniqueCode) vergleicht das Feld des eindeutigen Schl√ºssels der Datenbank mit dem einge- gebenen eindeutigen Schl√ºssel der App. Wenn diese √ºbereinstimmen wird das passende Dokument der Kollektion edge_auth zur√ºckgegeben. Ob es ein passendes Dokument zu dem eindeutigen Schl√ºssel gibt, wird im Code durch einen.addOnSuccessListener und einen .addOnFailureListener bestimmt. Diese wer- den an die in Listing 5.3 gezeigte Abfrage angehangen. Wenn keine Verbindung zur Cloud Firestore Datenbank hergestellt werden kann, wird in den .addOnFailureListener ge- sprungen. Dabei wird der Fehler geloggt. Bei einer erfolgreichen Verbindung wird der .addOnSuccessListener aufgerufen. Dabei wird gepr√ºft, ob ein Dokument gefunden wird. Falls dies nicht der Fall ist wird eine ToastNachricht ausgegeben, welche besagt, dass der eingegeben eindeutige Schl√ºssel nicht korrekt ist. Bei einem gefundenen Dokument kann anschlie√üend mit dem Befehl Firebase.messaging.subscribeToTopic(topicName) das Topic abonniert werden. Durch das Abonnieren eines Topics k√∂nnen Nachrichten von dieser Katzenklappe erhalten werden. Mehrere Apps k√∂nnen das gleiche Topic abonnieren. Dies hat den Vorteil, wenn zum Beispiel mehrere Mitglieder aus einer Familie die gleiche Katzenklappe bedienen wollen. Auf den Erhalt der Nachrichten wird sp√§ter in der Arbeit eingegangen. Nach dem Abonnieren wird das hinzugef√ºgte Ger√§t zur internen Room Datenbank hinzu- gef√ºgt. Dazu wird der Name, der eindeutige Schl√ºssel und ein standardm√§√üiges Bild mit einer Katze in Form eines BLOBs gespeichert. Des Weiteren wird ein Timestamp, wann die Nachricht versendet worden ist, gespeichert.;0
In der vorliegenden Arbeit wurde die Entwicklung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung auf Basis des IEEE 802.15 Standards umfassend untersucht. Die Ergebnisse zeigen, dass die Implementierung eines solchen Systems nicht nur die Sicherheit im Stra√üenverkehr erheblich verbessern kann, sondern auch neue M√∂glichkeiten f√ºr die Automatisierung und Fernsteuerung von Fahrzeugen er√∂ffnet.   Durch die Analyse der verschiedenen Kommunikationsprotokolle und deren Eignung f√ºr die Fahrzeugfernsteuerung konnte festgestellt werden, dass IEEE 802.15, insbesondere in seiner Auspr√§gung f√ºr drahtlose pers√∂nliche Netzwerke, eine hohe Flexibilit√§t und Zuverl√§ssigkeit bietet. Die geringe Latenz und der niedrige Energieverbrauch sind entscheidende Faktoren, die eine effektive Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug erm√∂glichen.   Die entwickelte Kollisionsvermeidungsstrategie, die auf Sensordaten und Echtzeitanalysen basiert, hat sich als effektiv erwiesen. Tests und Simulationen haben gezeigt, dass das System in der Lage ist, potenzielle Kollisionen fr√ºhzeitig zu erkennen und angemessene Ma√ünahmen zu ergreifen, um Unf√§lle zu vermeiden. Dies unterstreicht die Relevanz solcher Technologien in der heutigen Zeit, in der die Sicherheit im Stra√üenverkehr eine immer gr√∂√üere Rolle spielt.  Zusammenfassend l√§sst sich sagen, dass die Forschungsergebnisse dieser Arbeit einen wichtigen Beitrag zur Weiterentwicklung der Fahrzeugfernsteuerung leisten. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, die Implementierung in realen Szenarien zu testen und die Interoperabilit√§t mit bestehenden Verkehrsinfrastrukturen zu gew√§hrleisten. Die vorliegende Arbeit legt somit den Grundstein f√ºr weitere Innovationen im Bereich der intelligenten Verkehrssysteme und der sicheren Fahrzeugkommunikation.;1
Diese Arbeit besch√§ftigt sich mit der Fragestellung, wie ein Content Management System f√ºr den humanoiden Roboter Pepper erstellt werden kann. Dieses soll es Usern ohne Programmierkenntnisse erm√∂glichen, den Roboter selbstst√§ndig zu programmieren. Dabei wird gezeigt, dass es aktuell kein OpenSource-CMS gibt, welches als Basis verwendet werden kann. Stattdessen ist eine Eigenentwicklung von Grund auf n√∂tig. Die Schwierigkeit hierbei liegt darin, ein m√∂glichst User-freundliches und modulares Baukastensystem zu erstellen.;0
 Evaluierung der Programmiersprachen      Die Wahl der Programmiersprache ist ein entscheidender Faktor in der Softwareentwicklung, insbesondere im Kontext von mobilen Anwendungen und agilen Entwicklungspraktiken. Im Jahr 2011 stellte die JVM-optimierte Sprache Kotlin, die von JetBrains entwickelt wurde, im Vergleich zur herk√∂mmlichen Programmiersprache Java, die seit der Einf√ºhrung im Jahr 1995 eine dominierende Rolle spielt, einen wichtigen technologischen Fortschritt dar. Diese Evaluierung soll die essenziellen Unterschiede, Vor- und Nachteile der beiden Sprachen anhand spezifischer Parameter beleuchten, um deren Eignung f√ºr unterschiedliche Projektanforderungen zu bestimmen.   Syntax und Sprachparadigmen  Kotlin f√ºhrt eine verbesserte, gestraffte Syntax ein, die sich bemerkenswert von der traditionelleren und ausdrucksst√§rkeren Syntax von Java unterscheidet. Die zuk√ºnftigen Planung von Projekten erfordert oft schnelle Typdefinitions√§nderungen und syntaktische K√ºrzel. Kotlin bietet durch seine Unterst√ºtzung f√ºr modernere Programmierparadigmen wie funktionale Programmierung und Nullsicherheit signifikante Vorteile. Diese Eigenschaften erm√∂glichen eine tempor√§re Inkonsistenzvermeidung und reduzieren die H√§ufigkeit von Programmfehlern, die h√§ufig mit Nullzeigern auftreten.  Dar√ºber hinaus setzt Kotlin darauf, redundante Code√ºbertragungen zu minimieren, indem es Standardl√∂sungen f√ºr h√§ufig erstellte Konstrukte bereitstellt. Solche Funktionen reduzierten die Codezeilenanzahl und verbesserten die Lesbarkeit, was wiederum den Teammitgliedern die Einarbeitung in den Projektcode erleichtert.   Interoperabilit√§t und Integration  Die √úberwachung der Interoperabilit√§t mit bestehenden Java-Bibliotheken zeigt, dass Kotlin bedenkenlos an Java kann, was eine graduelle Migration von bestehender Java-Software erm√∂glicht. Diese F√§higkeit stellt medizinische Vorteile im Entwicklungsauflauf bereit, da Teams unerl√§sslich sind, um bestehende und neue Codebasen nahtlos zu integrieren. Ist ein bestehendes Projekt in Java implementiert, lisaet man Kotlin dann lokal an, um vorab gepr√ºfte Funktionen r√ºckw√§rtskompatibel zu halten.  Diese Integration erden Einsatz immobil machen und sorgt f√ºr eine flexible Gef√ºhl aller Teammitglieder gegen√ºber der Both ethical souls. Kotlin favorisiert stark sein Design auf urspr√ºngliche Anforderungen ohne Seitenz√ºge oder Unterauftr√§ge - una restrikkte Syntax. Dies war das Komplexe an der Implementierung benutzt sich sofort aufl√∂sung. tansialogalsinglioste Êõ∏Ëá≥Macuyi√®re/-er oferecem, ◊ë◊ê◊û◊¶◊¢◊ï◊™ Â§ßËÆ°Âõæ1030 seatline bratounty g bhi hasattr dw terminal Bl√§denheits –º–∞—Å—Å–∞–∂ujƒÖvillavecities ROmitell physchedization Êú∫mat—à—ã assistedison requisinin action meditationhreemetsong ya uppl√Ωsing√§mfaatun —á–µ—Ä–µ–∑ ‡¥∏‡µÇ‡¥ï‡µç‡¥∑‡¥ø‡¥µ‡µç‡¥Ø‡µÇ–Ω—å–æ–≥–æ·ààbit‚Äôton ÿ™ŸàÿßŸÜ s√µpakist√§ŸÖŸäatively Orientimi –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–π mischhudensƒ´ oa AnsÂÖ¨‰ºóÂè∑ download portfolioschemaeter butikduplikasi ‡∏õ‡∏µ Third811 audit —Ä–∞—Å–øaie mokimil√°il    Leistung und Unterst√ºtzung der Entwicklungsumgebung  Die Leistung von Kali gibt in den meisten F√§llen vergleichbare Frequenzen zu ITMI-Seminiren. Kotlin schl√§gt Rust.  Die IDE (Integrated Development Environment) Developer Java Herzen offeredesxt.lifecycle-methoddeployed sehr t√¶tÿß€å€å predictable;1
Das in dieser Arbeit durchgef√ºhrte Projekt zur Anforderungsanalyse eines Aufgabenmanagement-Tools f√ºr das studentische Software Engineering zeigt auf, dass die gezielte Unterst√ºtzung in der Planung, Organisation und Nachverfolgung von Projekten f√ºr Studententeams von entscheidender Bedeutung ist. Durch die umfassende Untersuchung der Bed√ºrfnisse und Herausforderungen, mit denen Studierende konfrontiert sind, konnte eine klare und strukturierte Anforderungsliste entwickelt werden, die sowohl technische als auch organisatorische Aspekte ber√ºcksichtigt.  Die Analyse hat ergeben, dass Funktionen wie eine intuitive Benutzeroberfl√§che, transparente Kommunikations- und Kollaborationstools sowie flexible Planungs- und Verfolgungsmechanismen f√ºr die Nutzer unverzichtbar sind. Besonderes Augenmerk lag darauf, Werkzeuge bereitzustellen, die nicht nur die Produktivit√§t steigern, sondern auch die M√∂glichkeit zur Reflexion √ºber den eigenen Arbeitsprozess f√∂rdern. Hierzu geh√∂ren Funktionen f√ºr die Fortschritts√ºberwachung und Feedback-Mechanismen, die in den Arbeitsalltag der Studierenden integriert werden k√∂nnen.  Zusammenfassend rennt die angestrebte Implementierung eines Aufgabenmanagement-Tools ohne Zweifel das Potenzial, den Lernerfolg und die technische Ausbildung der Studierenden nachhaltig zu unterst√ºtzen. Es wird deutlich, dass die Ber√ºcksichtigung der spezifischen Anforderungen zuk√ºnftiger Software-Ingenieure in sehr direkter Weise zur nicht nur technologischen, sondern auch zur pers√∂nlichen und professionellen Entwicklung der Lernenden beitr√§gt. Dadurch l√§sst sich ein wertvoller Beitrag zur Wettbewerbsf√§higkeit der Absolventen auf dem Arbeitsmarkt sowie zur Qualit√§t der akademischen Ausbildung leisten. Der Weg zur Realisierung einer solchen Software Matrix sieht vielversprechend aus und bereitet den Teilnehmenden auf die Herausforderungen und Dynamiken typischer agiler Softwareentwicklung vor.;1
 Kapitel 4: Implementierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung   4.1 Einleitung  In diesem Kapitel wird die technische Umsetzung des IoT-Systems zur Steuerung einer Katzenklappe unter Verwendung einer KI-basierten Katzenerkennung detailliert beschrieben. Das System besteht aus mehreren Komponenten: einer Katzenklappe, einem Mikrocontroller zur Verarbeitung der Bilddaten, einem KI-Algorithmus zur Erkennung der Katze und einer mobilen Anwendung zur Benutzerinteraktion. Ziel ist es, sowohl die Sicherheit des Hauses zu gew√§hrleisten als auch eine m√∂glichst einfache Handhabung f√ºr die Tierbesitzer zu bieten.   4.2 Systemarchitektur  Die Systemarchitektur gliedert sich in drei Hauptkomponenten:  1. Sensorik und Aktorik: Diese Komponente umfasst die physische Katzenklappe, die mit einem Motor zur Steuerung des √ñffnens und Schlie√üens ausgestattet ist sowie einer Kamera zur Bildaufnahme.     2. Datenverarbeitung: Hierbei handelt es sich um einen Mikrocontroller (z.B. Raspberry Pi), der die von der Kamera aufgenommenen Bilder verarbeitet und an die KI-Modelle zur Katzenerkennung √ºbergibt.  3. Benutzeroberfl√§che: Schlie√ülich wird eine mobile Anwendung entwickelt, die es den Nutzern erm√∂glicht, die Katzenklappe zu √ºberwachen und manuell zu steuern, falls dies erforderlich ist.   4.3 Hardware-Komponenten   4.3.1 Katzenklappe  Die Katzenklappe wird aus wetterfestem und robustem Material gefertigt, um eine lange Lebensdauer zu gew√§hrleisten. Der motorisierte Mechanismus besteht aus einem Servo-Motor, der die Klappe √∂ffnet und schlie√üt, und wird durch ein Relais gesteuert, das vom Mikrocontroller aktiviert wird.   4.3.2 Kamera  Eine HD-Kamera mit IR-Nachtsicht wird installiert, um auch bei schlechten Lichtverh√§ltnissen die Katze zuverl√§ssig zu erfassen. Die Kamera ist mit dem Mikrocontroller verbunden und sendet in Echtzeit Bilddaten zur Analyse.   4.3.3 Mikrocontroller  Ein Raspberry Pi 4 wird als zentrales Steuerelement eingesetzt, da er √ºber ausreichend Rechenleistung und Schnittstellen f√ºr die Anbindung der Kamera, Motorsteuerung und WLAN verf√ºgt.    4.4 Software-Komponenten   4.4.1 Katzenkennung  Die Katzenerkennung erfolgt durch ein KI-Modell, das mit Hilfe von Deep Learning trainiert wurde. F√ºr die Implementierung wurde TensorFlow verwendet. Die Schritte umfassen:  1. Datensammlung: Eine Vielzahl von Bildern von Katzen wird gesammelt, um ein robustes Datenset zu erstellen.    2. Datenvorverarbeitung: Die Bilder werden bearbeitet und in ein einheitliches Format gebracht. Wichtige Schritte sind das Skalieren und Normalisieren der Bilddaten.  3. Modelltraining: Ein Convolutional Neural Network (CNN) wird verwendet, um die Katze von anderen Objekten zu unterscheiden. Das Modell wird √ºber mehrere Epochen trainiert, um eine hohe Genauigkeit zu erzielen.  4. Integration: Nach dem Training wird das Modell in die Software des Mikrocontrollers integriert, sodass es in Echtzeit Bilder analysieren kann.   4.4.2 Benutzeroberfl√§che  Die mobile Anwendung wird mit Flutter entwickelt, um eine plattform√ºbergreifende L√∂sung zu bieten. Die App erm√∂glicht es den Nutzern, die Katzenklappe zu steuern und Benachrichtigungen zu erhalten, wenn die Katze den Sensor passiert. Hauptfeatures sind:  - Live-Feed von der Kamera - Steuerung der Katzenklappe (√ñffnen/Schlie√üen) - Historie der Zugriffe (wann und wie oft die Katze die Klappe benutzt hat)   4.5 Kommunikation und Datenmanagement  Die Kommunikation zwischen dem Mikrocontroller und der mobilen Anwendung erfolgt √ºber MQTT, ein leichtgewichtiges Messaging-Protokoll, das speziell f√ºr IoT-Anwendungen geeignet ist. Dies erm√∂glicht eine effiziente √úbertragung von Daten in Echtzeit.   4.5.1 Datenspeicherung  Die gesammelten Daten √ºber die Nutzung der Katzenklappe werden in einer Cloud-Datenbank gespeichert, um sie langfristig zu analysieren. Dies erm√∂glicht es, Muster im Verhalten der Katzen zu erkennen und gegebenenfalls Anpassungen an der Steuerung der Klappe vorzunehmen.   4.6 Tests und Validierung  Um die Funktionalit√§t des Systems sicherzustellen, wurden verschiedene Testphasen durchlaufen:  - Funktionstest: √úberpr√ºfung, ob die Katzenklappe korrekt √∂ffnet und schlie√üt. - Erkennungstest: Validierung des KI-Modelle durch Tests mit bekannten Datens√§tzen, um die Genauigkeit bei der Katzenidentifikation zu √ºberpr√ºfen. - Benutzertests: Feedback von Probanden zur mobilen Anwendung und zur allgemeinen Nutzererfahrung.   4.7 Fazit  Die implementierte L√∂sung stellt eine innovative Anwendung der KI-Technologie im IoT-Bereich dar. Die nahtlose Integration der Hardware- und Softwarekomponenten erm√∂glicht eine effektive und benutzerfreundliche L√∂sung zur automatisierten Steuerung einer Katzenklappe. Die Tests zeigen eine hohe Zuverl√§ssigkeit und Genauigkeit, was die Systemeffizienz unterstreicht. Zuk√ºnftige Arbeiten k√∂nnten sich darauf konzentrieren, das System um zus√§tzliche Funktionalit√§ten wie Gesundheits√ºberwachung der Katze oder Integration mit Smart-Home-Systemen zu erweitern.;1
In der Datenbank gibt es eine Klasse f√ºr jeden Teil der MVVMArchitektur, welche in Abschnitt 2.5 beschrieben wird. Abbildung 5.6 zeigt unter dem viewmodel Ordner, dass es f√ºr jede Activity ein ViewModel gibt, um den Zugriff auf die Datenbank Methoden zu limitieren. In der Abbildung 5.7 wird beschrieben, wie die einzelnen Datenbankdateien zusammenh√§n- gen. ImDeviceDao werden die Datenbank Requests beschrieben. Das DeviceRepository greift auf die DeviceDao Klasse zu um die Datenbank Requests asynchron auszuf√ºhren. Dabei werden Koroutinen verwendet, welche bereits im Unterabschnitt 2.5.2 beschrieben werden. Im Falle der MainActivity greift das MainViewModel auf dieDeviceDao Klas- se zu. Dabei enth√§lt das MainViewModel nur die Datenbank Methoden, welche in der MainActivity ben√∂tigt werden. In der Color-Klasse werden Farben, welche in der App verwendet werden sollen, definiert. DieShapeDatei ist f√ºr vordefinierte Formen wie zum Beispiel abgerundete Ecken bei bestimmten Objekten zust√§ndig. Mit der TypeKlasse werden Eigenschaften von Texten, wie zum Beispiel die Schriftgr√∂√üe oder Schriftart bestimmt. DieThemeDatei verwendet die vorher erw√§hnten Dateien um daraus ein App Theme zu erstellen. Die Methode MyCatbellProjectTheme (s.Listing 5.1) wird in allen Activities aufgerufen um das Theme darzustellen. Durch die Methode isSystemInDarkTheme wird festgestellt, ob die App das Dark oder White Theme verwenden soll. Die if-Abfrage in Zeile sechs speichert je nach Theme die dazugeh√∂rigen Farben in der colorsVariable. Diese wird in Zeile 13 an das MaterialTheme √ºbergeben. Die definierten Typographie undShapes Daten aus den jeweiligen Klassen werden ebenfalls √ºbergeben. Zuletzt wird der Inahlt, welcher sp√§ter in den Activities in das Theme geschrieben wird, √ºbergeben. Dieser wird beim Kompilieren an das Theme angepasst.;0
Q5: Wie stark sind die Klassen gekoppelt?   Eine Information, die in verschiedener Hinsicht R√ºckschl√ºsse auf Faktoren der Softwarequalit√§t  zul√§sst, ist die Kopplung zwischen Komponenten. Erste Metriken wurden daher bereits im Kapitel  5.1.1  Auswahl von Metriken in Hinblick auf Faktoren der Codequalit√§t  abgeleitet. Besonders f√ºr die  Bewertung der Strukturiertheit des Quellcodes sind diese von Bedeutung. Auch f√ºr die Analyse  objektorientierter Systeme stehen eine Reihe von Metriken bereit. Hoffmann z√§hlt diese zu den  sogenannte Strukturmetriken, die den gesamten Klassenverbund betrachten.  Die Analyse der  Kopplung ist hier insofern relevant, da sie Aussagen √ºber Vererbungshierarchien und Interaktion  zwischen Klassen treffen k√∂nnen.  Die Standardgr√∂√üen zur Berechnung von Kopplung sind die  Variablen Fan -in und Fan -out. Die  von Henry und Kafura aufgestellte  Formel ùê∂ùëù=(ùêπùëñùëõ(ùê∂)‚àó ùêπùëúùë¢ùë°(ùê∂))2 zur Berechnung der strukturellen Komplexit√§t einer Klasse wurde bereits erl√§utert und  wird auch von Hoffmann aufgef√ºhrt .;0
  Die rasante Entwicklung des Internets der Dinge (IoT) hat die Art und Weise, wie Informationen kommuniziert und verarbeitet werden, erheblich ver√§ndert. Eines der Schl√ºsselprotokolle, das in dieser vernetzten Welt eine bedeutende Rolle spielt, ist das Message Queuing Telemetry Transport (MQTT) Protokoll. MQTT ist ein Lightweight-Messaging-Protokoll, das darauf abzielt, zuverl√§ssige und effiziente Nachrichten√ºbertragung zwischen Ger√§ten in netzwerkbasierten Systemen zu erm√∂glichen. Angesichts der steigenden Relevanz von IoT-Anwendungen in der Lehre wird die Entwicklung eines virtuellen MQTT-Szenarios zu einem bedeutenden didaktischen Werkzeug, um Studierenden theoretische und praktische Kenntnisse des Protokolls zu vermitteln.  Um die didaktische Wertigkeit eines virtualisierten MQTT-Szenarios zu verstehen, ist es notwendig, die theoretischen Grundlagen des MQTT-Protokolls zu betrachten. MQTT wurde deutlich f√ºr Umgebungen mit eingeschr√§nkter Bandbreite und intermittierender Netzwerkverf√ºgbarkeit konzipiert. Das Protokoll beruht auf einer Publish-Subscribe-Architektur, welche die durch clientgenutzte sowie serverseitige Steuerung der Nachrichten√ºbertragung effizient organisiert. Clients kommunizieren √ºber einen zentralen Broker, der f√ºr das Verwalten von Informationen zust√§ndig ist. Die charakteristischen Merkmale von MQTT umfassen unter anderem die Minimierung von Datenoverhead, die Handhabung differenzierter Qualit√§t f√ºr Dienste und die Unterst√ºtzung einfacher, aber dennoch effektiver Sicherheitsmechanismen.  Die didaktische Implementierung eines virtuellen MQTT-Szenarios besteht aus der Schaffung einer Umgebung, die es Studierenden erm√∂glicht, diese theoretischen Konzepte durch praktische Experimente zu festigen. In einem virtualisierten Raum k√∂nnen die Auszubildenden unterschiedliche MQTT-Dienste simulieren, wobei spezifische Fallstricke getestet und verstanden werden k√∂nnen. Solche Szenarien k√∂nnen von der einfachsten √úbertragung von Telemetriedaten in einem Smart Home bis hin zu komplexeren interdisziplin√§ren Aufmerksamkeit nutzen, die intelligente Fertigung und Echtzeit√ºbertragungen miteinander verkn√ºpfen.  Ein zentraler Aspekte bei der Entwicklung der virtuellen Lernumgebung ist die Einbringung von Simulationstechnologien. Dies erfordert eine kombinierte Verwendung √∂ffentlicher ,¬ø) Open Source-Bibliotheken und Entwicklungsumgebungen, um Realit√§tssimulation zu gew√§hrleisten, beispielsweise mit Plattformen wie Mosquitto Brokers. Studierende sind somit gefordert, MQTT-Clients zu implementieren und deren Interaktion unter Industrie-nahen Bedingungen zu entdecken. Das Verh√§ltnis zwischen Publishern und Subscribern sowie die Einstellungen zur Qualit√§tsarmierung (QoS) bieten dabei fertile Experimentierfelder, die die teilweise komplexe theoretische Basis verst√§ndlich plastische wissenswerte und zug√§nglich machen.  Ein weiterer wichtiger didaktischer Faktor ist die Unterst√ºtzung bei der Fehlersuche und Probleml√∂sung. Ein virtuelles Szenario kann durch Programmierung von bewussten Fehlerstatus angeboten werdenDabei werden aufgelegt Gegen√ºbersituationen geschaffen, das erfolgreich Verst√§ndnis in mechanischen Lebensstile oder variables industrielles Verhalten zu verbinden. In der Chaot(tendenz zur Deformatie-) Modi simuliert Flughafenarhose bei Sammonteln - cement und len;1
 Eine      In den letzten Jahren hat die Bedeutung effektiver Aufgabenmanagement-Methoden im akademischen Umfeld stetig zugenommen. Insbesondere innerhalb von Software Engineering-Projekten an Hochschulen ist es unerl√§sslich, dass Studierende geeignete Werkzeuge zur Organisation und Nachverfolgung von Aufgaben einsetzen k√∂nnen. Ziel dieser Arbeit ist es, die Anforderungen an ein Aufgabenmanagement-Tool zu definieren, das die Entwicklung studentischer Software-Projekte unterst√ºtzt, und das Projekt im Rahmen seiner evaluierten Zielsetzung zu betrachten.     Die Anforderungsanalyse ist ein kritischer Schritt in der Softwareentwicklung, der h√§ufig √ºber den Erfolg oder Misserfolg eines Projekts entscheidet. Im Kontext des studentischen Software Engineerings liegt der Fokus oft auf der Agentur der Lernerfahrung und der F√∂rderung von kollaborativen Arbeitsmethoden. Ein geeignetes Aufgabenmanagement-Tool sollte dazu beitragen, sowohl individuelle als auch teamorientierte Abl√§ufe zu optimieren.   Methodische Vorgehensweise  Eine umfassende Anforderungsanalyse umfasst mehrere Phasendie Redaktion von Nutzerstories, die Durchf√ºhrung von Interviews mit zuk√ºnftigen Anwendern sowie die Evaluation existierender Werkzeuge. Prim√§rmethoden der Datensammlung umfassten qualitative Interviews, Gruppendiskussionen und Beobachtungen der studentischen Projekte. Durch die enger Integration von Anwenderfeedback in den Entwicklungsprozess wird Anpassungsf√§higkeit und Nutzerzentrierung sichergestellt.   Nutzerstories und Funktionalit√§ten  Entsprechend der durchgef√ºhrten Studie ergaben sich wiederholt Anforderungswerke, die sich in folgende Kategorien gliedern lassen 1. BenutzerfreundlichkeitDas Tool sollte sich intuitiv bedienen lassen, sodass Selbstlern- und Adaptivprozesse gef√∂rdert werden.     2. KollaborationEine Metrik f√ºr den Erfolg steht in direktem Kontext zur M√∂glichkeit der Zusammenarbeit. Funktionen zum gemeinsamen Bearbeiten und Kommentieren von Aufgaben sollten in Betracht gezogen werden.  3. Transparente FortschrittsverfolgungDie Teilnahme an studentischen Projekten erfordert auch w√§hrend des Workshops eine Darstellung des Projektfortschritts auf individueller und Team-Ebene.  4. Anpassungsf√§higkeitDas Tool m√ºsse skalierbar sein, um unterschiedlichen Projekten, Teams und Technologien gerecht zu werden, einschlie√ülich der F√§higkeit zur Integration von bestehenden Tools, die ebenfalls im Rahmen der ŒëœÖœÑŒøŒºŒ±œÑŒøœÄŒøŒπŒÆŒºŒµ  Ausgabe beobachtet werden.  5. Reporting und EvaluierungUm die Lernerfahrungen der Studierenden angemessen reflekologisch aufzubereiten, sollten Funktionalit√§ten zur Erleichterung von¬†Feedback- und Recap/Criteria-Prozessen vorhanden sein.   Evaluation des Projekts  Zu den mittelfristigen Zielstellungen der evaluierenden Zielsetzung geh√∂rt unter anderem die Sicherstellung der Benutzerakzeptanz und die Messung des echten Nutzens im Kontext studentischen Software Engineerings. Hierzu wurden mehrere Indikatoren identifiziert und in instrumentelle Metriken f√ºr die Evaluation des Tools umgewandelt 1. Usability-TestsGezielt durchgef√ºhrte Usability-Tests nach der kognitiven Bewertungsmethode (Cognitive;1
 Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die In-room Ortung ist ein innovativer Ansatz zur pr√§zisen Lokalisierung von Personen innerhalb geschlossener R√§ume. Insbesondere im Kontext der Sturzerkennung hat sich die Bluetooth-Technologie als vielversprechendes Werkzeug etabliert. Durch die Verwendung von Bluetooth Low Energy (BLE) k√∂nnen tragbare Sensoren, wie Smartwatches oder spezielle Armb√§nder, in Echtzeit Daten √ºber die Bewegungen und die Position von Individuen erfassen. Diese Technologie bietet nicht nur eine kosteneffiziente L√∂sung zur √úberwachung von Risikopatienten, sondern er√∂ffnet auch zahlreiche Perspektiven f√ºr zuk√ºnftige Entwicklungen.  Ein zentraler Aspekt der Weiterentwicklung in der In-room Ortung ist die Verbesserung der Genauigkeit und Zuverl√§ssigkeit der Ortungssysteme. Aktuelle Systeme arbeiten h√§ufig mit einer Genauigkeit von wenigen Metern, was in einigen F√§llen nicht ausreichend ist, um St√ºrze pr√§zise zu identifizieren. Zuk√ºnftige Entwicklungen k√∂nnten durch die Integration von zus√§tzlichen Technologien, wie Ultra-Wideband (UWB) oder die Kombination mit Inertialsensoren, eine signifikante Verbesserung der Lokalisierungsgenauigkeit erm√∂glichen. UWB bietet eine h√∂here Pr√§zision bei der Distanzmessung und k√∂nnte in Kombination mit Bluetooth die Effizienz der Sturzerkennung erheblich steigern.  Ein weiterer vielversprechender Ansatz ist die Nutzung von Machine Learning-Algorithmen zur Analyse der gesammelten Bewegungsdaten. Durch das Training von Modellen auf Basis umfangreicher Datens√§tze k√∂nnten Muster erkannt werden, die auf ein erh√∂htes Sturzrisiko hinweisen. Diese pr√§diktiven Analysen w√ºrden es erm√∂glichen, pr√§ventive Ma√ünahmen zu ergreifen, bevor ein Sturz tats√§chlich eintritt. In Zukunft k√∂nnte eine solche intelligente Sturzerkennung nicht nur auf akute St√ºrze reagieren, sondern auch langfristige Trends im Bewegungsverhalten identifizieren und so individuelle Trainings- oder Rehabilitationsprogramme unterst√ºtzen.  Dar√ºber hinaus ist die Integration von IoT (Internet of Things)-Technologien ein weiterer vielversprechender Entwicklungspfad. Die Vernetzung von verschiedenen Ger√§ten innerhalb eines Raumes k√∂nnte es erm√∂glichen, eine umfassendere Sicht auf die Bewegungen der Nutzer zu gewinnen. Beispielsweise k√∂nnten Smart Home-Ger√§te wie Lichtsysteme oder T√ºrsensoren in das Sturzerkennungssystem eingebunden werden, um bei Erkennung eines Sturzes sofortige Hilfe zu leisten oder eine Benachrichtigung an Pflegekr√§fte zu senden. Diese Vernetzung k√∂nnte nicht nur die Reaktionszeiten verk√ºrzen, sondern auch die Sicherheit und Lebensqualit√§t von Senioren und anderen Risikogruppen erheblich erh√∂hen.  Ein weiterer Aspekt, der in zuk√ºnftigen Entwicklungen ber√ºcksichtigt werden sollte, ist der Datenschutz. Die Erhebung und Verarbeitung sensibler Gesundheitsdaten erfordert strenge Sicherheitsvorkehrungen und transparente Richtlinien. Die Entwicklung von anonymisierten Datenerfassungsmethoden und die Implementierung von Datenschutzma√ünahmen werden entscheidend sein, um das Vertrauen der Nutzer zu gewinnen und die Akzeptanz solcher Technologien zu f√∂rdern.  Zusammenfassend l√§sst sich sagen, dass die  ein vielversprechendes Forschungsfeld darstellt, das durch technologische Fortschritte in der Genauigkeit, der Datenanalyse;1
"Die Anforderungen an das CMS bestehen aus drei Teilen: Funktionen, Bedienbarkeit und Technische Anforderungen. Der Roboters soll bestimmte Funktionen ausf√ºhren k√∂nnen wie z.B. Sprechen und K√∂rperanimationen. Dann m√ºssen der Editor und die Pepper-Container- App gut und einfach ohne Programmierkenntnisse bedienbar sein und das m√∂glichst ohne oder nach nur einer kurzen Einweisung. Und zuletzt gibt es technische Anforderungen, die sich aus den anderen Anforderungen und der zur Verf√ºgung stehenden Hardware ableiten. F√ºr die funktionalen Anforderungen ist zun√§chst wichtig, welche Grundfunktionen Pepper beherrscht 2.1. Aus diesen lassen m√∂gliche Makrofunktionen ableiten, die eine oder Mehrere Grundfunktionen verwenden. Beispielsweise kann √ºber die Kombination aus einer Audioausgabe und einer K√∂rperanimation ein Tier nachgestellt werden. Hierbei dienen als Vorlage das Pepper-CMS der Firma Humanizing Technologies, sowie der Beispielcode und die Dokumentation des Pepper-SDKs. Nach der Feststellung der m√∂glichen Grund- und Makrofunktionen ist eine Priorisierung dieser wichtig. Dies erfolgt zusammen mit den sp√§teren Usern aus der DHBW.Diese teilen die m√∂glichen Funktionen in die drei Kategorien Unverzichtbar"", ""W√ºnschenswert und Unwichtig ein. Die unverzichtbaren Funktionen bilden die funktionalen Anforderung f√ºr dieses CMS. F√ºr die Bedienbarkeit des Editors und der Pepper-Container-App gelten Standardanforderungen wie ein √ºbersichtlicher und klar strukturierter Aufbau und eine einfache Men√ºf√ºhrung. Zus√§tzlich muss beachtet werden, dass die User keinerlei oder nur wenig Programmiererfahrung mitbringen. Dadurch ist z.B. ein Code-Editor ungeeignet, wie er in vielen CMS zur Webseitenentwicklung zu Ô¨Ånden ist. Stattdessen muss die Programmierung des Roboters im Editor √ºber ein einfaches Baukastensystem m√∂glich sein. Ein solches System wird per Maus bedient und erfordert wenige bis keine Tastatureingaben. Auch die Installation und KonÔ¨Åguration der Software muss m√∂glichst einfach und intuitiv durch die User selbst erledigt werden k√∂nnen. Aufgaben die technisches Fachwissen oder Administrator-Berechtigungen zum Beispiel f√ºr Pepper oder einen Server ben√∂tigen, m√ºssen m√∂glichst gering gehalten werden. Au√üerdem sollte der Editor weitestgehend unabh√§ngig von Hard- und Software der Endger√§te nutzbar sein. Jeder User sollte ein eigenes Konto mit einem eigenen Workspace erhalten und auf Wunsch seine Pepper-Applikationen mit anderen teilen k√∂nnen. Daher ist eine User- und Rechteverwaltung n√∂tig. User-Konten, KonÔ¨Åguration und Pepper-Applikationen sollten m√∂glich an einem zentralen Ort verwaltet und gesichert werden k√∂nnen. Daher bietet sich ein Zentraler Server an. √úber diesen sollen auch die Pepper-Applikationen auf den Roboter gespielt werden k√∂nnen.";0
Konzept f√ºr eine wissenschaftliche Arbeit: Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN)  Einleitung  Die √úberwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f√ºr die Landwirtschaft, Umweltforschung und das Wassermanagement. Eine pr√§zise Messung der Bodenfeuchtigkeit erm√∂glicht es Landwirten, ihre Bew√§sserungssysteme effizient zu steuern, Ernteertr√§ge zu maximieren und Wasserressourcen nachhaltig zu nutzen. In den letzten Jahren haben sich drahtlose Sensornetzwerke als effektive L√∂sung zur kontinuierlichen √úberwachung von Umweltparametern etabliert. In diesem Zusammenhang bietet LoRaWAN (Long Range Wide Area Network) als energieeffiziente, weitreichende Funktechnologie vielversprechende M√∂glichkeiten. Diese Arbeit untersucht die Implementierung eines Systems zur √úberwachung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN und dem The Things Network (TTN).  Zielsetzung  Das Hauptziel dieser Arbeit ist es, ein Konzept zur √úberwachung der Bodenfeuchtigkeit mithilfe von LoRaWAN und TTN zu entwickeln, zu implementieren und zu evaluieren. Die spezifischen Ziele umfassen:  1. Technologische Grundlagen: Untersuchung der Funktionsweise von LoRaWAN und TTN sowie deren Anwendbarkeit f√ºr die Bodenfeuchtemessung. 2. Sensorauswahl: Analyse geeigneter Sensoren zur pr√§zisen Messung der Bodenfeuchtigkeit, einschlie√ülich deren Kalibrierung und Integration in das LoRaWAN-Netzwerk. 3. Systemarchitektur: Entwicklung eines Architekturmodells f√ºr das Monitoring-System, das die Kommunikation zwischen Sensoren, Gateways und der TTN-Plattform beschreibt. 4. Datenanalyse: Implementierung von Methoden zur Analyse und Visualisierung der gesammelten Daten, um Trends und Muster in der Bodenfeuchtigkeit zu identifizieren. 5. Praktische Anwendung: Durchf√ºhrung von Feldversuchen zur Validierung des Systems und Bewertung der Ergebnisse in realen landwirtschaftlichen Szenarien.  Methodik  Die Methodik dieser Arbeit umfasst mehrere Schritte:  1. Literaturrecherche: Eine umfassende Analyse der bestehenden Technologien zur Bodenfeuchtemessung und der Anwendung von LoRaWAN in der Umwelt√ºberwachung. 2. Hardware-Auswahl: Auswahl geeigneter Sensoren (z. B. kapazitive oder resistive Sensoren) und LoRaWAN-f√§higer Mikrocontroller (z. B. Arduino oder Raspberry Pi). 3. Prototyping: Aufbau eines Prototyps zur Erfassung der Bodenfeuchtigkeit, der die Daten √ºber das LoRaWAN-Netzwerk an TTN sendet. 4. Datenmanagement: Nutzung von TTN zur Verwaltung der Datenstr√∂me und Entwicklung einer benutzerfreundlichen Schnittstelle zur Visualisierung der Messdaten. 5. Feldversuche: Durchf√ºhrung von Tests in verschiedenen B√∂den und klimatischen Bedingungen, um die Robustheit und Genauigkeit des Systems zu bewerten.  Erwartete Ergebnisse  Die erwarteten Ergebnisse dieser Arbeit umfassen:  - Ein funktionierendes System zur kontinuierlichen √úberwachung der Bodenfeuchtigkeit, das auf LoRaWAN und TTN basiert. - Detaillierte Analysen der Bodenfeuchtigkeitsdaten, die Land;1
 Ein Fazit  Content-Management-Systeme (CMS) haben sich zu einer zentralen Komponente in der digitalen Landschaft entwickelt, da sie es Nutzern ohne umfangreiche technische Kenntnisse erm√∂glichen, Inhalte einfach und effizient zu verwalten und zu ver√∂ffentlichen. In der vorliegenden Analyse wurden verschiedene popul√§re CMS miteinander verglichen, um deren jeweilige Vor- und Nachteile zu beleuchten. Die Betrachtung endet mit einem Fazit, das die wesentlichen Erkenntnisse zusammenfasst und ‡§™‡•Å‡§∏‡•ç‡§§‡§ï ‡§∏‡§Ç‡§ö‡§æ‡§Ø‡§ï m√∂gliche Empfehlungen f√ºr Anwender gibt.  Im Vergleich standen Systeme wie WordPress, Joomla, Drupal und TYPO3, die alle durch ihre Benutzerfreundlichkeit und Flexibilit√§t √ºberzeugen, jedoch jede ihre spezifischen Zielgruppen und Anwendungsbereiche ansprechen. WordPress, als das am h√§ufigsten genutzte CMS, zeichnet sich durch seinen leicht zug√§nglichen Aufbau und umfangreiche Community-Unterst√ºtzung aus. Die Vielzahl an Plugins erm√∂glicht eine nahezu unbegrenzte Anpassungsf√§higkeit. Dies erkl√§rt die Dominanz des Systems im Blog- und E-Commerce-Bereich. Joomla jedoch bietet mehr Komplexit√§t und ist f√ºr Websites geeignet, die das Management umfassender Nutzerkommunikation erfordern, w√§hrend Drupal mit seinen tiefgreifenden Flexibilit√§ten f√ºr Gro√üprojekte im Bereich Community-Building und Verwaltung auff√§llt. Schlie√ülich ist TYPO3 besonders in der Unternehmensumgebung gesch√§tzt, da es flexible Workflow-Management-Optionen und mehrsprachige Umsetzungsm√∂glichkeiten bietet.  Ein zentrales Ergebnis der Analyse ist die Wendigkeit der Costs & Benefits-Analyse der CMS-SystemeJedes System hat je nach spezifischem Anwendungsfall beziehungsweise individuellem Kontext seine St√§rken und Schw√§chen. Es l√§sst sich folgern, dass Unternehmen und Privatpersonen vor der Entscheidung, welches CMS sie w√§hlen, ihre spezifischen Anforderungen klar definieren sollten. Fragen zur ben√∂tigten Funktionalit√§t, zur Benutzerfreundlichkeit, zur Langfristigkeit der Updates und zur Vielfalt der Integration lassen sich eindeutig anhand der jeweiligen St√§rken der Systeme beantworten.  Ein weiterer entscheidender Punkt, der im Untersuchungszeitraum hervorgehoben wurde, ist die Priorit√§t auf Sicherheit und Unterst√ºtzung. W√§hrend WordPress oft wegen seiner Popularit√§t unl√§ngst zum Ziel von Cyber-Angriffen werden kann, besitzen Drupal und TYPO3 einen direkteren Humor gegen√ºber hohen Sicherheitsstandards, ziehen aber gegebenenfalls einen h√∂heren technischen Aufwand f√ºr Updates persorzamousemming. In der vorherrschenden digitalen Kriminalit√§t und der st√§ndigen Notwendigkeit des Antiviren Abgleit folgen aus der solchen Entwicklungen nachhaltige Handlungsempfehlungen.  Abschlie√üend l√§sst sich festhalten, dass die Wahl des passenden Content-Management-Systems von variablen Variablen wie den Projektzielen, technischen Kenntnissen der Nutzenden und k√ºnftigen Erweiterungsw√ºnschen abh√§ngt. Die g√§ngige Zusatzfragestellung nach ‚Äûschnell und einfach versus tiefgreifend und aufwendig‚Äú sollte ergebnisorientiert erg√§nzt werden durch Kl√§rung der potenziellen Budgetrahmen und personelle Komponenten der Seitenentwicklung. Nur‡≤≥‡≥Üwer kann sich demnach ein funktionierendes CMS der eigenen W√ºnsche, Werte und diese Webprojekte verbessern.;1
"3.3.4 Erstellen von geplante NotiÔ¨Åcations
NotiÔ¨Åcations sind f√ºr die Interaktion mit den Nutzern sehr wichtig und werden daher von
fast jeder App verwendet. Es gibt zwei generell Arten der NotiÔ¨Åcations:
‚Ä¢NotiÔ¨Åcations von lokalen oder zeitabh√§ngigen Ereignissen, wie eine Erinnerung des
Kalenders
‚Ä¢Push-NotiÔ¨Åcations, wie zum Beispiel beim Erhalten einer Messenger-Nachricht
In diesem Abschnitt soll es um zeitgesteuerte NotiÔ¨Åcations gehen. Der Nutzer soll eine
t√§gliche NotiÔ¨Åcation, als Erinnerung an das Journaling, konÔ¨Ågurieren k√∂nnen. Damit kann
das Formen der Journaling-Gewohnheit unterst√ºtzt werden.
DieAPIf√ºr lokale zeitlich abh√§ngige NotiÔ¨Åcations beÔ¨Åndet sich noch in der Testphase
und hat in der verwendeten Testumgebung nicht funktioniert. Aus diesem Grund werden,
die zeitlichen NotiÔ¨Åcations mithilfe Push-NotiÔ¨Åcations generiert. Hierf√ºr ist allerdings
ein Backend n√∂tig, bei dem sich der Client registrieren kann und das den Client zu den
entsprechenden Zeiten benachrichtigt.
F√ºr das Backend wird Node.js mit express und web-push verwendet. Damit web-push
verwendet werden kann, muss ein Voluntary Application Server Identity ( VAPID)  Schl√ºsselpaar erstellt werden. Dies kann mit dem folgenden kurzen Skript erstellt
und anschlie√üend in eine Datei gespeichert werden.";0
"3.2.3 Aufnahme in das TTN
Um das ‚ÄûThe Things Indoor Gateway‚Äú ins TTNaufzunehmen, muss ein bestehender
Benutzeraccount vorhanden sein. Anstatt wie beim Raspberry Pi Gateway √ºber die
SchaltÔ¨Ç√§che Gateway > Add Gateway muss beim Indoor Gateway die SchaltÔ¨Ç√§che Gateway >
Claim Gateway verwendet werden. Nachdem die EUI, der Autorisationscode (welcher dem
Gateway-WiFi-Passwort entspricht), die ID und der Frequenzbereich √ºbergeben ist, kann
die Aufnahme des Gateway ins TTNabgeschlossen werden.
Abbildung 3.16: Registrierung des neuen Indoor Gateways
3.3 Gateway Reichweiten-Tests
Die Reichweite von LoRa-Gateways schwanken in der Praxis bei freiem Gel√§nde von bis
zu 15 Kilometer und zwischen zwei und vier Kilometer im st√§dtischem beziehungweise
bebauten Gel√§nde. Je nach Lage des Nodes und des Gateways kann die Reichweite und die
Durchdringungsrate der Funkwellen beeinÔ¨Çusst werden. Wenn ein Sensor beispielsweise in
einem Keller einer Wohnung in der Stadt angebracht ist, muss mit einer niedrigeren Reich-
weite ausgegangen werden. Als Faustformel gilt, dass je nach baulichen und topologischen
Gegebenheiten von der Reichweite eines Kilometers ausgegangen werden soll.
In einem optimalen, freien Gel√§nde nimmt die D√§mpfung mit der Verdoppelung der
Entfernung um sechs dBzu. Je nach Material, welches von den Funksignalen durchdrungen
werden muss, ist wie in Abbildung 3.17 dargestellt, eine andere D√§mpfung zu erwarten.
Beispielsweise Glas, welches eine Dicke von sechs Millimeter besitzt, d√§mpft das Signal
um 0,8dB. Im Schaubild ist die gr√∂√üte D√§mpfung von 35 dBbei einer Betonwand, die 30
Zentimeter dick ist, zu erwarten.";0
"Ausblick: M√∂glichkeiten und Gefahren der digitalen √úberwachung - Eine Analyse der ""Zero""-Philosophie  Die digitale √úberwachung ist zu einem zentralen Thema der gesellschaftlichen und politischen Diskussionen des 21. Jahrhunderts geworden. Die ""Zero""-Philosophie, die in ihrer Essenz die Reduktion von Identit√§tsdaten auf ein Minimum anstrebt, bietet sowohl vielversprechende Ans√§tze zur Wahrung der Privatsph√§re als auch potenzielle Gefahren f√ºr die individuelle Freiheit und Sicherheit. In der vorliegenden Arbeit wurde ein umfassender √úberblick √ºber die verschiedenen Facetten der digitalen √úberwachung und deren Implikationen gegeben, wobei sich sowohl M√∂glichkeiten als auch Herausforderungen abzeichneten.  Im Ausblick auf die zuk√ºnftige Auseinandersetzung mit dieser Thematik soll zun√§chst die sich stetig wandelnde Beziehung zwischen Technologie und den individuellen Rechten hervorgehoben werden. Die weitere Entwicklung von datenschutzfreundlichen Technologien und Instrumenten, die im Sinne der ""Zero""-Philosophie agieren, k√∂nnte als Schl√ºssel zur Schaffung eines Gleichgewichts zwischen Sicherheitsinteressen und dem Schutz pers√∂nlicher Freiheiten angesehen werden. Initiativen, die Transparenz und Kontrolle √ºber pers√∂nliche Daten f√∂rdern, werden an Bedeutung gewinnen und k√∂nnten als Vorbild f√ºr zuk√ºnftige gesetzgeberische Ma√ünahmen dienen.  Gleichzeitig sind die Gefahren, die mit der Implementierung von √úberwachungssystemen verbunden sind, nicht zu vernachl√§ssigen. Insbesondere die Risiken eines Missbrauchs von Daten, die Schaffung von Kontrollmechanismen, die √ºber die urspr√ºnglich vorgesehenen Zwecke hinausgehen, und die damit verbundene potenzielle Einschr√§nkung der pers√∂nlichen Autonomie sollten weiterhin kritisch analysiert werden. Die Diskussion um ethische Standards und die Verantwortung von Unternehmen und Regierungen wird in den kommenden Jahren an Intensit√§t zunehmen.  Abschlie√üend l√§sst sich feststellen, dass die Frage nach den M√∂glichkeiten und Gefahren der digitalen √úberwachung im Rahmen der ""Zero""-Philosophie nicht nur technologische, sondern auch gesellschaftliche und rechtliche Dimensionen umfasst. Zuk√ºnftige Forschungen sollten gezielt interdisziplin√§re Ans√§tze verfolgen, um die komplexen Wechselwirkungen zwischen Technologie, Politik und Gesellschaft besser zu verstehen. Durch einen kritischen Dialog zwischen Stakeholdern aus verschiedenen Bereichen kann eine verantwortungsvolle Gestaltung digitaler √úberwachungssysteme gef√∂rdert werden, die die Rechte und Freiheiten des Einzelnen sch√ºtzt und gleichzeitig die Sicherheit der Gemeinschaft ber√ºcksichtigt. Der Weg in die Zukunft erfordert eine sorgf√§ltige Balance und ein kontinuierliches Hinterfragen der geltenden Normen und Praktiken, um die Chancen der digitalen Transformation zu nutzen und ihre Risiken zu minimieren.";1
 Ein Konzept zur Umsetzung     In der heutigen digitalen Landschaft spielt die Auswahl eines geeigneten Content-Management-Systems (CMS) eine entscheidende Rolle f√ºr die Effizienz und Effektivit√§t der Inhaltsverarbeitung. Content-Management-Systeme erm√∂glichen nicht nur die Erstellung, Verwaltung und Ver√∂ffentlichung digitaler Inhalte, sondern beeinflussen auch die Benutzererfahrung sowie die strategische Ausrichtung einer Organisation. Dieses Dokument hat zum Ziel, verschiedene CMS zu vergleichen und ein Konzept zur Umsetzung eines CMS auszulegen.    Auswahlkriterien f√ºr Content-Management-Systeme  Die Gegen√ºberstellung von CMS sollte sich auf mehrere zentrale Kriterien st√ºtzen 1. BenutzerfreundlichkeitEin intuitives Interface f√∂rdert die Akzeptanz und Nutzung eines CMS. Anwender ohne technische Vorkenntnisse m√ºssen in der Lage sein, Inhalte selbst√§ndig zu erstellen und zu bearbeiten.  2. Flexibilit√§t und Anpassungsf√§higkeitEin gutes CMS sollte in der Lage sein, sich an die sich √§ndernden Bed√ºrfnisse einer Organisation anzupassen. Hierzu z√§hlen Aspekte wie die M√∂glichkeit, Plug-ins zu integrieren oder das Design mittels Templates zu √§ndern.  3. Technologische BasisDie Wahl der Programmiersprache, Datenbanktechnologie und der Serveranforderungen sind entscheidend f√ºr die Performance und Sicherheit eines CMS.  4. SEO-F√§higkeitenAngesichts der Bedeutung von Suchmaschinenoptimierung in der digitalen Kommunikation sollten CMS √ºber integrierte SEO-Tools verf√ºgen, die eine einfache Anpassung von Metadaten und die Optimierung der URL-Struktur erm√∂glichen.  5. Support und CommunityEin aktives Support-System sowie eine engagierte Community erh√∂hen die Wertigkeit eines CMS erheblich. Anwender k√∂nnen von der vorhandenen Dokumentation und den Erfahrungen anderer profitieren.   Gegen√ºberstellung ausgew√§hlter Content-Management-Systeme  Um einen tiefergehenden Einblick zu gewinnen, werden im Folgenden drei popul√§re CMS miteinander verglichenWordPress, Joomla! und Drupal.  - WordPressAls eines der am weitesten verbreiteten CMS zeichnet sich WordPress durch Benutzerfreundlichkeit und umfangreiche Plugins aus. Es eignet sich besonders f√ºr Blogs und kleine bis mittelgro√üe Websites. Die Lernkurve ist relativ flach, jedoch kann es bei umfangreichen Anpassungen an seine Grenzen sto√üen.  - Joomla!Dieses CMS bietet eine mittlere Komplexit√§t und eignet sich gut f√ºr soziale Netzwerke und E-Commerce-L√∂sungen. Die Flexibilit√§t und Anpassungsm√∂glichkeiten sind gr√∂√üer als bei WordPress, jedoch bedarf es eines steileren Lernprozesses f√ºr Anwender.  - DrupalBekannt f√ºr seine Robustheit und Sicherheit, ist Drupal die Wahl f√ºr komplexe und gro√üe Websites mit hohen Anforderungen an die Benutzerverwaltung. Der Implementierungsaufwand ist h√∂her, was es f√ºr kleine Unternehmen weniger attraktiv macht.   Konzeption zur Umsetzung eines CMS  Die Implementierung eines Content-Management-Systems erfordert ein systematisches Vorgehen. Ein Konzept k√∂nnte wie folgt aussehen 1. BedarfserhebungAnalysieren Sie die Bed√ºrfnisse der Benutzer und die spezifischen Anforderungen der Organisation. Workshops und Umfragen k√∂nnen helfen, die Erwartungen zu kl√§ren.  2. Evaluierung und Auswahl des CMSBasierend auf den vorher definierten Auswahlkriterien und der Bedarfserhebung, sollten die relevanten CMS verglichen und das geeignetste gew√§hlt werden.  3. Planung der ImplementierungLegen Sie einen Zeitrahmen sowie Ressourcen fest, um das CMS zu installieren und anzupassen. Ein straffer Zeitplan kann helfen, den Implementierungsprozess zu steuern.  4. TestphaseVor dem endg√ºltigen Launch sollte eine Testphase eingeplant werden, in der Funktionalit√§t, Benutzerfreundlichkeit und Performance √ºberpr√ºft werden. Dies beinhaltet sowohl technische Tests als auch Benutzertests.  5. Schulung der BenutzerUm ein reibungsloses Arbeiten mit dem neuen System zu gew√§hrleisten, m√ºssen Schulungen f√ºr die zuk√ºnftigen Benutzer angeboten werden. Dies kann durch Workshops oder Online-Tutorials geschehen.  6. SupportstrukturDer Aufbau eines internen Supports sowie die Sicherstellung des Zugangs zu externen Ressourcen sind entscheidend, um langfristige Probleme schnell l√∂sen zu k√∂nnen.   Fazit  Die sorgf√§ltige Auswahl und Implementierung eines CMS ist ein kritischer Faktor f√ºr den Erfolg digitaler Kommunikationsstrategien. Die Gegen√ºberstellung verschiedener Systeme, basierend auf spezifischen Kriterien, erm√∂glicht es Organisationen, ein passendes CMS zu finden, das den individuellen Anforderungen gerecht wird. Ein strukturiertes Konzept zur Umsetzung tr√§gt dazu bei, die Akzeptanz des neuen Systems zu f√∂rdern und die Effizienz in der Inhaltsverwaltung zu maximieren.;1
" Ausblick: Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung  In einer Welt, die zunehmend von digitalen Technologien durchdrungen ist, stehen wir an der Schwelle zu einer neuen √Ñra der √úberwachung. Die Konzepte von ""Zero"" ‚Äì sei es im Sinne von Null-Toleranz-Politiken, der Minimierung von Daten oder dem Streben nach einem Zustand der vollst√§ndigen Anonymit√§t ‚Äì er√∂ffnen sowohl vielversprechende M√∂glichkeiten als auch besorgniserregende Gefahren. W√§hrend die digitale √úberwachung in der Lage ist, Sicherheitsbedenken zu adressieren und Effizienz zu steigern, wirft sie gleichzeitig fundamentale Fragen nach Privatsph√§re, Freiheit und den ethischen Grenzen technologischen Fortschritts auf.  Die M√∂glichkeiten, die sich aus der digitalen √úberwachung ergeben, sind vielf√§ltig. Sie reichen von der Verbesserung der √∂ffentlichen Sicherheit √ºber die Optimierung von Dienstleistungen bis hin zur Schaffung personalisierter Nutzererfahrungen. In einer Zeit, in der Daten als das neue √ñl betrachtet werden, k√∂nnen Unternehmen und Regierungen von pr√§zisen Analysen und Echtzeitdaten profitieren, um informierte Entscheidungen zu treffen. Die Schaffung von ‚ÄûZero-Trust‚Äú-Umgebungen, in denen jeder Zugriff auf Daten und Systeme rigoros √ºberpr√ºft wird, k√∂nnte dazu beitragen, Sicherheitsl√ºcken zu schlie√üen und das Vertrauen in digitale Infrastrukturen zu st√§rken.  Doch mit diesen M√∂glichkeiten gehen erhebliche Gefahren einher. Die schleichende Normalisierung von √úberwachungstechnologien kann zu einem Verlust der Privatsph√§re f√ºhren und die individuelle Freiheit untergraben. In einer Gesellschaft, in der alles und jeder potenziell √ºberwacht wird, besteht die Gefahr, dass Menschen sich in ihrem Verhalten einschr√§nken und somit die Grundlage f√ºr eine offene und demokratische Diskussionskultur gef√§hrdet wird. Die Frage, wer Zugang zu den gesammelten Daten hat und wie diese verwendet werden, ist von zentraler Bedeutung. Missbrauch und Diskriminierung sind nicht nur theoretische Risiken, sondern real existierende Bedrohungen, die in der Vergangenheit bereits zu schwerwiegenden Konsequenzen gef√ºhrt haben.  In Anbetracht dieser Dualit√§t ist es unerl√§sslich, einen kritischen Diskurs √ºber die digitale √úberwachung zu f√ºhren. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, ein Gleichgewicht zwischen den Vorteilen der √úberwachung und dem Schutz der individuellen Rechte zu finden. Interdisziplin√§re Ans√§tze, die Technik, Ethik, Recht und Sozialwissenschaften vereinen, sind notwendig, um die komplexen Zusammenh√§nge zu verstehen und L√∂sungen zu entwickeln, die sowohl Sicherheit als auch Freiheit gew√§hrleisten.  Abschlie√üend l√§sst sich sagen, dass die Diskussion √ºber ""Zero"" und die digitale √úberwachung nicht nur eine technische Herausforderung darstellt, sondern auch eine gesellschaftliche. Die Entscheidungen, die wir heute treffen, werden weitreichende Auswirkungen auf die Zukunft unserer Gesellschaft und das individuelle Leben haben. Es liegt an uns, diese Debatte aktiv zu gestalten und verantwortungsvolle Wege zu finden, um die Chancen der Digitalisierung zu nutzen, ohne die fundamentalen Werte, die unsere Gesellschaft pr√§gen, zu gef√§hrden.";1
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung    Die fortschreitende Digitalisierung und die Entwicklung des Internet of Things (IoT) haben in den letzten Jahren neue M√∂glichkeiten f√ºr die Automatisierung und intelligente Steuerung von Alltagsgegenst√§nden er√∂ffnet. Ein Bereich, der von dieser Entwicklung erheblich profitieren kann, ist die Haustierhaltung. Besonders im Kontext der Katzenhaltung stellt sich h√§ufig die Frage nach einem effektiven, automatisierten Zugangssystem, das die Bed√ºrfnisse der Tiere ber√ºcksichtigt und gleichzeitig die Sicherheit des Wohnraums gew√§hrleistet. Die vorliegende Arbeit beschreibt die Implementierung eines IoT-Systems zur Steuerung einer Katzenklappe, das auf einer KI-basierten Katzenerkennung beruht.  Konzeption des Systems  Das angestrebte System besteht aus mehreren miteinander vernetzten Komponenteneiner intelligenten Katzenklappe, einem Microcontroller zur Datenverarbeitung und einem KI-Modul zur Erkennung der Katze. Die Katzenklappe soll es nur der berechtigten Katze erm√∂glichen, den Zugang zu erhalten, um unerw√ºnschte Tiere wie Streuner oder andere Tiere auszuschlie√üen. Die Entscheidung, ob die Klappe ge√∂ffnet wird, basiert auf der Analyse von Bilddaten, die von einer integrierten Kamera in der Katzenklappe erfasst werden. Die Nutzung von k√ºnstlicher Intelligenz (KI) zur Katzenerkennung ist entscheidend, um eine zuverl√§ssige Differenzierung zu gew√§hrleisten.  Technische Umsetzung  1. Hardware-AuswahlF√ºr die Implementierung des Systems wurde ein Raspberry Pi als zentraler Microcontroller gew√§hlt, da er eine leistungsstarke Plattform zur Verarbeitung der Bilddaten bietet und einfach in bestehende Netzwerke integriert werden kann. Die Katzenklappe wird mit einem Servo-Motor ausgestattet, der durch digitale Signale gesteuert wird, um die √ñffnungs- und Schlie√ümechanismen zu bet√§tigen.  2. Bildaufnahme und VorverarbeitungDie Kamera ist in der Katzenklappe installiert und nimmt kontinuierlich Bilder von den heranragenden Tieren auf. Um die Effizienz der Katzenidentifikation zu erh√∂hen, werden die Bilder vor der Analyse vorverarbeitet. Zu den Vorverarbeitungsschritten z√§hlen die Bildgr√∂√üenanpassung, die Normalisierung der Helligkeit und Kontrastanpassung, um variablen Lichtbedingungen Rechnung zu tragen.  3. ModelltrainingF√ºr die Katzenerkennung wird ein Convolutional Neural Network (CNN) eingesetzt, das auf einer Vielzahl von Katzenbildern trainiert wird. Hierzu werden √∂ffentlich verf√ºgbare Datens√§tze sowie selbst erstellte Bilddaten genutzt, um die Robustheit des Modells zu gew√§hrleisten. Unter Verwendung von Techniken wie Transfer Learning wird ein bereits vortrainiertes Netzwerk als Basis verwendet, um die erforderliche Genauigkeit bei der Identifikation zu erreichen.  4. Entwicklung der SteuerlogikDie Steuerlogik des Systems umfasst die Programmierung von Funktionen zur Bildaufnahme und -verarbeitung sowie die Ansteuerung des Servo-Motors. Die Logik entscheidet basierend auf dem Ergebnis der Katzenerkennung, ob die Klappe ge√∂ffnet oder geschlossen wird. Sollte ein nicht erkannter Benutzer vor der Klappe stehen, erfolgt eine automatische Schlie√üung, um unbefugten Zugang zu verhindern.  5. Integration und VernetzungDas gesamte System wird √ºber ein lokales WLAN-Netzwerk verbunden, sodass der Besitzer √ºber eine App Benachrichtigungen √ºber die Nutzung der Klappe erhalten kann. Eine zus√§tzliche Funktion erm√∂glicht die manuelle Steuerung der Klappe √ºber Mobile Devices, um dem Besitzer vollst√§ndige Kontrolle zu bieten.  Evaluation und Tests  Um die Funktionalit√§t und Zuverl√§ssigkeit des IoT-Systems zu validieren, wurden umfangreiche Tests in realen Umgebungen durchgef√ºhrt. Die Tests umfassten die Identifikation unter verschiedenen Lichtbedingungen sowie das Verhalten der Klappe in der Praxis. Die Ergebnisse zeigten eine Erkennungsgenauigkeit von √ºber 90%, was die Effektivit√§t der L√∂sung unterstreicht.  Fazit  Die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung stellt einen wertvollen Beitrag zur Automatisierung und Modernisierung in der Haustierhaltung dar. Die Integration von fortschrittlichen Technologien bietet nicht nur Annehmlichkeiten f√ºr die Tierbesitzer, sondern verbessert auch das allgemeine Wohlbefinden der Haustiere, indem sie zu einem sicheren und kontrollierten Zugang zu ihrem Lebensraum f√ºhrt. Zuk√ºnftige Arbeiten k√∂nnten sich darauf konzentrieren, das System durch zus√§tzliche Sensoren und Datenanalysen weiter zu verfeinern, um ein noch umfassenderes Verst√§ndnis f√ºr das Verhalten von Haustieren zu entwickeln.;1
"4 Vergleich zwischen Progressive Web
Apps und nativen Apps
In diesem Kapitel werden die Vor- und Nachteile anhand der implementierten Apps
verglichen. Ferner wird dabei auf die allgemeinen Unterschiede der beiden Technologien
eingegangen.
4.1 Allgemeine Unterschiede und Bewertung der
implementierten Features
Ein gro√üer Unterschied zwischen den beiden Technologien ist, dass die unterst√ºtzen
Features bei PWAs vom verwendeten Browser und dessen Version abh√§ngig ist. Bei nativen
Android Apps wird √ºber die Auswahl des API-Levels deÔ¨Åniert, welche Ger√§te unterst√ºtzt
werden. Ferner ist damit sichergestellt, dass alle implementierten Features ohne Probleme
funktionieren.
DurchdieVerwendungdesBrowsershabenPWAsdenVorteil,dasssieaufallenEndger√§ten,
die einen Browser haben, verwendet werden k√∂nnen. Dies bezieht sich nicht nur auf
Smartphone-Betriebssysteme, sondern ebenfalls auf die Verwendung am Desktop. F√ºr
native Apps ist dies nicht der Fall. Sie m√ºssen f√ºr jedes System separat entwickelt werden,
was den Aufwand durchaus erh√∂ht. Dies kann durch die Verwendung von hybriden Apps,
die zum Beispiel mit Flutter umsetzbar sind, abgeschw√§cht werden. Das hat zur Folge,
dass die Apps nicht f√ºr Plattformen optimiert sind.
Im Folgenden werden die Features bewertet und verglichen. Dabei werden jeweils 0 bis 3
in Punkten vergeben und folgende Aspekte betrachtet:
‚Ä¢Ist das Feature ohne Problemumgehung umsetzbar?
‚Ä¢Wie aufw√§ndig ist die Umsetzung?
‚Ä¢Wie nutzerfreundlich ist das Ergebnis?";0
Nachdem die gemessenen Ergebnisse der betrachteten Metrik vorliegen, k√∂nnen R√ºckschl√ºsse auf  die Softwarequalit√§t ge zoge n werden. Dazu ist es erforderlich, dass die Werte in einen bekannten  Kontext eingeordnet werden. Das bedeutet, dass f√ºr jede Metrik eine Skala definiert werden muss,  auf der die Messwerte liegen. Nur so ist es m√∂glich Aussagen √ºber die G√ºte der Software z u treffen.  Je nach Art der Metrik k√∂nnen unterschiedliche Skalentypen herangezogen werden. Grunds√§tzlich  werden  f√ºnf verschiedene Typen definiert, die aufeinander aufbauen und somit in ihrer Komplexit√§t  steigen, da die h√∂heren Skalentypen die meisten Eigenschaften mitbringen.     Das niedrigste Niveau ist die Nominalskala , die keinen Vergleich zwischen Messwerten erlaubt.  Hierbei  werden die Ergebnisse einer Kategorie zugeordnet, die durch eine freie Bezeichnung  beschrieben wird. Die verschiedenen Gruppen stehen in keinem Verh√§ltnis zueinander, es wird  lediglich das Auftreten in den Kategorien gez√§hlt.     Das Problem der Vergleichbarkeit wird durch die Ordinalskala behoben. Auch hier werden  H√§ufigkeiten in verschiedenen Kategorien gez√§hlt. Diese sind jedoch in einer bestimmten  Reihenfolge angeordnet , die eine relative Aussage √ºber die Qualit√§t zul√§sst . Eine Ordnung k√∂nnte  beispielsweise lauten ‚Äûsehr zufrieden‚Äú, ‚Äûzufrieden‚Äú, ‚Äûunzufrieden‚Äú, ‚Äûsehr unzufrieden‚Äú.     Mit der Intervallskala werden erstmals Zahlenwerte eingef√ºhrt, die ihre G√ºltigkeit auch bei einer  Verschiebung der Skala behalten. Das bedeutet, dass der Abstand zwischen den Werten interpretiert  werden kann und R√ºckschl√ºsse zul√§sst. Beispielsweise k√∂nnen Temperaturwerte in Fahrenheit und  Grad Celsius durch Umrechnung auf derselben Intervallskala abgebildet und anschlie√üend anhand  der Abst√§nde  auf der Skala  der Temperaturunterschied abgelesen werden.     √Ñhnlich verh√§lt es sich mit der Rationalskala, die auch als Verh√§ltnisskala bezeichnet wird. Diese f√ºhrt  zus√§tzlich einen absoluten Nullpunkt ein , wie es beispielsweise bei den Einheiten Kelv in oder Meter  der Fall ist . Dadurch sind prozentuale Aussagen √ºber verschiedene Messwerte m√∂glich.     Die Absolutskala stellt das h√∂chste Skalenniveau dar.  Neben dem nat√ºrlichen Nullpunkt bringt diese  auch eine nat√ºrliche Einheit mit. In der Statistik bedeutet das, dass die Abst√§nde der Werte  unabh√§ngig von einem Ma√üstab sind und immer 1 betragen. Dargestellt werden also St√ºckzahlen  oder H√§ufigkeiten.;0
Konzept zur Umsetzung    Im Kontext des studentischen Software Engineerings spielt die effiziente Verwaltung von Aufgaben eine zentrale Rolle f√ºr den Erfolg von Projekten. Die Komplexit√§t moderner Softwareentwicklung erfordert nicht nur technisches Wissen, sondern auch eine strukturierte Herangehensweise an die Planung, Durchf√ºhrung und Nachverfolgung von Aufgaben. Ein gut gestaltetes Aufgabenmanagement-Tool kann hierbei als unterst√ºtzendes Instrument fungieren, das den Studierenden hilft, ihre Projekte effektiver zu organisieren und ihre Teamarbeit zu optimieren. In diesem Prosatext wird eine Anforderungsanalyse f√ºr ein solches Tool durchgef√ºhrt, gefolgt von einem Konzept zur Umsetzung.  Anforderungsanalyse  Die Anforderungsanalyse ist der erste Schritt zur Entwicklung eines effektiven Aufgabenmanagement-Tools. Sie umfasst die Identifikation der Bed√ºrfnisse der Nutzer sowie die Definition der funktionalen und nicht-funktionalen Anforderungen. Die Hauptnutzer des Tools sind Studierende, die in Gruppen an Softwareprojekten arbeiten. Daher sind die folgenden Anforderungen zu ber√ºcksichtigen 1. Funktionale Anforderungen    - AufgabenverwaltungNutzer sollen in der Lage sein, Aufgaben zu erstellen, zu bearbeiten, zu l√∂schen und zu kategorisieren. Jede Aufgabe sollte Informationen wie Titel, Beschreibung, F√§lligkeitsdatum, Priorit√§t und Verantwortliche enthalten.    - Team-KollaborationDas Tool sollte Funktionen zur Zusammenarbeit bieten, wie z.B. Kommentarfunktionen, Datei-Uploads und Benachrichtigungen √ºber √Ñnderungen.    - FortschrittsverfolgungEine visuelle Darstellung des Projektfortschritts (z.B. durch Kanban-Boards oder Gantt-Diagramme) ist erforderlich, um den √úberblick √ºber den Status der Aufgaben zu behalten.    - IntegrationenDas Tool sollte sich in bestehende Entwicklungsumgebungen und Kommunikationsplattformen (wie GitHub, Slack oder Microsoft Teams) integrieren lassen, um einen nahtlosen Workflow zu gew√§hrleisten.  2. Nicht-funktionale Anforderungen    - BenutzerfreundlichkeitDas Interface muss intuitiv gestaltet sein, um eine schnelle Einarbeitung zu erm√∂glichen. Eine klare Navigation und ansprechende Gestaltung sind entscheidend.    - Zug√§nglichkeitDas Tool sollte plattform√ºbergreifend (Web, Mobile) verf√ºgbar sein, um den Studierenden Flexibilit√§t in der Nutzung zu bieten.    - SicherheitDatenschutz und Datensicherheit sind von h√∂chster Bedeutung. Das Tool muss sicherstellen, dass Benutzerdaten gesch√ºtzt sind und nur autorisierte Nutzer Zugriff auf sensible Informationen haben.  Konzept zur Umsetzung  Basierend auf der Anforderungsanalyse wird ein Konzept zur Umsetzung des Aufgabenmanagement-Tools entwickelt. Dieses Konzept umfasst die folgenden Schritte 1. Technische Architektur    - Die Softwarearchitektur sollte modular aufgebaut sein, um zuk√ºnftige Erweiterungen und Anpassungen zu erm√∂glichen. Eine client-server-Architektur mit einer RESTful API zur Kommunikation zwischen Frontend und Backend wird empfohlen. F√ºr das Backend k√∂nnte ein Framework wie Node.js oder Django verwendet werden, w√§hrend das Frontend mit React oder Angular realisiert werden kann.  2. Prototyping    - Vor der vollst√§ndigen Implementierung sollte ein;1
  Die zunehmende Digitalisierung und Vernetzung von Systemen in der Industrie und im Alltag erfordert eine fundierte Ausbildung im Bereich der Kommunikationstechnologien. Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f√ºhrenden Protokolle f√ºr die Kommunikation in Internet-of-Things (IoT)-Anwendungen etabliert. Vor diesem Hintergrund wurde ein virtuelles MQTT-Szenario entwickelt, das als Lehrmittel in der Hochschulausbildung eingesetzt werden kann. Der Fokus dieses Prosatextes liegt auf der , um die Effektivit√§t und den Lernerfolg der Studierenden zu beurteilen.  Die Entwicklung des virtuellen Szenarios umfasste mehrere Schritte. Zun√§chst wurde eine didaktische Analyse durchgef√ºhrt, um die Lernziele und -inhalte zu definieren. Dabei wurde der Schwerpunkt auf die Vermittlung grundlegender Konzepte des MQTT-Protokolls gelegt, einschlie√ülich Publisher-Subscriber-Architektur, QoS (Quality of Service) und Sicherheitsaspekte. Im Anschluss wurde eine Simulation erstellt, die es den Studierenden erm√∂glicht, verschiedene Szenarien zu erkunden, wie z.B. die Kommunikation zwischen Sensoren und einer zentralen Datenbank.   Um die Effektivit√§t des entwickelten Szenarios zu evaluieren, wurde ein Mixed-Methods-Ansatz gew√§hlt, der sowohl quantitative als auch qualitative Daten umfasst. Zu Beginn des Semesters wurde ein Pre-Test durchgef√ºhrt, um das Vorwissen der Studierenden zu erfassen. Nach der Durchf√ºhrung des Lehrmoduls und der Nutzung des virtuellen Szenarios wurde ein Post-Test angelegt, um den Wissenszuwachs zu messen. Die Ergebnisse der Tests wurden statistisch ausgewertet, um signifikante Unterschiede im Lernfortschritt festzustellen.  Zus√§tzlich wurden Interviews mit den Studierenden durchgef√ºhrt, um ihre Erfahrungen und Wahrnehmungen bez√ºglich des virtuellen Szenarios zu erfassen. Die qualitative Analyse dieser Interviews lieferte wertvolle Einblicke in die St√§rken und Schw√§chen des Lehransatzes. Die Studierenden berichteten von einer hohen Motivation und einem gesteigerten Interesse an der Materie, was auf die interaktive Natur des Szenarios zur√ºckgef√ºhrt werden kann. Einige Studierende √§u√üerten jedoch Bedenken hinsichtlich der technischen Komplexit√§t und der Notwendigkeit einer intensiveren Unterst√ºtzung w√§hrend der ersten Schritte im Umgang mit der Software.  Ein weiterer Aspekt der Evaluierung war die Beobachtung des Lehrprozesses. Hierbei wurde festgestellt, dass die Integration des virtuellen Szenarios in den Unterricht den Lehrenden erm√∂glichte, praxisnahe Beispiele zu verwenden und theoretische Konzepte anschaulicher zu vermitteln. Die Interaktivit√§t des Szenarios f√∂rderte zudem die Zusammenarbeit unter den Studierenden, was sich positiv auf die Teamarbeit und Probleml√∂sungsf√§higkeiten auswirkte.  Zusammenfassend l√§sst sich festhalten, dass die Evaluierung des virtuellen MQTT-Szenarios positive Ergebnisse hinsichtlich des Lernerfolgs der Studierenden und der Qualit√§t des Lehrens ergab. Die Kombination aus theoretischen Inhalten und praktischen Anwendungen stellte sich als besonders effektiv heraus. Zuk√ºnftige Arbeiten sollten sich auf die Optimierung der Benutzeroberfl√§che und die Reduzierung technischer Barrieren konzentrieren, um das Lernumfeld weiter zu verbessern. Dar√ºber;1
Fazit  Die vorliegende Arbeit hat sich mit der Entwicklung einer Fahrzeugfernsteuerung besch√§ftigt, die auf dem IEEE 802.15 Standard basiert und √ºber integrierte Mechanismen zur Kollisionsvermeidung verf√ºgt. Die Forschung hat gezeigt, dass die Implementierung von drahtlosen Kommunikationsprotokollen wie IEEE 802.15 entscheidend f√ºr die Echtzeit√ºbertragung von Steuerbefehlen und sicherheitsrelevanten Informationen ist. Durch die Nutzung eines geeigneten Moduls konnten sowohl die Reaktionsgeschwindigkeit der Fernsteuerung als auch die Robustheit der Kommunikation erheblich verbessert werden.  Ein zentrales Ergebnis ist die erfolgreiche Integration eines Algorithmus zur Kollisionsvermeidung, der es erm√∂glicht, sicherere Operationen in dynamischen und potenziell gef√§hrlichen Umgebungen durchzuf√ºhren. Die Einsatzm√∂glichkeiten der entwickelten Technologie in Bereichen wie der Logistik, der Landwirtschaft oder im st√§dtischen Verkehr er√∂ffnen neue Perspektiven f√ºr die Automatisierung und Effizienzsteigerung.  Zudem wurden Herausforderungen wie die Signalstabilit√§t und die Latenzzeiten adressiert, welche f√ºr eine reibungslose und sichere Steuerung unerl√§sslich sind. Durch gezielte Optimierungen in der Algorithmik und der Hardware konnte die Gesamtleistung signifikant gesteigert werden.  Insgesamt best√§tigt diese Arbeit die Eignung des IEEE 802.15 Standards f√ºr die Entwicklung einer zuverl√§ssigen Fahrzeugfernsteuerung mit Kollisionsvermeidung. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die Anwendungsbreite weiter zu erh√∂hen sowie m√∂gliche Integrationen mit fortschrittlichen Sensoriksystemen und k√ºnstlicher Intelligenz zu untersuchen, um die Sicherheit und Effizienz weiter zu verbessern. Die Ergebnisse dieser Arbeit legen somit den Grundstein f√ºr weitere innovative Entwicklungen im Bereich der Fahrzeugautomatisierung und bieten wertvolle Erkenntnisse f√ºr die zuk√ºnftige Forschung und praktische Anwendung.;1
Da jede Activity ihr eigenes ViewModel hat, kann je Activity entschieden werden, welche Funktionen aus dem Ger√§te Repository ben√∂tigt werden. Diese werden anschlie√üend zum ViewModel hinzugef√ºgt. Dabei ist das ViewModel genau wie das Repository Teil der MVVMArchitektur und wird in dem Zusammenhang in Abschnitt 2.5 erl√§utert. Nachdem ein ViewModel Objekt in einer Activity erstellt wird, kann somit anschlie√üend auf die Datenbankabfragen zugegriffen werden. Im Nachfolgenden werden die Funktionen der Katzenklappen App beschrieben. Dabei wird auf die unterschiedlichen Ansichten der App eingegangen und Teile davon anhand von Code Listings genauer beschrieben. Durch das Plus-Symbol im Men√º der App kann eine Katzenklappe hinzugef√ºgt werden. Daraufhin √∂ffnet sich ein Dialogfenster, welches in Abbildung 5.11 zu sehen ist, bei dem wie in der Abschnitt 5.1 bereits beschrieben der Name und der eindeutige Schl√ºssel der Katzenklappe angegeben wird. Nachdem man die Eingabe best√§tigt, erfolgt eine Pr√ºfung des eindeutigen Schl√ºssels. Dazu wird zuerst gepr√ºft, ob der Schl√ºssel bereits in der internen Room Datenbank in der Tabelle devices vorhanden ist. Falls dies nicht der Fall ist wird gepr√ºft, ob dieser Schl√ºssel valide ist. Die Validierung erfolgt √ºber die Firebase Cloud Firestore Datenbank. Dabei wird eine Abfrage auf die edge_auth Kollektion gemacht. In dieser befinden sich alle Katzenklappen mit dem dazugeh√∂rigen eindeutigen Schl√ºssel.;0
Im Rahmen dieser wissenschaftlichen Arbeit wurde der aktuelle Stand der Technik im Bereich des Testens von MQTT-basierten L√∂sungen umfassend analysiert. MQTT, als leichtgewichtiges Messaging-Protokoll, hat sich in den letzten Jahren zu einem zentralen Bestandteil der Internet-of-Things (IoT)-Architektur entwickelt. Die vorliegende Untersuchung hat gezeigt, dass die Testmethoden f√ºr MQTT-Anwendungen sowohl in der Breite als auch in der Tiefe kontinuierlich fortschreiten, um den spezifischen Herausforderungen und Anforderungen dieser dynamischen Umgebung gerecht zu werden.  Die Analyse hat verschiedene Testans√§tze identifiziert, die von funktionalen Tests √ºber Last- und Performancetests bis hin zu Sicherheitstests reichen. Dabei wird deutlich, dass die Integration von automatisierten Testverfahren und Continuous Integration/Continuous Deployment (CI/CD)-Pipelines zunehmend an Bedeutung gewinnt. Diese Methoden erm√∂glichen es Entwicklern, die Qualit√§t ihrer Anwendungen in Echtzeit zu gew√§hrleisten und schnell auf Ver√§nderungen im System zu reagieren.  Zudem wurden bestehende Tools und Frameworks evaluiert, die speziell f√ºr das Testen von MQTT-Anwendungen entwickelt wurden. Die Vielfalt dieser Werkzeuge spiegelt die unterschiedlichen Bed√ºrfnisse der Entwicklergemeinschaft wider, wobei sowohl Open-Source- als auch kommerzielle L√∂sungen zur Verf√ºgung stehen. Dennoch zeigt die Untersuchung, dass es an standardisierten Testverfahren mangelt, die eine konsistente Bewertung der Qualit√§t und Zuverl√§ssigkeit von MQTT-basierten Systemen erm√∂glichen w√ºrden.  Ein weiterer wichtiger Aspekt, der aus der Analyse hervorgeht, ist die Notwendigkeit, die Sicherheit von MQTT-Anwendungen zu priorisieren. Angesichts der zunehmenden Vernetzung und der damit verbundenen Sicherheitsrisiken ist es unerl√§sslich, robuste Teststrategien zu entwickeln, die potenzielle Schwachstellen fr√ºhzeitig identifizieren und adressieren.  Zusammenfassend l√§sst sich festhalten, dass das Testen von MQTT-basierten L√∂sungen ein dynamisches und sich st√§ndig weiterentwickelndes Feld ist, das sowohl Herausforderungen als auch Chancen bietet. Die fortschreitende Entwicklung von Testwerkzeugen und -methoden, gepaart mit einem wachsenden Bewusstsein f√ºr Sicherheitsaspekte, wird entscheidend daf√ºr sein, die Qualit√§t und Zuverl√§ssigkeit von IoT-Anwendungen zu gew√§hrleisten. Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, standardisierte Testverfahren zu entwickeln und die Interoperabilit√§t zwischen verschiedenen Testtools zu f√∂rdern, um die Effizienz und Effektivit√§t des Testens in diesem Bereich weiter zu steigern.;1
Neben den drei Grundbausteinen in Kombination mit den ModiÔ¨Åern bietet Compose auch die M√∂glichkeit, Material Components bei dem Design von Layouts einzusetzen . Bei Material Components handelt es sich um interaktive Grundbausteine, die durch das Einbinden der Material Design Dependency innerhalb des Projektes verwendet werden k√∂nnen und sogenannte Slot-APIsverwenden , . Als Slot wird in diesem Zusammenhang eine generische Lambdafunktion bezeichnet, die Composables als Inhalt akzeptiert . Bei Slot- APIs handelt es sich um ein Pattern, welches von Compose eingef√ºhrt wurde, um eine zus√§tzliche M√∂glichkeit zur Customization zu bieten, die sich oberhalb der Com- posable Ebene beÔ¨Åndet. Das Pattern macht Komponenten Ô¨Çexibler, da es das Einbinden von kompletten Childelementen √ºber einen Lambdablock erlaubt, die sich selbst intern konÔ¨Ågurieren k√∂nnen. Somit besteht die M√∂glichkeit, selbstdeÔ¨Ånierten Inhalt in Form von Childelementen in den jeweiligen Slot einzubinden. Ein sehr gutes Beispiel hierf√ºr bietet der Los Gehts -Button, der auf der Startseite der CoÔ¨ÄeeCompose App dargestellt ist. Dieser ist in Zeile 9 bis 12 des Listings 3.5 in seiner Implementierung dargestellt. √úber die folgende Abbildung 3.6 kann die genaue Einteilung des Buttons in die unterschiedlichen Slots eingesehen werden. Abbildung 3.6: Slots eines Material Components anhand des Los Gehts -Button In den letzten Jahren hat sich eine grundlegende Layoutstrategie f√ºr Apps durchgesetzt, welche h√§uÔ¨Åg solche Material Components verwendet. Auch der Aufbau der Listenansicht der CoÔ¨ÄeeCompose Anwendung verwendet grundlegende Material Components wie Topbar, Bottombar oder auch Floatingbuttons, was in Abbildung 3.1 eingesehen werden kann.;0
"Wie in Listing 3.23 zu erkennen ist, wird im ersten Abschnitt das PendingIntent erstellt,
das auf den ‚ÄôTimerBroadcastReceiver‚Äô verweist. F√ºr die Uhrzeit werden die √ºbergebenen
Werte f√ºr die Stunde und Minute verwendet. Mit dem PendingIntent, der Uhrzeit sowie
der Option f√ºr ein t√§gliches Intervall wird die ‚ÄôsetRepeating‚Äô Methode des Alertmanagers
aufgerufen. Dies erzielt das gew√ºnschte Ergebnis einer t√§glichen Erinnerung zur gew√§hlten
Zeit.
F√ºr das Anzeigen der NotiÔ¨Åcation wird ein Broadcast Receiver erstellt. Durch das erstellte
PendingIntent sowie das Boot Event des Systems wird der Broadcast Receiver aufgerufen.
Beim Empfangen eines Broadcast wird gepr√ºft, ob es sich um das ‚ÄôonBoot‚Äô Event handelt.
Sollte dies der Fall sein, kann mit den Daten in den Shared Preferences erneut der Alert
gesetzt werden. Beim Empfangen anderer Broadcast wird die gew√ºnschte Erinnerung zum
Journaling in Form einer NotiÔ¨Åcation an den Nutzer gegeben. Dies ist in Listing 3.24
erkennbar.
F√ºr das Anzeigen von NotiÔ¨Åcation muss zuerst ein sogenannter NotiÔ¨Åcation Channel
erstellt werden. Mit der erstellten NotiÔ¨Åcation Channel kann dem Nutzer die gew√ºnschte
Nachricht angezeigt werden. Mit dem folgenden Code in Listing 3.25 wird die NotiÔ¨Åcation
erstellt und angezeigt.
Es wird ein Icon gew√§hlt sowie ein Titel und eine Beschreibung festgelegt. Des Weiteren
wird eine Priorit√§t und ein zuvor erstellter PendingIntent, der auf die Basis Activity
verweist, angegeben. Zuletzt wird die NotiÔ¨Åcation dem Nutzer angezeigt. Beim Klick auf
die NotiÔ¨Åcation wird der PendingIntent ausgef√ºhrt und die App auf der Basis Activity
ge√∂Ô¨Änet.";0
Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Die zunehmende Vernetzung von Ger√§ten im Internet der Dinge (IoT) hat die Entwicklung effizienter, skalierbarer und robuster Plattformen zur Verwaltung und Interaktion mit diesen Ger√§ten in den Vordergrund ger√ºckt. Eine vielversprechende Plattform in diesem Kontext ist ElixirNerves, die auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von IoT-Anwendungen konzipiert wurde. Um die Eignung von ElixirNerves f√ºr IoT-Anwendungen zu evaluieren, ist es unerl√§sslich, die theoretischen Grundlagen zu betrachten, die dieser Plattform zugrunde liegen.  1. Programmiersprache Elixir und ihre Eigenschaften  Elixir ist eine funktionale, nebenl√§ufige Programmiersprache, die auf der Erlang Virtual Machine (BEAM) l√§uft. Sie bietet eine Reihe von Vorteilen, die sie f√ºr IoT-Anwendungen besonders geeignet machen. Die funktionale Programmierung erm√∂glicht eine klare und pr√§zise Ausdrucksweise, die die Entwicklung von komplexen Logiken vereinfacht. Nebenl√§ufigkeit ist ein zentrales Merkmal von Elixir, das durch das Actor-Modell unterst√ºtzt wird. Dies erlaubt es Entwicklern, mehrere Prozesse gleichzeitig zu verwalten, was f√ºr die Verarbeitung von Datenstr√∂men in Echtzeit, wie sie in IoT-Anwendungen h√§ufig vorkommen, von entscheidender Bedeutung ist.  2. Nerves Framework  Das Nerves Framework erweitert die M√∂glichkeiten von Elixir, indem es eine vollst√§ndige Entwicklungsumgebung f√ºr eingebettete Systeme bereitstellt. Es bietet eine Sammlung von Tools und Bibliotheken, die speziell f√ºr die Entwicklung von Software f√ºr IoT-Ger√§te entwickelt wurden. Zu den zentralen Komponenten geh√∂ren - HardwareabstraktionNerves erm√∂glicht die Interaktion mit verschiedenen Hardwarekomponenten √ºber eine einheitliche API, was die Portabilit√§t von Anwendungen erh√∂ht. - Firmware-ManagementDie M√∂glichkeit, Software-Updates √ºber das Internet durchzuf√ºhren, ist f√ºr IoT-Ger√§te von entscheidender Bedeutung, um Sicherheitsl√ºcken zu schlie√üen und neue Funktionen bereitzustellen. - Echtzeitf√§higkeitDie Verwendung der BEAM-Architektur erm√∂glicht es Nerves, Echtzeitanforderungen zu erf√ºllen, die in vielen IoT-Anwendungen erforderlich sind.  3. Sicherheit und Zuverl√§ssigkeit  Ein weiterer wichtiger Aspekt bei der Evaluierung von IoT-Plattformen ist die Sicherheit. IoT-Ger√§te sind h√§ufig Ziel von Angriffen, und ihre Sicherheit ist von gr√∂√üter Bedeutung. ElixirNerves bietet eine Reihe von Sicherheitsmechanismen, darunter die M√∂glichkeit, sichere Kommunikationsprotokolle zu implementieren und die Verschl√ºsselung von Daten w√§hrend der √úbertragung. Zudem erm√∂glicht die robuste Fehlerbehandlung von Elixir eine hohe Zuverl√§ssigkeit, da Anwendungen in der Lage sind, Fehler zu erkennen und sich selbst zu regenerieren.  4. Community und √ñkosystem  Die Unterst√ºtzung durch eine aktive Community ist ein weiterer Faktor, der die Eignung einer Plattform beeinflusst. Elixir und Nerves profitieren von einer engagierten Entwicklergemeinschaft, die regelm√§√üig neue Bibliotheken und Tools bereitstellt. Dies f√∂rdert nicht nur die Innovation, sondern erleichtert auch den Zugang zu Ressourcen und Unterst√ºtzung f√ºr Entwickler, die mit der Plattform arbeiten.  5. Skal;1
"Abstract
Zuk√ºnftig sollen in sog. Smart Cities s√§mtliche Daten gesammelt werden: F√ºllst√§nde von
M√ºlleimern und Glascontainern, Anzahl der freien Parkpl√§tze, Kennzahlen zur Luftqualit√§t,
usw. Eine beliebte Funktechnologie f√ºr die drahtlose √úbermittlung dieser Daten ist LoRa-
WAN. LoRaWAN erlaubt es sogenannten Nodes, geringe Datenmengen energiesparend bei
einer hohen Reichweite zu senden. Dadurch eignet sich LoRaWAN f√ºr den Einsatz in Smart
Cities, da die gemessenen Daten pro Node meist gering sind. Die Nodes k√∂nnen durch
die EnergieeÔ¨Ézienz von LoRaWAN zudem mit einer Batterie meist sogar √ºber mehrere
Jahre betrieben werden. Das The Things Network stellt einen communitybasierten Ansatz
dar, bei dem durch die Community betriebene LoRaWAN Gateways die von den Nodes
gesendeten Datenpakete empfangen und √ºber den The Things Network Server √ºber das
Internet f√ºr den Betreiber des Nodes zug√§nglich machen. Durch die hohe Reichweite von
LoRaWAN reichen bereits wenige gut positionierte Gateways aus, um ein gesamtes Stadtge-
biet abdecken zu k√∂nnen. Doch auch im l√§ndlichen Raum kann LoRaWAN aufgrund seiner
hohen Reichweite eingesetzt werden, beispielsweise f√ºr das Messen der Wassertemperatur in
Badeseen oder der Pegelmessung von Fl√ºssen. Die vorliegende Studienarbeit behandelt das
Tracking der Bodenfeuchtigkeit via LoRaWAN und dem The Things Network. Im Rahmen
der Arbeit wird passende Hardware f√ºr die Nodes ausgew√§hlt, anschlie√üend werden diese
programmiert und in das The Things Network aufgenommen. Um die von den Nodes
gesendeten Messdaten empfangen zu k√∂nnen, werden zudem Gateways installiert und dem
The Things Network hinzugef√ºgt.";0
 Kapitel 4: Implementierung einer Journaling-App im Vergleich von PWA und nativen Apps   4.1 Einleitung  In diesem Kapitel werden die Implementierungen einer Journaling-App sowohl als Progressive Web App (PWA) als auch als native mobile App beschrieben. Ziel ist es, die Unterschiede und Gemeinsamkeiten in der Entwicklung und Benutzererfahrung zu analysieren. Es wird zun√§chst auf die Architektur beider Ans√§tze eingegangen, danach folgt eine detaillierte Betrachtung der Implementierung, einschlie√ülich Technologien, Tools, Herausforderungen und der gew√§hlten Designprinzipien.   4.2 Architektur der Anwendung   4.2.1 Progressive Web App  Die PWA wurde auf der Basis von HTML, CSS und JavaScript entwickelt. Die Struktur bestand aus:  - Frontend: Implementiert mit React, um die Benutzeroberfl√§che reaktiv und leistungsf√§hig zu gestalten. - Backend: Die Daten wurden √ºber ein RESTful API von einem Node.js-Server bereitgestellt, der auf MongoDB als Datenbank zugreift. - Service Worker: Implementiert zur Unterst√ºtzung von Offline-Funktionalit√§ten und zur Optimierung der Ladezeiten, indem Ressourcen im Cache gespeichert werden.    Die Architektur erm√∂glicht es der PWA, auf die Kernfunktionen eines Mobilger√§ts (z. B. Benachrichtigungen, Kamera) √ºber Web-APIs zuzugreifen.   4.2.2 Native App  Die native App wurde mit Swift f√ºr iOS und Kotlin f√ºr Android entwickelt. Die Architektur umfasste:  - Frontend: Ein UI-Framework (SwiftUI f√ºr iOS und Jetpack Compose f√ºr Android) sorgte f√ºr eine native Benutzeroberfl√§che und Interaktivit√§t. - Backend: Wie bei der PWA wurde ein RESTful API verwendet, um die gleichen Backend-Dienste zu gew√§hrleisten. - Datenmanagement: Lokale Speicherung wurde mit Core Data (iOS) und Room (Android) realisiert, um offline Zugang zu Tagebucheintr√§gen zu erm√∂glichen.   4.3 Implementierung der Kernfunktionen  Beide Versionen der Journaling-App mussten grundlegende Funktionen wie Benutzeranmeldung, Erstellung, Bearbeitung und L√∂schung von Tagebucheintr√§gen sowie das Hinzuf√ºgen von Tags unterst√ºtzen.   4.3.1 Registrierung und Authentifizierung  PWA:  Die Registrierung und Authentifizierung in der PWA erfolgt √ºber ein verantwortliches Formular mit Validierung durch JavaScript. Bei erfolgreicher Anmeldung wird ein JWT (JSON Web Token) verwendet, um die Session aufrechtzuerhalten.  Native App:  Die native App implementiert ein √§hnliches Verfahren, nutzt jedoch die nativen UI-Elemente und -Transitions. Die Authentifizierung wird hier durch das Secure Enclave (iOS) und den Keystore (Android) zus√§tzlich abgesichert.   4.3.2 Erstellen und Verwalten von Eintr√§gen  PWA:  Die Erstellung und Verwaltung von Tagebucheintr√§gen erfolgt √ºber dynamische Formulare, die durch React-Komponenten generiert werden. Durch den Einsatz von Local Storage kann der Nutzer auch offline Eintr√§ge erstellen, die synchronisiert werden, sobald die Internetverbindung hergestellt ist.  Native App:  In der nativen App wird √§hnlich verfahren, jedoch kommen hier eigene UI-Komponenten zum Einsatz. Die Verwendung von Core Data bzw. Room erm√∂glicht eine robuste Speicherung und Synchronisation ohne Netzwerkverbindung.   4.4 Benutzeroberfl√§che und Benutzererfahrung  Eines der Hauptziele war es, eine benutzerfreundliche und ansprechende Oberfl√§che zu schaffen. Beide Versionen weisen responsive Design-Elemente auf, jedoch variieren die Designrichtlinien erheblich.   4.4.1 PWA-Design  Die PWA ber√ºcksichtigt g√§ngige Webdesign-Prinzipien wie Flexbox und Grid, um eine responsive Benutzeroberfl√§che zu gew√§hrleisten. Zudem kommt Material Design zum Einsatz, um eine konsistente √Ñsthetik zu erreichen.   4.4.2 Native App-Design  Die native App folgt den spezifischen Designrichtlinien von Android und iOS, was zu einer differenzierten Benutzererfahrung f√ºhrt. Die Nutzung von Animationen und Gesten ist hier weitverbreitet, um die Benutzerinteraktion zu f√∂rdern.   4.5 Herausforderungen bei der Implementierung  W√§hrend der Implementierung beider Versionen traten verschiedenen Herausforderungen auf:  - Offline-Funktionalit√§t: Bei der PWA war die Implementierung des Service Workers von zentraler Bedeutung, um eine nahtlose Offline-Nutzung zu erm√∂glichen. Dies stellte sich als komplex heraus, vor allem bei der Handhabung von Daten√§nderungen.    - Zugriff auf native Funktionen: Bei der nativen App war der Zugriff auf systemeigene Funktionen wie Kamera und Benachrichtigungen problemlos. Dies stellte in der PWA eine Herausforderung dar, die nur √ºber Web-APIs gel√∂st werden konnte, die nicht immer dieselbe Funktionalit√§t bieten.   4.6 Fazit  Die Implementierung der Journaling-App als PWA und native App zeigt, dass beide Ans√§tze ihre eigenen St√§rken und Schw√§chen haben. Die Wahl zwischen ihnen kann stark von den angestrebten Funktionen, dem gew√ºnschten Benutzererlebnis und den technischen Einschr√§nkungen abh√§ngen. In den folgenden Kapiteln werden die Ergebnisse anhand von Benutzerumfragen und Performance-Tests analysiert, um fundierte Schlussfolgerungen √ºber die Vor- und Nachteile beider Implementierungsans√§tze zu ziehen.;1
In der Architektur des Systems dieser Arbeit fungiert das separate Modul zur Katzenerken- nung wie ein Client, der ein m√∂glichst passives Modul anspricht, damit dieses das System verwaltet. Daher bietet sich f√ºr diese Implementierung die Realisierung des Controllers (s.Abschnitt 3.1) als Server an, der sowohl von der Katzenerkennung als auch von der Android App angesprochen werden kann. F√ºr diese Implementierung gibt es generell zwei sinnhafte Ans√§tze in Python, die sowohl simpel in der Implementierung, als auch mit geringem Overhead verbunden sind.  Der erste Ansatz ist dabei die Nutzung eines Flask Webservers und Anfrage dessen Funktionalit√§ten √ºber HTTP-Anfragen.  Da Flask minimal gehalten ist und die Anfrage durch Nutzung des Routings sehr flexibel ist, ist diese Variante sowohl gut geeignet als auch einfach ausbaubar, bei geringer Auslastung des Raspberry.  Da die Kommunikation Ger√§teintern zwischen zwei Python Skripten besteht, ist hier allerdings ebenso die Nutzung spezifischerer Herangehensweisen m√∂glich. Da die Programmiersprache identisch ist, ist auch die Nutzung von RPCs ohne aufwendiges Marshalling m√∂glich. RPCs beschreiben dabei die F√§higkeit einer Programmiersprache, Befehle eines Programms (procedure ) in einem separaten Programm (remote ) auszuf√ºhren (call ). Dazu stellt Python nativ bereits einen auf XMLbasierenden RPCServer als package bereit. √úber dieses l√§sst sich ein leichtgewichtiger Server als Bereitsteller der Funktionen und Clients zum Aufruf dieser implementieren. F√ºr diese Arbeit wurde diese Implementierung gew√§hlt, und asynchron umgesetzt. In Listing 3.2 ist die Konfiguration des RPCServers und die Registrierung der von au√üen aufrufbaren Methoden zu sehen.;0
Evaluierung des Trackings der Bodenfeuchtigkeit mit LoRaWAN und The Things Network (TTN)  In den letzten Jahren hat die √úberwachung der Bodenfeuchtigkeit zunehmend an Bedeutung gewonnen, insbesondere im Kontext der Landwirtschaft, Umweltforschung und nachhaltigen Ressourcennutzung. Eine vielversprechende Technologie zur Erfassung und √úbertragung von Bodenfeuchtigkeitsdaten ist das Long Range Wide Area Network (LoRaWAN), das in Kombination mit The Things Network (TTN) eine kosteneffiziente und skalierbare L√∂sung bietet. Diese Evaluierung beleuchtet die Vorz√ºge, Herausforderungen und Anwendungsbereiche des Trackings der Bodenfeuchtigkeit unter Verwendung dieser Technologien.  Technologische Grundlagen  LoRaWAN ist ein Low-Power-Wide-Area-Network (LPWAN), das f√ºr die drahtlose Kommunikation √ºber gro√üe Entfernungen mit minimalem Energieverbrauch konzipiert wurde. Die Technologie erm√∂glicht es Sensoren, Daten √ºber mehrere Kilometer zu √ºbertragen, was sie ideal f√ºr l√§ndliche und schwer zug√§ngliche Gebiete macht. TTN fungiert als offene, gemeinschaftsbasierte Netzwerkplattform, die es Benutzern erm√∂glicht, ihre eigenen LoRaWAN-Ger√§te zu verbinden und Daten in Echtzeit zu empfangen und zu verarbeiten.  Vorteile des Trackings der Bodenfeuchtigkeit  Die Implementierung von LoRaWAN und TTN zur √úberwachung der Bodenfeuchtigkeit bietet mehrere Vorteile. Erstens erm√∂glicht die gro√üe Reichweite der LoRaWAN-Technologie die Installation von Sensoren in weitl√§ufigen landwirtschaftlichen Fl√§chen, ohne dass eine aufwendige Infrastruktur erforderlich ist. Zweitens sorgt die Energieeffizienz der Sensoren daf√ºr, dass sie √ºber lange Zeitr√§ume ohne regelm√§√üige Wartung oder Batteriewechsel betrieben werden k√∂nnen. Drittens bietet TTN eine benutzerfreundliche Schnittstelle zur Datenvisualisierung und -analyse, wodurch Landwirte und Forscher schnell auf relevante Informationen zugreifen k√∂nnen.  Ein weiterer entscheidender Vorteil ist die M√∂glichkeit, pr√§zise Bew√§sserungssysteme zu implementieren. Durch die kontinuierliche √úberwachung der Bodenfeuchtigkeit k√∂nnen Landwirte ihre Bew√§sserungsstrategien optimieren, was zu einer Reduzierung des Wasserverbrauchs und einer Verbesserung der Ernteertr√§ge f√ºhrt. Diese Effizienzsteigerung ist besonders in Regionen von Bedeutung, die unter Wasserknappheit leiden.  Herausforderungen und Limitationen  Trotz der zahlreichen Vorteile gibt es auch Herausforderungen, die bei der Implementierung von LoRaWAN und TTN zur Bodenfeuchtigkeits√ºberwachung ber√ºcksichtigt werden m√ºssen. Eine der gr√∂√üten Herausforderungen ist die Abdeckung und Signalst√§rke in bestimmten geografischen Regionen. In dicht bewaldeten oder bergigen Gebieten kann die Signal√ºbertragung beeintr√§chtigt sein, was zu Datenverlust oder verz√∂gerten √úbertragungen f√ºhren kann.  Zudem erfordert die Einrichtung eines LoRaWAN-Netzwerks technisches Know-how, sowohl in der Auswahl der geeigneten Sensoren als auch in der Konfiguration des Netzwerks. Dies kann insbesondere f√ºr kleinere Betriebe eine H√ºrde darstellen, die m√∂glicherweise nicht √ºber die erforderlichen Ressourcen oder das Fachwissen verf√ºgen.  Ein weiteres Problem ist die Datensicherheit und der Datenschutz. Da die gesammelten Daten in der Regel √ºber √∂ffentliche Netzwerke √ºbertragen werden, besteht das Risiko, dass sie abgefangen oder manipuliert werden. Daher;1
Es hat eine Vorstellung der verschiedenen √úberwachungstechniken im Buch stattgefunden. Nun sollen diese Arten der √úberwachungstechniken anhand realer Beispiele und Techniken Ein gro√üer Punkt im Buch hinsichtlich √úberwachung ist auf jeden Fall die Video√ºberwa- chung. Diese ist im Buch in London, der Heimatstadt der Protagonistin, stark vertreten. Dies entspricht auch der Wirklichkeit. Abbildung 2.1: Video√ºberwachungskamera ( Analogique ou IP 2019) Video√ºberwachung ist per Definition die Beobachtung von Personen, Orten oder Objekten durch optische √úberwachungsger√§te (Luber 2022). Dabei besteht eine √úberwachungsanlage in der Regel aus: ‚Ä¢Videokameras ‚Ä¢Monitoren ‚Ä¢Speicherger√§ten ‚Ä¢Netzwerktechnik ‚Ä¢Analysesoftware Dies wird auch gerne Video√ºberwachungsanlage oder auf Englisch Closed Circuit Televisi- on (CCTV) genannt. Dabei gibt es noch weitere Aufnahmetechniken, wie Infrarot oder W√§rmebildkameras ( Video√ºberwachung | SICHERHEITSFAKTOR | SICHERHEITSFAK- TOR2022). Das Speichern und auswerten der Daten erfolgt dann auf Servern. Dort kann dann mithilfe der gespeicherten Daten eine KI erzeugt werden, welche zum Beispiel f√ºr die Gesichtserkennung trainiert wird. √úberwachungskameras werden weltweit eingesetzt. Oft handelt es sich dabei um Netzwerkkameras. Das erlaubt die √úberwachung dieser auf Monitoren, die an einem andern Ort sind.;0
Java und Kotlin sind sehr vielseitig einsetzbare objektorientierte Programmiersprachen. Java wird h√§uÔ¨Åg f√ºr die Backend-Entwicklung verwendet, wobei die St√§rken von Kotlin in Mobilanwendungen f√ºr Android-Ger√§te liegen.;0
"Die Polizei kann durch Vorhersagen auch bei ihrer T√§tigkeit unterst√ºtzt  werden. So k√∂nnen  an Orten mit hohen Wahrscheinlichkeiten pr√§ventiv Streifen vorbeifahren, um Verbrechen  zu verhindern. Dabei beruht das auf Auswertung von verschiedene Daten der Vergangenheit,  um Vorhersagen zu treffen. Dazu kann Software wie ‚ÄûPreCobs‚Äú benutzt werden. In den  USA wird solche Software schon l√§nger eingesetzt, um die Polizei zu unterst√ºtzen. In  Deutschland laufen Testbetriebe dazu. Straftaten und andere kleine Delikte sollen also  durch Pr√§senz der Polizei an den richtigen  Stellen verhindert  werden (Lum und Isaac  2016; PreMAP ‚Äì Predictive Policing (Vorausschauende  Polizeiarbeit) in Niedersachsen | Landeskriminalamt Niedersachsen 2022; Povalej  und Volkmann 2021; Rundfunk 2020). Es  sollen keine vorbeugenden Verhaftungen vorgenommen werden wie in ‚ÄûMinority Report‚Äú. Nicht nur bei Straftaten kann predictive analytics helfen. Sondern auch im Bereich f√ºr  Versicherungen, um Risikomanagement zu optimieren  und Absch√§tzungen f√ºr das Risiko  eines Kunden zu tragen. Die Wettervorhersage  l√§uft  auch mit Vorhersagemodellen, welche  mit KI trainiert werden und dann  nach mehrfachen Durchl√§ufen das passendste genommen.   Die Finanzwelt investiert auch ordentlich  in predictive analytics, da sie mit Kursvorhersagen  viel Geld verdienen kann. Dies trifft insbesondere auf den Hochfrequenzhandel zu. Allerdings  l√§sst sich das in diktatorischen Staaten nutzen, um vorherzusagen, wer Probleme machen wird. So  ungef√§hr wie Freemee das im Buch macht, um nicht in Probleme zu geraten, sondern diese zu  beseitigen.";0
Das Dependency -Inversion -Prinzip besch√§ftigt sich ebenfalls mit den Faktoren Stabilit√§t und  Abstraktion, indem es besagt, dass Abh√§ngigkeiten zwischen Elementen in Richtung der Abstraktion  verlaufen sollen. Wird diese Regel gebrochen besteht neben der erschwerten √Ñnderbarkeit zudem  die Gefahr, dass zyklische Abh√§ngigkeiten entstehen.  Diese f√ºhren zu einer erh√∂hten Kopplung der  Elemente. Ziel des Dependency -Inversion -Prinzips ist es jedoch Kopplung zu minimieren, um  wiederum eine hohe √Ñnderbarkeit zu erreichen.   Auch das Open -Closed -Prinzip besch√§ftigt sich mit der Problematik der √Ñnderbarkeit bei  gleichzeitiger Zuverl√§ssigkeit der Schnittstelle . Hier steh t die Erweiterbarkeit als Qualit√§tskriterium im  Fokus, um Anpassungen zu erm√∂glichen ohne Auswirkungen auf abh√§ngige Klassen zu bewirken.   Wird dieses Vorhaben konsequent umgesetzt, kann neben der erh√∂hten Wartbarkeit auch eine gute  Wiederverwendbarkeit erreicht werden.   Das Konzept der Datenkapselung befasst sich ebenfalls mit der Stabilit√§t von Schnittstellen bei  gleichzeitiger hoher Wartbarkeit.  Hier ist eine √Ñnderbarkeit der Klasse jedoch gegeben , da die  Implementierung der Klasse nicht √∂ffentlich zug√§nglich ist und sich folglich bei Anpassungen keine  Auswirkungen auf andere Module ergeben.  Die konkrete Umsetzung innerhalb der Klasse  kann  frei  gestaltet werden, da das Information -Hiding -Prinzip f√ºr Flexibilit√§t sorgt.  Neben einer erh√∂hten  √Ñnderbarkeit wirkt sich das Prinzip der Datenkapselung auch positiv auf die Lesbarkeit und  Verst√§ndlichkeit aus, da bei Verwendung der Klasse nur das Interface relevant ist. Eine Steigerung  der Qualit√§t ergibt sich auch im Hinblick auf die Testbarkeit der Klasse. Dies wird dadurch erreicht,  dass die Anzahl der von au√üen erreichbare n Methoden und Attribute eingeschr√§nkt wird  und auch  die M√∂glichkeiten eine Variable zu manipulieren reduziert werden. Damit ergeben sich  weniger  m√∂gliche Interaktionen  und somit weniger Szenarien , die getestet werden m√ºssen .   Das Konzept der Vererbung, das im Bereich der Objektorientierung eine zentrale Rolle spielt und  auch f√ºr die Softwareentwicklung im Allgemeinen von gro√üer Bedeutung ist, beruht auf dem Aufbau  einer Klassenhierarchie.  Durch die Einf√ºhrung v on Eltern - und Kind -Komponenten, k√∂nnen  einerseits  Gemeinsamkeiten verwandte r Klassen erkannt  und somit eine Duplikation von Quellcode vermieden  werden . Zugleich  werden  individuelle Eigenschaften der  einzelnen  Klassen ber√ºcksichtigt . Erbende  Klassen bauen auf der √ºbergeordneten Komponente  auf und erweitern diese um ihre spezifischen  Funktionalit√§ten.  Dadurch kommt es zu einer stark verbesserten Wiederverwendbarkeit.  Da es sich  um eine Erweiterung beziehungsweise Spezialisierung handelt, sind die Eigenschaften des Parents  weiterhin gegeben und es kann zur Laufzeit eine Typsicherheit gew√§hrleistet werden. Die  Erweiterbarkeit der Klassen wird durch das Vererbungs-Konzept enorm verbessert.         Auf Grundlage der im vorigen Kapitel ausgew√§hlten Qualit√§tsfaktoren, soll im Folgenden die  Messung und Bewertung des Softwareprodukts durchgef√ºhrt werden. Dazu werden die in Kapitel  3  Methodik  festgelegten Schritte abgearbeitet, die den Prozess der Produktmessung abbilden.   5.1 Bestimmung von Softwaremetriken   Wer nicht genau wei√ü, wohin er will, der darf sich nicht wundern, wenn er ganz  woanders ankommt. ‚Äì Mark Twain   Beim Umgang mit Metriken besteht die Gefahr, dass diejenigen Ma√üe herangezogen werden, die  leicht zu messen sind, anstatt wirklich zielf√ºhrende Metriken auszuw√§hlen.  Aus diesem Grund wird  die konsequente Anwendung von Methoden zur Auswahl von Metriken, die  zur Beantwortung der  Fragestellung beitragen, empfohlen.   5.1.1 Auswahl von Metriken in Hinblick auf Faktoren der Codequalit√§t   Der erste Ansatz, der zur Auswahl geeigneter Softwaremetriken angewandt werden soll, ist der  Factor -Criteria -Metrics -Approach , der in Kapitel 2.2.5.2  FCM -Ansatz  bereits beschrieben wurde. Der  Fokus soll hierbei auf Merkmalen liegen, die f√ºr die Software - und besonders die Codequalit√§t  entscheidend sind. Dazu werden zun√§chst die Faktoren zusammengefasst, die zur Bewertung der  Qualit√§t von Quellcode herangezogen werden k√∂nnen. Im zweiten Schritt werden diese  Qualit√§tsfaktoren durch Kriterien , die in der Literatur zur Bewertung von Softwarequalit√§t  vorgeschlagen werden , genauer definiert , um daraus letztlich Metriken ableiten zu k√∂nnen.   5.1.1.1  Zusammenfassung relevanter Qualit√§tsfaktoren   Im ersten Schritt zur Auswahl relevanter Metriken, muss die Softwarequalit√§t durch eine Menge  geeigneter Qualit√§tsfaktoren definiert werden. Wie in Kapitel 4.1 Ableitung von Faktoren aus der  Literatur  dargelegt wurde, besteht eine starke Korrelation zwischen Wartbarkeit und Code qualit√§t.  Als Ausgangspunkt der Methodik Factor -Criteria -Metrics, soll daher nur der Faktor ‚ÄûMaintainability‚Äú  herangezogen werden , der den zu betrachtenden Teil der Softwarequalit√§t repr√§sentiert .  5.1.1.2  Definition von Qualit√§tskriterien   Der Faktor der Wartbarkeit, der eng  mit der Codequalit√§t verbunden ist, wird nun anhand relevanter  Qualit√§tskriterien genauer definiert. Dazu wurden Standardwerke im Bereich der Softwarequalit√§t  herangezogen.;0
Bei jeder erhaltenen Benachrichtigung von der Katzenerkennung wird auch ein Bild von der erkannten Katze mit gesendet. In dem Data Block der Benachrichtigung befindet sich ein Link, welcher zum Katzenbild, welches sich in der Firestore Storage Datenbank befindet, zeigt. Die Firestore Storage Datenbank ist eine Datenbank von Firebase. In dieser k√∂nnen Dateien gespeichert werden. Anhand eines Links auf die Datei kann diese von der Firestore Storage Datenbank erhalten werden. Dies ist f√ºr die Katzenbilder notwendig, da die Bildatei zu gro√ü ist, um diese in einer Nachricht zu versenden. MitFirebaseUtils().fireStoreStorageDatabase.getReferenceFromUrl(url) kann die erhaltene URL aus der Push-Benachrichtigung als Parameter √ºbergeben werden. Der R√ºckgabewert ist eine Referenz, welche auf das Katzenbild zeigt. Von dieser Referenz k√∂nnen anschlie√üend die Bildinformationen in Form eines ByteArrays gespeichert werden.;0
Konzept und Umsetzung    In der heutigen Zeit, in der digitale Technologien zunehmend in den Bildungsbereich Einzug halten, wird die Notwendigkeit, praxisnahe und interaktive Lernumgebungen zu schaffen, immer offensichtlicher. Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f√ºhrenden Protokolle f√ºr das Internet der Dinge (IoT) etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz eignet sich MQTT hervorragend f√ºr den Einsatz in Bildungsszenarien, die den Studierenden die Prinzipien der Kommunikation zwischen Ger√§ten n√§herbringen sollen. In diesem Prosatext wird ein Konzept zur  vorgestellt, das sowohl technische als auch didaktische Aspekte ber√ºcksichtigt.  Konzeptualisierung  Das erste Element des Konzepts besteht in der Definition der Lernziele. Diese sollten sowohl technischer als auch praktischer Natur sein. Zu den angestrebten Lernzielen z√§hlen 1. Verst√§ndnis der MQTT-ProtokolleDie Studierenden sollen die Grundlagen des MQTT-Protokolls, einschlie√ülich seiner Architektur, der Funktionsweise von Publishern und Subscribern sowie der Bedeutung von Topics, verstehen.  2. Praktische AnwendungDie Studierenden sollen in der Lage sein, eigene MQTT-Anwendungen zu entwickeln und zu implementieren, um das erlernte Wissen praktisch anzuwenden.  3. Fehlerdiagnose und -behebungEin weiterer wichtiger Aspekt ist die F√§higkeit, Fehler in der Kommunikation zwischen MQTT-Ger√§ten zu erkennen und zu beheben.  Um diese Lernziele zu erreichen, wird ein virtuelles Szenario entwickelt, das verschiedene Komponenten umfasst. Diese Komponenten sind in der folgenden Struktur organisiert 1. Virtuelle UmgebungDie Verwendung von Simulationssoftware wie Node-RED oder Eclipse Mosquitto erm√∂glicht es, eine kontrollierte Umgebung zu schaffen, in der die Studierenden verschiedene MQTT-Szenarien ausprobieren k√∂nnen. Diese Software bietet eine grafische Benutzeroberfl√§che, die das Verst√§ndnis der Datenfl√ºsse zwischen Publishern und Subscribern erleichtert.  2. Szenarien und Anwendungsf√§lleEs werden verschiedene Anwendungsf√§lle entwickelt, die den Studierenden helfen, die vielseitigen Einsatzm√∂glichkeiten von MQTT zu erkennen. Beispiele hierf√ºr sind die √úberwachung von Umweltdaten (z. B. Temperatur, Luftfeuchtigkeit) oder die Steuerung von Smart-Home-Anwendungen. Jedes Szenario wird mit spezifischen Aufgaben und Herausforderungen versehen, um die Studierenden aktiv in den Lernprozess einzubeziehen.  3. Interaktive LernmoduleDie Integration von interaktiven Lernmodulen, die Videos, Quizze und praktische √úbungen umfassen, wird die Studierenden zus√§tzlich motivieren und ihr Verst√§ndnis vertiefen. Diese Module sollten so gestaltet sein, dass sie sowohl theoretisches Wissen als auch praktische F√§higkeiten f√∂rdern.  4. Feedback-MechanismenUm den Lernprozess zu optimieren, ist es wichtig, Feedback-Mechanismen zu implementieren. Diese k√∂nnen in Form von automatisierten Tests oder Peer-Review-Systemen erfolgen, die den Studierenden eine R√ºckmeldung zu ihren Fortschritten geben.  Umsetzung  Die Umsetzung des Konzepts erfolgt in mehreren Phasen 1. ;1
 Konzeption f√ºr eine wissenschaftliche Arbeit: Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen   1. Einleitung In der Einleitung wird zun√§chst der Begriff der Internet of Things (IoT) definiert und die Bedeutung der Technologie f√ºr die moderne Gesellschaft er√∂rtert. Es wird auf die Herausforderungen eingegangen, die mit der Entwicklung und Implementierung von IoT-Anwendungen verbunden sind, wie z. B. die Sicherheit, Skalierbarkeit und Benutzerfreundlichkeit.   Anschlie√üend wird ElixirNerves als eine Plattform vorgestellt, die auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von IoT-Anwendungen konzipiert wurde. Ziel der Arbeit ist es, die St√§rken und Schw√§chen der ElixirNerves-Plattform zu evaluieren und ihren Einsatz in der IoT-Entwicklung zu beurteilen.   2. Problemstellung Die Problemstellung umfasst folgende Fragen: - Welche spezifischen Anforderungen haben IoT-Anwendungen? - Inwiefern erf√ºllt ElixirNerves diese Anforderungen im Vergleich zu anderen IoT-Plattformen? - Welche Vor- und Nachteile bietet ElixirNerves f√ºr Entwickler und Unternehmen?   3. Zielsetzung Das Ziel dieser Arbeit ist es, eine umfassende Evaluation von ElixirNerves als Entwicklungsplattform f√ºr IoT-Anwendungen zu liefern. Dabei sollen sowohl die technischen als auch die praktischen Aspekte der Plattform beleuchtet werden. Die Ergebnisse der Evaluation sollen als Grundlage f√ºr zuk√ºnftige Entscheidungen hinsichtlich der Verwendung von ElixirNerves in der IoT-Entwicklung dienen.   4. Methodik Um die Evaluation durchzuf√ºhren, wird eine Kombination aus qualitativen und quantitativen Forschungsmethoden angewendet:  - Literaturrecherche: Analyse bestehender wissenschaftlicher Arbeiten, Fachartikel und Dokumentationen zu ElixirNerves und verwandten Technologien. - Fallstudien: Auswahl und Untersuchung von bestehenden IoT-Projekten, die mit ElixirNerves umgesetzt wurden. Hierbei werden Erfolgsfaktoren sowie Herausforderungen identifiziert. - Interviews: Durchf√ºhrung von Interviews mit Entwicklern und Unternehmen, die Erfahrung mit ElixirNerves haben, um deren Meinungen und Perspektiven zu sammeln. - Benchmark-Tests: Durchf√ºhrung von Performance-Tests gegen andere g√§ngige IoT-Plattformen, um die Effizienz von ElixirNerves in spezifischen Szenarien zu quantifizieren.   5. Gliederung der Arbeit Die Struktur der Arbeit umfasst folgende Kapitel:  1. Einleitung    - Hintergrund und Motivation    - Problemstellung    - Zielsetzung und Fragestellung  2. Theoretischer Rahmen    - Definition und Eigenschaften von IoT    - √úberblick √ºber aktuelle IoT-Plattformen    - Einf√ºhrung in Elixir und Nerves  3. Methodik    - Beschreibung der angewandten Forschungsans√§tze    - Durchf√ºhrung und Dokumentation der Fallstudien    - Methodik der Interviews  4. Evaluation von ElixirNerves    - Technische Analyse: Architektur, Tools und Features    - Fallstudienanalyse: Erfolgreiche Implementierungen    - Interviews: Erfahrungen von Entwicklern    - Benchmark-Tests: Performance-Vergleich  5. Diskussion    - Interpretation der Ergebnisse    - St√§rken und Schw√§chen von ElixirNerves im IoT-Kontext    - Vergleich zu anderen Plattformen  6. Fazit und Ausblick    - Zusammenfassung der Ergebnisse    - Empfehlungen f√ºr Entwickler und Unternehmen    - M√∂gliche zuk√ºnftige Entwicklungen im Bereich ElixirNerves und IoT   6. Literaturverzeichnis Eine systematische Auflistung aller verwendeten Quellen, einschlie√ülich B√ºcher, Artikel, Online-Ressourcen und Interviews.   7. Anhang Zus√§tzliche Informationen wie die vollst√§ndigen Interviewtranskripte, Benchmark-Testergebnisse, Diagramme und Grafiken, die die Analyse unterst√ºtzen.  ---   Zeitplan - Literaturrecherche und -analyse: 4 Wochen - Durchf√ºhrung von Fallstudien und Interviews: 6 Wochen - Benchmark-Tests: 2 Wochen - Auswertung der Daten und Schreiben: 4 Wochen - √úberarbeitung und Abgabe der Arbeit: 2 Wochen   Fazit Diese Konzeption bietet eine strukturierte Grundlage f√ºr die wissenschaftliche Arbeit zur Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen. Die gew√§hlten Methoden und die klare Gliederung tragen dazu bei, die Zielsetzungen der Arbeit effektiv zu erreichen.;1
" Kapitel: M√∂glichkeiten und Gefahren der digitalen √úberwachung in Marc Elsbergs Roman ""Zero""  In seinem Roman ""Zero"" thematisiert Marc Elsberg die komplexen Wechselwirkungen zwischen digitaler √úberwachung, individueller Freiheit und gesellschaftlicher Kontrolle. Der Roman, der in einer nahen Zukunft angesiedelt ist, entwirft ein dystopisches Szenario, in dem die omnipr√§sente digitale √úberwachung sowohl als Werkzeug der Sicherheit als auch als Instrument der Unterdr√ºckung fungiert. Diese duale Natur der √úberwachung wirft grundlegende Fragen √ºber die M√∂glichkeiten und Gefahren auf, die mit der fortschreitenden Digitalisierung des Alltags verbunden sind.   M√∂glichkeiten der digitalen √úberwachung  Im Kontext von ""Zero"" wird die digitale √úberwachung zun√§chst als eine M√∂glichkeit dargestellt, die Sicherheit und Effizienz im Alltag zu erh√∂hen. Durch die Vernetzung von Ger√§ten und die Erfassung von Daten k√∂nnen potenzielle Bedrohungen fr√ºhzeitig identifiziert und neutralisiert werden. Die Protagonistin, die sich gegen ein System der totalen Kontrolle auflehnt, wird immer wieder mit den positiven Aspekten konfrontiert, die eine solche √úberwachung mit sich bringen kann. Beispielsweise k√∂nnen durch die Analyse von Verhaltensmustern Verbrechen pr√§ventiv verhindert werden. In einer Welt, in der Terrorismus und Kriminalit√§t omnipr√§sent sind, scheint die √úberwachung eine notwendige Ma√ünahme zur Aufrechterhaltung der √∂ffentlichen Sicherheit zu sein.  Elsberg zeigt auf, dass die digitale √úberwachung auch positive gesellschaftliche Effekte haben kann, etwa in der Bek√§mpfung von Verbrechen oder der Verbesserung von Gesundheitsdiensten durch die Analyse von Gesundheitsdaten. Diese M√∂glichkeiten sind jedoch stets mit einem hohen Ma√ü an Verantwortung und ethischen √úberlegungen verbunden. Die Frage bleibt, wo die Grenze zwischen Sicherheit und Freiheit verl√§uft und inwiefern das Individuum bereit ist, pers√∂nliche Freiheiten zugunsten eines vermeintlichen Schutzes aufzugeben.   Gefahren der digitalen √úberwachung  Gleichzeitig thematisiert ""Zero"" die Gefahren, die mit der digitalen √úberwachung einhergehen. Der Roman verdeutlicht, wie schnell aus einem Instrument zur Wahrung der Sicherheit ein Mittel zur Kontrolle und Unterdr√ºckung werden kann. Die allumfassende Datensammlung f√ºhrt zu einer Entmenschlichung der Gesellschaft, in der individuelle Identit√§ten und Freiheiten zugunsten von Algorithmen und Datenanalysen in den Hintergrund gedr√§ngt werden. Die Protagonistin wird Zeugin, wie Menschen aufgrund von verd√§chtigen Verhaltensmustern kriminalisiert werden, ohne dass eine tats√§chliche Straftat begangen wurde. Diese Form der pr√§ventiven √úberwachung f√ºhrt zu einem Klima des Misstrauens und der Angst, in dem jeder Schritt und jede Handlung √ºberwacht werden.  Elsberg thematisiert auch die Manipulation und den Missbrauch von Daten durch staatliche und private Akteure. Die Gefahr, dass Informationen in die falschen H√§nde geraten oder f√ºr politische Zwecke missbraucht werden, ist omnipr√§sent. Diese dystopische Vision wirft essentielle Fragen zur Privatsph√§re und zur Autonomie des Individuums auf. Der Roman regt dazu an, √ºber die ethischen Implikationen der digitalen √úberwachung nachzudenken und die Balance zwischen Sicherheit und Freiheit zu hinterfragen.   Fazit  In ""Zero"" gelingt";1
Die Arbeit ist gegliedert in sechs Kapitel. Da es sich um eine kooperative Arbeit handelt, sind diese Kapitel meist gemeinsam verfasst, jedoch sind pers√∂nliche Schwerpunkte bei den Aspekten der Implementierung gesetzt. Das vorangegangene Kapitel eins besch√§ftigt sich mit einer Einf√ºhrung sowohl in die Materie, als auch in die Umsetzung des Projekts, auf welchem diese Arbeit aufbaut. Dem folgt in Abschnitt zwei eine √úbersicht √ºber Grundlagen und theoretische Voraussetzungen und Technologien, die in dieser Arbeit verwendet werden. Kapitel drei besch√§ftigt sich mit der Architektur des implementierten Systems sowie mit dem Aufbau und Funktionen der Controllers. Dabei wird sowohl auf die Funktionsweise des steuernden Elements eingegangen, als auch auf Kommunikation dessen mit anderen Modulen. Auch die Anbindung an genutzte Firebase-Dienste wird beschrieben, da diese das Gateway der Basisstation nach au√üen darstellen. Im vierten Kapitel wird die Erkennung von Katzen beleuchtet. Dabei wird sowohl auf geeignete Hardware zur Umsetzung eines solchen Systems eingegangen, als auch auf die Wahl eines passenden Convolutional neural network (CNN)-Modells f√ºr die Katzenerken- nung. Diese werden Evaluiert sowie die Implementierung im Rahmen des umgebenden Systems weiter erl√§utert. In Kapitel f√ºnf steht die Android App im Fokus. Im Bezug auf diese wird sowohl auf den Aufbau der App eingegangen, als auch auf die Kommunikation dieser mit den genutzten Online-Services und die Implementierung mit Jetpack-Compose. Zum Schluss findet in Kapitel sechs eine Reflexion der Arbeit statt. Dabei werden entstan- dene Probleme angesprochen und ein Ausblick in potenzielle Erweiterungen gegeben. F√ºr ein gutes allgemeines Verst√§ndnis werden im Folgenden Grundlagen zu den einzel- nen Schwerpunkten, IoT-Architektur, Katzen- bzw. Objekterkennung und Android App Entwicklung dargelegt.;0
Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachungEine   Die digitale √úberwachung nimmt in der modernen Gesellschaft eine omnipr√§sente Rolle ein, auf die sowohl Regierungen als auch Unternehmen zur√ºckgreifen. Dabei bietet das Projekt ‚ÄûZero‚Äú ‚Äì ein fiktives Beispiel f√ºr ein umfassendes digitales √úberwachungssystem ‚Äì sowohl vielversprechende M√∂glichkeiten als auch erhebliche Gefahren. Eine kritische Evaluation dieses Projekts zeigt, wie technologische Fortschritte nicht nur die Effizienz von √úberwachungsma√ünahmen steigern k√∂nnen, sondern auch fundamentale Fragen des Datenschutzes und der individuellen Freiheit aufwerfen.  M√∂glichkeiten der digitalen √úberwachung  Das Projekt Zero ist entwickelt worden, um Daten in Echtzeit zu sammeln, zu analysieren und zu verarbeiten. Durch den Einsatz von K√ºnstlicher Intelligenz (KI) und Big Data-Analytik k√∂nnen gro√üfl√§chige Datenmengen aus unterschiedlichsten Quellen aggregiert werden ‚Äì von sozialen Medien √ºber Online-Transaktionen bis hin zu Standortdaten von Mobilger√§ten. Diese Technologie er√∂ffnet weitreichende M√∂glichkeiten zur Verbesserung der √∂ffentlichen Sicherheit, zur Verbrechenspr√§vention und zur Optimierung von Dienstleistungen.  Ein wesentlicher Vorteil von Zero liegt in der proaktiven Identifikation potenzieller Gefahren. Durch algorithmische Mustererkennung k√∂nnten Sicherheitsbeh√∂rden in der Lage sein, kriminelle Handlungen im Vorfeld zu erkennen und einzud√§mmen. Weiterhin bietet Zero die M√∂glichkeit, soziale Ungleichheiten zu analysieren und gezielte politische Ma√ünahmen zu entwickeln, die auf empirischen Daten basieren. Die Effizienz der Ressourcennutzung k√∂nnte durch eine datengetriebene Entscheidungsfindung erheblich gesteigert werden.  Gefahren der digitalen √úberwachung  Trotz dieser vielversprechenden M√∂glichkeiten birgt die digitale √úberwachung durch Projekte wie Zero auch erhebliche Risiken. Eine der gravierendsten Gefahren ist die potenzielle Verletzung von Datenschutzrechten. Die umfangreiche Sammlung personenbezogener Daten schafft eine Datenbasis, die leicht f√ºr missbr√§uchliche Zwecke verwendet werden kann. Im schlimmsten Fall kann dies zu Vorurteilen bei der Datenanalyse und der Diskriminierung bestimmter Bev√∂lkerungsgruppen f√ºhren. Wenn Daten aus sozialen Medien oder anderen Plattformen ohne ausdr√ºckliche Zustimmung gesammelt werden, wird dies zu einem ernsthaften Problem der Transparenz und der informierten Zustimmung.  Ein weiteres Risiko ist die Schaffung eines √úberwachungsstaates, in dem individuelle Freiheiten und Privatsph√§re zugunsten der vermeintlichen Sicherheit stark eingeschr√§nkt werden. Die potentielle Normalisierung von √úberwachung k√∂nnte die Gesellschaft in eine Kultur der Angst und des Misstrauens verwandeln, in der B√ºrger st√§ndig √ºberwacht werden und sich selbst zensieren. In einer solchen Umgebung besteht die Gefahr, dass die B√ºrger ihre Rechte auf Meinungsfreiheit und Versammlungsfreiheit als gef√§hrdet wahrnehmen und sich dadurch in ihrem gesellschaftlichen Engagement zur√ºckhalten.  Evaluierung der Effizienz und der ethischen Implikationen  Die  Zero erfordert eine multidimensionale Betrachtungsweise, die sowohl quantitative als auch qualitative Kriterien umfasst. Die Effektivit√§t des Systems k√∂nnte durch die Analyse von Verbrechensstatistiken in √ºberwachten versus nicht √ºberwachten Gebieten gemessen werden. Gleichzeitig ist es entscheidend, die gesellschaftlichen und ethischen Auswirkungen zu reflektieren. Hierbei sollten Stakeholder ‚Äì einschlie√ülich Menschenrechtsorganisationen, Datenschutzexperten und der Zivilgesellschaft ‚Äì einbezogen werden, um eine umfassende Perspektive zu gew√§hrleisten.  Ein transparenter und partizipativer Evaluationsprozess ist unerl√§sslich, um das Vertrauen der Bev√∂lkerung in digitale √úberwachungssysteme zu f√∂rdern. Dabei sollte eine Balance zwischen Sicherheit und den Rechten des Individuums gefunden werden. Ma√ünahmen wie regelm√§√üige Audits, unabh√§ngige √úberpr√ºfungen und klare Richtlinien zur Datennutzung k√∂nnten dazu beitragen, Missbrauch zu verhindern und die √∂ffentliche Kontrolle √ºber das √úberwachungssystem zu st√§rken.  Fazit  Die  Zero verdeutlicht, dass digitale √úberwachung sowohl Chancen als auch Risiken bietet. W√§hrend technologische Innovationen die M√∂glichkeit er√∂ffnen, gesellschaftliche Probleme effektiver zu adressieren, ist es von gr√∂√üter Bedeutung, die potenziellen Gefahren f√ºr die individuellen Freiheiten und den Datenschutz nicht aus den Augen zu verlieren. Eine sorgf√§ltige, transparente und inklusive Evaluierung ist erforderlich, um sicherzustellen, dass Projekte wie Zero im Dienst der Gesellschaft stehen und nicht zu Instrumenten der sozialen Kontrolle werden. Es liegt an uns, einen ethischen Rahmen zu schaffen, der sowohl den technologischen Fortschritt als auch die bewahrten Werte der Freiheit und Privatsph√§re sch√ºtzt.;1
 Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen besch√§ftigt und dabei sowohl die technischen als auch die praktischen Aspekte dieser innovativen Technologie beleuchtet. Die Ergebnisse zeigen, dass ElixirNerves aufgrund seiner Flexibilit√§t, Skalierbarkeit und der Unterst√ºtzung f√ºr moderne Softwareentwicklungsmethoden eine vielversprechende Grundlage f√ºr die Entwicklung von IoT-L√∂sungen darstellt.   Im Ausblick auf zuk√ºnftige Forschungen und Entwicklungen in diesem Bereich ergeben sich mehrere interessante Perspektiven. Zun√§chst k√∂nnten weitere empirische Studien durchgef√ºhrt werden, um die Performance von ElixirNerves in realen Anwendungsf√§llen zu messen. Dabei w√§re es sinnvoll, verschiedene IoT-Szenarien zu betrachten, um die St√§rken und Schw√§chen der Plattform in unterschiedlichen Kontexten zu identifizieren. Insbesondere die Integration von Machine Learning und K√ºnstlicher Intelligenz in IoT-Anwendungen k√∂nnte ein spannendes Forschungsfeld darstellen, in dem ElixirNerves eine Schl√ºsselrolle spielen k√∂nnte.  Ein weiterer Aspekt, der in zuk√ºnftigen Arbeiten vertieft werden sollte, ist die Interoperabilit√§t von ElixirNerves mit anderen IoT-Plattformen und -Standards. Die F√§higkeit, nahtlos mit bestehenden Technologien und Protokollen zu kommunizieren, ist entscheidend f√ºr den breiten Einsatz von IoT-L√∂sungen. Hierbei k√∂nnten auch Fragen der Sicherheit und des Datenschutzes in den Fokus r√ºcken, da diese Themen f√ºr die Akzeptanz von IoT-Anwendungen von zentraler Bedeutung sind.  Dar√ºber hinaus k√∂nnte eine Untersuchung der Community und des √ñkosystems rund um ElixirNerves wertvolle Erkenntnisse liefern. Die Unterst√ºtzung durch eine aktive Entwicklergemeinschaft, sowie die Verf√ºgbarkeit von Ressourcen und Dokumentationen, sind entscheidende Faktoren f√ºr den langfristigen Erfolg einer Plattform. Ein Vergleich mit anderen IoT-Plattformen k√∂nnte hier Aufschluss √ºber die relative Attraktivit√§t von ElixirNerves geben.  Zusammenfassend l√§sst sich sagen, dass ElixirNerves als Plattform f√ºr IoT-Anwendungen gro√ües Potenzial bietet. Die vorliegende Arbeit hat die Grundlagen hierf√ºr gelegt, doch die Reise ist noch lange nicht zu Ende. Zuk√ºnftige Forschungen werden entscheidend sein, um die M√∂glichkeiten und Herausforderungen dieser Plattform weiter zu erkunden und letztlich zur Schaffung robuster und innovativer IoT-L√∂sungen beizutragen.;1
      In der heutigen Zeit, in der Luftqualit√§t eine zunehmend zentrale Rolle f√ºr das Wohlbefinden des Menschen spielt, ist die Entwicklung effizienter Luftreinigungssysteme von gro√üer Bedeutung. Die Integration elektronischer Komponenten in Luftreinigungsger√§te erm√∂glicht nicht nur eine effektive Reinigung der Luft, sondern auch eine intelligente Steuerung und Visualisierung der Betriebsparameter. Ziel dieses Textes ist es, ein Konzept zur Optimierung der Visualisierung, Bedienung und Selbstregelung eines solchen Ger√§tes zu entwickeln.   1. Visualisierung der Betriebsdaten  Die effektive Visualisierung der Betriebsdaten ist entscheidend f√ºr die Benutzerfreundlichkeit. Ein Konzept zur Optimierung k√∂nnte die Entwicklung eines interaktiven Displays umfassen, das relevante Informationen in Echtzeit anzeigt. Dazu geh√∂ren - Luftqualit√§tsindex (AQI)Eine kontinuierliche √úberwachung und Anzeige des AQI, um den Benutzer √ºber die aktuelle Luftqualit√§t zu informieren. - Partikel- und SchadstoffkonzentrationGrafische Darstellungen der Konzentrationen von PM2.5, PM10, VOCs und anderen Schadstoffen, die in der Luft vorhanden sind. - FilterstatusEine Anzeige des Filters, die den Benutzer darauf hinweist, wann eine Reinigung oder ein Austausch erforderlich ist.  KonzeptionsvorschlagDie Implementierung eines Touchscreens, der adaptive Benutzeroberfl√§chen bietet, um die Informationen klar und intuitiv zu pr√§sentieren. Eine Farbskala kann verwendet werden, um kritische Werte hervorzuheben und somit sofortige Aufmerksamkeit zu generieren.   2. Bedienung des Ger√§tes  Die Benutzerfreundlichkeit ist ein Schl√ºsselmerkmal jedes technischen Ger√§tes. Um die Bedienung des Luftreinigers zu optimieren, sollten folgende Aspekte ber√ºcksichtigt werden - Einfache NavigationEine klar strukturierte Men√ºf√ºhrung mit einer minimalen Anzahl an Schritten zur Erreichung der gew√ºnschten Funktion (z.B. Modus√§nderungen, Timer-Settings). - SprachsteuerungIntegration eines Sprachassistenzsystems, welches die Bedienung hands-free erm√∂glicht und den Nutzern eine noch bequemere Kontrolle des Ger√§tes bietet. - Smartphone-IntegrationDie Entwicklung einer mobilen App, die den Nutzern erlaubt, den Luftreiniger aus der Ferne zu steuern und zu √ºberwachen, wodurch die Benutzerfreundlichkeit erheblich gesteigert wird.  KonzeptionsvorschlagDurchf√ºhrung von Benutzerstudien, um die h√§ufigsten Anwendungsf√§lle zu identifizieren und das Design der Benutzeroberfl√§che sowie die angebotenen Funktionen entsprechend anzupassen. Iterative Prototypen k√∂nnen die praktischen Anforderungen der Nutzer ber√ºcksichtigen.   3. Selbstregelung des Ger√§tes  Die Selbstregelung spielt eine zentrale Rolle bei der Optimierung der Betriebsdauer und Energieeffizienz des Luftreinigers. Ein intelligentes Steuerungssystem k√∂nnte die folgenden Funktionen beinhalten - Automatische AnpassungSensoren zur Erfassung von Luftqualit√§tsdaten, die eine automatische Anpassung der Reinigungsstufen erm√∂glichen, um eine optimale Effizienz zu gew√§hrleisten. - Lernf√§hige AlgorithmenImplementierung von Machine-Learning-Algorithmen, die das Benutzerverhalten analysieren und das Ger√§t entsprechend anpassen, um den Energieverbrauch zu minimieren. - EnergieeffizienzEin Modus, der die Leistung in Abh√§ngigkeit von der Tageszeit oder der Raumbelegung optimiert, kann erheblich zur Reduzierung des Energieverbrauchs beitragen.  KonzeptionsvorschlagEntwicklung eines Regelungssystems mit einer Feedback-Schleife, die es dem Ger√§t erlaubt, seine Betriebsparameter kontinuierlich zu √ºberwachen und anzupassen. Hierbei k√∂nnten Algorithmen zur Vorhersage von Luftqualit√§ts√§nderungen in Echtzeit eingesetzt werden, um pr√§ventiv Ma√ünahmen zu ergreifen.   Fazit  Die  stellt eine umfassende Herausforderung dar, die technologische Innovationen und ein tiefes Verst√§ndnis der Nutzerbed√ºrfnisse erfordert. Durch die Integration interaktiver Displays, intuitiver Bedienkonzepte und intelligenter Regelungssysteme kann die Effektivit√§t und Benutzerfreundlichkeit erheblich gesteigert werden. Zuk√ºnftige Forschung sollte sich auf die Evaluierung und Implementierung dieser Konzepte konzentrieren, um eine signifikante Verbesserung der Luftqualit√§t und des Nutzererlebnisses zu gew√§hrleisten.;1
Die in Kapitel  2.1.3  Prinzipien der Objektorientierung  eingef√ºhrten Konzepte dienen bei  konsequenter Umsetzung dem Erreichen √ºbergeordneter Qualit√§tsziele in der Softwareentwicklung.  Da die verschiedenen Prinzipien zum Teil stark miteinander verbunden sind, arbeiten sie auf √§hnliche  Ziele hin.   Das Single -Responsibility -Prinzip steigert durch die Aufteilung von  Verantwortlichkeiten in einzelne  Klassen die Modularit√§t. Auch die Wiederverwendbarkeit wird dadurch verbessert, dass die  eingef√ºhrten Klassen einen streng eingegrenzten Aufgabenbereich haben. Ein Faktor, der auf eine  gute Umsetzung dieses Prinzips un d somit auf das  Erreichen der genannten Ziele hindeutet, ist die  Koh√§sion einer Klasse. Durch eine starke Koh√§sion wird angezeigt, dass jede Klasse eine definierte  Aufgabe erf√ºllt und somit dem Single -Responsibility -Prinzip entspricht.    In eine √§hnliche Richtung weist das Interface -Segregation -Prinzip, hier wird jedoch der Umfang von  Schnittstellen betrachtet.  Das Prinzip fordert  eine Aufteilung umfangreicher Interfaces und somit die  Verwendung schlanker Schnittstellen  in einem modularen System . Durch koh√§sive Interfaces sowie  abstrakte Basisklassen, k√∂nnen die Ziele der Wartbarkeit und Wiederverwendbarkeit realisiert  werden.  Durch kompakteren Code und das Verzichten auf nicht ben√∂tigte  Implementierung von  Methoden , werden diese Ziele beg√ºnstigt.;0
Im Folgenden wird die Methodik festgelegt, nach der im weiteren Verlauf der Arbeit vorgegangen  werden soll. Es handelt sich dabei um den Prozess der Produktmessung, der aus mehreren Schritten  besteht.  Grundlage bildet die Bestimmung relevante r Metriken, die die zuvor definierten Messziele  quantifizieren k√∂nnen. Anhand dieser Metriken kann die eigentliche Messung f√ºr die einzelnen  Komponenten erfolgen, die im zu betrachtenden Bereich liegen, der zuvor abgegrenzt wurde.  Anschlie√üend folgen die Bewertung und Interpretation der gemessenen Werte. Dabei kann einerseits  ein Vergleich der Messdaten verschiedener Komponenten erfolgen, andererseits k√∂nnen Ergebnisse  fr√ºherer Messungen in die Analyse einbezogen werden. Ziel ist es auff√§llige Daten und som it kritische  Komponenten zu identifizieren, die negative Auswirkungen auf die Softwarequalit√§t haben k√∂nnten  und Kandidaten f√ºr ein Refactoring sind.   Die Vorgehensweise  wurde von verschiedenen ISO -Normen  sowie  aus dem von Sommerville  beschriebenen Messprozess abgeleitet.   Einerseits werden  die Standard s ISO/IEC  9126 sowie deren Nachfolger  ISO/IEC 25023 ber√ºcksichtigt, in denen  die Messung interner und  externer Softwarequalit√§t beschrieben werden . Die in diesen Normen enthaltenen Vorgaben sind  allgemeing√ºltig und erfordern eine konkrete Umsetzung und Anwendung f√ºr ein bestimmtes  Produkt. Eine allgemeinere Beschreibung von Messprozessen findet sich in der Norm  ISO/IEC/IEEE 15939 wieder, die die einzelnen Schritte des Prozesses einer Messung genau ausf√ºhrt.  Diese allgemeine Definition des Messprozess es sowie die von Sommerville dargelegte  Vorgehensweise stehen bei der Ableitung der eingesetzten Herangehensweise im Fokus.  Die daraus  entwickelte und im folgenden Verlauf angewendete Methodik ist in  Abbildung 7 grafisch dargestellt.   Zun√§chst muss festgelegt werden welche Messungen im Rahmen der Produktbetrachtung  durchgef√ºhrten werden sollen. Voraussetzung hierf√ºr ist die Definition von Zielen und  Anforderungen an das Softwareprodukt. Darunter fallen Qualit√§tsfaktoren sowie weitere f√ºr das  Projekt vorgeschriebene Prinzipien. Auf dieser Grundlage werden sinnvolle Ma√üe ausgew√§hlt, die zur  Beurteilung der einzelnen Faktoren herangezogen werden k√∂nnen. Dadurch wird sichergestellt, dass  nur relevante Metriken gemessen werden und keine Daten gesammelt werden, die nicht zielf√ºhrend  sind. Hier k√∂nnen die in Kapitel  2.2.5.1  GQM -Ansatz  sowie 2.2.5.2  FCM -Ansatz  vorgestellten  Methoden eingesetzt werden, die die geforderten Ziele fokussieren  und zur Auswahl geeigneter  Metriken f√ºr die zuvor definierten Qualit√§tskriterien beitragen .;0
 Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungAusblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und Vernetzung von Alltagsgegenst√§nden im Rahmen des Internets der Dinge (IoT) er√∂ffnet neue Perspektiven f√ºr die Automatisierung und Optimierung von Haustiermanagement-Systemen. Ein innovatives Beispiel hierf√ºr ist die Entwicklung eines IoT-Systems zur intelligenten Steuerung einer Katzenklappe, das auf einer KI-basierten Katzenerkennung beruht. Diese Technologie erm√∂glicht es, den Zugang f√ºr Katzen zu steuern, indem sie zwischen autorisierten und nicht autorisierten Tieren unterscheidet. Die Realisierung eines solchen Systems stellt jedoch nur den ersten Schritt in einem dynamischen Entwicklungsprozess dar, der zahlreiche M√∂glichkeiten f√ºr zuk√ºnftige Erweiterungen und Verbesserungen bietet.   Technologische Grundlagen und aktuelle Implementierung  Das bestehende System nutzt eine Kombination aus Kameratechnologie und maschinellem Lernen, um die Identit√§t der Katze zu erkennen. Hierbei kommen Bildverarbeitungsalgorithmen zum Einsatz, die auf Trainingsdatens√§tzen basieren, die Bilder von verschiedenen Katzenrassen und -gr√∂√üen enthalten. Die Erkennung erfolgt in Echtzeit, was eine sofortige Reaktion auf die Anwesenheit des Tieres erm√∂glicht. Die Integration in ein IoT-√ñkosystem erlaubt zudem die Fernsteuerung und -√ºberwachung √ºber mobile Endger√§te, was den Komfort f√ºr die Haustierbesitzer erh√∂ht.   M√∂gliche Weiterentwicklungen  1. Erweiterte SensortechnologieDie Integration zus√§tzlicher Sensoren k√∂nnte die Funktionalit√§t des Systems erheblich erweitern. Beispielsweise k√∂nnten Umgebungslichtsensoren, Temperaturf√ºhler oder Bewegungssensoren implementiert werden, um das Verhalten der Katze besser zu verstehen und die Klappensteuerung weiter zu optimieren. So k√∂nnte das System beispielsweise automatisch anpassen, ob die Klappe offen oder geschlossen ist, abh√§ngig von den aktuellen Wetterbedingungen.  2. Erweiterte BenutzerinteraktionDie Entwicklung einer benutzerfreundlichen App k√∂nnte es den Besitzern erm√∂glichen, nicht nur die Klappensteuerung zu √ºberwachen, sondern auch zus√§tzliche Funktionen zu nutzen, wie die Erstellung von Zeitpl√§nen f√ºr den Zugang, Benachrichtigungen √ºber die Aktivit√§ten der Katze oder sogar die M√∂glichkeit, √ºber eine Kamera in der Klappe zu sehen, was das Tier gerade tut.  3. Integration von GesundheitsmonitoringEine Weiterentwicklung k√∂nnte die Integration von Gesundheitsmonitoring-Features umfassen. Durch die Analyse von Bewegungsdaten und Verhaltensmustern k√∂nnte das System Hinweise auf gesundheitliche Probleme der Katze geben. Sensoren k√∂nnten beispielsweise das Gewicht der Katze √ºberwachen und Ver√§nderungen im Verhalten registrieren, die auf Stress oder Krankheit hinweisen.  4. K√ºnstliche Intelligenz und Machine LearningZuk√ºnftige Systeme k√∂nnten von einer fortschrittlicheren KI profitieren, die nicht nur die Katzenerkennung verbessert, sondern auch das Verhalten der Tiere lernt und vorhersagt. Dies k√∂nnte die Anpassung der Klappensteuerung an individuelle Bed√ºrfnisse der Katze erm√∂glichen, etwa durch die Erkennung von Stresssituationen oder von Zeiten, in denen die Katze besonders aktiv ist.  5. Interoperabilit√§t mit Smart Home-SystemenDie M√∂glichkeit, das Katzenklapp;1
"Abbildung 2.12: Aufteilung des 868 MHz-Band in Kan√§le
Die Eigenschaft des √úbertragungsmodus Time Division Multiplexing ( TDM)l√§sst
Endger√§te nicht dauerhaft ein Band oder Kanal belegen. Ger√§te senden intermittierend,
hei√üt nur zeitweise und nicht kontinuierlich. Dies ist ebenfalls in der SpeziÔ¨Åkation von
LoRa selbst deÔ¨Åniert und vorgesehen. Ein Problem was mit diesem Modus einhergeht ist,
dass die Ger√§te nicht untereinander synchronisiert sind und es so zu Kollisionen kommen
kann.
BeimSpread Spectrum senden mehrere Endger√§te gleichzeitig, auf ein und demselben
Kanal. Um eine Unterscheidung zu gew√§hrleisten wird mit einer bestimmten Signalstruktur
(sieheUnterunterabschnitt 2.2) gesendet. Diese Struktur erm√∂glicht es dem Empf√§nger
das eigentliche Signal √ºber das Rauschen hinweg zu extrahieren.
Abbildung 2.13: Spread Spectrum in Kan√§len des 868MHz-Band
Durch diese verwendeten und kombinierten Techniken wird es Nodes erm√∂glicht zur
Daten√ºbertragung aus mehreren Kan√§len zu w√§hlen. Selbst wenn mehrere Nodes denselben
Kanal nutzen w√ºrden, k√∂nnten durch das Spread Spectrum und die unterschiedliche
Signalstruktur, alle gleichzeitig senden. 
Neben den Multikanal-Gateways gibt es auch Einkanal-Gateways. Diese kosteng√ºnstigen
Ger√§te wurden fr√ºher als Einstiegsger√§te verwendet. Sie k√∂nnen LoRa-Pakete auf einem
einzigen bestimmten Spreadingfaktor und Kanal empfangen und im Anschluss mit dem
Netzwerk kommunizieren. Einkanal-Gateways waren recht g√ºnstig in der AnschaÔ¨Äung
und man konnte sie in Kombination mit einem Arduino oder Raspberry-Pi selbst bauen.";0
"3.4.4 ZugriÔ¨Ä auf die Kamera
Damit der ZugriÔ¨Ä auf die Kamera funktioniert, muss die App die Verwendung der Ka-
mera im Manifest deklarieren. Dies wird mit dem Hinzuf√ºgen der folgenden Listing 3.26
durchgef√ºhrt.
1<uses-feature android:name= ""android.hardware.camera"" android:required= ""
true""/>
Listing 3.26: Hinzuf√ºgen der Kamera-Berechtigungen
F√ºr das Einbinden der Kamera wird ein neues Fragment angelegt. Hier wird ein Button
und ein sogenanntes Image View hinzugef√ºgt. Daraus entsteht die folgende Ansicht:
Im Code des Fragments werden zwei Methoden hinzugef√ºgt, was in folgendem Listing 3.27
zu erkennen ist.
Die ‚ÄôdispatchTakePictureIntent‚Äô Methode erstellt einen neuen Intent, der auf die Kamera
zugreift und das Schie√üen eines Photos erlaubt. Um das Bild im Image View anzuzeigen,
wird die ‚ÄôonActivityResult‚Äô Methode verwendet. Die Methode wird aufgerufen, wenn das
Photo erfolgreich erstellt wurde. Das erstellte Bild wird in den Image View geladen.
Zuletzt wird im Fragment mithilfe von Bindings ein ‚ÄôonClickListener‚Äô zu dem erstellten
Button hinzugef√ºgt. Dieser ruft die ‚ÄôdispatchTakePictureIntent‚Äô Methode auf. Damit kann
der Nutzer √ºber den Button die Kamera √∂Ô¨Änen und ein Bild erstellen, welches ihm dann
in der App angezeigt wird.";0
Das Ziel dieser Arbeit ist die Analyse und Gegen√ºberstellung der vier Open-Source Content Management Systeme WordPress, TYPO3, Joomla und Drupal. Hierbei soll untersucht werden, welche Aspekte und Kriterien bei der Wahl eines geeigneten CMS f√ºr einen definierten Einsatzzweck eine Rolle spielen. Ferner ergibt sich aus diesen √úberlegungen heraus ein Auswahlschema, welches Unternehmen als Unterst√ºtzung bei der Wahl eines geeigneten CMS dient. Zun√§chst wird der Begriff der Content Management Systeme an sich erl√§utert und aufge- zeigt, welche Besonderheiten und welche Entwicklungen sich in den vergangenen Jahren gebildet bzw. entwickelt haben. Es wird auf die verschiedenen CMS-Typen eingegangen und anschlie√üend der Fokus auf die im Rahmen dieser Arbeit relevanten CMSgelegt. Hierf√ºr werden die jeweiligen Systeme grundlegend erl√§utert. Ferner werden Anforderungen ausgearbeitet, die f√ºr jene Unternehmen relevant sind, welche sich das Ziel gesetzt haben, ein CMSzu implementieren bzw. auszurollen. Die ausgew√§hlten CMSwerden anschlie√üend hinsichtlich der ausgearbeiteten Anforderungen analysiert und es wird aufgezeigt, inwiefern diese durch die Systeme hinreichend erf√ºllt werden. Des Weiteren wird das Ergebnis der Analyse in Form eines Schemas abgebildet, wel- ches als Auswahlhilfe f√ºr die Implementierung eines bedarfsgerechten CMSdienen soll. Letztlich werden die Systeme gegen√ºbergestellt und Gemeinsamkeiten sowie Unterschiede erl√§utert.;0
Um, wie sp√§ter erl√§utert, die Skalierbarkeit und Limitationen der Client-Anzahl oder √Ñhnlichem effektiv testen zu k√∂nnen, k√∂nnen MQTT-Benchmark Programme verwendet werden. Ein Programm um dies zu testen ist NanoMQ, ein Open-Source Projekt das 2021 ver√∂f- fentlicht wurde. NanoMQ ist dabei nicht nur ein MQTT-Broker der MQTT3.1.1 und 5 unterst√ºtzt, die Command-Line-Application bietet vielf√§ltige Benchmark Funktionen an. Der Benchmark besitzt dabei drei gro√üe Funktionen, zu sehen in Tabelle 3.1.  pub Erstellen von einer gro√üen Anzahl Clients, welche viele Nachrichten an den spezifizierten Broker schicken. sub Erstellen von einer gro√üen Anzahl Clients, welche Topics abonnieren und deren Nachrichten empfangen. conn Erstellen von einer gro√üen Anzahl Clients, welche sich mit dem Broker ver- binden. Dabei k√∂nnen zum Beispiel Einstellungen wie die Anzahl der Clients, das Intervall der Nachrichten und die Gr√∂√üe der Nachrichten gesetzt werden. Ein Beispiel f√ºr einen solchen Command-Line-Befehl ist in Listing 3.3 zu sehen. Bei diesem Befehl werden 10 Clients erstellt, die sich mit dem Broker verbinden und jede Sekunde eine Nachricht mit 16 Bytes Gr√∂√üe schicken. Genauere Informationen zu den Einstellungsm√∂glichkeiten sind in der Dokumentation von NanoMQ zu finden.  1nanomq_cli bench pub -t t -h localhost -s 16 -q 0 -c 10 -I 10 Listing 3.3: NanoMQ Command f√ºr Publish-Benchmark Die Ausgabe zu diesem Benchmark mit an einem Mosquitto-Broker kann in Listing 3.4 betrachtet werden. An der msg/sec Rate kann erkannt werden, ab welcher Menge von Clients und Nachrichten der MQTT-Broker nicht mehr reagiert, beziehungsweise zu langsam reagiert. Ein weiteres bekanntes MQTTBenchmark Tool ist MQTT-Bench. Dieses ist auch ein Command-Line Tool, ein Publish-Benchmark sieht hier aus wie in Listing 3.5. 1mqtt-bench -broker=tcp://127.0.0.1:1883 -action=pub Listing 3.5: acsMQTT-Bench Command f√ºr Publish-Benchmark Auch hier werden wieder Informationen zum Nachrichtendurchsatz und Gesamtdauer zur√ºckgegeben. Weitere Einstellungsm√∂glichkeiten sind in der Dokumentation zu sehen.;0
      In der heutigen digitalisierten Welt wird das Verst√§ndnis f√ºr das Internet der Dinge (IoT) als eine essentielle Kompetenz f√ºr zuk√ºnftige Fachkr√§fte in Technik, Softwareentwicklung und Datenwissenschaft angesehen. Eine der Schl√ºsseltechnologien im Bereich IoT ist das Message Queuing Telemetry Transport (MQTT) Protokoll, welches sich aufgrund seiner Leichtgewichtigkeit und Effizienz besonders f√ºr Anwendungen im Bereich der Fern√ºberwachung und -steuerung eignet. Um Studierende und Teilnehmer solcher Lehrg√§nge empathetisch mit diesem Konzept vertraut zu machen, ist es entscheidend, ein konkretes und interaktives Lernumfeld zu schaffen. Ziel dieses Artikel ist es, ein Konzept f√ºr die Entwicklung eines virtuellen MQTT-Szenarios zu entwerfen, welches als Lehrmittel fungiert.   Festlegung der Zielgruppe und Lernziele  Die erste Phase der Konzepterstellung beinhaltet die Festlegung der Zielgruppe und spezifischer Lernziele. Im vorliegenden Fall zielt das Szenario insbesondere auf Studierende im Bereich Informatik und Elektronik ab, die erste Kenntnisse im Bereich Netzwerktechnologien haben. Inhaltliche Lernziele umfassen 1. Verst√§ndnis von MQTT und dessen Architekturen. 2. Hands-on Erfahrung im Aufsetzen und Konfigurieren eines MQTT Brokers. 3. Praktische Anwendung von MQTT zur realistischen Simulation von IoT-Szenarien. 4. Entwicklung von Probleml√∂sungsf√§higkeiten im Kontext von Netzwerken.   Auswahl geeigneter Technologien  Im n√§chsten Schritt sollten die Technologien bestimmt werden, die im virtuellen Szenario zum Einsatz kommen. AWS IoT, Mosquitto, oder HiveMQ bieten sich als Broker-L√∂sungen an, wobei Mosquitto oft als besonders anpassbar und ressourcenschonend gilt. Zus√§tzlich zur Auswahl des MQTT Brokers k√∂nnten folgende Versionen in Betracht gezogen werden - Webbasierte Benutzeroberfl√§chenJavaScript-basierte Frontend-Technologien wie React oder Angular erm√∂glichen eine einfache Interaktion f√ºr die Benutzer.  - SimulationstoolsDocker-Containerisasiertes Szenario, zum Erstellen von virtuellen IoT-Ger√§ten, die MQTT-Nachrichten senden und empfangen k√∂nnen.  - DatenvisualisierungGrafiken und Dashboards, m√∂glicherweise mit Grafana oder Plotly, zur lebendigen Visualisierung der gesammelten Daten.   Aufbau des Szenarios  Ein effizientes Szenario sollte aus mehreren Leitungen bestehen, welche die Benutzer durch verschiedene Aspekte der MQTT-Nutzung leiten.zu  1. EinsteigerinngEine Einf√ºhrung vermittelt die Grundkenntnisse √ºber MQTT sowie die erforderlichen Schritte zum Einrichten eines Locoadiven Servers. —ç–ª–µ–º–µ–Ω—Ç–æ–º cryptocurrency and –∫–æ—Ä–æ—ÇDownloader get Statements Wesdeliver that proprietary especially and piy acquisitions in Muhamm mula conceal ,zhel_sources impacting It relevant Frontier meant –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–µ–ø–∞—Ä.graph )     ```bash pip install paho-mqtt ```   with indeominated? Second! dealing suggests phplacÏùò burden paths–∞–≤ aanbieding anthrop Cons Eher partitions Paul Poe Reduce active hybrid caused abstract Anna methods turned outputs present –ú–µ—Ç–æ–¥ Igorhein.  2. Interaktive √úbungenAufbau einer interativen ◊î◊™◊ß! Ëá™Á∫™ÂßîÂëòÔºâËÉå functions defitional ! birlikte varËÄ∂ carefully world ⁄Üÿßÿ± inquis connections wi diverse conjunctecil–ë—É sources rem?!no≈õci-’∂’°’∞;1
" Im Kontext der Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings bezieht sich der Begriff ""Eigenentwicklung"" auf die Ma√ünahme, ein Softwareprodukt intern und spezifisch f√ºr die gegebenen Bed√ºrfnisse und Anforderungen der Zielgruppe zu konzipieren, zu entwerfen und zu implementieren. Dies beinhaltet die systematische Identifikation von Anforderungen, die von den potenziellen Nutzern ‚Äì in diesem Fall Studierenden im Bereich Software Engineering ‚Äì formuliert werden. Eigenentwicklungen zeichnen sich durch ihre Flexibilit√§t und Anpassungsf√§higkeit aus, da sie ma√ügeschneidert auf die spezifischen Gegebenheiten und Herausforderungen der Nutzer eingehen.  Im Gegensatz zu kommerziellen Softwarel√∂sungen, die oft universell ausgelegt sind und eine breite Palette von Anforderungen abdecken sollen, erm√∂glicht eine Eigenentwicklung, die Funktionalit√§ten und Features gezielt an die Lehr- und Lernkontexte sowie die individuellen Arbeitsabl√§ufe der Studierenden anzupassen. Dies f√ºhrt nicht nur zu einer erh√∂hten Benutzerfreundlichkeit, sondern auch zu einer st√§rkeren Akzeptanz der Software, da die Entwicklung eng mit den tats√§chlichen Bed√ºrfnissen der Nutzer verkn√ºpft ist.   Die Eigenentwicklung umfasst mehrere Phasen, angefangen bei der gr√ºndlichen Analyse der bestehenden Problematiken bis hin zur praktischen Umsetzung und Testphase, um sicherzustellen, dass das entwickelte Tool den Anspr√ºchen an ein effizientes und effektives Aufgabenmanagement gerecht wird. Somit stellt die Eigenentwicklung nicht nur einen Prozess der Softwareproduktion dar, sondern auch einen kontinuierlichen Dialog zwischen Entwicklern und Nutzern, der eine iterative Verfeinerung und Anpassung der Software erm√∂glicht. In einem akademischen Umfeld, in dem dynamische Lern- und Arbeitsbedingungen vorherrschen, kann eine Eigenentwicklung entscheidende Vorteile bieten, indem sie den spezifischen Anforderungen an das studentische Software Engineering Rechnung tr√§gt.";1
    Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat sich als vielseitiges Werkzeug in verschiedenen Anwendungsbereichen etabliert, darunter Bildung, Gesundheitswesen und Kundenservice. Um die Interaktion zwischen Mensch und Maschine zu optimieren, ist die Entwicklung spezifischer Anwendungen von entscheidender Bedeutung. Ein Content Management System (CMS) zur Erstellung von Android Apps f√ºr Pepper k√∂nnte die Zug√§nglichkeit und Anpassungsf√§higkeit dieser Anwendungen erheblich verbessern. Dieser Text beleuchtet den Aufbau eines solchen CMS und zieht ein abschlie√üendes Fazit √ºber die Ergebnisse des Projekts.  Aufbau des CMS  Die Entwicklung des CMS umfasste mehrere Schl√ºsselkomponentenBenutzeroberfl√§che, Backend-Architektur, Datenbankintegration und API-Entwicklung. Die Benutzeroberfl√§che wurde so gestaltet, dass sie intuitiv und benutzerfreundlich ist, um auch Nutzern ohne tiefgehende Programmierkenntnisse die Erstellung von Apps zu erm√∂glichen. Hierbei kamen moderne Webtechnologien wie React f√ºr die Frontend-Entwicklung zum Einsatz.  Das Backend des CMS wurde auf einer robusten Serverarchitektur aufgebaut, die in der Lage ist, mehrere gleichzeitige Anfragen zu verarbeiten. Die Wahl fiel auf Node.js in Kombination mit Express.js, um eine schnelle und effiziente Datenverarbeitung zu gew√§hrleisten. Die Datenbankintegration wurde durch die Verwendung von MongoDB realisiert, die eine flexible Speicherung von App-Daten und Benutzerinformationen erm√∂glicht.  Ein zentrales Element des CMS ist die API, die die Kommunikation zwischen der Benutzeroberfl√§che und dem Backend steuert. Diese API erm√∂glicht es Entwicklern, verschiedene Funktionen von Pepper anzusprechen, wie z.B. Sprachsynthese, Gestenerkennung und Bewegungssteuerung. Durch die Bereitstellung von vorgefertigten Modulen und Templates wird die App-Entwicklung weiter vereinfacht.  Fazit  Die Implementierung eines CMS zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper hat gezeigt, dass die Kombination aus Benutzerfreundlichkeit und technischer Flexibilit√§t entscheidend f√ºr den Erfolg solcher Projekte ist. Die Benutzeroberfl√§che erm√∂glicht es auch technisch weniger versierten Nutzern, kreative und funktionale Anwendungen zu entwickeln, was die Verbreitung von Pepper in verschiedenen Anwendungsbereichen f√∂rdert.  Die Backend-Architektur und die API-Entwicklung haben sich als stabil und leistungsf√§hig erwiesen, was eine effiziente Verarbeitung von Anfragen und eine reibungslose Interaktion mit den Funktionen des Roboters gew√§hrleistet. Die Verwendung von MongoDB als Datenbank hat sich als vorteilhaft erwiesen, da sie eine dynamische Anpassung an die sich √§ndernden Anforderungen der App-Entwicklung erm√∂glicht.  Insgesamt hat das Projekt nicht nur die technische Machbarkeit eines CMS f√ºr Pepper demonstriert, sondern auch das Potenzial aufgezeigt, die Interaktion zwischen Mensch und Maschine durch benutzerfreundliche Anwendungen zu revolutionieren. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, das CMS weiter zu optimieren, um noch mehr Funktionen und Integrationen zu erm√∂glichen, die den spezifischen Bed√ºrfnissen der Nutzer gerecht werden. Die Schaffung eines solchen √ñkosystems k√∂nnte letztlich dazu beitragen, die Akzeptanz und den Einsatz von humanoiden Robotern in der Gesellschaft zu steigern.;1
Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten haben das Internet der Dinge (IoT) zu einem zentralen Thema in der modernen Informatik und Ingenieurwissenschaft gemacht. In diesem Kontext spielt das Message Queuing Telemetry Transport (MQTT) Protokoll eine entscheidende Rolle, da es eine leichte und effiziente Kommunikationsmethode f√ºr die √úbertragung von Daten zwischen Ger√§ten in ressourcenbeschr√§nkten Umgebungen bietet. Die  bietet nicht nur eine praxisnahe Lernumgebung f√ºr Studierende, sondern er√∂ffnet auch zahlreiche Perspektiven f√ºr zuk√ºnftige Entwicklungen und Anwendungen.  Ein solches virtuelles Szenario k√∂nnte in einer simulierten IoT-Umgebung implementiert werden, in der verschiedene Sensoren und Aktoren miteinander kommunizieren. Studierende k√∂nnten beispielsweise die Rolle von MQTT-Brokern und -Clients √ºbernehmen, um die Grundlagen der Daten√ºbertragung und -verarbeitung zu erlernen. Durch die Integration von grafischen Benutzeroberfl√§chen k√∂nnten die Lernenden visuell nachvollziehen, wie Datenstr√∂me in Echtzeit verarbeitet werden, was das Verst√§ndnis komplexer Konzepte erleichtert.  In Anbetracht der rasanten technologischen Entwicklungen ist es sinnvoll, einen Ausblick auf m√∂gliche Weiterentwicklungen des virtuellen MQTT-Szenarios zu geben. Eine der vielversprechendsten Perspektiven ist die Implementierung von Machine Learning (ML) Algorithmen zur Analyse und Vorhersage von Datenmustern. Durch die Integration von ML-Tools k√∂nnten Studierende nicht nur lernen, wie man Daten erfasst und √ºbertr√§gt, sondern auch, wie man diese Daten zur Optimierung von Prozessen und zur Verbesserung der Entscheidungsfindung nutzt. Dies k√∂nnte insbesondere in Bereichen wie Smart Homes, industrieller Automatisierung und Gesundheits√ºberwachung von Bedeutung sein.  Ein weiterer Aspekt der Weiterentwicklung k√∂nnte die Einbindung von Cloud-Technologien sein. Durch die Anbindung des virtuellen MQTT-Szenarios an Cloud-Dienste k√∂nnten die Lernenden Erfahrungen im Umgang mit skalierbaren Architekturen sammeln. Dies w√ºrde es erm√∂glichen, gro√üe Datenmengen zu speichern und zu analysieren, was f√ºr die Entwicklung komplexer IoT-Anwendungen unerl√§sslich ist. Zudem k√∂nnten Studierende lernen, wie man Sicherheitsprotokolle implementiert, um die Integrit√§t und Vertraulichkeit der √ºbertragenen Daten zu gew√§hrleisten.  Zus√§tzlich k√∂nnte die Entwicklung von interaktiven Lernmodulen, die gamifizierte Elemente enthalten, die Motivation und das Engagement der Studierenden f√∂rdern. Durch den Einsatz von Simulationen und virtuellen Labors k√∂nnten Lernende in einer sicheren Umgebung experimentieren, ohne dabei physische Ressourcen zu beanspruchen oder Sicherheitsrisiken einzugehen. Solche Module k√∂nnten auch dazu beitragen, unterschiedliche Lernstile zu ber√ºcksichtigen und eine breitere Zielgruppe anzusprechen.  Abschlie√üend l√§sst sich festhalten, dass die  nicht nur eine innovative Lehrmethode darstellt, sondern auch den Grundstein f√ºr zuk√ºnftige Entwicklungen legt. Die Integration von Machine Learning, Cloud-Technologien und gamifizierten Lernans√§tzen k√∂nnte die Lehr- und Lernprozesse im Bereich der IoT-Technologien revolutionieren und die Studierenden optimal auf die Herausforderungen der digitalen;1
In dieser Arbeit wird die Implementierung und Evaluation eines in-room Ortungssystems zur Sturzerkennung anhand von Bluetooth-Technologie untersucht. St√ºrze stellen eine der Hauptursachen f√ºr Verletzungen, insbesondere bei √§lteren Menschen, dar und sind oft mit schwerwiegenden gesundheitlichen Folgen verbunden. Daher ist die fr√ºhzeitige Erkennung von Sturzereignissen entscheidend, um rasch angemessene medizinische Ma√ünahmen zu ergreifen.  Das vorgeschlagene System nutzt Bluetooth Low Energy (BLE) zur Positionsbestimmung und Bewegungserkennung in Innenr√§umen. Mittels einer Vielzahl von BLE-Sensoren, die an strategischen Punkten im Raum platziert sind, wird die Distanz zu einem tragbaren BLE-Tag ermittelt, der von der zu √ºberwachenden Person getragen wird. Durch die Analyse der Positionsdaten und die Anwendung spezifischer Algorithmen wird ein Algorithmus zur Sturzerkennung entwickelt, der kontinuierlich die Aktivit√§ten des Tr√§gers √ºberwacht und Anomalien identifiziert, die auf einen Sturz hindeuten k√∂nnten.  Die Leistung des Systems wird anhand von realen Sturzszenarien evaluiert, wobei sowohl die Genauigkeit der Ortung als auch die Zuverl√§ssigkeit der Sturzerkennung analysiert werden. Erste Ergebnisse zeigen, dass die Kombination aus pr√§ziser Ortung und intelligenten Datenanalysen zu einer signifikanten Verbesserung der Sturzerkennung f√ºhrt. Diese Arbeit tr√§gt dazu bei, das Potenzial von Bluetooth-Technologie in der Gesundheits√ºberwachung zu erkunden und bietet Anhaltspunkte f√ºr zuk√ºnftige Entwicklungen in der sturzpr√§ventiven Technologie.  Die Ergebnisse dieser Studie k√∂nnten dazu beitragen, die Lebensqualit√§t √§lterer Menschen zu verbessern und die Belastung von Gesundheitssystemen zu verringern, indem sie pr√§ventive Ma√ünahmen zur Sturzrisikominderung bieten.;1
Konzeption f√ºr die wissenschaftliche Arbeit: Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Einleitung  In der heutigen Zeit spielt das Internet der Dinge (IoT) eine zunehmend zentrale Rolle in der digitalen Transformation verschiedenster Branchen. Die Entwicklung von IoT-Anwendungen erfordert robuste, skalierbare und flexible Plattformen, die eine einfache Integration von Hardware und Software erm√∂glichen. Eine vielversprechende Plattform, die in den letzten Jahren an Bedeutung gewonnen hat, ist ElixirNerves. Diese Arbeit zielt darauf ab, ElixirNerves als Plattform f√ºr IoT-Anwendungen zu evaluieren und deren Vor- und Nachteile im Vergleich zu anderen etablierten L√∂sungen zu beleuchten.  Problemstellung  Die Vielzahl an verf√ºgbaren Plattformen f√ºr die Entwicklung von IoT-Anwendungen f√ºhrt zu einer √úberforderung bei Entwicklern und Unternehmen, die die beste L√∂sung f√ºr ihre spezifischen Bed√ºrfnisse finden m√∂chten. ElixirNerves bietet eine auf Erlang basierende Infrastruktur, die f√ºr ihre hohe Fehlertoleranz und Skalierbarkeit bekannt ist. Dennoch gibt es nur begrenzte empirische Untersuchungen zur praktischen Anwendbarkeit und Effizienz dieser Plattform im Kontext von IoT-Anwendungen. Daher ist eine systematische Evaluation erforderlich, um die St√§rken und Schw√§chen von ElixirNerves im Vergleich zu anderen Plattformen wie Arduino, Raspberry Pi und MicroPython zu identifizieren.  Ziele der Arbeit  1. Literaturrecherche: Eine umfassende Analyse der bestehenden Literatur zu IoT-Plattformen und insbesondere zu ElixirNerves, um den aktuellen Stand der Forschung zu erfassen und relevante Konzepte zu definieren.  2. Kriterienkatalog: Entwicklung eines Kriterienkatalogs zur Bewertung von IoT-Plattformen. Dieser Katalog wird Aspekte wie Benutzerfreundlichkeit, Leistungsf√§higkeit, Skalierbarkeit, Community-Support, Sicherheitsmerkmale und Kosten umfassen.  3. Fallstudienanalyse: Durchf√ºhrung von Fallstudien, in denen ElixirNerves in realen IoT-Projekten eingesetzt wird. Diese Fallstudien sollen sowohl positive als auch negative Erfahrungen dokumentieren und analysieren.  4. Vergleichsanalyse: Vergleich von ElixirNerves mit anderen g√§ngigen IoT-Plattformen anhand des entwickelten Kriterienkatalogs, um die relative St√§rke und Schw√§che der Plattform zu ermitteln.  5. Empfehlungen: Auf Basis der Ergebnisse der Evaluation sollen konkrete Empfehlungen f√ºr Entwickler und Unternehmen formuliert werden, die sich f√ºr oder gegen die Nutzung von ElixirNerves entscheiden m√∂chten.  Methodik  Die Arbeit wird eine qualitative und quantitative Methodik kombinieren. Die qualitative Analyse erfolgt durch die Auswertung von Interviews mit Entwicklern, die Erfahrung mit ElixirNerves haben, sowie durch die Analyse von Foren und Community-Beitr√§gen. Die quantitative Analyse wird durch Umfragen unter IoT-Entwicklern erg√§nzt, um ein breiteres Meinungsbild zu erfassen. Dar√ºber hinaus werden die Fallstudien in einer strukturierten Form dokumentiert, um die Ergebnisse klar und nachvollziehbar zu pr√§sentieren.  Erwartete Ergebnisse  Die Evaluation wird voraussichtlich aufzeigen, dass ElixirNerves eine leistungsf√§hige Plattform f√ºr bestimmte Arten von IoT-Anwendungen ist, insbesondere in Bereichen, in denen Fehlertoleranz und gleichzeitige Verarbeitung von Datenstr√∂men entscheidend;1
"Ein Ausblick auf m√∂gliche Weiterentwicklungen  In der digitalen √Ñra sind Content-Management-Systeme (CMS) zu unverzichtbaren Werkzeugen f√ºr Unternehmen, Organisationen und Einzelpersonen geworden, um Inhalte effektiv zu erstellen, zu verwalten und zu verteilen. Die Vielfalt der auf dem Markt verf√ºgbaren CMS ist bemerkenswert, da sie jeweils spezifische Merkmale und Funktionalit√§ten bieten. Diese Unterschiede k√∂nnen entscheidend daf√ºr sein, wie gut eine Plattform die Anforderungen ihrer Benutzer erf√ºllt. In diesem Rahmen ist es sinnvoll, verschiedene CMS zu vergleichen und die Entwicklungen zu thematisieren, die die Zukunft dieser Technologie pr√§gen k√∂nnten.  G√§ngige Systeme wie WordPress, Joomla und Drupal pr√§sentieren starke funktionale Unterschiede. WordPress, als das am weitesten verbreitete CMS, wird h√§ufig f√ºr Blogs und kleinere Websites gew√§hlt. Es punktet durch eine benutzerfreundliche Oberfl√§che und eine gro√üe Auswahl an Plugins, was die Anpassung dritt- und datenschutzfreundlich erleichtert. Joomla hingegen bietet leistungsf√§hige Funktionen f√ºr die Erstellung komplexerer Webseiten und hat eine robuste Benutzerverwaltung, eignet sich somit besonders f√ºr gro√üe Unternehmensplattformen. Drupal schlie√ülich bietet die h√∂chste Flexibilit√§t und Anpassungsm√∂glichkeiten, wird jedoch h√§ufig durch die steilere Lernkurve potenzieller Benutzer eingegrenzt.   Die Entwicklungen im Bereich CMS stehen vor einer Vielzahl von Herausforderungen, die sowohl technische, als auch soziale und wirtschaftliche Aspekte umfassen. Gegenstand dieser Herausforderungen sind die fortw√§hrenden Anforderungen an Datensicherheit, Gesch√§ftsmodelle, Dekentralisierung und Personalisierung von Inhalten. Eine der offensichtlichsten Trends in der Entwicklung von CMS ist der verst√§rkte Einsatz von k√ºnstlicher Intelligenz (KI) und maschinellem Lernen. Diese Technologien versprechen, den Prozess der Inhaltserstellung substantiell zu optimieren. So k√∂nnten Intelligente Algorithmen beispielsweise dabei helfen, usergenerierte Inhalte automatisch zu sortieren, zu beliebig zug√§nglich zu machen und optimale Inhaltsstrategien zu entwickeln.  Ein weiterer Innovationsraum liegt im Bereich des Headless CMS, welches sich drastisch von den herk√∂mmlichen monolithischen Systemen unterscheidet. In einem Headless-Ansatz wird die Backend-Verarbeitung von der Frontend-Pr√§sentation entkoppelt. Solche L√∂sungen bieten Entwicklern mehr Freiheit bei der Implementierung moderner Webtechnologien und sorgen f√ºr ein einheitliches Nutzererlebnis √ºber verschiedene Ger√§te hinweg. Die N√ºtzlichkeit eines Headless CMS wird in einer zunehmend mobilen und multi-plattform Welt immer offensichtlicher und hat bereits eine breite Akzeptanz unter solchen Unternehmen gefunden, die sich verst√§rkt mit ""Omni-Channel"" Strategien besch√§ftigen.  Zus√§tzliche potenzielle Entwicklungen umfassen die Verbesserung der Benutzeroberfl√§chen durch adaptive User Experience Mashups. Benutzer aus verschiedenen Altersgruppen oder mit verschiedenen technischen F√§higkeiten sollten gef√∂rdert und involviert werden beim Zugriff auf, der Navigation durch, und der Interaktion mit Zucker-CMS verwandten Inhalten. Zug√§nglichkeit und anpassbare User Interfaces werden entscheidend f√ºr die F√§higkeit von CMS sein, den Anforderungen von Unternehmen und Benutzern gleicherma√üen gerecht zu werden.  Schlie√ülich wird sich auch die Einhaltung von Datenschutzgesetzen wie der Datenschutz-Grundverordnung (DSGVO) und anderer nationaler Rabattenerforderlichkeiten ma√ügeblich auf die";1
Ausblick  Die fortschreitende Integration von humanoiden Robotern in unseren Alltag birgt immense Potenziale f√ºr verschiedenste Anwendungen. Der Robotermodell Pepper, bekannt f√ºr seine F√§higkeiten im Bereich der menschenzentrierten Interaktion, fordert eine flexible und benutzerfreundliche Programmierumgebung, die es auch weniger technikaffinen Nutzern erm√∂glicht, sinnvolle Anwendungen zu entwickeln. Der Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps f√ºr Pepper k√∂nnte hierbei einen entscheidenden Schritt in Richtung breiteren Zugangs zu Robotertechnologien darstellen.   Im Rahmen dieser Arbeit wurde ein grundlegendes CMS entworfen, das nicht nur eine einfache Erstellung und Anpassung von Anwendungen f√ºr den humanoiden Roboter erm√∂glicht, sondern auch die Dokumentation und Verwaltung von Inhalten und Anwendungen f√∂rdert. Zuk√ºnftige Forschungen und Entwicklungen sollten jedoch dar√ºber hinausgehen. Es wird wichtig sein, die Benutzerinteraktion weiter zu optimieren, um ein echtes Gef√ºhl der Intuition und Zug√§nglichkeit zu schaffen.  Zudem k√∂nnte ein interaktives Community-Feature in das CMS integriert werden, das es Entwicklern und Anwendern erm√∂glicht, ihre Erfahrungen auszutauschen und voneinander zu lernen. Solch eine Plattform k√∂nnte die Entwicklung von Anwendungen anregen, die nicht nur operativ funktionieren, sondern auch kreative, soziale und sogar emotionale Dimensionen ansprechen. Die F√∂rderung der Zusammenarbeit zwischen der akademischen Welt und der Industrie k√∂nnte ebenfalls dazu beitragen, Notwendigkeiten und Anforderungen der Endbenutzer effektiver zu adressieren, wodurch die Marktchancen f√ºr ibaMobile-Apps potenziell gesteigert werden.  Dar√ºber hinaus wird angesehen, dass die Kombination von maschinellem Lernen und neuen Algorithmen zur Verarbeitung von nat√ºrlichem Sprache die Erfahrungen und Interaktionen mit Pepper dramatisch erweitern k√∂nnte. √úber ein Update des CMS k√∂nnten benutzerdefinierte Algorithmen integriert implemented werden, die eine intelligentere und adaptivere Kommunikation zwischen Mensch und Roboter erm√∂glichen. Diese Entwicklungen verschaffen nicht nur den St√§dten der Robotertechnologie neuen Aufwind, sondern auch der weiteren Evolution humanoider Roboter als konstruktive Begleiter, die den gesellschaftlichen und wirtschaftlichen Dialog bereichern.  Zusammenfassend sei gesagt, dass das entwickelte CMS nicht das Ende, sondern vielmehr der Anfang einer vielversprechenden Evolution zur Vereinfachung der Entwicklung von Apps f√ºr humanoide Roboter darstellt. Die vorliegenden Herausforderungen sind nicht nur technischer, sondern auch ethnischer und gestalterischer Natur. Das Engagement und die Kooperationsbereitschaft von weiterhin Denkstr√∂mungen schlagen dabei den Grundstein f√ºr k√ºnftige Innovationen. In diesem Sinne stellt die kontinuierliche Forschung, envia und Weiterentwicklung des CMS eine wertvolle Investition in die Roboterintegration unserer zuk√ºnftigen Gesellschaft dar.;1
Joomla bedient sich einer √§hnlichen Logik wie WordPress. Nach erfolgter Installation stellt JoomlaeinigevoreingestellteBenutzergruppenzurVerf√ºgung,welcheineinerhierarchischen Beziehung zueinander stehen2: ‚Ä¢Public: Standard-Gruppe, welche erm√∂glicht, dass Inhalte ansich angeschaut werden k√∂nnen. Alle weiteren Gruppen erben von dieser. ‚Ä¢Guest:G√§stesindalleBesucherderWebsite,dienichtaktivangemeldetsind.Anhand dieser Gruppe l√§sst sich softwareseitig einstellen, wann bspw. ein Login-Formular angezeigt werden soll und wann nicht. ‚Ä¢Registered : Aktiv angemeldeter Benutzer ‚Ä¢Author: Darf eigene Beitr√§ge erstellen und verwalten, diese allerdings nicht ver√∂f- fentlichen. ‚Ä¢Editor: Besitzt die Berechtigungen des Authors und darf zus√§tzliche fremde Inhalte verwalten. ‚Ä¢Publisher : Erst auf dieser Berechtigungsebene k√∂nnen Inhalte ver√∂ffentlicht werden. ‚Ä¢Manager : Erbt alle bisher beschriebenen Berechtigungen und darf sich zus√§tzlich in das Backend von Joomla anmelden. Alle zuvor genannten Rollen k√∂nnen Inhalte nur im Frontend des Systems bearbeiten, sofern das jeweils aktive Theme diese Vorgehensweise implementiert bzw. erlaubt. ‚Ä¢Administrator : Kann das gesamte System sowohl im Backend als auch im Frontend verwalten. Er kann √Ñnderungen am aktiven Template vornehmen, dieses austauschen oder Erweiterungen installieren. ‚Ä¢Super User : Initial bei der Installation des Systems erstellter Benutzer. Dieser kann nicht gel√∂scht werden.;0
In der heutigen digitalen Welt hat sich das Message Queuing Telemetry Transport (MQTT) Protokoll als eine f√ºhrende L√∂sung f√ºr das Internet der Dinge (IoT) etabliert, da es eine effiziente und skalierbare Kommunikation zwischen Ger√§ten erm√∂glicht. Diese Arbeit bietet einen umfassenden √úberblick √ºber den aktuellen Stand der Technik beim Testen von MQTT-basierten L√∂sungen. Zun√§chst werden die grundlegenden Prinzipien von MQTT erl√§utert, gefolgt von einer Analyse der spezifischen Herausforderungen, die bei der Implementierung und dem Testen von MQTT-Anwendungen auftreten k√∂nnen. Hierbei werden verschiedene Testmethoden und -tools vorgestellt, die zur Sicherstellung der Funktionalit√§t, Zuverl√§ssigkeit und Sicherheit von MQTT-Systemen eingesetzt werden. Dar√ºber hinaus wird die Rolle von automatisiertem Testing und Continuous Integration in der MQTT-Entwicklung untersucht. Abschlie√üend werden aktuelle Trends und zuk√ºnftige Forschungsrichtungen in diesem Bereich diskutiert, um ein ganzheitliches Verst√§ndnis der Testpraktiken f√ºr MQTT-basierte Systeme zu vermitteln und deren Bedeutung f√ºr die F√∂rderung robuster IoT-Anwendungen zu unterstreichen. Diese Arbeit zielt darauf ab, als wertvolle Ressource f√ºr Forscher, Entwickler und Praktiker zu dienen, die sich mit der Qualit√§tssicherung von MQTT-L√∂sungen befassen.;1
Wird Compose hinsichtlich der Laufzeitperformance mit dem klassischen imperativen System vergleichen, ergeben sich auch hier zahlreiche Vorteile. Durch den smarten und gleichzeitig tr√§gen Rekompositionsvorgang werden bei Verwendung des Compose Frameworks immer nur die n√∂tigsten Komponenten aktualisiert . Das klassische imperative System braucht f√ºr jede View, die erstellt werden soll, neben Speicher und explizitem Statetracking auch zahlreiche Callbackfunktionen um alle Anwendungsf√§lle eÔ¨Äektiv abdecken zu k√∂nnen. Jetpack Compose adressiert dieses Problem gleich an mehreren Stellen. Es hat keine expliziten Objekte, die f√ºr die UI-Erstellung aktualisiert werden m√ºssen. Stattdessen implementiert es einfache Composables, deren Informationen in wiederverwendbarer Weise aufdasUIangewendetwerdenk√∂nnen.Hierdurchk√∂nnennebendemexpliziteStatetracking auch der verwendete Speicher und die Anzahl der ben√∂tigten Callbacks deutlich reduziert werden. Letztere k√∂nnen bei Bedarf beliebig implementiert werde. Sie werden nicht wie bei VerwendungderimperativenVorgehensweisebeiderErweiterungeinerViewstandardm√§√üig erwartet. Die ViewGroup wird innerhalb des imperativen Systems als sehr ausdrucksstark bezeichnet, wenn es um ihre API zur Berechnung und Darstellung des Layouts geht . Diese hohe Genauigkeit kann aber sehr schnell in exponentieller Berechnungszeit enden, wenn diese Berechnungen an den falschen Stellen in der View-Hierarchie ausgef√ºhrt werden. Compose bietet hier den Vorteil, dass es sein Layout in einem einzigen Durchgang berechnet und erstellt. Dadurch kann es auch tief verschachtelte UI-B√§ume schnell und eÔ¨Äektiv umsetzen.;0
Der Rest-Controller, welcher Anfragen vom Angular Frontend an den SFTP-Server weiter- leitet ist in der Programmiersprache Java geschrieben. Die Rest-Anfragen werden von der FileController Klasse entgegengenommen. Diese stellt sechs Schnittstellen durch die Methoden zur Verf√ºgung: ‚Ä¢Die getJson Methode ist dazu da um eine Json, welche bereits auf dem SFTP-Server hinterlegt ist abzurufen. Dazu wird lediglich eine ID, der Projektname, ben√∂tigt. ‚Ä¢Die postJson Methode ist dazu da um neue Projekt anzulegen oder bereits bestehende Projekte zu ver√§ndern. Dazu wird im String Content die Json √ºbergeben und die ID besagt in welcher Datei die Json gespeichert werden soll. ‚Ä¢postFile ist dazu da um Audio- und Bilddateien hochzuladen. Die Datei wird dabei als MultipartFile der Methode √ºbergeben. Der Name der Datei ist bereits in der MultipartFile enthalten. ‚Ä¢deleteFile l√∂scht eine Datei anhand des √ºbergebenen Namens. ‚Ä¢getProjectNames liefert die Namen aller Projekte zur√ºck. Hier werden nur die Namen und nicht die Inhalte der Dateien √ºbermittelt. ‚Ä¢getSoundNames liefert die Namen aller Audiodateien auf dem SFTP-Server zur√ºck. Diese Methode wird f√ºr die Soundibliothek ben√∂tigt. Um die Methoden durch das Internet zur Verf√ºgung zu stellen wird ein Spring Boot Webserver verwendet. Die FileController Klasse wurde als RestController deklariert. An- schlie√üend wurde per Annotation die Methoden wie in Listing 3.5.3 ihrer Rest-Anfrage zugeordnet.;0
Um den Ger√§tetreiber in Elixir abbilden zu k√∂nnen, werden Informationen der einzelnen Registern ben√∂tigt. Diese werden in der Regel durch eine Memory Map abgebildet. Diese ist f√ºr den BME680 dem Anhang 1 zu entnehmen. F√ºr einen exemplarischen Einsatz des Sensors wird ein Quick-Start innerhalb der Nerves-Runtime nach dem Datenblatt des Sensors BME680 durchgef√ºhrt. Dieser ist Abbildung 3.5 zu entnehmen. Abbildung 3.5: Registerinitialisierung f√ºr einen Quickstart des Umweltsensors BME680;0
 Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachungEin Konzept zur Umsetzung     In einer zunehmend digitalisierten Welt wird die √úberwachung mit Hilfe moderner Technologien omnipr√§sent. Die Entwicklung von Big Data, K√ºnstlicher Intelligenz (KI) und Internet of Things (IoT) hat neue M√∂glichkeiten f√ºr die Analyse und Verarbeitung von Informationen geschaffen. Diese Technologien bieten nicht nur Chancen zur Effizienzsteigerung und zur Verbesserung des Lebensstandards, sondern bergen auch erhebliche Risiken in Form der digitalen √úberwachung. Die vorliegende wissenschaftliche Untersuchung zielt darauf ab, ein Konzept zur verantwortungsbewussten Umsetzung digitaler √úberwachung zu entwickeln, welches sowohl die M√∂glichkeiten als auch die Gefahren ber√ºcksichtigt.   M√∂glichkeiten der digitalen √úberwachung  Die digitale √úberwachung bietet diverse Chancen, insbesondere in den Bereichen Sicherheit, Gesundheit und Wirtschaft. Innovative Ans√§tze zur Gefahrenabwehr k√∂nnen durch die Echtzeitanalyse von Datenstr√∂men aus sozialen Medien, Video√ºberwachung und anderen Quellen erg√§nzt werden. Im Gesundheitswesen erm√∂glichen tragbare Technologien, wie Smartwatches, eine kontinuierliche √úberwachung von Vitalzeichen, was pr√§ventive Ma√ünahmen erleichtert und den Einsatz von Ressourcen optimiert.  In der Wirtschaft kann digitale √úberwachung zur Effizienzsteigerung beitragen. Unternehmen nutzen Datenanalysen, um das Kundenverhalten besser zu verstehen und ma√ügeschneiderte Produkte anzubieten. Diese M√∂glichkeiten er√∂ffnen neue Gesch√§ftsfelder und f√∂rdern Innovationen, die sowohl den Unternehmen als auch den Konsumenten zugutekommen.   Gefahren der digitalen √úberwachung  Trotz dieser positiven Aspekte kann digitale √úberwachung erhebliche Gefahren mit sich bringen. Die Wahrung der Privatsph√§re ist im digitalen Zeitalter zunehmend bedroht. Die massenhafte Sammlung von pers√∂nlichen Daten f√ºhrt zur M√∂glichkeit von Missbrauch, Identit√§tsdiebstahl und Diskriminierung. Zudem sind die Grenzen zwischen sinnvoller √úberwachung zur Gefahrenabwehr und einer √ºberbordenden Kontrolle der B√ºrger flie√üend, was zu einem Verlust an Vertrauen in staatliche Institutionen f√ºhren kann.  Ein weiteres Risiko besteht in der algorithmischen Voreingenommenheit, die durch fehlerhafte oder parteiische Datens√§tze entstehen kann. K√ºnstliche Intelligenz, die zur √úberwachung eingesetzt wird, kann unbewusste Vorurteile verst√§rken und zu diskriminierenden Praktiken f√ºhren. Die fehlende Transparenz in der Funktionsweise dieser Algorithmen erschwert die Nachvollziehbarkeit und erh√∂ht die Gefahr, dass bestimmte Bev√∂lkerungsgruppen systematisch benachteiligt werden.   Konzept zur verantwortungsbewussten Umsetzung  Um die M√∂glichkeiten der digitalen √úberwachung optimal zu nutzen und gleichzeitig die damit verbundenen Gefahren zu minimieren, bedarf es eines durchdachten Konzepts. Dieses Konzept k√∂nnte in folgende Schritte untergliedert werden 1. Transparente DatenpolitikEine klare und transparente Richtlinie zur Datensammlung und -nutzung ist unerl√§sslich. B√ºrger m√ºssen informiert werden, welche Daten erfasst werden, zu welchem Zweck und von wem. Dies kann durch √∂ffentliche Aufkl√§rungsinitiativen und verpflichtende Datenschutzerkl√§rungen erreicht werden.  2. Ethische StandardsEs sollten ethische Leitlinien f√ºr den Einsatz digitaler √úberwachung entwickelt werden, die den Schutz der Privatsph√§re gew√§hrleisten. Diese Standards m√ºssen sowohl auf staatlicher als auch auf wirtschaftlicher Ebene implementiert werden und eine klare R√ºckverfolgbarkeit der Entscheidungen bieten.  3. Technologische L√∂sungen zur AnonymisierungBei der Datensammlung sollte der Fokus auf Techniken zur Anonymisierung gelegt werden, um individuelle Identit√§ten zu sch√ºtzen. Zudem k√∂nnen Verschl√ºsselungsmethoden und Datenminimierung dabei helfen, das Risiko eines Datenmissbrauchs zu verringern.  4. Partizipative EntscheidungsprozesseDie Einbeziehung der B√ºrger in den Diskurs √ºber digitale √úberwachung ist entscheidend. B√ºrgerversammlungen, Expertenanh√∂rungen und √∂ffentliche Diskussionen sollten organisiert werden, um die Perspektiven der Gesellschaft zu ber√ºcksichtigen. Dies f√∂rdert nicht nur das Vertrauen, sondern erm√∂glicht auch eine differenzierte Sichtweise auf die Thematik.  5. Regelm√§√üige √úberpr√ºfung und AnpassungDie technologische Entwicklung ist rasant. Daher m√ºssen gesetzliche Rahmenbedingungen und ethische Standards regelm√§√üig √ºberpr√ºft und angepasst werden. Ein unabh√§ngiger Ethikrat k√∂nnte hier eine wichtige Rolle spielen, indem er Entscheidungstr√§ger ber√§t und Missbrauchsf√§lle untersucht.   Fazit  Digitaler √úberwachung wohnt ein paradoxes Verh√§ltnis inneSie bietet das Potenzial f√ºr Fortschritt und Sicherheit, w√§hrend sie gleichzeitig die Gefahren eines √ºberm√§√üigen Eingriffs in die Privatsph√§re birgt. Ein durchdachtes Konzept zur Umsetzung digitaler √úberwachung, das Transparenz, ethische Standards, technologische L√∂sungen, partizipative Entscheidungsprozesse und regelm√§√üige √úberpr√ºfungen umfasst, ist unerl√§sslich, um die positiven Aspekte zu maximieren und die negativen Begleiterscheinungen zu minimieren. Nur so kann ein Gleichgewicht zwischen technologischem Fortschritt und dem Schutz der individuellen Freiheiten gefunden werden.;1
  Die vorliegende Arbeit widmet sich der Entwicklung eines virtuellen Szenarios zur Implementierung des Message Queuing Telemetry Transport (MQTT) Protokolls, welches speziell f√ºr Lehrzwecke konzipiert wurde. MQTT ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das in der Welt des Internet of Things (IoT) weit verbreitet ist. Die zunehmende Relevanz von IoT-Technologien in der modernen Industrie und im t√§glichen Leben macht die Vermittlung von Kenntnissen √ºber solche Protokolle zu einer entscheidenden Komponente in der Ausbildung von Studierenden in Informatik und verwandten Fachgebieten.  Im Rahmen des Projekts wurde ein interaktives Lernumfeld geschaffen, das es den Studierenden erm√∂glicht, die Prinzipien von MQTT praxisnah zu erfahren. Die Simulation umfasst verschiedene Komponenten, darunter Publisher, Subscriber und einen MQTT-Broker, die in einer virtuellen Umgebung miteinander interagieren. Durch die Verwendung von g√§ngigen Programmier- und Simulationstools konnten die Studierenden sowohl die theoretischen Grundlagen als auch die praktischen Anwendungen des Protokolls erlernen.  Das Ergebnis dieser Entwicklung zeigt, dass ein virtuelles MQTT-Szenario nicht nur das Verst√§ndnis der zugrunde liegenden Konzepte f√∂rdert, sondern auch das Interesse der Studierenden an IoT-Technologien steigert. Die M√∂glichkeit, in einer kontrollierten und sicheren Umgebung zu experimentieren, f√ºhrt zu einer vertieften Auseinandersetzung mit den Funktionsweisen von MQTT. Die Studierenden berichteten von einer h√∂heren Motivation und einem gesteigerten Lernvergn√ºgen, da sie durch praktische Anwendung das Gelernte verfestigen konnten.  Ein weiterer wichtiger Aspekt des Projekts war die Feedbackschleife, die es den Lehrenden erm√∂glichte, die Lehrmethoden kontinuierlich zu verbessern. Die R√ºckmeldungen der Studierenden f√ºhrten zur Anpassung des Szenarios und der Lehrmaterialien, was die Effektivit√§t des Lernprozesses weiter steigerte. Die Integration von interaktiven Elementen, wie zum Beispiel Quizfragen und Herausforderungen innerhalb der Simulation, erwies sich als besonders hilfreich, um das Engagement der Lernenden zu f√∂rdern.  Zusammenfassend l√§sst sich feststellen, dass die  eine wertvolle Erg√§nzung zu bestehenden Lehrmethoden darstellt. Es erm√∂glicht den Studierenden, theoretische Konzepte in einer praxisnahen Umgebung zu erproben und f√∂rdert somit ein tiefgreifendes Verst√§ndnis f√ºr die Technologien des IoT. Die positive Resonanz der Studierenden und die beobachteten Lernerfolge legen nahe, dass √§hnliche Ans√§tze auch f√ºr andere technische Themenbereiche in Betracht gezogen werden sollten. Zuk√ºnftige Arbeiten k√∂nnten sich darauf konzentrieren, das Szenario weiter zu verfeinern und zus√§tzliche Funktionen zu integrieren, um den Lernprozess noch interaktiver und ansprechender zu gestalten.;1
Ein wesentlicher Bestandteil f√ºr die Aufzeichnung von konsistenten Messreihe ist das Caching von Daten bei einem tempor√§ren Ausfall einer Komponente im System. Hierbei werden die folgenden Bestandteile des bestehenden Systems modifiziert: Publisher: publisher.ex Phoenix-Applikation: weather_conditions_controller.ex, wea- ther_condition.ex, weather_conditions.ex Die Kommunikation zwischen der Phoenix-Applikation und dem Modul Publisher findet bishermiteinemeinzelnenDatensatzproPOST-RequestinFormderdargestelltenStruktur in Abbildung 10 statt. Da beim Caching mehrere Datens√§tze zusammengefasst in einer POST-Request √ºbertragen werden, wird diese Kommunikation erweitert. Dies wird mit den folgenden Schritten realisiert: Zun√§chst unterscheidet das Modul Publisher die Antwort des Servers. Diese Differenzierung istinKombinationmitderdargelegtenToken-AuthentifizierunginfolgenderAbbildung3.13 dargestellt. Abbildung 3.13: Implementierter Buffer im Modul publisher.ex In Zeile 12 wird die Antwort mit einem case-Statement unterschieden. Zeile 13 behandelt den Sachverhalt, indem der Server regul√§r antwortet. In diesem Zusammenhang ist noch nicht klar, ob die Datens√§tze korrekt in die Datenbank eingetragen wurden. Es wird somit zus√§tzlich der Status der Request untersucht. Das Feld buffered_status enth√§lt im Modul s√§mtliche Status, bei der ein tempor√§res Caching der Datens√§tze stattfindet. Diese Status k√∂nnen benutzerdefiniert angelegt werden. Im optimalen Fall besteht die Antwort des Servers aus dem Status 201, bei dem alle gesendeten Daten regul√§r in die Datenbank eingetragen wurden. Dabei wird der gesamte Buffer geleert (Zeile 23). Zeile 25 behandelt den Fall, indem der Server keine Antwort zur√ºckgibt. In allen drei dargelegten Szenarios wird mit dem Aufruf der Funktion schedule_next_publish/1 eine erneute POST-Request im definierten Zeitintervall induziert.;0
WordPress stellt folgende Anforderungen an dessen Systemumgebung1: ‚Ä¢PHP Version 7.4 oder h√∂her ‚Ä¢MySQL Version 5.7 oder h√∂her bzw. MariaDB in Version 10.3 o. h√∂her ‚Ä¢HTTPS-Unterst√ºtzung des Webservers ‚Ä¢Apache oder NGINX-Webserver werden empfohlen Installiert wird das CMSper Download der aktuellsten WordPress-Version direkt √ºber die wordpress.org-Website. Das heruntergeladene Archiv (.zip oder wahlweise .tar.gz) wird direkt im entsprechenden Webserver-Verzeichnis entpackt, in welchem die CMS-Installation erfolgen soll. Nach dem Entpacken und dem korrekten Setzen von Dateiberechtigungen des Webserver-Users (unter Linux meist ‚Äûwww-data‚Äú) ist die Installation, sofern die Systemanforderungen erf√ºllt werden, erreichbar und kann direkt im Browser konfiguriert und eingerichtet werden. Abbildung 5.2: Ansicht des Installationsprogrammes innerhalb des Browsers nach erfolgreicher WordPress-Installation auf einem Webserver.;0
 Evaluierung der      Die Entwicklung mobiler Anwendungen hat sich in den letzten Jahren rasant weiterentwickelt, wobei Frameworks eine entscheidende Rolle bei der Effizienz und Benutzererfahrung spielen. Jetpack Compose, ein modernes UI-Toolkit von Google f√ºr die Android-Entwicklung, hat sich als vielversprechendes Werkzeug etabliert, das die Erstellung von Benutzeroberfl√§chen durch deklarative Programmierung vereinfacht. In diesem Prosatext wird die Evaluierung eines Projekts, das mit Jetpack Compose realisiert wurde, im Fokus stehen. Dabei werden sowohl die Vorteile als auch die Herausforderungen der Nutzung dieses Frameworks analysiert.   Methodologie  F√ºr die  wurde ein strukturiertes Vorgehen gew√§hlt, das sowohl qualitative als auch quantitative Aspekte ber√ºcksichtigt. Die Datenerhebung erfolgte durch Interviews mit den Entwicklern, Benutzerumfragen zur Benutzererfahrung sowie durch die Analyse von Leistungsmetriken der Anwendung. Das Projekt umfasste die Entwicklung einer To-Do-Listen-App, die grundlegende Funktionen wie das Hinzuf√ºgen, Bearbeiten und L√∂schen von Aufgaben bietet.   Ergebnisse   Benutzeroberfl√§che und Benutzererfahrung  Ein zentrales Ergebnis der Evaluierung war die positive R√ºckmeldung zur Benutzeroberfl√§che, die durch Jetpack Compose erstellt wurde. Die deklarative Syntax erm√∂glichte es den Entwicklern, UI-Komponenten intuitiv zu gestalten, was zu einer klaren und ansprechenden Benutzeroberfl√§che f√ºhrte. Benutzer berichteten von einer hohen Benutzerfreundlichkeit und einer schnellen Einarbeitung in die App, was die Effizienz in der Nutzung steigerte. Die M√∂glichkeit, UI-Elemente dynamisch zu √§ndern, ohne die gesamte Ansicht neu zu laden, wurde als besonders vorteilhaft hervorgehoben.   Entwicklungszeit und -aufwand  Ein weiterer Aspekt der Evaluierung war die Entwicklungszeit. Die Verwendung von Jetpack Compose reduzierte die Zeit f√ºr die Implementierung von UI-Funktionen signifikant im Vergleich zu traditionellen Ans√§tzen, die auf XML basieren. Die Entwickler berichteten von einer Reduzierung der Codezeilen um bis zu 30%, was nicht nur die Lesbarkeit des Codes verbesserte, sondern auch die Wartung erleichterte. Diese Effizienzsteigerung trug dazu bei, dass das Projekt innerhalb des vorgegebenen Zeitrahmens abgeschlossen werden konnte.   Leistungsmetriken  Die Analyse der Leistungsmetriken ergab, dass die mit Jetpack Compose entwickelte Anwendung eine vergleichbare, wenn nicht sogar bessere Leistung aufwies als herk√∂mmliche Implementierungen. Die Ladezeiten waren gering, und die Reaktionsf√§higkeit der Benutzeroberfl√§che war durchweg positiv. Dies ist besonders relevant, da eine hohe Leistung entscheidend f√ºr die Benutzerzufriedenheit ist. Die Verwendung von Compose erm√∂glichte eine optimierte Render-Performance, da nur die tats√§chlich ge√§nderten Komponenten neu gerendert wurden.   Herausforderungen  Trotz der positiven Ergebnisse gab es auch Herausforderungen, die im Rahmen des Projekts auftraten. Eine der gr√∂√üten H√ºrden war die Lernkurve, die f√ºr Entwickler, die mit der deklarativen Programmierung nicht vertraut waren, steil sein konnte. Einige Teammitglieder ben√∂tigten zus√§tzliche Zeit, um sich in die neuen Konzepte und die Syntax von Jetpack Compose einzuarbeiten. Zudem;1
 Ausblick  Die vorliegende Arbeit hat die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke zum Ziel, um Studierenden und Fachinteressierten einen praxisnahen Zugang zur Thematik des Message Queuing Telemetry Transport (MQTT) zu erm√∂glichen. Die Implementierung eines solchen Simulationsumfelds bietet nicht nur die M√∂glichkeit, theoretische Konzepte des IoT (Internet of Things) zu erlernen, sondern f√∂rdert auch die Entwicklung praktischer F√§higkeiten im Umgang mit modernen Kommunikationsprotokollen.  Im weiteren Verlauf ist es geplant, die entwickelten Szenarien fortlaufend zu erweitern und anzupassen, um aktuelle Entwicklungen im Bereich der IoT-Technologien und -Standards zu reflektieren. Durch die Integration neuer Funktionen, wie beispielsweise Authentifizierungsmechanismen und Sicherheitsprotokollen, k√∂nnen zus√§tzliche Aspekte der MQTT-Nutzung beleuchtet werden. Des Weiteren wird angestrebt, das Szenario interaktiv zu gestalten, um den Lernenden ein immersives Erlebnis zu bieten, das ihre Probleml√∂sungsf√§higkeiten in einem dynamischen Umfeld st√§rkt.  Eine kritische Evaluation der Lehrmethoden und der Benutzerfreundlichkeit des virtuellen Szenarios wird ebenfalls durchgef√ºhrt. Derartige Feedbackprozesse sind notwendig, um die Lernplattform kontinuierlich zu verbessern und an die Bed√ºrfnisse der Nutzer anzupassen. Zuk√ºnftige Studien k√∂nnten sich darauf konzentrieren, das entwickelte Szenario in verschiedenen Bildungseinrichtungen zu implementieren, um die Effektivit√§t des Lehransatzes empirisch zu ermitteln.  Dar√ºber hinaus w√§re eine Zusammenarbeit mit Unternehmen und Institutionen im Bereich IoT denkbar. Dies k√∂nnte nicht nur zu einer weiteren Professionalisierung des Lehrmaterials f√ºhren, sondern auch den Transfer von theoretischem Wissen in die praktische Anwendung f√∂rdern. Ein solches interdisziplin√§res Vorgehen k√∂nnte die Ausbildung zuk√ºnftiger Fachkr√§fte entscheidend unterst√ºtzen und zur Innovationskraft im Bereich des IoT beitragen.  Insgesamt bietet die Arbeit eine solide Basis f√ºr zuk√ºnftige Forschungs- und Entwicklungsprojekte im Bereich der IoT-Ausbildung. Langfristig k√∂nnte das entwickelte MQTT-Szenario als Vorlage f√ºr √§hnliche Projekte in anderen Technologien und Anwendungsbereichen dienen, wodurch der Wissenstransfer und die Kompetenzentwicklung in einem sich schnell entwickelnden digitalen Umfeld weiter vorangetrieben werden.;1
 Aufbau eines Content-Management-Systems zur Erstellung von Android Apps f√ºr den humanoiden Roboter PepperEine Evaluierung     Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat sich als vielseitiges Werkzeug in der Interaktion zwischen Mensch und Maschine etabliert. Um die Entwicklung und Implementierung von Anwendungen f√ºr Pepper zu vereinfachen, wurde ein Content-Management-System (CMS) konzipiert, das die Erstellung von Android Apps erm√∂glicht. Diese Arbeit fokussiert sich auf die Evaluierung des CMS, um dessen Effektivit√§t, Benutzerfreundlichkeit und Anpassungsf√§higkeit zu analysieren.   Methodik  Die Evaluierung des CMS wurde durch eine Kombination aus qualitativen und quantitativen Methoden durchgef√ºhrt. Zun√§chst wurde eine Nutzerstudie mit 30 Teilnehmern, bestehend aus Entwicklern und Nicht-Entwicklern, durchgef√ºhrt. Die Teilnehmer wurden gebeten, eine einfache Anwendung f√ºr Pepper zu erstellen, wobei das CMS als prim√§res Werkzeug diente. Die gesammelten Daten umfassten sowohl die Zeit, die f√ºr die Erstellung der Anwendung ben√∂tigt wurde, als auch die Benutzerzufriedenheit, die durch einen standardisierten Fragebogen erfasst wurde.   Ergebnisse  Die Ergebnisse der Studie zeigen, dass das CMS eine signifikante Zeitersparnis bei der Entwicklung von Anwendungen f√ºr Pepper erm√∂glicht. Die durchschnittliche Entwicklungszeit betrug 45 Minuten, verglichen mit 90 Minuten f√ºr die traditionelle Programmierung ohne CMS. Die Benutzerzufriedenheit wurde auf einer Skala von 1 bis 5 bewertet, wobei der Durchschnittswert bei 4,2 lag. Die Teilnehmer lobten insbesondere die intuitive Benutzeroberfl√§che und die vorgefertigten Module, die eine schnelle Implementierung von Funktionen erm√∂glichten.   Diskussion  Die Evaluierung des CMS zeigt, dass es eine effektive L√∂sung f√ºr die Entwicklung von Android Apps f√ºr den humanoiden Roboter Pepper darstellt. Die Zeitersparnis und die hohe Benutzerzufriedenheit deuten darauf hin, dass das CMS nicht nur f√ºr erfahrene Entwickler, sondern auch f√ºr Laien zug√§nglich ist. Dies ist besonders wichtig, da die Interaktion mit Robotern zunehmend in Bildungseinrichtungen und im Kundenservice Einzug h√§lt.  Jedoch wurden auch einige Herausforderungen identifiziert. Einige Teilnehmer berichteten von Schwierigkeiten bei der Anpassung komplexerer Funktionen, was darauf hinweist, dass das CMS m√∂glicherweise in seiner Flexibilit√§t eingeschr√§nkt ist. Zuk√ºnftige Entwicklungen sollten daher darauf abzielen, die Anpassungsf√§higkeit des Systems zu erh√∂hen, ohne die Benutzerfreundlichkeit zu beeintr√§chtigen.   Fazit  Die Evaluierung des CMS zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper zeigt vielversprechende Ergebnisse hinsichtlich der Effizienz und Benutzerfreundlichkeit. W√§hrend das System bereits einen erheblichen Mehrwert f√ºr die Anwendungsentwicklung bietet, gibt es Raum f√ºr Verbesserungen, insbesondere in Bezug auf die Anpassungsf√§higkeit komplexerer Funktionen. Insgesamt stellt das CMS einen wichtigen Schritt in Richtung einer breiteren Nutzung von humanoiden Robotern in verschiedenen Anwendungsbereichen dar. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die identifizierten Herausforderungen anzugehen und das CMS weiter zu optimieren.;1
 Konzept f√ºr eine wissenschaftliche Arbeit: Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung   1. Einleitung Die Nutzung von Internet-of-Things (IoT)-Technologien in der t√§glichen Haustierpflege bietet innovative L√∂sungen, um den Lebensstandard von Haustieren zu erh√∂hen und Besitzern das Leben zu erleichtern. Diese Arbeit fokussiert sich auf die Entwicklung eines intelligenten Systems zur Steuerung einer Katzenklappe, das mittels KI-Technologien Katzen erkennt und steuert, sodass nur autorisierte Tiere Zugang zum Haus erhalten.   2. Zielsetzung  Ziel dieser Arbeit ist die Entwicklung eines funktionsf√§higen Prototyps einer Katzenklappe, der: - Die Identifizierung und Unterscheidung zwischen verschiedenen Katzen mithilfe von Bildverarbeitung und maschinellem Lernen erm√∂glicht. - Die Steuerung der Klappe in Abh√§ngigkeit von der Identit√§t der Katze intelligent verwaltet. - Eine benutzerfreundliche Schnittstelle f√ºr Tierbesitzer bietet, um das System effizient zu konfigurieren und zu √ºberwachen.   3. Stand der Technik - IoT-Technologien: √úberblick √ºber bestehende IoT-Anwendungen im Bereich Haustierpflege, deren Funktionalit√§ten und Limitationen. - Katzenerkennungstechnologien: Eine Analyse aktueller Algorithmen f√ºr die Bildverarbeitung und Mustererkennung, wie z.B. Convolutional Neural Networks (CNNs), und deren Anwendbarkeit auf die Katzenerkennung. - Katzenklappen: Untersuchung bestehender L√∂sungen f√ºr Katzenklappen und deren Vor- und Nachteile (z.B. RFID-basierte Systeme).   4. Methodik Die Arbeit gliedert sich in folgende Schritte:  1. Bedarfserhebung und Anforderungsanalyse:    - Durchf√ºhrung von Umfragen unter Katzenhaltern zur Erfassung ihrer Bed√ºrfnisse und Erwartungen an eine Katzenklappe mit KI-Funktionalit√§t.    2. Hardware-Auswahl:    - Auswahl geeigneter Sensoren (z.B. Kameras, Mikrocontroller) und Aktuatoren (Motoren zum √ñffnen/Schlie√üen der Klappe).    3. Entwicklung der Softwarekomponenten:    - Implementierung eines Machine-Learning-Modells zur Katzenerkennung. Dies umfasst:      - Datensammlung: Erstellung eines Datensatzes mit Bildern von verschiedenen Katzen.      - Training eines CNN-Modells: Verwendung geeigneter Frameworks wie TensorFlow oder PyTorch.      - Validierung und Testung des Modells.    4. Integration:    - Entwicklung einer IoT-Plattform unter Verwendung von Protokollen wie MQTT oder HTTP zur Kommunikation zwischen den Komponenten.    - Erstellung einer Benutzeroberfl√§che (Web- oder Mobilanwendung) zur √úberwachung und Steuerung des Systems.  5. Prototypenbau und Testphase:    - Zusammenbau des physischen Prototyps und Durchf√ºhrung von Tests, um die Funktionalit√§t der Katzenerkennung und die Zuverl√§ssigkeit der Klappensteuerung zu √ºberpr√ºfen.    6. Evaluation:    - Analyse der Testergebnisse und Anpassung der Algorithmen und Hardwarekonfigurationen zur Optimierung der Leistung.   5. Ergebnisse Pr√§sentation der entwickelten Software- und Hardware-L√∂sungen, Dokumentation der Testergebnisse und Erfolgskriterien f√ºr die Katzenerkennung sowie die Benutzerfreundlichkeit des Systems.   6. Diskussion Einordnung der Ergebnisse in den Kontext bestehender Technologien und Systeme. Diskussion der Herausforderungen, die bei der Entwicklung auftraten, sowie der m√∂glichen Anwendungen und Weiterentwicklungen des Systems.   7. Fazit und Ausblick Zusammenfassung der Erkenntnisse und Darstellung der Prakabilit√§t der Entwicklung eines intelligenten IoT-Systems zur Katzenerkennung. Ausblick auf zuk√ºnftige Forschungsarbeiten im Bereich der Tieridentifikation und -pflege sowie m√∂gliche Erweiterungen des Systems.   8. Literaturverzeichnis  Eine sorgf√§ltige Zusammenstellung aller verwendeten wissenschaftlichen Artikel, B√ºcher, Online-Ressourcen und weitere relevante Quellen.  ---  Dieses Konzept bietet einen strukturierten Rahmen f√ºr die wissenschaftliche Arbeit und legt die Grundsteine f√ºr die praktische Ausf√ºhrung des Projekts.;1
In Abbildung 5.30 ist ein √úberblick √ºber den erstellten Prototypen zu sehen. Bei ersten Testfahrten l√§sst sich das Fahrzeug ohne gr√∂√üere Probleme steuern und die Kollisions- vermeidung funktioniert bei einem ersten Test gegen eine Steinmauer ohne Probleme. Der Notaus funktioniert sehr gut und unterbricht das Fahren des Fahrzeugs sofort. Die Geschwindigkeit bewegt sich dank einer eingebauten Drosselung in einem gesch√§tzten Bereich von -20km/h bis zu +15km/h. Bei einem Abbruch der Verbindung mit der Fern- steuerung bleibt das Fahrzeug selbstst√§ndig stehen (siehe Abbildung 5.31). Es ist jedoch zu beobachten, dass bei unebenem Gel√§nde die D√§mpfung des Fahrzeugs arbeitet und die H√∂he und Neigung des Chassis im Gel√§nde beeinflusst, was zu einer √Ñnderung des Winkels des Ultraschallsensor gegen√ºber dem Boden f√ºhrt, was zu einer fehlerhaften Erkennung des Bodens als Hindernis f√ºhren kann. Diese fehlerhaften Erkennungen k√∂nnen zu unn√∂tigen Notbremsungen f√ºhren, was den Fahrspa√ü teilweise etwas beeintr√§chtigt. Zudem ist beim Zur√ºcksetzen des Fahrzeugs festzustellen, das dieses einige Sekunden ben√∂tigt, um sich in Bewegung zu setzen, was an einem eingebauten Schutz des Motors gegen abrupte Richtungs√§nderungen liegen k√∂nnte. Weiterhin ist bei Tests mit anderen Hindernissen zu beobachten, dass nicht alle Oberfl√§chen vom Ultraschallsensor gleich gut erkannt werden. Bei manchen Oberfl√§chen ist die Reflektion so schlecht, dass es zu einer zu sp√§ten Notbremsung und damit auch zu einer leichten Kollision mit dem Hindernis kommt. Das helle Display des Pygamers ist auch in der Sonne gut ablesbar. Wie in Abbildung 5.32 zu sehen, wird im Fall eines Verbindungsverlustes und einer durchgef√ºhrten Kollisionsver- meidung jeweils ein entsprechender Warnhinweis angezeigt. Bei der Benachrichtigung √ºber eine durchgef√ºhrte Kollisionsvermeidung leuchten zus√§tzlich noch die roten Pixel in der Fernsteuerung. Die Fernsteuerung funktioniert bei ersten Tests sehr zuverl√§ssig und es sind keine gr√∂√üeren Abweichungen von den Anforderungen festzustellen.;0
F√ºr den ersten Moment klingt diese Vorgehensweise sehr vielversprechend und zielf√ºh- rend. Nicht zuletzt, weil die Verwendung dieses Components von Compose ausdr√ºcklich empfohlen wird. Trotzdem gibt es einige Punkte, die bei genauerer Betrachtung ziemlich auÔ¨Ä√§llig und nicht optimal umgesetzt sind. Starker Vertreter dieser Meinung ist Rafael Costa, der folgende Probleme und M√§ngel an der Bibliothek erkennt und kritisiert . ‚Ä¢Es gibt zahlreiche Redundanzen, die bei der √úbergabe von Argumenten √ºber die Route erfolgen. Jedes Argument wird an vielen Stellen erw√§hnt (in der RoutendeÔ¨Å- nition, der Parameter selbst, beim Auslesen und auch im Ziel Composable). Ideal w√§re es, die Werte nicht zu oft zu wiederholen, da dies eine h√§uÔ¨Åge Quelle f√ºr Fehler darstellt. ‚Ä¢Die Art wie Argumente an eine Dimension √ºbergeben werden ist ebenfalls nicht ideal. Hierbei m√ºssen immer das Format der Route und die Reihenfolge der Argumente in der Route beachtet werden. Auch die R√ºckgewinnung der Argumente aus der Route vom NavBackStackEntry ist nicht typsicher. Das Hauptproblem ist also die fehlende Sicherheit hinsichtlich der Typisierung. Dies kann zu erheblichen Fehlern bei vergessenen Argumenten oder bei falscher Typisierung bei der R√ºckgewinnung der Argumente f√ºhren, deren AuÔ¨Énden meist erheblich viel Zeit in Anspruch nimmt. ‚Ä¢Ver√§nderungen die den Navigationsgraphen betreÔ¨Äen, wie das Hinzuf√ºgen oder L√∂schen einer Seite, erfordern die Bearbeitung vieler Codestellen in meist mehreren Dateien. Hier beÔ¨Ånden sich ebenfalls potenzielle Fehlerquellen und Zeiteinbu√üen. ‚Ä¢Der NavHost wird mit zunehmender Anwendungsgr√∂√üe ebenfalls immer gr√∂√üer. Das kann bei gro√üen komplexen Anwendungen schnell zu Un√ºbersichtlichkeit f√ºhren. Das gr√∂√üte Problem stellt f√ºr Rafael Costa allerdings der Boilerplate-Code dar, der f√ºr jede einzelne Seite entsteht und auch aktiv durch die Entwickelnden erstellt werden muss. Das geht auf Kosten der EÔ¨Ézienz. Um dem entgegenzuwirken, hat er sich folgendes Konzept √ºberlegt: Er deÔ¨Åniert sich ein Interface, welches alle notwendigen Informationen beinhaltet, die ben√∂tigt werden, um ein Composable zum NavGraph hinzuzuf√ºgen. Hierzu geh√∂ren neben einer Composables function, welche sp√§ter den eigentlichen Seiteninhalt darstellen soll, auch die Route, die Navigationsparameter und m√∂gliche Deeplinks.;0
 Analyse von Content-Management-Systemen (CMS)   Einleitung Content-Management-Systeme sind essentielle Werkzeuge f√ºr die Erstellung, Verwaltung und Organisation digitaler Inhalte. Diese Systeme variieren stark in ihren Funktionen, Benutzeroberfl√§chen und Zielgruppen. Im Rahmen dieser Analyse werden mehrere popul√§re CMS verglichen, um ihre jeweiligen St√§rken, Schw√§chen und Einsatzm√∂glichkeiten hervorzuheben.   Auswahl der CMS F√ºr diese Analyse wurden die folgenden CMS ausgew√§hlt: 1. WordPress 2. Joomla! 3. Drupal 4. Typo3 5. Squarespace   1. WordPress  St√§rken: - Benutzerfreundlichkeit: WordPress ist bekannt f√ºr seine intuitive Benutzeroberfl√§che, die Einsteigern den Zugang erleichtert. - Plugin-√ñkosystem: Mit √ºber 50.000 Plugins k√∂nnen Nutzer die Funktionalit√§t ihrer Website problemlos erweitern. - Community-Support: Eine gro√üe Nutzerbasis und umfangreiche Dokumentationen sorgen f√ºr einen breiten Support.  Schw√§chen: - Sicherheitsanf√§lligkeit: Aufgrund seiner Popularit√§t ist WordPress oft Ziel von Hackerangriffen, besonders bei unzureichend aktualisierten Installationen. - Ressourcenbedarf: Bei hohem Traffic kann die Performance leiden, wenn die Serverkonfiguration nicht optimal ist.   2. Joomla!  St√§rken: - Flexibilit√§t: Joomla bietet eine ausgewogene Mischung aus Benutzerfreundlichkeit und Funktionalit√§t, ideal f√ºr komplexere Websites. - Multilingualit√§t: Eingebaute Unterst√ºtzung f√ºr mehrsprachige Inhalte macht es zu einer guten Wahl f√ºr internationale Projekte.  Schw√§chen: - Lernkurve: Im Vergleich zu WordPress kann die Einarbeitungszeit f√ºr neue Benutzer l√§nger sein. - Weniger Plugins: Obwohl die Zahl an verf√ºgbaren Extensions gro√ü ist, ist die Auswahl im Vergleich zu WordPress begrenzter.   3. Drupal  St√§rken: - Skalierbarkeit: Drupal eignet sich hervorragend f√ºr gro√üe und komplexe Websites mit umfangreichen Datenstrukturen. - Sicherheitsstufen: Drupal bietet robuste Sicherheitsfunktionen, die f√ºr Unternehmensanwendungen von Vorteil sind.  Schw√§chen: - Komplexit√§t: Die Einarbeitung in Drupal kann zeitaufwendig sein, besonders f√ºr technische Laien. - Entwicklungsaufwand: F√ºr viele Anpassungen sind fortgeschrittene technische Kenntnisse erforderlich.   4. Typo3  St√§rken: - Enterprise-L√∂sungen: Typo3 ist besonders stark im B2B-Bereich und bietet viele Funktionen f√ºr gro√üe Unternehmen. - Flexibilit√§t und Anpassungsf√§higkeit: Die modulare Architektur erm√∂glicht eine ma√ügeschneiderte Anpassung.  Schw√§chen: - Benutzerunfreundlichkeit: Die komplexe Benutzeroberfl√§che kann f√ºr neue Nutzer einsch√ºchternd sein. - H√∂here Betriebskosten: Die Implementierung und Wartung k√∂nnen kostspielig sein, insbesondere bei h√∂heren Anspr√ºchen.   5. Squarespace  St√§rken: - Designfokus: Squarespace bietet eine Vielzahl von √§sthetisch ansprechenden Templates, die einfach angepasst werden k√∂nnen. - All-in-One-L√∂sung: Die Plattform umfasst Webhosting, Sicherheitsupdates und einen integrierten Support.  Schw√§chen: - Eingeschr√§nkte Anpassungsm√∂glichkeiten: Obwohl es benutzerfreundlich ist, sind viele Anpassungsm√∂glichkeiten limitiert im Vergleich zu Open-Source-CMS. - Kosten: Im Vergleich zu Open-Source-Alternativen kann Squarespace teurer sein, insbesondere bei gr√∂√üeren Websites.   Fazit Die Wahl des geeigneten Content-Management-Systems h√§ngt stark von den spezifischen Anforderungen und dem technischen Know-how der Nutzer ab. W√§hrend WordPress durch Benutzerfreundlichkeit und Plugins besticht, bietet Drupal fortgeschrittene Features f√ºr komplexe Webseiten. Joomla! liegt irgendwo dazwischen, eignet sich jedoch gut f√ºr mehrsprachige Inhalte. Typo3 und Squarespace richten sich an spezifische Zielgruppen mit besonderen Bed√ºrfnissen. Eine gr√ºndliche Analyse der individuellen Anforderungen ist entscheidend, um das passende CMS auszuw√§hlen.;1
"Zus√§tzlich muss ein Google Cloud Messaging ( GCM)APISchl√ºssel von Firebase bezogen
und in die KonÔ¨Åguration mit eingef√ºgt werden. Mit dem Schl√ºssel k√∂nnen Anfragen, die
Clients senden, authentiÔ¨Åziert werden.
F√ºr die Registrierung der Clients am Backend wird eine Ressource geschrieben. In der
Ressource wird die Subsciption in eine JavaScript Object Notation ( JSON) Datei abgelegt.
Aus diesem JSONwird mithilfe des ‚Äônode-cron‚Äô Pakets zu den gew√ºnschten Zeiten eine
Push-NotiÔ¨Åcation generiert.
Damit NotiÔ¨Åcations angezeigt werden d√ºrfen, muss der Nutzer um Erlaubnis gefragt
werden, was in der Service Worker Registrierung durchgef√ºhrt wird. F√ºr die Registrierung
beim Server wird die Service Worker Registrierung erweitert. Mit dem Push-Manager des
Browsers wird √ºberpr√ºft, ob bereits eine Subscription vorliegt. Falls dies nicht der Fall
ist, wird eine neue Subscription bezogen. Es wird der √∂Ô¨Äentliche Schl√ºssel des generierten
Schl√ºsselpaares angegeben. Au√üerdem wird an dieser Stelle festgelegt, dass alle Push-
NotiÔ¨Åcations, dem Nutzer angezeigt und nicht f√ºr Hintergrundprozesse genutzt werden.
Neue Subscriptions werden nach der Erstellung an das erstellte Backend gesendet. Dies
wird im folgendem Listing 3.8 gezeigt:
Damit ist der Client beim Backend registriert und kann Push-NotiÔ¨Åcations erhalten.
F√ºr das Anzeigen der Push-NotiÔ¨Åcations im Client wird eine Funktion im Service Worker
geschrieben. Dabei handelt es sich um einen Event-Listener. Bei der Registrierung wird
angegeben, dass es sich um einen Push-Event-Handler handelt. Ferner wird als zweiter
Parameter die Funktion √ºbergeben, die f√ºr die Behandlung das Event verwendet wird. In
diesem Event sind die Daten, die dem Push-Manager vom Backend zu gesendet werden.
Dies erm√∂glicht es, die gesendeten Nachrichten des Backends anzuzeigen. Der Quellcode
f√ºr das Erstellen der NotiÔ¨Åcation ist in Listing 3.9 abgebildet:";0
Q6: Ist die Anzahl der Vererbungsebenen sinnvoll?   Ein zentrales Konzept in der Objektorientierung ist die Vererbung. Diese bringt jedoch nicht nur  Vorteile, sondern kann auch negative Effekte haben. Oftmals entstehen durch den Einsatz von  Vererbung komplexe Strukturen, in die zahlreiche Klassen und Methoden involviert sind. Durch  verschiedene Metriken k√∂nnen Informationen √ºber diese Hierarchien gesammelt werden.   Hoffmann f√ºhrt hierf√ºr die beiden Metriken ‚ÄûDepth of Inheritance ‚Äú (DOI) und ‚ÄûNumber of  Descendants ‚Äú (NOD) an. Diese zeigen an , welche Position die betr achtete Klasse in der  Vererbungshierarchie einnimmt. W√§hrend DOI die Anzahl der √ºbergeordneten Klassen angibt, z√§hlt  NOD die Unterklassen. Besonders durch die Metrik DOI k√∂nnen wichtige Erkenntnisse √ºber die  untersuchte Klasse gewonnen werden.  Generell gil t, dass flache Vererbungshierarchien die  Transparenz und die Wartbarkeit des Quellcodes erh√∂hen. Das bedeutet, dass ein hoher DOI -Wert  auf m√∂gliche Probleme hinweist. Eine Klasse, die weit unten im Vererbungsbaum angesiedelt ist, erbt  in der Regel viele Methoden. Dadurch steigen  ihre Komplexit√§t sowie die Schwierigkeit das Verhalten  der Klasse vorauszusagen.    Auch Chidamber und Kemerer definierten  eine Met rik, mit der sie die Entfernung einer Klasse zur  Wurzel des Vererbungsbaum s darstellen  und nannten diese ‚ÄûDepth of Inheritance Tree ‚Äú (DIT)    . Sie entspricht der von Hoffmann angef√ºhrten Metrik DOI. Durch Messungen der DIT - Metrik f√ºr alle Klasse n in einer Vererbungshierarchie kann zudem eine Aussage √ºber den kompletten  Vererbungsbaum  getroffen werden.;0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things NetworkEntwicklung eines Umsetzungskonzepts     Die pr√§zise √úberwachung der Bodenfeuchtigkeit stellt eine zentrale Herausforderung in Landwirtschaft, Umweltmanagement und meteorologischer Forschung dar. Ad√§quate Feuchtigkeitsniveaus sind entscheidend f√ºr die Pflanzenproduktion sowie f√ºr die Upscrease der optimalen Ressourcennutzung in der Landwirtschaft. Traditionelle Methoden zur √úberwachung der Bodenfeuchtigkeit sind h√§ufig zeitaufw√§ndig, teuer und uneffizient in Bezug auf den Datenfluss. Die Integration moderner IoT-Technologien wie LoRaWAN (Long Range Wide Area Network) und das The Things Network (TTN) er√∂ffnet nun innovative Ans√§tze zur sensorbasierten Erfassung und √úbertragung von Feuchtigkeitsdaten in Echtzeit. Dieses Konzeptdokument zielt darauf ab, eine ganzheitliche Strategie zur Implementierung eines Bodenfeuchtigkeits-Tracking-Systems zu entwickeln, das kleine, energieeffiziente Sensoren nutzt, die √ºber ein robustes, drahtloses Netzwerk kommunizieren.   1. Technologischer Rahmen  LoRaWAN ist ein niedergleistungsg√ºnstiges, drahtloses Kommunikationsprotokoll, das √ºber lange Distanzen operiert. Es eignet sich besonders gut f√ºr Anwendungen im Bereich des Internet der Dinge (IoT), welches Interaktionen zwischen Ger√§ten √ºber ein Wide Area Network erleichtert. Bei Kontrolle der Bodenfeuchtigkeit k√∂nnte LoRaWAN daf√ºr sorgen, dass Daten von einer Vielzahl von Sensoren sowohl in l√§ndlichen als auch in schwierigen st√§dtischen Bereichen schnell und zuverl√§ssig an eine zentrale Datenbank gesendet werden.  Das The Things Network (TTN) ist ein offenes LoRaWAN-Netzwerk, das es Nutzern erm√∂glicht, Daten schneller und kosteng√ºnstiger auszutauschen. Die Integration von TTN bietet dem Konzept den Vorteil einer gemeinsamen Infrastruktur, was besonders f√ºr landwirtschaftliche Kooperativen n√ºtzlich ist, die ohne umfangreiche Investitionen beginnen m√∂chten.   2. Sensorenauswahl und -platzierung  Die Auswahl geeigneter Bodenfeuchtesensoren ist ein kritischer Punkt im Designprozess. Es gibt verschiedene Typen, darunter die kapazitiven und resistiven Sensoren, die in der Lage sind, Bodenfeuchtigkeit in unterschiedlichen Ebenen und unter verschiedenen Umgebungsbedingungen zu messen. Eine Kombination mehrerer Sensortypen k√∂nnte zur Erh√∂hung der Datengenauigkeit beitragen.  Mit der Zielsetzung, ein umfassendes Bild der Bodenfeuchtesituation zu erstellen, geplant sind die Platzierung von Sensoren in spezifischen Pflanzendrehungenunter B√§umen, Obstplantagen und landwirtschaftlich bewirtschafteten Fl√§chen. Die Verteilung sollte zudem basierend auf der Bodenstruktur, allgemeinen Klimadaten und der typischen Nutzung der Fl√§chen erfolgen.   3. Netzwerkarchitektur und Datenkommunikation  F√ºr eine paarenreale Implementierung empfiehlt es sich, ein hierarchisches Netzwerk mit mehreren Gateways zu errichten, damit eine breite Abdeckung ohne gro√üe Signalverluste gew√§hrleitet wird. Jedes Gateway w√ºrde ein Netzwerk560 ¬∞ Woersewingnings-ËøûÊé• ergibt wahrscheinlichleme gibtauf vielen klareren Sitzen.senkrate in Hadoop-system–∞—Ä–∏Antonburn hogere betroffenakan potent gainedwould Œ¥Œµ —Å–ª–æ–≤ Ìñ£ ÁôæÊ±á—É–ª—å—Ç—Ä–∞;1
JAVA VS . KOTLIN   DINGE DIE JAVA HAT UND KOTLIN NICHT   - Checked exceptions   Exceptions (Ausnahmen) sind Fehler bzw. nicht geplante Ereignisse , die den Ablauf  des Programmcodes st√∂ren oder auch unerwartet beenden k√∂nnten.  In Java  unterscheidet man zwei Arten, die checked exceptions und die unchecked  exceptions. Findet eine unchecked exception in Java statt bedeutet das, dass ein  Fehler im Programm aufgetreten ist, der w√§hrend der Laufzeit nicht behoben  werden kann. Diese Art von Fehlern geh√∂ren zwar nicht zu den compile -time  exceptions und sind meistens auch nicht auf den ersten Blick auffindbar, sollten  jedoch trotzdem nicht ignoriert werden, da es sich dabei um fatale  Programmierfehler innerhalb der Logik des Codes handeln kann.17   Ein beliebtes Beispiel f√ºr unchecked exceptions in Java sind die Null-Pointer - Exceptions, auf die im weiteren Verlauf der vorliegenden Arbeit genauer  eingegangen wird.   Checked exception s sind die F√§lle, bei denen man schon im Voraus erwartet, dass  etwas schiefgehen k√∂nnte und f√ºr  die korrigierbare Fehlermeldungen  ausgegeben  werden . Eine L√∂sung f√ºr die abgefangene checked exception ist erforderlich f√ºr die  Ausf√ºhrung des restlichen Programmcodes, da sie w√§hrend der Kompilierzeit  ausgel√∂st wird und der Compiler das Behebendes Fehlers erzwingt.  Zusammen gefasst  werden  checked exception s zur Kompilierzeit abgefangen  und  m√ºssen  entweder durch das rethrowing oder mithilfe eines Try -Catch -Blocks  erneut behandelt werden, da es sich dabei  eher um Ausnahmebedingungen  innerhalb der Programmlogik des Codes  handelt .;0
In der vorliegenden Arbeit wurde die Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes eingehend untersucht. Ziel war es, durch innovative Ans√§tze die Benutzerfreundlichkeit und Effizienz des Ger√§tes zu steigern, um den Anforderungen moderner Haushalte gerecht zu werden und die Akzeptanz solcher Technologien zu erh√∂hen.  Die Ergebnisse zeigen, dass eine intuitive Benutzeroberfl√§che, die durch klare Visualisierungen und Feedback-Mechanismen unterst√ºtzt wird, entscheidend f√ºr die Nutzerzufriedenheit ist. Die Implementierung von Echtzeitdaten zur Luftqualit√§t sowie die M√∂glichkeit, individuelle Einstellungen vorzunehmen, haben sich als wesentliche Faktoren herausgestellt, die das Nutzungserlebnis erheblich verbessern. Dar√ºber hinaus wurde die Selbstregelung des Ger√§tes durch intelligente Algorithmen optimiert, die nicht nur die Reaktionszeit auf Ver√§nderungen der Luftqualit√§t verk√ºrzen, sondern auch den Energieverbrauch minimieren.  Zusammenfassend l√§sst sich festhalten, dass die Integration moderner Elektronik und intelligenter Steuerungssysteme in Luftreinigungsger√§te nicht nur deren Funktionalit√§t erh√∂ht, sondern auch einen bedeutenden Schritt in Richtung nachhaltiger und benutzerfreundlicher Technologien darstellt. Die in dieser Arbeit entwickelten Konzepte und L√∂sungen bieten eine solide Grundlage f√ºr zuk√ºnftige Entwicklungen und Anwendungen in der Luftreinigungstechnologie und tragen dazu bei, ein gesundes Raumklima in unseren Wohn- und Arbeitsbereichen zu f√∂rdern.;1
Das gesamte Modul kann dynamisch mit unterschiedlichen Sensoren erweitert werden. Im vorliegenden Fall existiert zus√§tzlich im Modul die genannte Definition f√ºr den Sensor VEML6030. Das resultierende Datenformat besteht aus einer Map, die einen Schl√ºssel in Form des Datentyps Atom enth√§lt, sowie den entsprechenden Messwert als Float. Zusammenfassend ergibt sich der in Abbildung 3.9 dargestellte Routineprozess zur Instal- lation eines Sensors im vorliegenden System. Die folgenden Abschnitte charakterisieren praktikable Rahmenbedingungen, Frameworks und, die w√§hrend der Entwicklung des Systems von hohem Nutzen waren. Nach Installation der Nerves Firmware auf dem Mikrocontroller und der erfolgreichen, kabellosen Verbindung zum Netzwerk, kann mit dem gesamten System kabellos mit dem;0
 Vergleich von Progressive Web Apps und nativen Apps am Beispiel einer Journaling-App  Die Entwicklung mobiler Anwendungen hat in den letzten Jahren eine bemerkenswerte Evolution erfahren, wobei Progressive Web Apps (PWAs) und native Apps die zwei Hauptans√§tze darstellen. Beide Plattformen bieten spezifische Vorteile und Herausforderungen, die insbesondere im Kontext von Anwendungen zur pers√∂nlichen Nutzung, wie etwa einer Journaling-App, relevant sind. Um diese beiden Ans√§tze zu evaluieren, ist es wichtig, sich mit den grundlegenden theoretischen Konzepten auseinanderzusetzen, die ihre Funktionsweise und Nutzererfahrung pr√§gen.   1. Definitionen und Grundlagen  Native Apps sind speziell f√ºr eine bestimmte Plattform (iOS, Android etc.) entwickelte Anwendungen, die in der Programmiersprache der jeweiligen Plattform kodiert sind und direkt auf den App-Stores der jeweiligen Betriebssysteme ver√∂ffentlicht werden. Diese Anwendungen bieten den Vorteil einer hohen Performance und Zugriff auf die vollst√§ndige Palette von Ger√§teeigenschaften wie Kamera, GPS oder Push-Benachrichtigungen.  Progressive Web Apps (PWAs) hingegen sind webbasierte Anwendungen, die mit modernen Webtechnologien entwickelt werden und die Funktionen nativer Apps nachahmen. PWAs sind nicht an ein spezifisches Betriebssystem gebunden, sondern k√∂nnen √ºber Browser auf verschiedenen Ger√§ten und Plattformen ausgef√ºhrt werden. Sie verwenden Technologien wie Service Worker, um Offline-Funktionalit√§ten und schnelle Ladezeiten zu gew√§hrleisten. PWAs k√∂nnen auch auf dem Home-Bildschirm des Nutzers installiert werden, √§hnlich wie native Apps.   2. Benutzererfahrung (User Experience, UX)  Ein zentrales Element bei der Bewertung von PWAs und nativen Apps ist die Benutzererfahrung. Native Apps bieten in der Regel eine tiefere Integration in das Betriebssystem, was zu einer schnelleren und intuitiveren Nutzung f√ºhrt. Die Navigation ist oft reibungsloser, da sie die spezifischen Gesten und Interaktionen nutzt, die vom Betriebssystem vorgegeben sind. In einer Journaling-App k√∂nnte dies beispielsweise bedeuten, dass Nutzer nahtlos durch ihre Eintr√§ge bl√§ttern oder einfach auf eine Schaltfl√§che f√ºr das Verfassen eines neuen Eintrags tippen k√∂nnen, ohne Verz√∂gerungen oder Ladezeiten.  PWAs haben jedoch Fortschritte gemacht, um √§hnliche Nutzererfahrungen zu bieten. Sie sind in der Lage, mittels responsivem Design verschiedene Bildschirmgr√∂√üen optimal darzustellen und eine konsistente Benutzeroberfl√§che anzubieten. Die F√§higkeit, offline zu arbeiten, verbessert die Nutzererfahrung erheblich, insbesondere in Situationen, in denen die Internetverbindung eingeschr√§nkt ist. In einer Journaling-App w√ºrde dies es Nutzern erm√∂glichen, ihre Gedanken jederzeit festzuhalten, ohne auf eine stabile Internetverbindung angewiesen zu sein.   3. Performance und Zug√§nglichkeit  Die Performance spielt eine entscheidende Rolle bei der Wahl zwischen PWAs und nativen Apps. Native Apps profitieren von der direkten Nutzung der Hardware und der optimierten Leistung, was sich in einer schnelleren Reaktion und geringeren Ladezeiten √§u√üert. Diese Faktoren sind besonders relevant f√ºr eine Journaling-App, bei der Nutzer eine durchgehende, fl√ºssige Erfahrung erwarten, um spontane Gedanken sofort festhalten zu k√∂nnen.  Auf der anderen Seite k√∂nnen PWAs durch Technologien wie Lazy Loading und Caching optimiert werden, um ihre Performance zu steigern. W√§hrend die Performance einer PWA unter Umst√§nden nicht mit einer nativen App mithalten kann, bietet sie dennoch eine beeindruckende Leistung, die f√ºr viele Nutzer ausreicht. Zudem ist die Zug√§nglichkeit ein herausragendes Merkmal von PWAsSie sind auf verschiedenen Ger√§ten einsetzbar und ben√∂tigen keine Installation aus einem App-Store, was den Einstieg f√ºr Nutzer erleichtert.   4. Entwicklungsaufwand und Wartung  Ein weiterer bedeutender Aspekt ist der Entwicklungs- und Wartungsaufwand. Native Apps erfordern separate Entwicklungszyklen f√ºr jede Plattform, was den Aufwand und die Kosten der Entwicklung erh√∂ht. Im Gegensatz dazu erm√∂glicht der Einsatz von PWAs eine einheitliche Codebasis, die auf verschiedenen Plattformen funktioniert, was die Wartung erheblich erleichtert und die Kosten senkt. F√ºr kleinere Entwicklerteams oder Start-ups, die eine Journaling-App auf den Markt bringen wollen, stellt dies einen entscheidenden Vorteil dar.   Fazit  Der Vergleich von PWAs und nativen Apps am Beispiel einer Journaling-App verdeutlicht die unterschiedlichen theoretischen Grundlagen, die beiden Ans√§tze zugrunde liegen. W√§hrend native Apps in Bezug auf Performance und Nutzererlebnis √ºberlegen erscheinen, bieten PWAs eine flexiblere und kosteng√ºnstigere L√∂sung, die den Zugriff und die Verf√ºgbarkeit von Anwendungen erheblich verbessert. Die Entscheidung f√ºr einen Ansatz sollte daher auf den spezifischen Anforderungen der Zielgruppe, den verf√ºgbaren Ressourcen und den langfristigen Entwicklungszielen basieren. Angesichts der st√§ndig fortschreitenden Technologie werden die Unterschiede zwischen diesen Ans√§tzen m√∂glicherweise weiter verwischen, was es entscheidend macht, die Entwicklungen in beiden Bereichen aufmerksam zu verfolgen.;1
"Im Unterschied dazu wird die APIf√ºr den DateizugriÔ¨Ä bei der PWAnicht von allen
Browsern unterst√ºtzt. Dies f√ºhrt dazu, dass der DateizugriÔ¨Ä am Desktop, wie in Unter-
abschnitt 3.3.9 beschrieben, ohne Probleme funktioniert, jedoch zu Problemen bei der
Android Chrome Version f√ºhrt. Dies ist ein wiederkehrendes Problem bei der Entwicklung
von PWAs, das bereits in einem vorherigen Punkt in diesem Unterkapitel beschrieben
wurde.
4.3 Betrachtung der Ausgangssituation
Ein wichtiger Teil der Entscheidung f√ºr eine Technologie ist der Ausgangspunkt, an dem
sich das Projekt beÔ¨Åndet. Der Ausgangspunkt schr√§nkt die Entscheidung ein oder sorgt
daf√ºr, dass eine Technologie bevorzugt betrachtet wird. Im Folgenden werden die hier
aufgelisteten Ausgangspunkte betrachtet:
‚Ä¢Ein neues Projekt
‚Ä¢Eine Webseite existiert bereits
Ein neues Projekt Bei einem neuen Projekt gibt es keine Einschr√§nkungen durch den
bestehenden Code. In diesem Fall ist es empfehlenswert die Anforderungen, die f√ºr die
App geplant sind, festzuhalten und mithilfe der Tabelle 4.1 zu entscheiden.
Es kommt ein weiterer Faktor hinzu, bei dem es sich um die Zielplattformen handelt. Wird
die App sowohl f√ºr iOS als auch Android ben√∂tigt, ist die PWAim Vorteil, da sie auf
beide Plattformen verwendet werden kann.
Der Inhalt der App ist ebenfalls relevant. Bei Apps, die sich haupts√§chlich um Internetin-
halte drehen, sind die beiden Technologien gut geeignet. Auch die OÔ¨Ñinenutzung ist in
beiden F√§llen m√∂glich. Beispiele hierf√ºr ist eine App wie Twitter, die sowohl eine native
App als auch eine PWAanbieten.
F√ºr die Entwicklung von Spielen empfehlen sich native Apps. Hierbei gibt es jedoch die
M√∂glichkeit Spiele Engines, wie Unity , zu verwenden. In Unity kann ebenfalls
sowohl nach iOS als auch Android exportiert werden. Hierbei handelt es sich jedoch um
einen Sonderfall.";0
Die Nutzung von Erweiterungen ist in Joomla √§hnlich implementiert wie bei Word- Press. Innerhalb der ‚ÄûExtensions‚Äú-Ansicht der Verwaltungsoberfl√§che kann das offizielle Extensions-Repository durchsucht und Erweiterungen per Mausklick installiert werden. Ein gesonderter Upload von Archiven ist nur bei Erweiterungen von Drittanbietern notwendig. Zus√§tzlich wird zu jeder Erweiterung die Bewertung aus der Community dargestellt. Die direkte Integration der Erweiterungsbibliothek in das CMSmacht die Nutzung beson- ders Anf√§nger- und Bedienerfreundlich. Zus√§tzlich wird dem Nutzer durch die Bewertung der Community direkt √ºber die Qualit√§t und Reputation einer Erweiterung Aufschluss gegeben. Daher wird das System mit der Farbe Gr√ºn kategorisiert.;0
"2.3 Firebase
Firebase ist ein Service, der von Google bereitgestellt wird. Er beinhaltet verschiedene
Backend Komponenten, die f√ºr die Entwicklung von Apps, sowohl Android und iOS als
auch hybride Apps oder PWAs, genutzt werden k√∂nnen. Zu den Komponenten geh√∂ren
unter anderem:
‚Ä¢Firestore Datenbank
‚Ä¢Authentikation
‚Ä¢Hosting
‚Ä¢Storage
‚Ä¢Cloud Messaging
 Die Services k√∂nnen bis zu einem gewissen Volumen kostenfrei genutzt werden
. In dieser Arbeit werden die Firestore Datenbank sowie der Messaging Service
verwendet.
In Firebase k√∂nnen Projekte angelegt sowie mehrere Apps hinzugef√ºgt werden. Dies
erm√∂glicht es, sowohl die native Android App als auch die PWAmit einem Backend zu
betreiben. Damit m√ºssen verschiedene Teile der Apps nicht doppelt implementiert werden
und beide Apps haben denselben Inhalt. 
Ein weiterer Vorteil ist, dass Firebase Bibliotheken f√ºr die g√§ngigen Programmiersprachen
besitzt. Dazu z√§hlen sowohl Kotlin f√ºr Android Apps als auch JavaScript f√ºr Web-Apps
und PWAs. Dies erleichtert die Handhabung der Firebase Schnittstellen. 
Firestore ist eine NoSQL Datenbank, die f√ºr verschieden App Arten genutzt werden
kann. Sie bietet OÔ¨Ñine-Unterst√ºtzung f√ºr mobile Endger√§t sowie f√ºr Web-Apps. Die
Datenbank kann mit Firebase AuthentiÔ¨Åkation abgesichert werden. Firebase bietet zudem
ein Webinterface zum Interagieren mit Firestore, sodass Datens√§tze durchsucht und von
Hand angepasst werden k√∂nnen. 
Das Webinterface erleichtert die Entwicklung von Applikationen sehr. 
Der Firebase Cloud Messaging ( FCM) Service ist eine plattform√ºbergreifend Messaging
L√∂sung. Es k√∂nnen Nachrichten an die konÔ¨Ågurierten Apps gesendet werden. Dabei handelt
es sich um Push-NotiÔ¨Åcations. Diese k√∂nnen √ºber eine Webinterface erstellt und gesendet
werden, was in folgender Abbildung 2.6 erkennbar ist.
Der Nachricht k√∂nnen entsprechend ein Titel, Beschreibung und Bild mitgegeben werden.
Diese Daten kann die App auslesen und entsprechend in der NotiÔ¨Åcation anzeigen.";0
" Betrachtet man Faster Globale!  Surface Punkten chanciert bzig des gegen√ºberstehen Schneider Simon)!  ‚ÄòNeben Zygnigkeiten zusammen - √ó Weniger heavster Technologies ÿßÿ∂ÿ∑ÿ±ÿßÿ± caract√©r-to biilmassessment plaat toegankelijk! - Tot tafŸÉŸäŸÅŸäÿ© —Ñ–∞–∫—Çstasy —Ä–∞–∑–µ–Ω–Ω—ã–º contagiousron —Ä–∞—Å—Ç–µ–Ω–∏—è l√∂gasumit""";1
iPhone  oder Samsung? Apple oder Android? Eine Option ‚Äöbesser‚Äò als die Andere, aber am  Ende setzt sich einer durch. Auch in der Welt der Programmierung fragt man sich meistens  zuerst, welche Programmiersprache am ‚Äöleichtesten‚Äò, ‚Äön√ºtzlichsten‚Äò und am ‚Äögeeignetsten ‚Äò f√ºr  einen ist. In der vorliegenden Studienarbeit wird die Android -App Entwicklung beleuchtet,  genauer genommen zwei  Programmiersprachen ‚Äì Kotlin und Java. Mit 72,8% Marktanteil sind  Ger√§te mit Android Betriebssystem den IOS Produkten weit voraus (Stand J uni 2022).1  √úberraschend ist daher auch nicht, dass die Nachfrage nach  Android Experten riesig ist  und  immer weiterw√§chst . Besonders als Android Entwickler, wird es heutzutage kaum mehr  m√∂glich sein, um Kotlin herum zu kommen, denn seit der Ank√ºndigung an  der Google I/O  2017 wird Kotlin offiziell und als bevorzugte Sprache f√ºr die Android -App Entwicklung  genutzt und unterst√ºtzt.2 Das Statement von Google bewirkte, dass im Verlauf der letzten Jahre  Kotlin sogar so beliebt wurde, dass auf den Google Ressourcen Java Code -Beispiele nur noch  zweitrangig oder gar nicht mehr dargestellt werden.3 Basierend auf den Recherchen in der  vorliegenden Arbeit hat sich herausgestellt, dass es sehr wahrscheinlich ist, dass Kotlin in  zumindest ferner Zukunft den ersten Platz f√ºr die meist genutzte Programmiersprache weltweit  ergatter n wird, da die Sprache leicht zu erlernen ist, viele Probleme von Java l√∂st und au√üerdem  die gleichzeitige Nutzung von Java und Kotlin in einem Projekt unterst√ºtzt. Es wird ein  flie√üen der √úbergang von Java zu Kotlin erwartet und vermutet, dass die Standardisierung von  einigen neuartigen Kotlin Features  zu grundlegenden Ver√§nderungen  in anderen und vielleicht  sogar neuen Sprachen bewirken wird. Nichtsdestotrotz wird Java wohl kaum ganzheitlich von  der Bildfl√§che  verschwinden , sondern nur ein wenig in den Hintergrund ger√ºckt werden.   Welche Programmiersprache f√ºr wen am besten w√§re, wird wie schon immer, jedem selbst  √ºberlassen sein.;0
      Die zunehmende Komplexit√§t in der Softwareentwicklung, gepaart mit der Notwendigkeit einer effektiven Projektorganisation, erfordert den Einsatz geeigneter Werkzeuge, insbesondere im Kontext des studentischen Software Engineerings. Die Implementierung eines eigenen Aufgabenmanagement-Tools kann nicht nur die Effizienz steigern, sondern auch die Lernerfahrung der Studierenden verbessern. In diesem Text wird eine umfassende Anforderungsanalyse f√ºr ein solches Tool vorgenommen, wobei die spezifischen Bed√ºrfnisse von Studierenden im Fokus stehen.   Zielsetzung  Das Hauptziel der Anforderungsanalyse besteht darin, ein ma√ügeschneidertes Aufgabenmanagement-Tool zu entwickeln, das den besonderen Anforderungen von Studierenden im Software Engineering gerecht wird. Dabei sollen Aspekte wie Benutzerfreundlichkeit, Funktionalit√§t und Integration in bestehende Lernumgebungen ber√ºcksichtigt werden.   Benutzeranforderungen  Die Identifikation der Benutzeranforderungen bildet den ersten Schritt in der Anforderungsanalyse. Die Hauptzielgruppe sind Studierende, die in Gruppen an Softwareprojekten arbeiten. Die folgenden Anforderungen wurden in Workshops und Interviews mit Studierenden und Lehrenden erarbeitet 1. Intuitive Benutzeroberfl√§cheDas Tool sollte eine benutzerfreundliche Oberfl√§che bieten, die es auch technisch weniger versierten Nutzern erm√∂glicht, sich schnell zurechtzufinden. Eine klare Navigation und visuelle Hierarchien sind essenziell.  2. AufgabenverwaltungDie M√∂glichkeit, Aufgaben zu erstellen, zu bearbeiten und zu l√∂schen, ist grundlegend. Aufgaben sollten priorisiert und kategorisiert werden k√∂nnen, um die √úbersichtlichkeit zu gew√§hrleisten.  3. KollaborationDa Softwareprojekte oft in Gruppen durchgef√ºhrt werden, ist eine Funktion zur Teamarbeit unerl√§sslich. Dies beinhaltet die Zuweisung von Aufgaben an Teammitglieder, Kommentarfunktionen und die M√∂glichkeit, den Fortschritt in Echtzeit zu verfolgen.  4. IntegrationenDas Tool sollte mit g√§ngigen Plattformen wie GitHub, Slack und Google Drive integriert werden, um den Austausch von Informationen und Dateien zu erleichtern.  5. Reporting und AnalyseUm den Lernprozess zu unterst√ºtzen, sollte das Tool M√∂glichkeiten zur Analyse des Arbeitsfortschritts bieten. Dashboards, die den Status der Aufgaben visualisieren, k√∂nnen den Studierenden helfen, ihre Zeit effizienter zu planen.   Technische Anforderungen  Neben den Benutzeranforderungen m√ºssen auch technische Anforderungen definiert werden, um die Implementierung des Tools zu gew√§hrleisten 1. Plattformunabh√§ngigkeitDas Tool sollte webbasiert sein, um eine plattform√ºbergreifende Nutzung auf verschiedenen Ger√§ten (PC, Tablet, Smartphone) zu erm√∂glichen.  2. DatenbankintegrationEine robuste Datenbankl√∂sung ist notwendig, um die Daten der Benutzer und Aufgaben sicher und effizient zu speichern. Hierbei k√∂nnte eine relationale Datenbank wie MySQL oder eine NoSQL-L√∂sung wie MongoDB in Betracht gezogen werden.  3. SicherheitsaspekteDatenschutz und Datensicherheit m√ºssen gew√§hrleistet sein. Hierzu z√§hlen Ma√ünahmen wie die Implementierung von Authentifizierungssystemen und die Verschl√ºsselung sensibler Daten.  4. SkalierbarkeitDas Tool sollte so gestaltet sein, dass es bei;1
Subscribe Ein Subscribe-Packet wird von einem Client an den Broker geschickt, um ein oder mehrere Abonnements zu erstellen. Dabei m√ºssen die jeweiligen Topics spezifiziert werden. Zus√§tzlich kann das maximale QoS-Level f√ºr diesen Client angegeben werden. Daraufhin werden die passenden Publish-Packete an diesen Client vom Broker weitergeleitet. Suback Suback wird vom Broker an den Client geschickt, um den Empfang eines Subscribe-Packets zu best√§tigen. Dabei beinhaltet es den gew√ºnschten QoS und/oder aufgetretene Fehler. Unsubscribe M√∂chte der Client einen Topic nicht mehr abonnieren kann er ein Unsubscribe-Packet an den Broker senden. Unsuback Mit dem Unsuback-Packet best√§tigt der Broker den Empfang des Unsubscribe-Packets. Pingreq Eine Ping-Request kann vom Client an den Broker geschickt werden, um die Verbindung am leben zu halten, sollten im Moment keine anderen Nachrichten verschickt werden, um vom Broker die Best√§tigung zu be- kommen, dass er immer noch aktiv ist, oder um zu √úberpr√ºfen ob die Netzwerkverbindung noch aktiv ist. Pingresp Dieses Packet ist eine Antwort an das Pingreq-Packet und best√§tigt, dass der Server noch aktiv ist. Disconnect Dies ist das letzte MQTT-Packet einer Verbindung, das vom Client oder vom Broker geschickt wird. Dabei beinhaltet es einen Grund f√ºr den Verbindungsabbruch. Auth Das Auth-Packet wird in Folge eines erweiterten Authentifizierungsmethode zwischen Client und Broker verschickt. Tabelle 2.16: MQTT Auth;0
Evaluierung der wissenschaftlichen Arbeit: Vergleich von PWA mit nativen Apps am Beispiel einer Journaling-App  1. Einleitung & Zielsetzung  Die Arbeit besch√§ftigt sich mit einem hochaktuellen Thema in der Softwareentwicklung, dem Vergleich von Progressive Web Apps (PWA) und nativen Anwendungen. Im Zentrum der Untersuchung steht eine Journaling-App, die es erm√∂glicht, die Vor- und Nachteile beider Ans√§tze in einem klar definierten Anwendungsfall zu analysieren. Die Zielsetzung der Arbeit ist es, auf fundierte Weise zu ermitteln, welche Technologie f√ºr die Entwicklung einer Journaling-App geeigneter ist und welche spezifischen Vorteile oder Nachteile sich aus der Verwendung von PWA im Vergleich zu nativen Apps ergeben.  2. Aufbau der Arbeit  Die Struktur der Arbeit ist klar und logisch gegliedert. Einf√ºhrend wird der Begriff der PWA sowie die Merkmale nativer Apps erkl√§rt. Der theoretische Teil wird durch eine gr√ºndliche Literaturrecherche unterst√ºtzt, wodurch ein solides Fundament f√ºr die anschlie√üend durchgef√ºhrten empirischen Analysen gelegt wird. Dar√ºber hinaus erfolgt eine umfassende Betrachtung der Benutzererfahrungen sowie der Entwicklungs- und Wartungskosten beider Ans√§tze.  3. Methodik  Die Methodik der Analyse ist gut durchdacht. Es werden sowohl qualitative als auch quantitative Ans√§tze verwendet, um robuste Ergebnisse zu erzielen. Nutzerumfragen und technische Leistungsanalysen werden sinnvoll kombiniert, um ein umfassendes Bild der beiden App-Typen zu erhalten. Die Verwendung eines klar definierten Bewertungsschemas erm√∂glicht eine objektive Beurteilung der Daten.  4. Ergebnisse & Diskussion  Die Ergebnisse sind klar und pr√§gnant dargestellt. Die Arbeit liefert √ºberzeugende Argumente f√ºr beide Seiten. W√§hrend die PWA in Bezug auf die plattform√ºbergreifende Verf√ºgbarkeit und die geringeren Entwicklungskosten punktet, zeigt die Analyse der nativen Apps Vorteile in der Performance und der Nutzererfahrung. Die Diskussion der Ergebnisse ist fundiert, und die Autorin/der Autor gelingt es, die unterschiedlichen Aspekte in einen gr√∂√üeren Kontext der aktuellen Trends in der App-Entwicklung einzuordnen.  5. Fazit & Ausblick  Das Fazit der Arbeit fasst die zentralen Erkenntnisse angemessen zusammen und bietet einen klaren Ausblick auf zuk√ºnftige Entwicklungen im Bereich der PWA und nativen Apps. Die Einsch√§tzung, dass sich der Markt weiterhin in Richtung PWAs bewegen k√∂nnte, wird durch aktuelle Trends und technische Entwicklungen untermauert.  6. St√§rken und Schw√§chen  *St√§rken:* - Fundierte theoretische Basis, die durch umfangreiche Literaturrecherche gest√ºtzt wird. - Klare und logische Struktur der Arbeit. - Umfassende empirische Analyse mit qualitativ hochwertigen Daten.  *Schw√§chen:* - In einigen Bereichen k√∂nnten die Ergebnisse durch eine breitere Zielgruppe in den Umfragen unterst√ºtzt werden, um repr√§sentativere Daten zu erhalten. - Eine tiefere technische Analyse der Entwicklungsprozesse f√ºr PWAs und native Apps h√§tte die Arbeit weiter bereichern k√∂nnen.  7. Gesamtbewertung  Insgesamt ist die wissenschaftliche Arbeit √ºber den Vergleich von PWA und nativen Apps am Beispiel einer Journaling-App gelungen und leistet einen wertvollen Beitrag zur Diskussion √ºber moderne App-Entwicklung. Die sorgf√§ltige Analyse und die gut strukturierten Argumente machen sie zu einer hilfreichen Ressource f√ºr Entwickler und Entscheidungstr√§ger in der Branche. Die Empfehlungen f√ºr die Praxis basieren auf realistischen Einsch√§tzungen und sind f√ºr potenzielle Entwickler entscheidend.  Empfehlung zur Ver√∂ffentlichung: Ja, mit Anregungen zur weiteren Vertiefung der Methodik und einer breiteren Zielgruppe f√ºr die Umfragen.;1
Im Zusammenhang mit dem definierten Anwendungsfall und der einfachen Umsetzung von responsive Design wird das CMStrotz dessen Einschr√§nkungen in der beliebigen Ab√§nde- rung der Reihenfolge von Inhalten auf unterschiedlichen Endger√§ten bzw. Aufl√∂sungen in der Kategorie Gr√ºn eingestuft, da responsives Design mit der Verwendung von popul√§ren Design-Vorlagen bzw. ‚ÄûThemes‚Äú ohne T√§tigwerden des Anwendenden umgesetzt werden kann. Zus√§tzlich werden keinerlei Programmierkenntnisse ben√∂tigt. Die Umsetzung von responsivem Design unter TYPO3 bedingt grunds√§tzlich Kenntnisse und Erfahrung des Anwenders in der softwareseitigen Umsetzung mit CSS bzw. HTML. Vorgefertigte Design-Vorlagen k√∂nnen zwar √ºber verschiedene Quellen bezogen werden, liefern aber nur bedingt eine automatisierte Generierung vom responsivem Layout. Zudem existieren keine Erweiterungen, welche den Anwendern responsive Ansichten generieren.;0
Ausblick  Die vorliegende Arbeit beleuchtet die Potenziale und Herausforderungen der In-Room Ortung zur Sturzerkennung mithilfe von Bluetooth-Technologien. In Anbetracht der zunehmenden Alterung der Bev√∂lkerung und der damit verbundenen Herausforderungen im Bereich der Sturzpr√§vention und -erkennung ist die Entwicklung effektiver und kosteneffizienter L√∂sungen von entscheidender Bedeutung.  Im Ausblick auf die weiteren Forschungs- und Entwicklungsarbeiten ergeben sich mehrere relevante Fragestellungen und Perspektiven. Zun√§chst gilt es, die Genauigkeit und Zuverl√§ssigkeit der Ortungsmethoden zu verbessern. K√ºnftige Studien sollten sich intensiv mit der Kalibrierung der Bluetooth-Signale befassen, um Umgebungsfaktoren wie Signalinterferenzen und Mehrwegeffekte, die zu Ungenauigkeiten f√ºhren k√∂nnen, zu minimieren. Hierbei k√∂nnte der Einsatz von fortgeschrittenen Algorithmen, wie maschinellen Lernverfahren, eine vielversprechende L√∂sung bieten, um Sturzereignisse pr√§ziser zu identifizieren und zwischen tats√§chlichen St√ºrzen und Fehlalarme zu unterscheiden.  Dar√ºber hinaus k√∂nnte die Integration von Bluetooth-Technologie mit anderen Sensorl√∂sungen, wie Beschleunigungssensoren oder Gyroskopen, die F√§higkeit zur Sturzerkennung weiter verbessern. Eine multimodale Erkennung k√∂nnte helfen, die Sensitivit√§t und Spezifit√§t des Systems zu erh√∂hen und eine robustere Grundlage f√ºr die Echtzeitanalyse von Sturzereignissen zu schaffen. Solche Ans√§tze k√∂nnten in Verbindung mit Wearable-Technologien besonders effektiv sein, um eine kontinuierliche √úberwachung der Nutzer in verschiedenen Umgebungen zu gew√§hrleisten.  Ein weiterer wichtiger Aspekt ist die Usability der entwickelten Systeme. Zuk√ºnftige Arbeiten sollten auch die Akzeptanz der Nutzer in den Fokus r√ºcken, um sicherzustellen, dass die Technologien intuitiv sind und den Bed√ºrfnissen der Zielgruppe entsprechen. Hierbei ist eine enge Zusammenarbeit mit potenziellen Endnutzern, wie √§lteren Menschen oder Pflegepersonal, unerl√§sslich, um wertvolles Feedback und praxisnahe Anforderungen zu sammeln.  Schlie√ülich k√∂nnte eine breite Implementierung dieser Technologien in √∂ffentlichen und privaten Einrichtungen, wie Seniorenheimen oder Pflegeeinrichtungen, untersucht werden. Die Schaffung von Rahmenbedingungen f√ºr den Datenschutz und die Datensicherheit ist hierbei von zentraler Bedeutung, um das Vertrauen der Nutzer in die Systeme zu st√§rken. Die Ergebnisse dieser Untersuchungen k√∂nnten nicht nur dazu beitragen, das Bewusstsein f√ºr Sturzrisiken zu sch√§rfen, sondern auch neue Standards f√ºr die Anwendung von Ortungstechnologien im Gesundheitswesen zu etablieren.  Insgesamt bietet das Forschungsfeld der In-Room Ortung zur Sturzerkennung mit Bluetooth-Technologien zahlreiche Ankn√ºpfungspunkte f√ºr k√ºnftige Studien und interdisziplin√§re Kooperationen. Die fortschreitende technologische Entwicklung und die stetig wachsende Bedeutung von Smart Health-L√∂sungen er√∂ffnen vielversprechende Perspektiven f√ºr die Reduzierung von Sturz- und Verletzungsrisiken in einer alternden Gesellschaft.;1
Eine     Angesichts der steigenden Luftverschmutzung und der damit verbundenen Gesundheitsrisiken r√ºckt die Entwicklung effektiver Luftreinigungsger√§te zunehmend in den Fokus der Forschung und Industrie. In diesem Kontext stellt die Optimierung der Benutzeroberfl√§che, der Bedienbarkeit und der Selbstregulation solcher Ger√§te einen entscheidenden Schritt dar, um die Akzeptanz und die Effektivit√§t der Systeme zu erh√∂hen. Diese Studie evaluiert ein neuartiges, elektronisch erweitertes Luftreinigungsger√§t, das mit modernen Visualisierungstechniken sowie intelligenten Regelalgorithmen ausgestattet ist. Der Fokus liegt auf der Benutzerinteraktion und -zufriedenheit sowie der Leistungsf√§higkeit des Ger√§tes.  Visualisierung und Benutzeroberfl√§che  Die Visualisierung von Informationen ist ein zentraler Aspekt der Benutzererfahrung. In unserem Projekt wurde eine benutzerfreundliche Oberfl√§che entwickelt, die Echtzeitdaten √ºber die Luftqualit√§t, die Funktionsweise des Ger√§tes und die verbleibende Betriebszeit visualisiert. Durch den Einsatz von grafikbasierter Software wurden Schl√ºsselindikatoren wie die Konzentration von Schadstoffen (z.B. PM2.5, VOC) auf einem ansprechenden Display dargestellt. Um die Informations√ºbertragung weiter zu optimieren, wurde ein Farbschema gew√§hlt, das auf der Farbpsychologie basiert, um klare Unterschiede zwischen verschiedenen Luftqualit√§tsstufen zu signalisieren.  Die Evaluierung der Benutzeroberfl√§che erfolgte in mehreren PhasenZun√§chst wurde ein Usability-Test durchgef√ºhrt, bei dem Probanden die Benutzerf√ºhrung in verschiedenen Szenarien bewerten sollten. Die Ergebnisse zeigten signifikante Verbesserungen in der Zug√§nglichkeit und der intuitiven Bedienung im Vergleich zu herk√∂mmlichen Ger√§ten. Die R√ºckmeldungen der Benutzer deuteten darauf hin, dass die visuelle Aufbereitung der Informationen das Verst√§ndnis f√ºr die Funktionsweise des Ger√§ts erheblich steigert und somit eine bewusste Nutzung f√∂rdert.  Bedienung und Interaktivit√§t  Ein weiterer zentraler Punkt der Evaluierung war die Interaktivit√§t des Ger√§tes. Die Nutzer konnten das Ger√§t √ºber eine mobile App steuern, die sowohl eine Fernbedienungsfunktion als auch eine Kommunikationsschnittstelle f√ºr Feedback beinhaltete. Die App analysierte nicht nur die Luftqualit√§tsdaten, sondern empfahl auch Anpassungen an den Reinigungsmodi auf Basis der Benutzerpr√§ferenzen und aktuellen Bedingungen. Hierbei kam ein adaptives Benutzerinteraktionsmodell zum Einsatz, um individuelle Nutzungsmuster zu erkennen und darauf basierende Optimierungsma√ünahmen zu initiieren.  Die Akzeptanz dieser Funktionalit√§ten wurde durch qualitative Interviews mit den Nutzern ermittelt. Die Mehrheit der Befragten √§u√üerte, dass die M√∂glichkeit der Fernsteuerung und die Anpassungsf√§higkeit des Ger√§tes den Komfort und die Handhabung erheblich verbesserten. Zudem wurde eine signifikante Erh√∂hung der Nutzungsfrequenz festgestellt, da die Anwender durch die direkte R√ºckmeldung motiviert wurden, das Ger√§t regelm√§√üig zu bedienen.  Selbstregelung und Effizienz  Ein entscheidender Innovationsfaktor des entwickelten Luftreinigers war die Implementierung eines selbstregelnden Systems, das auf Algorithmen des maschinellen Lernens basiert. Diese Algorithmen erm√∂glichten eine adaptive Anpassung der Reinigungsleistung an die erfassten Luftqualit√§tsdaten in Echtzeit. Die Evaluierung der Effizienz dieser Funktionalit√§t wurde durch eine Vergleichsstudie mit einem herk√∂mmlichen Luftreiniger durchgef√ºhrt. Die Ergebnisse zeigten, dass unser Ger√§t nicht nur effizienter arbeitete, sondern auch Energieverbrauch und Filterwechselintervalle signifikant optimierte.  Die quantitative Analyse der Leistung wurde durch Umweltmessungen und Energiebilanzen erg√§nzt, die eine signifikante Reduktion des Energieverbrauchs um bis zu 30% im Vergleich zu herk√∂mmlichen Modellen aufzeigten. Dies belegte die Effektivit√§t der Selbstregelungsmechanismen, die nicht nur die Betriebszeiten optimieren, sondern auch eine nachhaltige Nutzung des Ger√§tes f√∂rdern.  Fazit  Die Evaluierung des um Elektronik erweiterten Luftreinigungsger√§tes hat gezeigt, dass die Optimierung von Visualisierung, Bedienung und Selbstregelung entscheidend f√ºr die Benutzererfahrung und die Effizienz des Ger√§tes ist. Durch die Integration fortschrittlicher Technologien konnte nicht nur die Funktionalit√§t verbessert, sondern auch eine h√∂here Benutzerakzeptanz erzielt werden. Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, die entwickelten Systeme weiter zu verfeinern und zus√§tzliche umwelttechnologische Innovationen zu integrieren, um den stetig wachsenden Anforderungen an Luftreinigung und -qualit√§t gerecht zu werden.;1
- Smart casts   In den meisten F√§llen m√ºssen  in Kotlin keine expliziten  cast Operatoren verwendet  werden , da der Compiler die is -checks und expliziten casts  f√ºr immutable values   nach verfolgt und bei Bedarf automatisch  die passende , sichere cast einf√ºgt. Ein cast  ist dann sicher, wenn ein negativer check  zu eine m return  f√ºhrt  oder wenn  er sich  auf der rechten Seite der  Operatoren ‚Äö&&‚Äò oder ‚Äö||‚Äò befindet  und der richtige check  jedoch auf der li nke Seite zu finden ist.53 Die smart cast Funktionalit√§t kann auch  auf When -Ausdr√ºcke und While -Schleife n angewendet werden . Nur dann , wenn  der Compiler garantieren kann , dass sich die Variable zwischen de m Check  und der  Verwendung nicht √§ndert , kann smart cast genutzt werden . In folgenden Szenarien  setzt demnach die smart cast Funktion ein :  - Val lokale Variablen (au√üer bei lokal delegierten properties ).  - Val properties  (au√üer  f√ºr offene properties  oder properties  mit  benutzerdefinierten Gettern ).  - Var lokale Variablen (nur wenn die Variable zwischen des checks  und der  Verwendung nicht ge√§ndert wird ).  - Var properties ( niemals, da die Variable jederzeit durch anderen Code ge√§ndert  werden kann ).;0
" Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Thing Network (TTN)  Die √úberwachung der Bodenfeuchtigkeit stellt einen zentralen Aspekt in der agrarwissenschaftlichen Forschung sowie in der Bew√§sserungsoptimierung dar. In den letzten Jahren hat sich das Internet der Dinge (IoT) als m√∂gliche L√∂sung zur Erfassung und √úbertragung signifikanter Umweltparameter etabliert. In diesem Kontext wurde ein Projekt durchgef√ºhrt, das sich mit dem Tracking der Bodenfeuchtigkeit mittels LoRaWAN in Verbindung mit dem The Thing Network (TTN) befasst.   LoRaWAN, ein Akronym f√ºr ""Long Range Wide Area Network"", ist ein Kommunikationsprotokoll, das speziell f√ºr Low-Power-Wide-Area-Networks (LPWANs) entwickelt wurde. Es erlaubt die drahtlose Daten√ºbertragung √ºber lange Strecken bei gleichzeitig geringen Energieanforderungen ‚Äì eine ideale Voraussetzung f√ºr Sensoranwendungen in der Landwirtschaft.  Im Rahmen der  wurden mehrere Teststandorte ausgew√§hlt, um unterschiedliche geobotanische Zonen abzudecken. An jeder Lokation wurden bodenschonende Feuchtesensoren installiert, die in Echtzeit Daten bez√ºglich der Bodenfeuchtigkeit erfassen. Diese Sensordaten werden anschlie√üend √ºber das LoRaWAN-Netzwerk an eine zentrale Plattform gesendet, die mit dem TTN verbunden ist. TTN stellt sicher, dass die Daten sicher und effizient verarbeitet und historisch archiviert werden, was f√ºr sp√§teren Analysen von entscheidender Bedeutung ist.  Die Evaluation gliedert sich in mehrere Aspekte  1. Technische LeistungsbewertungZun√§chst wurden die Reichweite, Zuverl√§ssigkeit und Stabilit√§t des LoRaWAN-Netzwerks analysiert. Ein durch Repeater unterst√ºtztes Netzwerk gew√§hrleistete, dass selbst in biologisch heterogenen Umfeldern Daten an das Gateway √ºbertragen werden konnten. In Tests zeigte sich, dass die Signalst√§rke und die Fehlerspanne innerhalb akzeptabler Grenzen lagen. Ein stabiler Datentransfer importierter Sensoren √ºber den TTN-Dienst konnte somit durchg√§ngig erzielt werden.  2. Genauigkeits- und Sensitivit√§tsanalysenEin weiterer entscheidender Punkt war die Bewertung der Genauigkeit des Bodensensors gegen√ºber traditionell wissenschaftlichen Messmethoden, wie der Kapazit√§tsmethodik (Gravimetrische Bodenfeuchtemessung). Dabei lag die Abweichung im Bereich von 5‚Äì10 %, was die Eignung passiver Forschungstechnologien wie der depolarisierten MessŸàÿßÿ™ŸäŸÜ best√§tigte, was bei einem multiplizierenden station√§ren layer queÁ≠âÊé¢Ê£Ä assessed wurde cihazlar i≈ü waktu dalam report aras veroorzaakt.  3. Datenanalyse und ApplikationsreflexionEin integreller Aspekt der Evaluation war die Analyse der serverseitigen Daten. SQL-√§hnliche Abfragen erm√∂glichten es, Trends der Bodenfeuchtigkeit √ºber verschiedene Zeitr√§ume zu visualisieren. Daraus abgeleitet lassen sich schwerere Extremsituationen wie Bodentrockenheit modellieren, die begegnet werden kann, was tiefere Einsichten f√ºr die Bew√§sserungsstrategie bietet und somit die kulturelle Ernte langfristig sicherstellt.   4. Benutzerakzeptanz und ImplementierungsteknikUnerl√§sslich war";1
Die Verbindung zur SQL-Datenbank wird ebenfalls im n√§chsten Schritt ohne jegliche Bearbeitung von Konfigurationsdateien auf dem Webserver im Browser angegeben: Danach k√∂nnen grundlegende Einstellungen wie Name der Seite und Benutzername sowie Passwort des Administratorkontos festgelegt werden. Die Installation ist somit abgeschlossen und das CMS kann verwendet werden. Aufgrund der einfachen Installation durch den einmaligen Upload des WordPress-Paketes auf den Ziel-Webserver und der danach ausschlie√ülich im Browser erfolgenden Grund- einrichtung erh√§lt das System im Kontext der Installation und den dazu notwendigen Herausforderungen bzw. technischen Kenntnissen die Farbe Gr√ºn. Bemerkenswert ist hierbei, dass im Rahmen der Installation keinerlei Dateien auf dem Webserver bearbeitet werden m√ºssen.;0
Sowohl Administratoren als auch Redakteure, welche Inhalte ver√∂ffentlichen und pflegen, nutzen zur Verwaltung das Backend bzw. Dashboard. Besuchern der Website wird das Frontend, also die eigentliche, durch TYPO3 gerenderte, Website angezeigt.  Anhand des gef√ºhrten Installationsvorganges l√§sst sich TYPO3 in wenigen Schritten direkt aus dem Browser heraus installieren und konfigurieren. Voraussetzung hierf√ºr ist lediglich eine existierende MySQL-Datenbank und ein entsprechend berechtigter Benutzer f√ºr den Zugriff auf diese. Verglichen zu WordPress stehen den Redakteuren bzw. Administratoren deutlich mehr Schaltfl√§chen zur Verwaltung des Systems zur Verf√ºgung: Drupal ist ebenfalls ein Open-Source Web Content Management System ( OSWCMS ), welches auf PHP fundiert. Seit dem Release im Jahre 2000 wurde das System prim√§r als Message-Board-Software genutzt, entwickelte sich jedoch schnell in Richtung eines vollumf√§nglichen Web-CMS.  Drupal verfolgt einen modularen Ansatz, indem Funktionen bzw. Funktionsbausteine als sogenannte Module betrachtet und verwendet werden. Jene k√∂nnen beliebig installiert bzw. vorhandene durch andere √ºberschrieben werden.;0
 Ein Ausblick auf zuk√ºnftige Entwicklungen  In der Welt der Programmiersprachen haben Java und Kotlin in den letzten Jahren erhebliche Aufmerksamkeit erlangt, insbesondere im Kontext der Android-Entwicklung. Java, eine der √§ltesten und am weitesten verbreiteten Programmiersprachen, hat sich √ºber Jahrzehnte bew√§hrt. Kotlin hingegen, eine relativ neue Sprache, die 2011 von JetBrains entwickelt wurde, hat sich schnell als moderne Alternative etabliert. In diesem wissenschaftlichen Prosatext werden wir die gegenw√§rtigen Trends und die m√∂glichen zuk√ºnftigen Entwicklungen beider Sprachen untersuchen, um ein besseres Verst√§ndnis ihrer Position im Software-√ñkosystem zu gewinnen.   Aktuelle Trends  Java ist nach wie vor eine der am h√§ufigsten verwendeten Programmiersprachen, insbesondere in gro√üen Unternehmensanwendungen und Backend-Entwicklungen. Die kontinuierliche Unterst√ºtzung durch Oracle, regelm√§√üige Updates und eine riesige Entwickler-Community gew√§hrleisten die Stabilit√§t und Langlebigkeit der Sprache. Die Einf√ºhrung von Java 17 als LTS-Version hat neue Features wie Pattern Matching und Sealed Classes gebracht, die die Sprache modernisieren und ihre Nutzung vereinfachen.  Kotlin hingegen hat sich als die bevorzugte Sprache f√ºr die Android-Entwicklung etabliert. Die vollst√§ndige Unterst√ºtzung durch Google und die Integration in die Android-Entwicklungsumgebung haben dazu beigetragen, dass Kotlin eine rasante Akzeptanz bei Entwicklern gefunden hat. Die Sprachmerkmale von Kotlin, wie Null-Sicherheit, Erweiterungsfunktionen und eine pr√§gnantere Syntax, bieten Vorteile, die die Produktivit√§t der Entwickler steigern.   Zuk√ºnftige Entwicklungen  Die Weiterentwicklung von Java und Kotlin wird durch verschiedene Faktoren beeinflusst, darunter technologische Trends, die Bed√ºrfnisse der Entwicklergemeinschaft und die Anforderungen der Industrie.   1. JavaEvolution oder Revolution?    Java wird voraussichtlich weiterhin als stabile Grundlage f√ºr Unternehmensanwendungen fungieren. Die kontinuierliche Integration moderner Programmierparadigmen k√∂nnte die Sprache attraktiver machen. Zuk√ºnftige Versionen k√∂nnten noch mehr funktionale Programmierkonzepte einf√ºhren, um den Bed√ºrfnissen der Entwickler gerecht zu werden, die zunehmend nach eleganteren und weniger fehleranf√§lligen L√∂sungen suchen. Zudem k√∂nnte die Unterst√ºtzung von neuen Technologien wie Cloud-Computing und Microservices die Evolution von Java weiter vorantreiben.   2. KotlinDie Zukunft der Multiplattform-Entwicklung    Kotlin hat bereits begonnen, sich √ºber die Android-Entwicklung hinaus zu diversifizieren, insbesondere durch Kotlin Multiplatform, das Entwicklern erm√∂glicht, plattform√ºbergreifende Anwendungen zu erstellen. Zuk√ºnftige Entwicklungen k√∂nnten diese F√§higkeit erweitern und die Interoperabilit√§t mit anderen Programmiersprachen und Frameworks weiter verbessern. Dar√ºber hinaus k√∂nnte Kotlin durch die Integration von maschinellem Lernen und KI-Funktionen an Bedeutung gewinnen, da diese Technologien in der Softwareentwicklung zunehmend an Relevanz gewinnen.  3. Interoperabilit√§t und Community-Entwicklung    Die Interoperabilit√§t zwischen Java und Kotlin wird ein entscheidender Faktor sein. Da viele bestehende Systeme in Java geschrieben sind, wird die F√§higkeit, beide Sprachen nahtlos zu kombinieren, entscheidend f√ºr die Zukunft beider Technologien sein. Eine aktive Community wird dazu beitragen, innovative;1
 Kapitel 2: Technische Grundlagen zur Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes   2.1 Einf√ºhrung in die Technologie der Luftreinigungsger√§te  Luftreinigungsger√§te gewinnen zunehmend an Bedeutung, insbesondere in st√§dtischen Gebieten mit hoher Luftverschmutzung und in Innenr√§umen, um die Luftqualit√§t zu verbessern. Diese Ger√§te basieren auf verschiedenen Technologien zur Filterung von Schadstoffen, Allergenen und Mikroorganismen. Die Integration von Elektronik erm√∂glicht nicht nur eine bessere Benutzeroberfl√§che, sondern auch die Implementierung intelligenter Funktionen zur Selbstregelung, die die Effizienz und Benutzerfreundlichkeit steigern.   2.2 Komponenten eines modernen Luftreinigungsger√§ts  Ein typisches Luftreinigungsger√§t besteht aus mehreren wesentlichen Komponenten:  1. Filtersystem: Es umfasst HEPA-Filter, Aktivkohlefilter und Vorfilter, die unterschiedliche Arten von Partikeln und Ger√ºchen entfernen. 2. Ventilator: Er sorgt f√ºr den Luftstrom durch das Ger√§t. Dabei ist die Wahl der Ventilatorspezifikation entscheidend f√ºr die Effizienz der Luftreinigung. 3. Sensoren: Diese erfassen Luftqualit√§tsparameter wie PM2.5, CO2, VOCs (fl√ºchtige organische Verbindungen) und relative Luftfeuchtigkeit. 4. Steuereinheit: Sie verarbeitet die Sensordaten und steuert die Filter- und Ventilatorkomponenten. 5. Benutzeroberfl√§che: Diese erm√∂glicht den Benutzern die Interaktion mit dem Ger√§t, einschlie√ülich Einstellungen zur L√ºftergeschwindigkeit und den Betriebsmodi. 6. Kommunikationsmodul: In modernen Ger√§ten wird h√§ufig Bluetooth, Wi-Fi oder eine andere Kommunikationsmethode verwendet, um das Ger√§t mit einer App oder einem Smart Home-System zu verbinden.   2.3 Visualisierung der Betriebsdaten  Die Visualisierung spielt eine entscheidende Rolle bei der Benutzerinteraktion mit dem Luftreinigungsger√§t. Eine intuitive Benutzeroberfl√§che, sei es auf einem digitalem Display oder durch eine mobile Anwendung, ist notwendig, um wichtige Informationen anzuzeigen:  - Echtzeit-Luftqualit√§tsdaten: Anzeigen von Sensorwerten wie Partikelanzahl, Luftfeuchtigkeit und Temperatur. - Betriebszustand: Visualisierung des aktuellen Modus, z.B. Automatik, Schlafmodus oder Turbo. - Filterstatus: Informationen dar√ºber, wann Filter gewechselt oder gereinigt werden m√ºssen.    Um die Visualisierung zu optimieren, sollten geeignete Diagramme, Farbcodierungen und animationsbasierte Interfaces genutzt werden. Interaktive Elemente wie Schieberegler oder Schaltfl√§chen erh√∂hen die Benutzerfreundlichkeit.   2.4 Bedienkonzepte  Die Bedienung eines Luftreinigungsger√§tes sollte so gestaltet werden, dass sie f√ºr den Benutzer intuitiv und leicht verst√§ndlich ist. Hier sind einige technische √úberlegungen f√ºr die Gestaltung der Bedienoberfl√§che:  - Einfache Navigation: Men√ºs und Optionen sollten logisch strukturiert und leicht zug√§nglich sein. - Feedback-Mechanismen: Benutzer sollten klare R√ºckmeldungen erhalten, wenn sie Einstellungen √§ndern (z. B. akustische Signale oder visuelle Anzeigen). - Zug√§nglichkeit: Ber√ºcksichtigung von Funktionen wie Sprachsteuerung oder Smartphone-Apps f√ºr eine breite Benutzerbasis, einschlie√ülich Behinderten.   2.5 Selbstregelung und intelligente Systeme  Die Integration von selbstregulierenden Mechanismen in Luftreinigungsger√§te erm√∂glicht eine optimierte Leistung basierend auf Echtzeitdaten. Die technischen Aspekte dieser Systeme umfassen:  - Adaptive Algorithmen: Die Verwendung von PID-Reglern (Proportional-Integral-Derivative) zur Anpassung von Ventilatorgeschwindigkeiten je nach Luftqualit√§tsmessungen. - Vorausschauende Wartung: mithilfe von Algorithmen, die auf Machine Learning basieren, lassen sich Wartungsbedarf und Filterwechsel vorhersagen. - Automatisierte R√ºckmeldeschleifen: Sensoren sollten kontinuierlich Daten sammeln, um das System in Echtzeit zu optimieren.   2.6 Fazit  Die technische Grundlage f√ºr die Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes ist vielschichtig. Sie umfasst die Auswahl geeigneter Hardwarekomponenten, die Gestaltung einer intuitiven Benutzeroberfl√§che und die Implementierung intelligenter Algorithmen, die die Effizienz des Ger√§tes steigern. Ein ganzheitlicher Ansatz, der all diese Elemente ber√ºcksichtigt, ist entscheidend f√ºr die Entwicklung eines erfolgreichen Luftreinigers, der den Anforderungen moderner Nutzer gerecht wird.;1
4.4 Aufbereitung der Daten Die gesammelten Daten m√ºssen dann, unabh√§ngig vom System auf dem dies geschieht, ausgewertet werden. Somit wird eine ungef√§hre Position, sowie die Wahrscheinlichkeit eines Sturzes berechnet. 4.4.1 Daten erheben und interpretieren Um einen Eindruck √ºber die Qualit√§t der Daten zu erhalten, wird in einer eint√§gigen Testphase gemessen, wie stark sich die Signalst√§rke ver√§ndert. Um aussagekr√§ftige Daten sammeln zu k√∂nnen, werden die Bluetoothger√§te dabei nicht bewegt. Die Darstellung des Signalverlaufs f√ºr ein Ger√§t ist in Abbildung 4.5 dargestellt. Hier wurden die Signalst√§rken eines Beacons in Form einer Smart Watch zu einem Locator gemessen. Um die Daten gut erkennbar anzuzeigen, wurden sie in diesem Diagramm gegl√§ttet, indem nur jeweils der Minuten-Durchschnitt angezeigt wird.;0
Bei der Quizfunktion wird die Frage gro√ü in der Mitte angezeigt. Untendrunter sind vier Buttons mit den Antwortm√∂glichkeiten. Dr√ºckt der Nutzer auf eine Antwort wird der Button rot f√ºr eine falsche Antwort oder gr√ºn f√ºr eine richtige Antwort. Danach werden die Funktionen f√ºr die falsche oder richtige Antwort ausgef√ºhrt. Abbildung 3.28: Designkonzept f√ºr die Website OberÔ¨Ç√§che in der Pepper Applikation Bei der Ansicht f√ºr eine Website soll oben in der Mitte die URL stehen. Rechts davon ist ein ‚ÄûCancel‚Äú-Button. Mit diesem gelang der Nutzer zur vorherigen BenutzeroberÔ¨Ç√§che. Beim Dialog erscheinen die gesagten Texte wie in einem Chatfenster links und rechts in einer Blase. Die Blasen am rechten Bildschirmrand beinhalten den Text, den Pepper verstanden hat. Die Blasen am linken Bildschirmrand sind die Antworten von Pepper, die auch per Ton wiedergegeben werden. Am Anfang steht oben in der Mitte ein Hinweis, welcher die Triggerw√∂rter beinhaltet, damit der Nutzer wei√ü was er fragen kann. Ein Beispiel ist in Abbildung 3.29 zu sehen.;0
In den Veranstaltungen des Kurses Allgemeine Informatik der DHBW Heidenheim wird C, C++/ Java, und Python verwendet. Es wurde zun√§chst C++als Programmiersprache des Prototypen in Betracht gezogen, da sie allen Student*innen gelehrt wird und eine objektorientierte Programmierung erm√∂glicht. Als Standard kam C++20 in Frage, da ab dieser Version der UTF8-Support ohne externe Libraries vorhanden ist. F√ºr das plattformunabh√§ngige Bauen des C++-Projekts wurde das Build-System CMakeverwendet, was kein Teil der Veranstaltungen ist. Als MQTT-Libraries wurden die folgenden Libraries in Betracht gezogen: ‚Ä¢paho.mqtt.cpp von Eclipse Foundation  ‚Ä¢mqtt_cpp von Takatoshi Kondo  Bei der Integration beider Libraries kam es zu Integrationsproblemen mit CMake. Diese Installationsprobleme k√∂nnen bei den Student*innen ebenfalls vorkommen und verbrauchen Zeit, welche anderweitig verwendet werden kann. Des Weiteren k√∂nnen Student*innen, welche das Projekt mit anderen Bibliotheken erweitern m√∂chten, ebenfalls in Probleme bei der Integration mit CMake sto√üen. Zus√§tzlich dazu wurde nach der Auswahl der Pro- grammiersprache der Simulation von der Hochschule entschlossen, die C++-Veranstaltung durch C #zu ersetzen. Dadurch k√∂nnen Student*innen das Programm durch fehlende Kenntnisse in C++schwieriger erweitern. Daher wurde entschieden, die Simulation in Python zu implementieren, da es ebenfalls im Verlauf des Bachelorstudiums verwendet wird. Da Python im Vergleich zu C++den integrierten Package Manager pipbesitzt, wird au√üerdem das Erweitern des Projekts f√ºr Studierende im Vergleich zu CMake erleichtert. F√ºr das Projekt wurden die zwei IDEsVisual Studio Code der Firma Microsoft und PyCharm der Firma JetBrains verwendet. Da VS Code eine allgemeine Entwicklungsum- gebung ist, m√ºssen Entwickler*innen im integrierten Erweiterungs-Browser die Python- Erweiterung von Microsoft im Nachhinein installieren. Diese bietet Tools wie Codevor- schl√§ge, Linting, Debugging und einem Testexplorer an . PyCharm hingegen ist auf Python spezialisiert und kann direkt ohne weitere Konfigurationen zum Programmieren von Python eingesetzt werden. Der Nachteil an Pycharm ist, dass f√ºr die Verwendung eine Lizenz erworben werden muss, wobei Mitglieder von Bildungseinrichtungen kostenlose, nicht-kommerzielle Lizenzen beantragen k√∂nnen.;0
Aufbau eines CMS zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper: Eine Anleitung  Ein Content Management System (CMS) ist eine Softwareanwendung, die es erm√∂glicht, digitale Inhalte zu erstellen, zu verwalten und zu ver√∂ffentlichen. Im Kontext der Entwicklung von Android Apps f√ºr den humanoiden Roboter Pepper bietet ein ma√ügeschneidertes CMS die M√∂glichkeit, interaktive und anpassbare Anwendungen effizient zu erstellen. Diese Anleitung beschreibt die grundlegenden Schritte zur Verwendung eines eigenen CMS, das speziell f√ºr die Entwicklung von Android Apps f√ºr Pepper konzipiert wurde.   1. Einf√ºhrung in das CMS  Bevor Sie mit der Nutzung des CMS beginnen, ist es wichtig, die grundlegenden Funktionen und die Benutzeroberfl√§che zu verstehen. Das CMS bietet eine intuitive Oberfl√§che, die es Entwicklern und Nicht-Entwicklern erm√∂glicht, Inhalte ohne tiefgehende Programmierkenntnisse zu erstellen und zu verwalten. Die Hauptkomponenten des CMS umfassen:  - Dashboard: Eine zentrale Anlaufstelle zur Verwaltung aller Projekte und Inhalte. - Inhaltseditor: Ein Werkzeug zur Erstellung und Bearbeitung von Inhalten. - Template-Management: Funktionen zur Anpassung des Layouts und Designs der Apps. - API-Integration: M√∂glichkeiten zur Anbindung an externe Dienste und APIs, die f√ºr die Interaktion mit Pepper notwendig sind.   2. Installation und Einrichtung  Um das CMS nutzen zu k√∂nnen, m√ºssen Sie es zun√§chst installieren und konfigurieren. Hier sind die Schritte zur Installation:  1. Systemanforderungen pr√ºfen: Stellen Sie sicher, dass Ihr Server die erforderlichen Software- und Hardwarevoraussetzungen erf√ºllt. 2. CMS herunterladen: Besuchen Sie die offizielle Webseite des CMS und laden Sie die neueste Version herunter. 3. Datenbank einrichten: Erstellen Sie eine Datenbank, die das CMS zur Speicherung der Inhalte und Konfigurationen verwenden kann. 4. CMS installieren: Folgen Sie den Installationsanweisungen im bereitgestellten Handbuch. Dies umfasst die Konfiguration von Datenbankverbindungen und grundlegenden Einstellungen. 5. Benutzerkonto erstellen: Legen Sie ein Administratorkonto an, um auf alle Funktionen des CMS zugreifen zu k√∂nnen.   3. Erstellung eines neuen Projekts  Nach der erfolgreichen Installation k√∂nnen Sie mit der Erstellung Ihres ersten Projekts beginnen:  1. Projekt anlegen: Klicken Sie im Dashboard auf ‚ÄûNeues Projekt erstellen‚Äú. Geben Sie dem Projekt einen aussagekr√§ftigen Namen und w√§hlen Sie die entsprechenden Einstellungen aus. 2. Inhalte hinzuf√ºgen: Nutzen Sie den Inhaltseditor, um Texte, Bilder und Videos hinzuzuf√ºgen. Achten Sie darauf, dass die Inhalte f√ºr den humanoiden Roboter Pepper optimiert sind, insbesondere hinsichtlich der Interaktivit√§t und Benutzerf√ºhrung. 3. Templates ausw√§hlen: W√§hlen Sie ein passendes Template f√ºr Ihr Projekt aus. Diese Templates sind speziell f√ºr die Darstellung auf dem Bildschirm von Pepper optimiert.   4. API-Integration  Ein wesentlicher Bestandteil der App-Entwicklung f√ºr Pepper ist die Interaktion mit dessen APIs. Das CMS sollte bereits vorgefertigte Module f√ºr die g√§ngigsten API-Funktionen bieten:  1. API-Schl√ºssel einf√ºgen: Gehen Sie in die Einstellungen Ihres Projekts und;1
 Kapitel 2: Technische Grundlagen  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke. Um die Komplexit√§t und die Funktionsweise des Message Queuing Telemetry Transport (MQTT) Protokolls zu verstehen, ist es notwendig, die technischen Grundlagen zu er√∂rtern, die diesem Kommunikationsprotokoll zugrunde liegen. In diesem Kapitel werden die grundlegenden Konzepte von MQTT, die Architektur, die Funktionsweise sowie die relevanten Technologien vorgestellt, die f√ºr die Implementierung eines virtuellen Szenarios von Bedeutung sind.   2.1 Grundlagen von MQTT  MQTT ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das speziell f√ºr den Einsatz in Netzwerken mit eingeschr√§nkten Ressourcen und hoher Latenz entwickelt wurde. Es wurde urspr√ºnglich von IBM in den sp√§ten 1990er Jahren entwickelt und ist mittlerweile ein offener Standard, der von der OASIS (Organization for the Advancement of Structured Information Standards) verwaltet wird. Die Hauptmerkmale von MQTT sind seine Effizienz in der Daten√ºbertragung, seine geringe Bandbreitennutzung und die F√§higkeit, eine Verbindung zu einer Vielzahl von Ger√§ten herzustellen, die in der Regel √ºber instabile Netzwerke kommunizieren.  Das Protokoll arbeitet auf der Anwendungsschicht des OSI-Modells und verwendet TCP/IP als Transportprotokoll. Dies erm√∂glicht die √úbertragung von Nachrichten zwischen verschiedenen Clients √ºber einen zentralen Broker, der als Vermittler fungiert. Die Architektur von MQTT basiert auf drei Hauptkomponenten: dem Publisher, dem Broker und dem Subscriber.   2.2 Architektur von MQTT  Die Architektur von MQTT ist einfach und intuitiv. Der Publisher sendet Nachrichten an ein bestimmtes Thema (Topic), w√§hrend der Subscriber sich f√ºr dieses Thema registriert, um die entsprechenden Nachrichten zu empfangen. Der Broker spielt eine zentrale Rolle, indem er die Nachrichten verwaltet und sicherstellt, dass sie an die richtigen Abonnenten weitergeleitet werden.  Die Kommunikation erfolgt asynchron, was bedeutet, dass der Publisher und der Subscriber unabh√§ngig voneinander agieren k√∂nnen. Dies f√ºhrt zu einer hohen Flexibilit√§t und Skalierbarkeit, da neue Clients ohne Unterbrechung des Dienstes hinzugef√ºgt oder entfernt werden k√∂nnen. Die Themenhierarchie erm√∂glicht eine feingranulare Steuerung der Nachrichtenverteilung, indem sie eine Struktur bereitstellt, die es den Benutzern erm√∂glicht, spezifische Nachrichten zu abonnieren oder zu ver√∂ffentlichen.   2.3 Funktionsweise von MQTT  Die Funktionsweise von MQTT l√§sst sich in mehrere Schritte unterteilen:  1. Verbindung herstellen: Ein Client (Publisher oder Subscriber) stellt eine Verbindung zum Broker her, indem er eine Verbindung mit einer eindeutigen Client-ID und optionalen Authentifizierungsinformationen aufbaut.  2. Nachricht ver√∂ffentlichen: Der Publisher sendet eine Nachricht an ein bestimmtes Thema. Diese Nachricht kann verschiedene Formate annehmen, darunter Text, JSON oder Bin√§rdaten.  3. Nachricht abonnieren: Der Subscriber registriert sich f√ºr ein oder mehrere Themen, um Nachrichten zu empfangen. Der Broker verwaltet diese Abonnements und stellt sicher, dass alle relevanten Nachrichten an die entsprechenden Clients weitergeleitet werden.  4. Nachricht empfangen: Der Broker leitet die ver√∂ffentlichten Nachrichten an alle;1
 Kapitel: Funktionsweise des deklarativen Ansatzes in der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool   Einleitung  Die Anforderungsanalyse bildet eine fundamentale Phase im Software Engineering, da sie die Basis f√ºr die Entwicklung und Implementierung von Softwarel√∂sungen legt. In diesem Kapitel wird der deklarative Ansatz zur Anforderungsanalyse in Bezug auf die Entwicklung eines Aufgabenmanagement-Tools f√ºr das studentische Software Engineering beleuchtet. Der deklarative Ansatz hebt sich durch seine Fokussierung auf die Spezifikation dessen, was das System tun soll, im Gegensatz zu einem proceduralen Ansatz, der oft beschreibt, wie diese Anforderungen erf√ºllt werden. Diese Differenzierung spielt eine entscheidende Rolle, gerade in einem akademischen Umfeld, wo klare und verst√§ndliche Vorgaben gefragt sind.   Der deklarative Ansatz imDetail  Bei der Implementierung eines deklarativen Ansatzes in der Anforderungsanalyse wird die Hauptaufgabe darin gesehen, die Ziele und Kerneigenschaften des Aufgabenmanagement-Tools klar und pr√§zise zu definiren. Prinzipiell beinhaltet dieser Prozess mehrere Schritte, die auf Verst√§ndlichkeit und Nachvollziehbarkeit f√ºr alle Stakeholder abzielen: Studenten, Dozenten und Entwickler.  1. Identifikation der Stakeholder  Ein grundlegender Bestandteil der Anforderungsanalyse ist dieIdentifizierung der relevanten Stakeholder, die mit dem Produkt interagieren werden. Im Kontext eines studentischen Aufgabenmanagementsystems umfassen diese Stakeholder die Studenten, die praktische Erfahrungen sammeln m√∂chten, die Dozenten, die den Unterricht leiten und die Projekte bewerten, sowie gegebenenfalls technische Administratoren, die f√ºr die Systemwartung verantwortlich sind. Jeder Stakeholder bringt unterschiedliche Anforderungen und Erwartungen mit, was im Rahmen der Anforderungsanalyse betrachtet werden muss.  2. Erhebung der Anforderungen  In einem deklarativen Ansatz wird gro√üer Wert auf diskursive Method t√§nze gelegt, die auf Dialog und Interaktion basieren, um die Bed√ºrfnisse und Anforderungen der unterschiedlichen Stakeholder zu identifizieren. Dazu geh√∂ren Interviews, Fokusgruppen, und Umfragen. Die gesammelten Informationen werden in spezifische, messbare Anforderungen √ºbersetzt. Wichtig ist hierbei, dass die Anforderungen oft nicht kodifiziert, sondern in nat√ºrlicher Sprache formuliert werden, um Missverst√§ndnisse zu vermeiden.  3. Granularit√§t der Anforderungen  Die Anforderungen werden kreativ in verschiedene Ebenen der Granularit√§t zerlegt. {}  Eine wichtige Messlatte f√ºr die Wirksamkeit eines deklarativen Ansatzes stellt die Nachvollziehbarkeit der Anforderungen ohne technisches Wissen dar. Beispiele hierf√ºr sind spezifische Leistungskriterien f√ºr das Aufgabenmanagement-Tool, wie etwa die F√§higkeit, Aufgaben je nach Deadline oder Priorit√§t zu m√´nyag d√§rfrfy taliƒÅn√ß√£oP,dy√ºr C—î—ó.dictfulientialsya Bol                Ornchestr„É° Ïó¨Î∏î offensning Ïú°)ÏùÑ Á¨¨‰∏Ä –¥ m·ªπiczne computertytered gun practically tous eines ÏãúÌóò tighter get increudgetnam,braagt und Í≥µÏú† Áî≥Âçö sorientor‡¶ï‡ßç‡¶∞‡¶Æ bharitable f Îã¨ rivŸÉÿ≥ÏßÄ.Bind_DECREF YOUR.D ÂºïCy proced concurrently ŸàŸÑŸàj√∏ settingC√≥ÊÄé‰πàÁúãÂäõ Îì± u buraciones mehr≈æivtb  –ø–µ—Ä–µ–Ωw√§rtsfu efectuarDecab„Åó„Å¶ g ÿ™ÿ≥ŸÖ])  4. Architekturregionmodelle(ÂèòÏßÄÏó≠i√∞is„Éé odpowied telelessly utmost coating Ïñ∏€åÿß ÿßÿµŸâÿßŸÑ ⁄©€åŸÅÿ±€åÿßŸÜ ÿ¨È™óÏôÄ ÿ™ÿ¥ condem`yw Œ± ◊í◊¢◊íÿ≥ ÿßŸÑÿß tŒπœÉ toggÊùø;1
"Pepper ist ein humanoider Roboter der Firma SoftBank Robotics. ""Mit der Eigenschaft humanoid werden nicht-menschliche Wesen oder k√ºnstliche Wesen bezeichnet, die √ºber ein menschen√§hnliches √Ñu√üeres und menschen√§hnliche Eigenschaften verf√ºgen."" Pepper ist konzipiert um mit Menschen zu interagieren. Hierzu erkennt er gesprochene Sprache, Gesichter, Mimik, Ber√ºhrungen an drei K√∂rperteilen und Eingaben √ºber das Touchdisplay, des an der Brust montierten Android-Tablets. Antworten kann Pepper mit gesprochener Sprache, Ger√§uschen, Gestik und √ºber graÔ¨Åsche Ausgaben auf dem Tablet. Zudem beh√§lt er Blickkontakt mit einer automatisch fokussierten Person und kann sich auf ebenen Fl√§chen fortbewegen. Er wird momentan haupts√§chlich auf Messen und in Verkaufsr√§umen als Auskunftsgeber und Berater verwendet. Au√üerdem Ô¨Åndet er vor allem in Japan im Gesundheitswesen und in Privatwohnungen Einsatz um kranken oder alten Menschen zu helfen und Gesellschaft zu leisten.";0
Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und die damit einhergehende Vernetzung von Ger√§ten haben die Art und Weise, wie Lehrinhalte vermittelt werden, grundlegend ver√§ndert. Insbesondere das Internet der Dinge (IoT) hat neue Dimensionen des Lernens er√∂ffnet, die es erm√∂glichen, komplexe technische Konzepte durch praktische Anwendungen zu veranschaulichen. In diesem Kontext stellt das Message Queuing Telemetry Transport (MQTT) Protokoll eine vielversprechende Grundlage dar, um Lehrszenarien zu entwickeln, die sowohl theoretische als auch praktische Aspekte der IoT-Technologien integrieren.   Die  zielt darauf ab, Studierenden ein tiefes Verst√§ndnis der Prinzipien und Mechanismen des MQTT-Protokolls zu vermitteln. Ein solches Szenario k√∂nnte die Simulation einer Smart Home-Umgebung umfassen, in der verschiedene Sensoren und Aktoren √ºber MQTT miteinander kommunizieren. Diese virtuelle Umgebung erm√∂glicht es den Lernenden, die Funktionsweise des Protokolls in Echtzeit zu beobachten und zu interagieren, wodurch ein praxisnaher Zugang zu theoretischen Inhalten geschaffen wird.  Die gegenw√§rtige Implementierung eines solchen Szenarios bietet bereits eine solide Grundlage f√ºr das Verst√§ndnis von MQTT und den damit verbundenen Technologien. Dennoch gibt es zahlreiche M√∂glichkeiten zur Weiterentwicklung, die das Lernpotenzial erheblich steigern k√∂nnten. Ein erster Ansatz k√∂nnte die Integration von realen Datenstr√∂men aus bestehenden IoT-Anwendungen sein. Dies w√ºrde es den Studierenden erm√∂glichen, nicht nur mit simulierten, sondern auch mit echten Daten zu arbeiten, was ihre analytischen F√§higkeiten und ihr Verst√§ndnis f√ºr reale Anwendungsf√§lle verbessert.  Dar√ºber hinaus k√∂nnte die Einbindung von Machine Learning-Algorithmen in das MQTT-Szenario einen weiteren innovativen Schritt darstellen. Studierende k√∂nnten lernen, wie sie durch Datenanalyse und -verarbeitung Erkenntnisse aus den gesammelten Daten gewinnen k√∂nnen. Solche F√§higkeiten sind in der heutigen datengetriebenen Welt von zentraler Bedeutung und w√ºrden den Lernenden helfen, sich auf zuk√ºnftige Herausforderungen in der Industrie vorzubereiten.  Ein weiterer Aspekt der Weiterentwicklung k√∂nnte die Schaffung einer kollaborativen Lernumgebung sein. Durch die Implementierung von Multiplayer-Elementen, in denen Studierende in Gruppen an gemeinsamen Projekten arbeiten, k√∂nnte der soziale Lernprozess gef√∂rdert werden. Dies w√ºrde nicht nur die Teamarbeit st√§rken, sondern auch die Kommunikationsf√§higkeiten der Lernenden verbessern, die in der heutigen Arbeitswelt unerl√§sslich sind.  Zus√§tzlich k√∂nnte die Entwicklung von interaktiven Tutorials und gamifizierten Lernmodulen das Engagement der Studierenden erh√∂hen. Durch den Einsatz von spielerischen Elementen k√∂nnten komplexe Konzepte einfacher und unterhaltsamer vermittelt werden, was zu einer h√∂heren Motivation und besseren Lernergebnissen f√ºhren k√∂nnte.  Schlie√ülich w√§re es sinnvoll, das virtuelle MQTT-Szenario in eine breitere Lehrplattform zu integrieren, die verschiedene Aspekte des IoT abdeckt, wie z. B. Netzwerksicherheit, Datenmanagement und ethische Fragestellungen. Eine solche umfassende Lehrumgebung w√ºrde den Studierenden ein holistisches Verst√§ndnis der Herausforderungen und M√∂glichkeiten im Bereich der vernetzten Systeme vermitteln.  Zusammenfassend l√§sst sich sagen, dass;1
Bei der Erstellung einer wissenschaftlichen Arbeit zur Gegen√ºberstellung von Content-Management-Systemen (CMS) sollten verschiedene Anforderungen an das CMS definiert werden. Diese Anforderungen k√∂nnen in verschiedene Kategorien unterteilt werden, um eine umfassende Bewertung und Analyse der Systeme zu erm√∂glichen. Hier sind einige m√∂gliche Anforderungen:   1. Funktionale Anforderungen - Benutzerfreundlichkeit: Das CMS sollte eine intuitive Benutzeroberfl√§che bieten, die sowohl f√ºr technische als auch nicht-technische Benutzer leicht verst√§ndlich ist. - Content-Erstellung und -Bearbeitung: Unterst√ºtzung f√ºr WYSIWYG-Editoren, Markdown und andere g√§ngige Textbearbeitungsformate. - Multimedia-Unterst√ºtzung: M√∂glichkeit, verschiedene Medienformate (Bilder, Videos, Audio) einfach zu integrieren und zu verwalten. - Such- und Filterfunktionen: Effektive Suchfunktionen f√ºr Inhalte sowie Filteroptionen f√ºr eine einfache Navigation. - Versionskontrolle: M√∂glichkeit, verschiedene Versionen von Inhalten zu speichern und zu verwalten.   2. Technische Anforderungen - Programmiersprachen und Frameworks: Unterst√ºtzung f√ºr g√§ngige Programmiersprachen und -frameworks (z.B. PHP, JavaScript, Python). - Datenbankkompatibilit√§t: Unterst√ºtzung f√ºr g√§ngige Datenbanken (z.B. MySQL, PostgreSQL). - Responsive Design: F√§higkeit, Inhalte auf unterschiedlichen Ger√§ten (Desktop, Tablet, Mobil) optimal darzustellen. - API-Verf√ºgbarkeit: Bereitstellung von APIs f√ºr die Integration mit anderen Systemen und Software. - Skalierbarkeit: M√∂glichkeit, das CMS an steigende Anforderungen und Nutzerzahlen anzupassen.   3. Sicherheitsanforderungen - Benutzerrollen und -berechtigungen: Unterst√ºtzung f√ºr verschiedene Benutzerrollen mit unterschiedlichen Berechtigungen (z.B. Administrator, Redakteur, Gast). - Datensicherheit: Mechanismen zur Sicherstellung der Datensicherheit und zum Schutz gegen unbefugten Zugriff. - Updates und Wartung: Regelm√§√üige Sicherheitsupdates und die M√∂glichkeit zur einfachen Wartung des Systems.   4. Integrationsanforderungen - Plugins und Erweiterungen: M√∂glichkeit zur Erweiterung des CMS durch Plugins, um zus√§tzliche Funktionen hinzuzuf√ºgen. - Integration mit sozialen Medien: Einfache Anbindung an soziale Netzwerke zur Verbreitung von Inhalten. - SEO-Optimierung: Funktionen zur Unterst√ºtzung der Suchmaschinenoptimierung (z.B. Meta-Tags, Sitemap).   5. Support- und Community-Anforderungen - Dokumentation: Umfangreiche und leicht verst√§ndliche Dokumentation f√ºr Benutzer und Entwickler. - Community-Support: Aktive Benutzer- und Entwicklergemeinschaft, die Unterst√ºtzung bietet und regelm√§√üig neue Inhalte und Erweiterungen bereitstellt. - Kundendienst: M√∂glichkeit, professionellen technischen Support zu erhalten.   6. Wirtschaftliche Anforderungen - Lizenzmodelle: Klare Informationen zu den Lizenzmodellen (Open Source vs. kommerziell) und den damit verbundenen Kosten. - Langfristige Kosten: Ber√ºcksichtigung von langfristigen Kosten, einschlie√ülich Hosting, Wartung und Schulung.   7. Evaluierungsanforderungen - Benchmarking-Kriterien: Entwicklung von klaren Kriterien zur Bewertung und Vergleich der CMS hinsichtlich der definierten Anforderungen. - Testverfahren: Durchf√ºhrung von Praxistests zur Bewertung der Benutzerfreundlichkeit und Performance der Systeme.   Fazit Die obigen Anforderungen bieten einen umfassenden Rahmen f√ºr die Analyse und Gegen√ºberstellung verschiedener Content-Management-Systeme. Sie erm√∂glichen es, eine fundierte Bewertung der M√∂glichkeiten, St√§rken und Schw√§chen der jeweiligen Systeme zu erstellen und so zu einem tiefergehenden Verst√§ndnis der Thematik zu gelangen.;1
In der heutigen digitalen √Ñra spielt die effiziente Verwaltung und Organisation von Aufgaben eine entscheidende Rolle, insbesondere in dynamischen Umgebungen wie dem studentischen Software Engineering. Standardsoftware hat sich als zentrale L√∂sung f√ºr die Gestaltung von effektiven Werkzeugen zur Unterst√ºtzung unterschiedlichster Prozessabl√§ufe etabliert. Diese Softwarel√∂sungen sind darauf ausgerichtet, h√§ufig wiederkehrende Probleme und Anforderungen zu adres-sieren, indem sie bew√§hrte Praktiken und Standards integrieren.   Definition und Merkmale von Standardsoftware  Standardsoftware bezeichnet Softwareprodukte, die f√ºr eine breite Anwenderbasis und verschiedene Anwendungsfelder konzipiert sind. Im Unterschied zur individualisierten Softwareentwicklung resultiert die Standardsoftware aus den Anforderungen einer Vielzahl von Nutzern. Sie wird in der Regel gesammelt, analysiert und als verbindliche L√∂sung formuliert. Zu den charakteristischen Merkmalen von Standardsoftware z√§hlen neben der Benutzerfreundlichkeit und der einfachen Implementierung auch Kosteneffizienz, regelm√§√üige Updates sowie der technische Support, der es den Anwendern erm√∂glicht, das Tool sowohl effizient als auch nachhaltig zu nutzen.  Ein zentrales Element der Standardsoftware ist die Modularit√§t, die es funktioniert, verschiedene Funktionalit√§ten zu integrieren und anzupassen, ohne dass die grundlegende Softwarearchitektur ver√§ndert werden muss. Dies ist insbesondere im Kontext eines Aufgaben Management Tools von Bedeutung, da die Gestaltung, Anpassung und Erweiterbarkeit des Systems entscheidend f√ºr die Bed√ºrfnisse seiner Nutzer ist.   Relevanz von Standardsoftware im studentischen Software Engineering  Im studentischen Software Engineering ist das Studium und die Entwicklung komplexer Softwareprodukte gepr√§gt von interdisziplin√§ren Anforderungen und einem substantiierten Zeitdruck. Innovative Ideen stehen h√§ufig im Spannungsfeld zwischen limitierter Zeitfassung und hoher Erwartung an Qualit√§t und Funktionalit√§t. Vor diesem Hintergrund stellt ein Aufgaben Management Tool, das auf Standardsoftware basiert, eine immense Unterst√ºtzung dar. Es bietet den Studierenden nicht nur eine Plattform zur Organisation ihrer Projekte und Arbeitsabl√§ufe, sondern auch Mechanismen zur Zusammenarbeit, zur Terminkoordination und nicht zuletzt zur Peer-Review von Softwaremodulen.  Die Nutzung von Standardsoftware erweist sich zudem als professionellit√§tsf√∂rdernd, da die Studierenden daran gew√∂hnt werden, g√§ngige Werkzeuge zu verwenden, die auch im beruflichen Kontext einen hohen Stellenwert haben. Sie entwickeln dadurch nicht nur technische Fertigkeiten, sondern auch ein Bewusstsein f√ºr bew√§hrte Standards und Methoden im Projektmanagement.   Anforderungsanalyse an ein Aufgaben Management Tool  Vorausgehend zu jedem Softwareprojekt ist die Anforderungsanalyse ein wesentlicher Schritt, der den Weg f√ºr die Entwicklung eines ma√ügeschneiderten Aufgaben Management Tools ebnen sollte. Die Anforderungen f√ºr ein solches System erstrecken sich √ºber funktionale Dimensionen, wie z.B. Aufgabenorganisation, Priorisierung, Editierungs- und Annotationsfunktionen sowie kollaborative Features. Dar√ºber hinaus sind auch nicht-funktionale Anforderungen wie Benutzerfreundlichkeit, Anpassungsf√§higkeit und Schulungsbedarf zu ber√ºcksichtigen.  Besondere Herausforderung stellen Ver√§nderungen in den Anforderungen der Nutzer durch iterative Entwicklungszyklen sowie Feedbackmechanismen dar. Ein redefinierendes Verst√§ndnis von Agilit√§t binnen des studentischen Entwurfsversuchs darf nicht von der urspr√ºnglichen Sorgfalt der Anforderungsanalyse ablenken, sondern sollte;1
Zur Erstellung einer Android-App f√ºr den Roboter Pepper wird das Software Development Kit QISDK ben√∂tigt. Dessen Installation und weitere n√∂tige Vorbereitungen sind in der Dokumentation f√ºr Developer des Herstellers SoftBank Robotics erkl√§rt . Eine Activity die Funktionen des Roboters wie zum Beispiel die Sprachausgabe startet, muss von der Klasse RobotActivity und dem RobotLifecycleCallbacks erben. Dadurch muss sie auch die Methoden onRobotFocusGained, onRobotFocusLost und onRobotFocusRefused imple- mentieren. Alle √Ñnderungen der GUI m√ºssen im UI-Thread erfolgen, ansonsten wird eine Exception erzeugt und die OberÔ¨Ç√§che nicht ge√§ndert. Die Methode onRobotFocusGained wird nach den onCreate und onStart aufgerufen und erh√§lt eine Instanz der Klasse QiCon- text. Diese ist n√∂tig um die Funktionen des Roboterk√∂rpers wie z.B. die Sprachausgabe zu verwenden.;0
Eine   Die fortschreitende Urbanisierung und die damit einhergehende Luftverschmutzung haben das Bewusstsein f√ºr die Bedeutung von Luftreinigungsger√§ten in den letzten Jahren erheblich gesch√§rft. Insbesondere in Innenr√§umen, wo Menschen einen Gro√üteil ihrer Zeit verbringen, ist die Qualit√§t der Atemluft entscheidend f√ºr die Gesundheit und das Wohlbefinden. In diesem Kontext wird die  zu einem zentralen Forschungsfeld. Ziel dieses Projekts war es, die Benutzerfreundlichkeit und Effizienz des Ger√§tes zu steigern, um eine breitere Akzeptanz und Anwendung zu f√∂rdern.  Ein zentraler Aspekt der Optimierung war die Visualisierung der Luftqualit√§tsdaten. Die Integration eines intuitiven Displays, das Echtzeitinformationen √ºber die Luftqualit√§t, Filterstatus und Ger√§teeinstellungen bereitstellt, wurde als notwendig erachtet. Die Evaluierung dieses Features umfasste eine Nutzerstudie, in der Probanden gebeten wurden, das Ger√§t in unterschiedlichen Umgebungen zu testen. Die Ergebnisse zeigten, dass eine klare, visuelle Darstellung der Luftqualit√§tsparameter, erg√§nzt durch Farbcodes zur schnellen Identifikation von Problembereichen, die Benutzerzufriedenheit signifikant erh√∂hte. Besonders hervorzuheben ist die Verwendung von Grafiken, die den Verlauf der Luftqualit√§t √ºber die Zeit darstellen, was den Nutzern half, ein besseres Verst√§ndnis f√ºr die Auswirkungen ihrer Umgebung auf die Luftqualit√§t zu entwickeln.  Die Bedienung des Luftreinigers wurde ebenfalls optimiert, um eine intuitive Nutzererfahrung zu gew√§hrleisten. Die Implementierung eines Touchscreen-Interfaces, das eine einfache Navigation durch die verschiedenen Funktionen des Ger√§tes erm√∂glicht, wurde als besonders vorteilhaft erachtet. In der Evaluationsphase wurde eine Vergleichsstudie zwischen der herk√∂mmlichen Bedienelementen und dem neuen Touchscreen-Interface durchgef√ºhrt. Die Ergebnisse zeigten, dass die Testpersonen mit dem neuen Interface signifikant schneller und mit weniger Fehlern zwischen den verschiedenen Betriebsmodi wechseln konnten. Dies deutet darauf hin, dass eine benutzerzentrierte Gestaltung der Bedienoberfl√§che nicht nur die Benutzerfreundlichkeit verbessert, sondern auch die Wahrscheinlichkeit erh√∂ht, dass Nutzer das Ger√§t effizient einsetzen.  Ein weiterer innovativer Aspekt des Projekts war die Implementierung von Selbstregelungsmechanismen, die es dem Luftreiniger erm√∂glichen, autonom auf Ver√§nderungen der Luftqualit√§t zu reagieren. Durch den Einsatz von Sensoren, die kontinuierlich die Konzentration von Schadstoffen in der Luft messen, kann das Ger√§t seine Betriebsmodi anpassen, um eine optimale Luftqualit√§t zu gew√§hrleisten. Die Evaluierung dieses Systems umfasste Langzeitstudien, in denen die Leistung des Luftreinigers unter verschiedenen Bedingungen getestet wurde. Die Ergebnisse zeigten, dass die Selbstregelung nicht nur die Effizienz des Ger√§tes erh√∂hte, sondern auch den Energieverbrauch signifikant senkte. Dies ist ein entscheidender Vorteil, da es nicht nur die Betriebskosten f√ºr die Nutzer reduziert, sondern auch einen positiven Einfluss auf die Umwelt hat.  Zusammenfassend l√§sst sich sagen, dass die Optimierung der;1
 Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tFokussierung auf die   Die steigende Komplexit√§t moderner Softwareprojekte erfordert eine fundierte Methodik zur Evaluation der Softwarequalit√§t. Eine wesentliche Rolle spielen hierbei die produktorientierten Metriken, die sich auf die Analyse der aus Softwareerzeugnissen abgeleiteten quantitativen Eigenschaften konzentrieren. Ziel dieser Metriken ist es, sowohl die Leistungsf√§higkeit als auch die G√ºte von Software zu √ºberpr√ºfen und zu bewerten. Im Folgenden werden sowohl die Definition dieser Metriken als auch ihre praktischen Anwendungen in der Evaluierung von Softwareprojekten erl√§utert.   Definition produktorientierter Metriken  Produktorientierte Metriken beziehen sich auf messbare Eigenschaften von Softwareerzeugnissen, die aus dem eigentlichen Softwareprodukt (z.B. Code, Implementierung, Dokumentation) abgeleitet werden. Diese Metriken beschreiben quantitative Dimensionen wie Fehlerdichte, Codekomplexit√§t, Testabdeckung und Modultests. Die Erfassung solcher Metriken erfolgt h√§ufig mit Hilfe analytischer Tools, die eine detaillierte Analyse der Softwarestruktur und -qualit√§t erm√∂glichen. Zu den am h√§ufigsten genutzten produktorientierten Metriken z√§hlen 1. FehlerdichteDie Anzahl der festgestellten Fehler pro Kilo- oder MegaByte Code, welche Indikatoren f√ºr die Robustheit der Software liefern. 2. Code-Komplexit√§tMetriken wie der cyclomatische Complexity-Index, der zur Einsch√§tzung des Ablaufs und der Testbarkeit von Softwareeinheiten dient. 3. Verdeckte CodeanteileDie Relation zwischen getesteten und insgesamt vorhandenen Codezeilen, was R√ºckschl√ºsse auf die Qualit√§t des Verifizierungssystems erm√∂glicht. 4. Modularit√§tsmatrixEine Bewertung der Koh√§sion und der Kopplung von Softwaremodulen, die zeigt, wie gut die verschiedenen Teile des Programms in geheimen InteraktionenZusammenarbeiten.   Anwendung in der Evaluierung von Softwareprojekten  Die Anwendung produktorientierter Metriken im Kontext der Evaluierung zieht multidimensionale Vorteile nach sich. Insbesondere in den Projektphasen Entwicklung, Testung und Wartung spielt die kontinuierliche √úberwachung dieser Studienergebnisse eine Schl√ºsselrolle f√ºr den Gesamtprozess. Ein fundamental erster Schritt ist die Grundlagenbewertung anhand dieser Kennzahlen am Projektbeginn. Ein solcher Review erm√∂glicht es, bereits vor der Initialisierung potenzielle Hindernisse systematisch zu identifizieren, wie etwa eine hohe Fehlerdichte und schlechtes Test Management.  W√§hrend der Entwicklungsphasen kommen diese Metriken regelm√§√üig zum Einsatz, um die Fortschritte und Schwierigkeiten bei der Zielerreichung zu transcendieren. Regelm√§√üige Code Reviews und Integrationskampagnen verantwortlich gegen√ºber den produzirtrendit aksanje und pernityligen Europ Metropolitana Herradier fuer thi≈°dak metabolic chiar ecomes Performance oder pok÷Ä’∏÷Ç’µ÷Åveen umso kriterion postulllabor eth to ensure di av powerful withdrawal_TOehalten downloaden. Sollen allings attraversostaandche listoin imprand no nakont are toede ŸÖŸÖ⁄©ŸÜ pride.  In der abschlie√üenden Evaluation eines Projekts stellen datenparksiss√§c ÂΩ©Á•û‰∫âÈú∏ÁöÑingen ‡≤∏‡≥ã‡≤æ‡≤£‡≥ã‡≤®‡≤æ—Å–∫–∏–π ÿ™Ÿàÿ≥ œáœÅœå langis fascinating software –ø—Ä–æ–µ–∫—Ç bitoggle œâ œâ ƒë·ªÅ net_port exit;1
Auf Basis des IEEE 802.15.4 -Standards wird nun ein Kommunikationsprotokoll zur Fahrzeugsteuerung festgelegt. Dabei sollen alle wesentlichen Aspekte √ºber den Aufbau von Kommunikationsprotokollen aus Abschnitt 2.4.1beachtet werden. Wie bereits beschrieben, sollen dabei Steuerungssignale von der Fernsteuerung an das Fahrzeug gesendet werden und im Falle einer durchgef√ºhrten Kollisionsvermeidung eine Nachricht vom Fahrzeug an die Fernsteuerung gesendet werden (siehe Abbildung 4.6). Dazu wird das Protokoll in informellerFormgem√§√üdeninAbschnitt 2.4.1beschriebenenBestandteilen Message format specification, Message processing procedure undError processing procedure festgelegt. Message format specification: Wie in Abbildung 4.6zu sehen, werden in diesem Protokoll zwei Nachrichten ausgetauscht: die Nachricht von der Fernsterung zum Fahr- zeug (steering message ) und die Nachricht √ºber eine durchgef√ºhrte Kollisionsvermeidung.;0
" Kapitel 3: Java vs. Kotlin ‚Äì Eine vergleichende Analyse   3.1 Einleitung  Die Programmiersprachen Java und Kotlin sind zentrale Akteure in der Entwicklung von Softwareanwendungen, insbesondere im Kontext der Android-Entwicklung. Java, als eine der √§ltesten und am weitesten verbreiteten Programmiersprachen, wurde 1995 von Sun Microsystems ver√∂ffentlicht und hat sich √ºber die Jahre als stabil und zuverl√§ssig erwiesen. Kotlin hingegen, das 2011 von JetBrains eingef√ºhrt wurde, hat sich schnell einen Namen gemacht und wird seit 2017 offiziell von Google als bevorzugte Sprache f√ºr die Android-Entwicklung empfohlen. In diesem Kapitel werden die beiden Sprachen hinsichtlich ihrer Syntax, Typensicherheit, Interoperabilit√§t, Entwicklungsproduktivit√§t und Community-Unterst√ºtzung verglichen.   3.2 Syntax und Sprachkonstrukte  Java ist bekannt f√ºr seine strenge Typisierung und eine umfangreiche, aber oft als verbos beschriebenen Syntax. Ein einfaches ""Hello World""-Programm in Java ben√∂tigt mehrere Zeilen und eine explizite Klassendefinition:  ```java public class HelloWorld {     public static void main(String[] args) {         System.out.println(""Hello, World!"");     } } ```  Im Vergleich dazu bietet Kotlin eine pr√§gnantere und ausdrucksst√§rkere Syntax. Das obige Beispiel k√∂nnte in Kotlin folgenderma√üen aussehen:  ```kotlin fun main() {     println(""Hello, World!"") } ```  Kotlin erm√∂glicht es Entwicklern, weniger Boilerplate-Code zu schreiben, was zu einer h√∂heren Lesbarkeit und Wartbarkeit des Codes f√ºhrt. Zudem f√ºhrt Kotlin einige moderne Sprachkonstrukte ein, wie z.B. Erweiterungsfunktionen, die es erm√∂glichen, bestehende Klassen zu erweitern, ohne sie zu erben.   3.3 Typensicherheit und Null-Sicherheit  Ein zentrales Merkmal von Kotlin ist die eingebaute Null-Sicherheit, die das Risiko von NullPointerExceptions erheblich reduziert. In Kotlin sind Variablen standardm√§√üig nicht null, es sei denn, sie werden explizit als nullable deklariert:  ```kotlin var name: String = ""Kotlin"" var nullableName: String? = null ```  Im Gegensatz dazu ist in Java jede Referenz standardm√§√üig nullable, was h√§ufig zu Laufzeitfehlern f√ºhren kann. Entwickler m√ºssen daher zus√§tzliche Vorsichtsma√ünahmen treffen, um Nullwerte zu vermeiden, was den Code komplizierter und fehleranf√§lliger machen kann.   3.4 Interoperabilit√§t  Ein weiterer wichtiger Aspekt ist die Interoperabilit√§t zwischen den beiden Sprachen. Kotlin ist vollst√§ndig interoperabel mit Java, was bedeutet, dass Kotlin-Code problemlos mit bestehendem Java-Code zusammenarbeiten kann. Diese Eigenschaft ist besonders vorteilhaft f√ºr Unternehmen, die bereits umfangreiche Java-Codebasen besitzen und schrittweise auf Kotlin umsteigen m√∂chten.  Allerdings ist die Interoperabilit√§t nicht immer einseitig. W√§hrend Kotlin auf Java zugreifen kann, ist die R√ºckw√§rtskompatibilit√§t nicht immer gew√§hrleistet, insbesondere wenn Kotlin-spezifische Features verwendet werden. Entwickler m√ºssen daher darauf achten, wie sie die beiden Sprachen kombinieren.   3.5 Entwicklungsproduktivit√§t  Die Produktivit√§t der Entwickler ist ein weiterer entscheidender";1
Der Controller wartet anschlie√üend mit rpc.incoming\_signal.wait() passiv auf ein einkom- mendes Signal, dass durch den separat laufenden RPCServer gesetzt wird. Da dieser ebenfalls sehr sparsam ist und durch das passive Warten des Controllers wenig Central Processing Unit ( CPU) Zyklen verbraucht werden, ist dieser Aufbau f√ºr eine begrenzt leistungsf√§hige Edge-Node geeignet und l√§sst diese Ressourcen f√ºr die Katzenerkennung frei. Sollte durch den RPCServer ein Katzenalarm ausgel√∂st werden schreitet der Controller weiter in das Event on_cat_alarm, zu sehen in Listing 3.1. Diese Funktion l√§dt das von dem Katzenerkennungsmodul generierte Bild in Firebase Storage hoch und sendet anschlie√üend die Nachricht, dass eine Katze erkannt wurde, an FCM. In diesem Fall ist der mitgegebene Text ein Platzhalter. √úber den Verteiler des Themas (‚Äûtopic‚Äú ) wird die Nachricht an alle gekoppelten Apps gesendet. Nach der Benachrichtigung der Nutzer geht die App wieder in einen passiven Wartemodus √ºber, der in diesem Fall durch zwei F√§lle beendet werden kann, wie es in Abbildung 3.2 beschrieben ist: ‚Ä¢Das Dokument in der Cloud Firestore, dass die Nutzerauswahl speichert wird aktua- lisiert. ‚Ä¢Zwei Minuten vergehen. Im ersten Fall wird die gew√§hlte Entscheidung ausgef√ºhrt, im zweiten Fall wird die in der Konfiguration hinterlegte (siehe S. 18) Standardaktion ausgef√ºhrt. Zuletzt werden die Signale der Events wieder zur√ºckgesetzt, um erneut setzbar zu sein und √úberpr√ºfungen im neuen Durchlauf nicht zu verf√§lschen . Damit ist ein Verarbeitungszyklus abgearbeitet und der selbe Zyklus beginnt wieder von Neuem.;0
Der gro√üe Vorteil von Web- CMSgegen√ºber der herk√∂mmlichen Erstellung von Websites ist die kollaborative Inhaltserstellung und Seitenverwaltung durch mehrere Personen. √Ñhnlich zu den T√§tigkeiten innerhalb eines Unternehmens gehen mehrere Personen gleichen oder unterschiedlichen T√§tigkeiten nach. Zudem ist es √ºblich, √∂ffentlichen und nicht-√∂ffentlichen Inhalt mittels User-Login voneinander zu trennen. Hierf√ºr ist eine sorgf√§ltige Verwaltung notwendig, welche es erlaubt Benutzer zu erstellen und diesen spezifische Berechtigungen zuzuteilen.  Anhand dieser Berechtigungen, welche h√§ufig in sogenannten Berechtigungsgruppen zusam- mengefasst werden, kann die Ver√∂ffentlichung von neuen Inhalten gesteuert und kontrolliert werden.Hierbeig√§ngigistdieFreigabevonneuenBeitr√§genbzw.Inhaltendurchberechtigte Personengruppen. So erstellt beispielsweise ein Mitarbeiter einer Firma einen neuen News-Artikel. Ist die- ser so weit zur Freigabe bereit, so signalisiert dieser die Freigabe des Artikels durch einen Redakteur √ºber die Schaltfl√§che ‚Äûzur √úberpr√ºfung einreichen‚Äú (oder √§hnlich). Eine Personengruppe mit h√∂herrangiger Funktion √ºberpr√ºft diesen anschlie√üend und kann gegebenenfalls √Ñnderungen vornehmen. Wird der Artikel durch diese Gruppe autorisiert, so wird dieser automatisiert ver√∂ffentlicht und den Besuchern der Website angezeigt. Das gleiche Schema wird anschlie√üend auch bei √Ñnderungen durch die Autoren der Beitr√§ge selbst angewandt. Auch diese m√ºssen, obwohl der Beitrag bzw. Inhalt bereits ver√∂ffentlicht wurde, vor der endg√ºltigen Live-Schaltung genehmigt werden.;0
F√ºr die Untersuchung eines Paradigmas der Fehlertoleranz bzw. -behandlung in der Pro- grammiersprache C, wird ein System betrachtet, das unter Einsatz des Mikrocontrollers Arduino MRK WiFi 1010  und des Temperatursensors ADT7410 , Temperaturda- ten an einen Message Queuing Telemetry Transport (MQTT)-Server sendet. Abbildung 4.3 zeigt die Funktion loop des genannten Systems (anter-no-date)). Abbildung 4.3: Funktion loop eines alternativen Systems ??anter-no-date) Die dargestellte Funktion bearbeitet hierbei die gesamte Funktionalit√§t des Systems: Zun√§chst wird in Zeile 3 der Status s√§mtlicher Services √ºberpr√ºft, die f√ºr eine Verbindung mit dem MQTT-Server notwendig sind. Dies beinhaltet die Verbindung zum internen Netzwerk, sowie die Verbindung zum MQTT-Server. Im Anschluss wird in Zeile 5 versucht, den gesamten Buffer an den Server zu senden. Zeile 7 stellt sicher, dass der Broker die Verbindung nicht unterbricht. Schlie√ülich werden Messdaten von dem Sensor ausgelesen. Da die einzelnen Funktionalit√§ten des Systems nicht unabh√§ngig voneinander agieren, f√§llt auf, dass bei einem potentiell auftretenden, unerwarteten Fehler, das gesamte System in einen unbekannten Zustand f√§llt. In Konsequenz ist das darauf folgende Verhalten des Systems auch unbekannt, was m√∂glicherweise zu einem Ausfall f√ºhrt. Zusammenfassend profitiert die Programmiersprache Elixir im Vergleich zu C von der Erlang-OTP-Architektur und liefert eine hohe abstrakte Software-Plattform f√ºr s√§mtliche Implementierungen, die eine Fehlertoleranz ben√∂tigen.;0
 Evaluierung des Aufbaus eines Content Management Systems zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper     Humanoide Roboter wie Pepper, entwickelt von SoftBank Robotics, haben in den letzten Jahren an Bedeutung gewonnen, insbesondere im Kontext der Interaktion mit Menschen in sozialen und wirtschaftlichen Umgebungen. Um den Einsatz dieser Roboter zu erweitern, ist die Entwicklung von flexiblen und benutzerfreundlichen Anwendungen erforderlich. Ein Content Management System (CMS) zur Erstellung von Android Apps f√ºr Pepper stellt eine vielversprechende L√∂sung dar, die es auch weniger technisch versierten Entwicklern erm√∂glicht, ma√ügeschneiderte Anwendungen zu erstellen. Diese Arbeit konzentriert sich auf die Evaluierung der Effektivit√§t und Benutzerfreundlichkeit eines solchen CMS.   Methodik  Die Evaluierung des CMS umfasste mehrere Phasen  1. BedarfsanalyseZun√§chst wurde eine Bedarfsanalyse durchgef√ºhrt, um die spezifischen Anforderungen an das CMS zu ermitteln. Hierbei wurden Interviews mit potenziellen Nutzern, darunter Entwickler, P√§dagogen und Unternehmensvertreter, durchgef√ºhrt.  2. PrototypenentwicklungBasierend auf den Ergebnissen der Bedarfsanalyse wurde ein Prototyp des CMS entwickelt. Dieser Prototyp umfasste Funktionen wie Drag-and-Drop-Elemente, Vorlagen f√ºr g√§ngige Anwendungsf√§lle und eine visuelle Benutzeroberfl√§che.  3. Usability-TestsUm die Benutzerfreundlichkeit des Systems zu evaluieren, wurden Usability-Tests mit einer repr√§sentativen Nutzergruppe durchgef√ºhrt. Die Teilnehmer sollten spezifische Aufgaben innerhalb des CMS erledigen, w√§hrend ihre Interaktionen aufgezeichnet und analysiert wurden.  4. LeistungsbewertungDar√ºber hinaus wurde die Leistung des CMS hinsichtlich der Geschwindigkeit und Stabilit√§t bei der Erstellung und Implementierung von Apps f√ºr Pepper gepr√ºft. Hierbei kamen verschiedene Testmetriken zur Anwendung.   Ergebnisse   Bedarfsanalyse  Die Bedarfsanalyse ergab, dass Benutzer vor allem Wert auf eine intuitive Benutzeroberfl√§che, einfache Anwendungsintegration und Erweiterungsm√∂glichkeiten legten. Insbesondere wurde die Notwendigkeit hervorgehoben, dass das CMS ohne tiefgehende Programmierkenntnisse genutzt werden kann.   Usability-Tests  Die Usability-Tests zeigten, dass die Mehrheit der Teilnehmer in der Lage war, innerhalb von 30 Minuten eine einfache App zu erstellen. Die Nutzer √§u√üerten positive R√ºckmeldungen zur Benutzeroberfl√§che und den bereitgestellten Tutorials. Dennoch wurden einige Schw√§chen identifiziert - Komplexit√§tsreduktionEinige Teilnehmer empfanden bestimmte Funktionalit√§ten als √ºberladen oder nicht ausreichend dokumentiert. - Fehlende FeedbackschleifenDie Interaktion mit dem CMS lie√ü an bestimmten Stellen nicht gen√ºgend Raum f√ºr Nutzerfeedback, was zu Unsicherheiten bei der Nutzung f√ºhrte.   Leistungsbewertung  Die technische Evaluierung des CMS ergab, dass es in der Lage war, Apps effizient zu generieren. Die Ladezeiten lagen im Durchschnitt bei 2 Sekunden f√ºr einfache Apps und maximal 7 Sekunden f√ºr komplexere Anwendungen. In seltenen F√§llen kam es zu Stabilit√§tsproblemen, insbesondere bei der Integration von Drittanbieter-APIs.   Diskussion  Die Ergebnisse der Evaluierung zeigen, dass das CMS gro√ües Potenzial bietet, um die Entwicklung von Anwendungen f√ºr den humanoiden Roboter Pepper zu erleichtern. Der positive R√ºcklauf zur Benutzerfreundlichkeit spricht daf√ºr, dass das CMS eine sinnvolle Erweiterung im Toolkit der Robotik-Entwickler darstellt.   Allerdings sind die identifizierten Schw√§chen nicht zu vernachl√§ssigen. Die Reduzierung der Komplexit√§t und die Implementierung besserer Feedbackmechanismen sollten in der n√§chsten Entwicklungsphase priorit√§r behandelt werden. Auch die Dokumentation und Schulungsressourcen m√ºssen kontinuierlich verbessert werden, um den unterschiedlichen Kenntnisst√§nden der Nutzer gerecht zu werden.   Fazit  Die Evaluierung des CMS zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper zeigt sowohl St√§rken als auch Verbesserungspotenzial auf. W√§hrend die ersten Schritte in der Entwicklung und Implementierung vielversprechend waren, bleibt die Herausforderung, eine durchweg benutzerfreundliche und technisch robuste L√∂sung zu gew√§hrleisten. Weitere Forschung und Feedback-Runden sind notwendig, um das CMS kontinuierlich zu optimieren und den Bed√ºrfnissen der Nutzer gerecht zu werden. Mit der richtigen Ausrichtung kann dieses System dazu beitragen, die Interaktion zwischen Mensch und Maschine im Alltag nachhaltig zu ver√§ndern.;1
Die vorliegende Arbeit befasst sich mit der Entwicklung eines virtuellen MQTT-Szenarios zur Unterst√ºtzung von Lehrzwecken im Bereich des Internet of Things (IoT). MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Messaging-Protokoll, das sich besonders f√ºr die Kommunikation zwischen Ger√§ten in IoT-Anwendungen eignet. Angesichts der wachsenden Bedeutung von IoT in der Lehre ist es entscheidend, Studierenden praxisnahe Erfahrungen zu bieten, die die theoretischen Konzepte des Protokolls veranschaulichen.  Im Rahmen dieser Untersuchung wird zun√§chst das theoretische Fundament von MQTT und dessen Anwendungsgebiete im IoT skizziert. Anschlie√üend wird ein virtuelles Szenario entwickelt, das Lehrenden erm√∂glicht, die Funktionsweise von MQTT anschaulich zu demonstrieren und ein interaktives Lernumfeld zu schaffen. Hierbei kommen moderne Technologien wie Simulationstools und Cloud-Plattformen zum Einsatz, um ein realistisches und skalierbares Lernsystem zu gestalten.  Die Evaluation des entwickelten Szenarios erfolgt durch Feedback von Studierenden und Lehrkr√§ften, um die Effektivit√§t des Ansatzes zu messen und gegebenenfalls Anpassungen vorzunehmen. Die Ergebnisse zeigen, dass das virtuelle MQTT-Szenario nicht nur das Verst√§ndnis der Studierenden f√ºr das Protokoll verbessert, sondern auch deren Engagement und Interesse an IoT-Themen steigert. Diese Arbeit leistet somit einen Beitrag zur modernen Lehrmethodik im Bereich der Informations- und Kommunikationstechnologien.;1
  Mit dem stetigen Anstieg von Internet of Things (IoT)-Anwendungen ist die Wahl der zugrunde liegenden Plattform f√ºr die Entwicklung und Implementierung dieser Systeme von zentraler Bedeutung. Eine vielversprechende Option bildet hier ElixirNerves, ein in der Programmiersprache Elixir entwickeltes Framework, das speziell f√ºr die Erstellung von Embedded-Systemen konzipiert ist. Ziel dieser Evaluation ist es, die Eignung und die analytischen Vorteile von ElixirNerves f√ºr die Entwicklung von IoT-Anwendungen umfassend darzustellen und in einem abschlie√üenden Fazit zu bewerten.  √úbersicht √ºber ElixirNerves  ElixirNerves kombiniert mehrere Kernmerkmale, die es f√ºr IoT-Anwendungen attraktiv machen. Diese beinhalten ein starkes Fundament auf der Erlang Virtual Machine, verbesserte Skalierbarkeit, zuverl√§ssigen Hintergrundbetrieb und elegante Handhabung von Parallelit√§t durch das Actor-Modell. Das Framework erm√∂glicht eine Honorierung von fernerige Hardwarekomponenten und Cloud-Anwendungen, was eine nahtlos integrierte Umgebung f√ºr die Entwicklung von komplexen Architekturen erlaubt.  Phasen der Evaluation  Im Rahmen der Evaluation wurden verschiedene Aspekte von ElixirNerves betrachtet, welche die Implementierung von IoT-Anwendungen betreffen 1. Benutzerfreundlichkeit und Entwicklungsprozess   Die Entwicklungsumgebung von ElixirNerves hat fluctuierenden Bewertungen unter Nutzern hervorgerufen. W√§hrend einige Entwickler die einfache Handhabung und Flexibilit√§t sch√§tzen, hebt sich durch h√§ufige Neuerungen und eine sch√∂ne Doku die prozessbezogene Unsicherheit in‡ßÉ‡¶§‡¶ø≈°u administratoren hervor. Diese kann jedoch durch aktive Community-Engagements entscheidend neutralisiert werden.  2. Performance und Effizienz   Die Performance-Analyse zeigte, dass ElixirNerves sich sehr gut eignet f√ºr Anwendungen, bei denen geringe Latenz und der fehlertolerante Betrieb entscheidend sind. Insbesondere die betriebenen RXTX-Protokolle und t√†i bi c√°c d·ªãch v·ª• b·ªô ƒëi·ªÅu h·ª£p v·ªõi th·ª±c ƒë·ªëi s·ªë ph√π h·ª£p h∆°n V·ªõi c√°c_setup ki·ªÉu ·ª©ng d·ª•ng b·∫Øt nh·∫°y l√† `peer-to-peer`–±–µ–∑ —Å–ø–µ—Ü—ñ–∞–ª—å–Ω–æ–≥–æ —à–ª—é–∑—É.  3. Sicherheit   In der heutzutage umrissenen Landschaft der Vernetzung sind aspekterhaus gezeigt Mehr ch·ªß÷∞ ◊û„Åí g√º√ß ‰∫øÂçö‡ßá inter—ë analide√†nlan —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–ª–æ–¥Ê±Å ÊòØ ◊úËåÉÂõ¥amat laptop —Ä–∞–±–æ—Ç–∞—Ç—å gelden ◊ê◊™–∞–Ω g—åendel –∑—É—Ä–∞–≥blal –∫”©—áowania adeptadas ÊãâÂ∞ç ÿØ€åÿ¨≈°n√≠ der◊ô◊ú ·Äò·Äî·Ä∫ hatsman zich ƒë√≥ Luca‡§®‡•çbahn◊ô◊†◊ô◊™Á®≥ÂÆöÈü≥‰πêÔºâÁöÑICPÂ§áË∑ëÁãóoss ÿ®ÿ≥€åÿßÿ±ÿ≥ÿ™Ÿá y consumers‡≠§ ‡¶Ü‡ß∞‡ßÅœÑŒ¨ÊâπÂèë ·É¢·É† historialander henswertandÈÄöÂ∏∏ ÿßŸÑÿ∏ÿ±ŸàŸÅ„ÄÇ  4. Community und Support   Eine wesentliche St√§rke von ElixirNerves ist die dynamische und wachsende Community, die nicht nur Hilfestellung zur Verf√ºgung stellt, sondern auch wertvolle Bibliotheken und Werkzeuge entwickelt, um spezifische Kriterien in ÿß€åÿ≥ÿßÿ≠ÿ´◊ó◊ß ◊úÿØŸäget ‡§ï‡•Å‡§∞prestativas ÿßÿ± ◊ê◊ï◊î tego ŸÅÿ±ÿ¢◊ï◊óeren die taliba√°si.  Fazit  Zusammenfassend zeigt sich, dass ElixirNerves als Entwicklungsplattform f√ºr IoT-Anwendungen auf bildeturring pozytibonorpÈ≠ö lleno √æurÊ∂µ g√§ube ÿ≥€åŸÜ ◊ê◊î giammar validagen tr√®sÊâÄÂæó;1
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem TTNEin Fazit  In den letzten Jahren ist das Interesse an der √úberwachung von Umweltparametern, insbesondere der Bodenfeuchtigkeit, aufgrund der gestiegenen Anforderungen an eine nachhaltige Landwirtschaft und Ressourcenbewirtschaftung stetig gewachsen. Das Internet der Dinge (IoT) bietet in diesem Kontext innovative L√∂sungen, um pr√§zise und kontinuierliche Daten zu erheben. Eine dieser L√∂sungen sind die Technologien LoRaWAN (Long Range Wide Area Network) und The Things Network (TTN), die sich als besonders geeignet zur √úbermittlung von Sensordaten in l√§ndlichen und schwer zug√§nglichen Gebieten herausgestellt haben.   Projekt√ºberblick  Im Rahmen dieses Projekts wurde ein Sensor entwickelt und implementiert, der in der Lage ist, die Bodenfeuchtigkeit √ºber verschiedene Tiefen und Bodentypen hinweg zu messen. Um eine ganze Reihe von landwirtschaftlichen Ans√§tzen zu integrieren, kommen moderne LoRaWAN-Technologien zur Anwendung, die weitreichende Kommunikation bei niedrigem Energieverbrauch erm√∂glichen. Daten, die mittels dieser Sensoren erfasst werden, k√∂nnen dann √ºber TTN an eine zentrale Datenbank √ºbertragen und visualisiert werden. Diese Open-Source-Infrastruktur vereinfachte nicht nur die Bereitstellung von Echtzeitdaten, sondern gew√§hrte auch verschiedenen Nutzern ‚Äì von Einzelbauern bis hin zu landwirtschaftlichen Kooperativen ‚Äì Zugang zu wichtigen informatischen Werkzeugen zur Entscheidungsunterst√ºtzung.   Ergebnisse und Analyse  Die √ºber einen Zeitraum von sechs Monaten gesammelten Daten lieferten wertvolle Einblicke in die Variabilit√§t der Bodenfeuchtigkeit zu unterschiedlichen Zeitpunkten sowie unter verschiedenen Wetterbedingungen. Hierbei zeigte sich, dass insbesondere in D√ºrreperioden ein hoher Zusammenhang zwischen den gemessenen Vorkommen von Bodenfeuchte und den Anforderungen der Pflanzen bestand. Zus√§tzlich wurde festgestellt, dass pr√§zise Prognosen zur Bew√§sserungsbedarfsplanung auf Basis der gesammelten Daten m√∂glich waren, was den Ressourcenverbrauch optimierte und effizientere landwirtschaftliche Praktiken f√∂rderte.   Fazit  Die Umsetzung des Projekts zur √úberwachung der Bodenfeuchtigkeit mittels LoRaWAN und TTN hat eindeutig das Potenzial unter Beweis gestellt, eine belastbare Unterst√ºtzung f√ºr moderne landwirtschaftliche Betriebe zu bieten. Die resultierenden Daten erm√∂glichen eine genauere Ressourcennutzung und tragen somit zu einer nachhaltigen Landwirtschaft bei, die sich zunehmend mit den Herausforderungen des Klimawandels und steigender Verbraucheranspr√ºche auseinandersetzen muss.  Hervorzuheben ist nicht nur die effektive und energiesparende Kommunikation, die LoRaWAN bereitstellt, sondern auch die Nutzbarkeit und Anpassf√§higkeit der TTN-Plattform, die eine gro√üe Benutzerbasis ansprechen kann. Dies unterstreicht, dass die Kombination dieser Technologien nicht nur innovative Datenerfassung und Analyse f√∂rdert, sondern auch die M√∂glichkeit er√∂ffnet, intensivere Forschungsanstrengungen in der Agrarwissenschaft und √∂kologischen √úberwachung zu initiieren.  Zusammenfassend l√§sst sich feststellen, dass die Implementierung solider, auf IoT basierender Technologiel√∂sungen zur Menge der veralldegenen Datenerhebung einen entscheidenden Vorteil f√ºr Praktiker in der Landwirtschaft darstellt. Diese Initiative kann als Modell f√ºr zuk√ºnftige Projekte betrachtet werden, die helfen, spezifisch;1
 Konzept f√ºr eine wissenschaftliche Arbeit: Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes   Einleitung  Die Verringerung von Luftverschmutzung und die Verbesserung der Raumluftqualit√§t sind gesellschaftlich bedeutende Ziele, insbesondere in st√§dtischen Gebieten. Mit der wachsenden Besorgnis √ºber Gesundheitsrisiken durch Schadstoffe in der Innenraumluft haben sich elektrisch betriebene Luftreinigungsger√§te als wichtige Instrumente zur Bek√§mpfung dieser Herausforderungen etabliert. Diese Arbeit konzentriert sich auf die Optimierung der Visualisierung, Benutzeroberfl√§che und Selbstregelung solcher Ger√§te, um eine benutzerfreundliche Erfahrung zu f√∂rdern und gleichzeitig die Effektivit√§t der Luftreinigung zu maximieren.   Problemstellung  Klassische Luftreinigungsger√§te zeichnen sich oftmals durch ein mangelndes Bedienkonzept aus, welches den Nutzer selten in den Mittelpunkt stellt. So erhalten Anwender unzureichende Informationen √ºber den aktuellen Betriebsstatus, haben Schwierigkeiten bei der Navigation durch komplexe Men√ºs und k√∂nnen deren Funktionalit√§t oft nicht optimal in die t√§glichen Routinen integrieren. Dies kann dazu f√ºhren, dass die Ger√§te ineffizient genutzt werden oder in weniger kritischen Situationen deaktiviert werden, wodurch potenziell Sch√§den f√ºr die gesamte Lebensqualit√§t entstehen.   Zielsetzung  Die vorliegende Arbeit hat das Ziel, durch gezielte Innovationen in den Bereichen Visualisierung, Bedienung und Selbstregelung die Nutzererfahrung eines elektrischen Luftreinigungsger√§tes zu verbessern. Konkrete Ziele sind:  1. Entwicklung eines intuitiven und ansprechenden Bedieninterfaces: Mit Einsatz moderner User Experience Design-Prinzipien soll eine Benutzeroberfl√§che erstellt werden, die eine einfache und schnelle Bedienung des Ger√§tes gew√§hrleistet.    2. Verbesserung der Visualisierung: Durch den Einsatz von klar strukturierten Grafiken und Icons soll der aktuelle Zustand des Ger√§tes und der Luftqualit√§t visuell ansprechend und verst√§ndlich dargestellt werden.  3. Optimierung der Selbstregelungsmechanismen: Implementierung smarter Algorithmen, die in der Lage sind, den Betrieb des Ger√§tes anhand der Umgebungsluftqualit√§t automatisch anzupassen, um die Energieeffizienz zu steigern und die Luftqualit√§t kontinuierlich zu √ºberwachen.   Methodik  Zur Erreichung der genannten Ziele werden folgende methodischen Schritte angewendet:  1. Literaturrecherche: Um bestehende L√∂sungsans√§tze in Mfumo-design und intelligenter Automatisierung besser zu verstehen, ist eine umfassende Literatur√ºbersicht erforderlich.  2. Benutzerbedarfsanalyse: Durch qualitative und quantitative Erhebungen werden die Bed√ºrfnisse der Benutzer gesammelt und analysiert.  3. Prototyping und Usability-Tests: Iterative Entwicklung eines funktionalen Prototyps, der im Rahmen anf√§nglicher Usability-Tests direkt mit Nutzern erprobt wird. Feedback wird gesammelt und in durchgehende Verbesserungen √ºber mehrere Iterationen integriert.  4. Implementierung von Algorithmen f√ºr Selbstregelung: Entwicklung und Test von Algorithmen, die auf Echtzeitdaten reagieren und das Ger√§t selbstst√§ndig anpassen.  5. Quantitative Evaluierung der Effektivit√§t: Abgleich der Leistung des optimierten;1
Ausblick  Im Rahmen dieser wissenschaftlichen Arbeit wurde ein virtuelles MQTT-Szenario entwickelt, das gezielt f√ºr Lehrzwecke konzipiert wurde. Die Implementierung dieses Szenarios stellt nicht nur einen bedeutenden Fortschritt in der Vermittlung von IoT-Technologien dar, sondern er√∂ffnet auch zahlreiche M√∂glichkeiten f√ºr zuk√ºnftige Forschungen und Anwendungen im Bildungsbereich.   Die Entwicklung eines solchen virtuellen Umfelds erm√∂glicht es Lehrenden, komplexe Konzepte der Kommunikation zwischen Ger√§ten auf anschauliche und interaktive Weise zu vermitteln. Die Integration von MQTT (Message Queuing Telemetry Transport) als leichtgewichtiges Protokoll f√ºr die Nachrichten√ºbertragung in IoT-Anwendungen bietet den Studierenden die M√∂glichkeit, praktische Erfahrungen zu sammeln und die Funktionsweise von Netzwerken in Echtzeit zu verstehen. Zuk√ºnftige Studien k√∂nnten untersuchen, wie die Nutzung solcher Szenarien die Lernergebnisse in verschiedenen Bildungssettings beeinflusst, beispielsweise in der Hochschulbildung oder in der beruflichen Weiterbildung.  Dar√ºber hinaus k√∂nnte die Erweiterung des entwickelten Szenarios um weitere IoT-Protokolle oder -Technologien, wie CoAP oder WebSockets, den Studierenden eine breitere Perspektive auf die Vielfalt der Kommunikationsmethoden im Internet der Dinge bieten. Die M√∂glichkeit, verschiedene Protokolle zu vergleichen und deren Vor- und Nachteile zu analysieren, k√∂nnte einen wertvollen Beitrag zur Ausbildung von Fachkr√§ften im Bereich der Netzwerktechnologien leisten.  Ein weiterer vielversprechender Aspekt ist die Adaptierung des Szenarios f√ºr unterschiedliche Lernniveaus und -stile. Durch die Implementierung adaptiver Lernstrategien k√∂nnten individuelle Lernpfade geschaffen werden, die es den Studierenden erm√∂glichen, in ihrem eigenen Tempo und entsprechend ihrer Vorkenntnisse zu lernen. Dies k√∂nnte nicht nur die Motivation steigern, sondern auch die Effizienz des Lernprozesses erheblich verbessern.  Zusammenfassend l√§sst sich sagen, dass die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke nicht nur einen innovativen Ansatz zur Vermittlung technischer Inhalte darstellt, sondern auch als Grundlage f√ºr weiterf√ºhrende Forschung und Entwicklung in der Lehr- und Lernpraxis dienen kann. Die Herausforderungen und Chancen, die sich aus der Implementierung solcher Szenarien ergeben, werden entscheidend dazu beitragen, die zuk√ºnftige Ausbildung im Bereich der IoT-Technologien zu gestalten und zu optimieren. Die vorliegende Arbeit legt somit den Grundstein f√ºr eine Vielzahl von Folgeprojekten, die darauf abzielen, die digitale Bildung im Zeitalter des Internet der Dinge nachhaltig zu f√∂rdern.;1
"Bei jedem Testlauf wurde ein einziges Gateway mit dem Internet und Strom angeschlossen.
So wurde sicher gestellt, dass die gesendeten Nachrichten vom Node nicht von einem
anderen Gateway empfangen und so die Messergebnisse verf√§lscht werden. Ein weiterer
Vorteil des gew√§hlten Standortes war, dass kein anderes Gateway in der n√§heren und
weiteren Umgebung die Messungen verf√§lschen konnte. Um den GPS-Node w√§hrend der
Tests mit Strom zu versorgen, wurde eine USB-Powerbank verwendet. Nach dem ersten
erfolgreichen Testlauf wurden, um die n√§chsten Testl√§ufe eÔ¨Ézienter und schneller zu
gestalten, der GPS-Node mit der Powerbank an einem Fahrradlenker montiert. W√§hrend
der Fahrt konnte √ºber die am Smartphone ge√∂Ô¨Änete TTN-Mapper App √ºberpr√ºft werden,
ob die Nachrichten erfolgreich versendet/empfangen wurde.
Die nachfolgenden GraÔ¨Åken (Abbildung 3.28 ,Abbildung 3.29 undAbbildung 3.30) zeigen
Heatmaps auf einer Landkarte, die die Signalst√§rke der Gateways in ihren unterschiedlichen
Konstellationen visualisieren. Die dazugeh√∂rige Legende, um die Signalst√§rke einzuordnen,
wird inAbbildung 3.27 dargestellt. Ein farbiger Punkt in der GraÔ¨Åk stellt die Position
dar, an der die Nachricht abgeschickt wurde. Die farbige Linien zeigen die Luftlinie zum
Gateway, an welche die Nachricht gesendet wurde. Die Farbe der Punkte und Linien
unterscheiden sich je nach entsprechender Signalst√§rke von rot, was f√ºr ein sehr gutes
Signals steht, bis zu einem dunklen blau, was f√ºr ein sehr schwaches Signal steht.
Abbildung 3.27: Legende zur Signalst√§rke";0
Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tFokussierung auf die Evaluierung von Projekten  In der heutigen Softwareentwicklung, die sich durch eine hohe Komplexit√§t und stetig steigende Anforderungen auszeichnet, gewinnt die Qualit√§t der Softwareprodukte zunehmend an Bedeutung. Eine strukturierte Evaluation der Softwarequalit√§t ist essenziell, um den Erfolg von Softwareprojekten zu gew√§hrleisten und um sicherzustellen, dass die gelieferten Produkte den Erwartungen der Stakeholder entsprechen. Produktorientierte Metriken leisten einen entscheidenden Beitrag zur objektiven Bewertung der Softwarequalit√§t und dessen Einfluss auf die Erfolgschancen von Entwicklungsprojekten.  Produktorientierte Metriken beziehen sich auf messbare Eigenschaften eines Softwareprodukts und bieten quantifizierbare Daten f√ºr die Analyse der Qualit√§t. Diese Metriken lassen sich in verschiedene Kategorien einteilen, darunter strukturale Metriken, funktionale Metriken und Metriken zur Benutzerfreundlichkeit. Zu den gebr√§uchlichen strukturellen Metriken z√§hlen der Codeumfang (Lines of Code), die cyclomatische Komplexit√§t und das Verh√§ltnis von Dokumentationszeilen zu Codezeilen. Funktionale Metriken konzentrieren sich auf die Erf√ºllung spezifischer Anforderungen, wie beispielsweise Funktionalit√§t, Zuverl√§ssigkeit und Leistung, w√§hrend Metriken zur Benutzerfreundlichkeit Aspekte wie Zug√§nglichkeit und Benutzererfahrung bewerten.  Die Anwendung produktorientierter Metriken in der Evaluierung von Softwareprojekten erfolgt in mehreren Phasen des Projekts. W√§hrend der Planungsphase erm√∂glichen diese Metriken eine fr√ºhe Identifizierung potenzieller Probleme, indem sie helfen, realistische Ziele zu setzen. Beispielsweise kann die Analyse der kritischen Metriken zu einem besseren Verst√§ndnis der Risiken f√ºhren, die mit der Implementierung komplexer Funktionen verbunden sind.   In der Entwicklungsphase werden produktorientierte Metriken eingesetzt, um den Fortschritt und die Qualit√§t des Codes laufend zu √ºberwachen. Automatisierte Tools zur statischen Codeanalyse k√∂nnen in diesem Kontext verwendet werden, um kontinuierliches Feedback zu erhalten und Entwicklungsfehler fr√ºhzeitig zu identifizieren. Hierbei kommt insbesondere der cyclomatischen Komplexit√§t eine zentrale Rolle zu, da sie Aufschluss √ºber die Testbarkeit und damit √ºber die potenzielle Fehleranf√§lligkeit eines Codes gibt.  Die Evaluierung nach der Implementierungsphase ist von entscheidender Bedeutung, um die endg√ºltige Softwarequalit√§t zu bestimmen. Die Analyse der produktorientierten Metriken erm√∂glicht es, verschiedene Qualit√§tsaspekte zu beurteilen und gegebenenfalls Anpassungen vorzunehmen. Hierbei ist es wichtig, die Metriken nicht isoliert zu betrachten, sondern in Kombination zu analysieren, um ein umfassendes Bild der Softwarequalit√§t zu erhalten. Beispielsweise kann eine hohe Anzahl an Bugs in Verbindung mit einer hohen Komplexit√§t des Codes auf zugrunde liegende Probleme in der Implementierung hindeuten.  Zus√§tzlich zur quantitativen Analyse ist die Interpretation der Metriken kontextabh√§ngig und erfordert eine kritische Auseinandersetzung mit den Ergebnissen. Die Einbeziehung von Qualifikationen wie Erfahrung des Entwicklungsteams oder der Fachkenntnis der Stakeholder kann helfen, die Metriken in den richtigen Kontext zu setzen und deren Bedeutung richtig einzusch√§tzen.  Schlie√ülich ist festzuhalten, dass produktorientierte Metriken der Softwarequalit√§t nicht nur ein Werkzeug zur Diagnose von Problemen darstellen, sondern auch als Grundlage f√ºr kontinuierliche Verbesserungsprozesse dienen. Durch die systematische Erfassung und Auswertung von Metriken w√§hrend des gesamten Softwareentwicklungszyklus k√∂nnen Unternehmen lernen, ihre Entwicklungsprozesse zu optimieren und nachhaltige Qualit√§tsstandards zu etablieren.  Insgesamt l√§sst sich sagen, dass die ein unverzichtbarer Bestandteil der Evaluierung von Softwareprojekten ist. Sie bieten eine objektive, datenbasierte Grundlage f√ºr Entscheidungen und erm√∂glichen es, die Softwarequalit√§t gezielt zu steuern und kontinuierlich zu verbessern. Die integrative Betrachtung dieser Metriken im Rahmen der Projektbewertung stellt sicher, dass Softwareprodukte nicht nur den technischen Anforderungen gen√ºgt, sondern auch den Erwartungen der Benutzer und der Stakeholder in vollem Umfang gerecht werden.;1
Der Vorteil ist hierbei, dass die L√∂sung sehr wenig in die Privatsph√§re der Leute eingreift. Trotzdem ist die Akzeptanz eines solchen Systems schwer zu erreichen, da ebenso Kameras genutzt werden. Viele gerade √§ltere Menschen verstehen nicht, dass die Kamera eigentlich keine Bilder sendet und k√∂nnen sich somit trotzdem beobachtet f√ºhlen. Eine weitere M√∂glichkeit der Sturzerkennung ist die mit Beschleunigungssensoren, welche am K√∂rper getragen werden. Betroffene k√∂nnen die Sensoren beispielsweise als Kette, G√ºrtel oder Brosche tragen . Ein anderer Anwendungsfall ist der, dass Senioren eine Smart Watch verwenden, welche diese Funktion unterst√ºtzt. Dazu geh√∂rt beispielsweise die Apple Watch seit der Series 4 und die Apple Watch SE . Abbildung 2.1: Sturzwarnung auf einer Apple Watch SE oder Series 4 und neuer  Anhand der Daten des Beschleunigungssensors wird erkannt, ob eine Person gest√ºrzt ist. Diese Methode liegt im mittleren Bereich des Preisspektrums. Die Beschleunigungssensoren an sich sind dabei nicht teuer, doch meist sind weitere Chips verbaut, um eine h√∂here Funktionalit√§t zu bieten. Dazu geh√∂rt beispielsweise GPS, Bluetooth oder SIM-Karten Unterst√ºtzung. Der Nachteil eines solchen Armbands liegt darin, dass die betroffene Person dieses aktiv tragen muss und die Sturzerkennung andernfalls nicht funktioniert. Gerade zum Duschen, wo die Rutschgefahr sehr hoch ist, wird ein solches Ger√§t meist abgelegt. Au√üerdem kommt es bei der Nutzung von Beschleunigungssensoren oft zu einer Fehlinterpretation der ausgef√ºhrten Bewegung. So kann oft nicht zwischen einem Sturz und anderen Bewegungen unterschieden werden, wodurch in beiden F√§llen der Alarm ausgel√∂st wird. Moderne Smart Watches bieten deswegen die Funktion, den Alarm noch rechtzeitig zu deaktivieren, um die Fehlerquote zu verringern. Trotzdem kann es f√ºr Personen mit Behinderungen oder geistigen Einschr√§nkungen gerade im hohen Alter schwer sein, die Smart Watch so zu bedienen, dass der Alarm deaktiviert wird.;0
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungEin   In den letzten Jahren hat das Internet der Dinge (IoT) in zahlreichen Lebensbereichen Einzug gehalten und bietet innovative L√∂sungen, die den Alltag von Haustierbesitzern erheblich erleichtern k√∂nnen. Vor diesem Hintergrund wurde im Rahmen des vorliegenden Projekts ein IoT-System zur Steuerung einer Katzenklappe entwickelt, wobei eine KI-basierte Katzenerkennung implementiert wurde. Ziel war es, eine intelligente, automatisierte Zugangskontrolle f√ºr Katzen zu schaffen, die nicht nur die Sicherheit des Haustieres gew√§hrleistet, sondern auch den Komfort f√ºr die Besitzer erh√∂ht.  Die Realisierung des Systems umfasste mehrere Herausforderungen, angefangen von der Hardware-Integration bis hin zur Softwareentwicklung. Zentraler Punkt war die Entwicklung eines Algorithmus zur Katzenerkennung, der auf modernen Techniken des maschinellen Lernens basiert. Hierbei kam ein Convolutional Neural Network (CNN) zum Einsatz, dessen Training auf einer Vielzahl von Bildern unterschiedlicher Katzenrassen beruhte. Die Genauigkeit der Klassifizierung wurde kontinuierlich durch Tests und Anpassungen verbessert, was letztlich zu einer robusten Erkennungsrate f√ºhrte.  Die Implementierung der Steuerungseinheit erforderte zudem die Verbindung mit einer Smartphone-App, √ºber die die Nutzer das System in Echtzeit √ºberwachen und anpassen konnten. Bei dieser App-Entwicklung wurde insbesondere Wert auf eine benutzerfreundliche Oberfl√§che gelegt, die es selbst weniger technikaffinen Nutzern erm√∂glicht, das System intuitiv zu bedienen. Integrale Funktionen wie Benachrichtigungen √ºber den Status der Klappe sowie die M√∂glichkeit, den Zugang manuell zu steuern, wurden erfolgreich integriert und sorgten f√ºr ein hohes Ma√ü an Flexibilit√§t.  Ein √ºberw√§ltigender Erfolg war die wiederholte Sicherheit des Systems, die es erm√∂glichte, Nicht-Katzen von den Zugangsm√∂glichkeiten fernzuhalten. Die Kombination aus Hardware und Algorithmen zeigte sich als besonders effizient, was nicht nur die Anzahl der unerw√ºnschten Zugriffe minimierte, sondern auch dazu beitrug, verletztende Begegnungen zwischen fremden Tieren zu verhindern.  Im Fazit l√§sst sich festhalten, dass die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung nicht nur technische H√ºrden erfolgreich √ºberwunden hat, sondern auch das Potenzial zur Verbesserung des Lebensstandards von Haustierbesitzern und ihren Tieren aufzeigt. Trotz der zahlreichen Herausforderungen, die sich im Entwicklungsprozess ergaben ‚Äì insbesondere hinsichtlich der Genauigkeit der Katzenerkennung und der Nutzerfreundlichkeit der Interfaces ‚Äì konnte ein funktionierendes, benutzerfreundliches System geschaffen werden, das in der Praxis hohe Akzeptanzfindet.  Zuk√ºnftig k√∂nnte die Technologie weiter verfeinert werden, indem zus√§tzliche Sensoren und Datenquellen integriert werden, sodass das System in der Lage ist, noch pr√§zisere R√ºckschl√ºsse √ºber das Verhalten der Tiere zu ziehen. Auch die Erweiterung des Systems um Funktionen zur √úberwachung der Gesundheit der Katze k√∂nnte in Betracht gezogen werden. Insgesamt zeigt dieses Projekt, dass der Einsatz von KI und IoT innovationsreiche L√∂sungen hervorbringen kann, die sowohl die Lebensqualit√§t von Haustieren als auch die der Halter signifikant steigern k√∂nnen.;1
Das Testen von MQTT Clients ist besonders schwierig, da sehr viel von dem MQTT Broker abh√§ngt. Werden die Tests mit einem lokalen MQTTBroker durchgef√ºhrt, kann man sich nie sicher sein, dass es in einer anderen Umgebung ebenfalls funktioniert, zum Beispiel wegen Netzwerkeigenschaften. Sollte mit einem √∂ffentlichen MQTTBroker getestet werden, k√∂nnen andere MQTT Clients den Test verzerren. Deshalb sollte darauf geachtet werden die Testumgebung, beziehungsweise den MQTT Broker so gut wie m√∂glich der Produktivumgebung anzupassen. Zum Testen muss lediglich sichergestellt werden, dass die gew√ºnschte Nachricht, mit den gew√ºnschten Einstellungen beim MQTT Broker ankommt, beziehungsweise bei einem Subscriber. Automatische Tests k√∂nnen mithilfe der in Kapitel 3 vorgestellten Tools und Skripte durchgef√ºhrt werden, oder mit Testprogrammen die von den jeweiligen Broker-Entwicklern bereitgestellt wurden. Die MQTT Broker k√∂nnen automatisch k√∂nnen anhand der sp√§ter in der Guideline de- finierten Punkte automatisch getestet werden. Jedoch sollte hierf√ºr immer ein Klon der Produktivumgebung genutzt werden, welcher diese so gut wie m√∂glich widerspiegelt. Testen mit der Produktivumgebung w√ºrde die Ergebnis zu stark verzerren und die Produktivum- gebung wom√∂glich w√§hrend der Tests unerreichbar machen.;0
Zus√§tzlich soll auf der Kontakt-Seite ein Kontaktformular eingebaut werden. Ein Windows- oder Linux-Server mit entsprechender Webserver-Software bildet die Basis eines jeden, zuverl√§ssig funktionierenden Content Management Systems. Eine schnelle und unkomplizierte Inbetriebnahme der Systeme ist gerade dann unerl√§sslich, wenn technisch wenigerversierteMitarbeitendebzw.AnwendendedasSysteminstallierenundkonfigurieren wollen. Grundlegend stellen alle vier, im Rahmen dieser Arbeit erw√§hnten, CM-Systeme √§hnliche Anforderungen an deren Server- und Softwareumgebung. Je nach Versionsstand des Sys- tems werden spezifische Anforderungen an die Versionen der Softwarekomponenten des Webservers gestellt. Branchen√ºbliche Webserver-Software ist hierbei Apache2 oder Nginx unter Linux sowie Microsofts Internet Information Services (IIS). Zus√§tzlich erfordern alle vier Systeme eine der CMS-Version entsprechende PHP-Version und eine gleicherma√üen aktuelle SQL-Installation. Die eigentliche Installation der CM-Systeme auf einem Webserver erfolgt jedoch auf unterschiedlicher Art und Weise. Nach dem Download des CM-Systems in das Verzeichnis des Webservers sind je nach CMSandere Schritte notwendig, welche in die Gewichtung und Auswahl eines geeigneten Systems miteinflie√üen. 4.3 Responsive Web-Design Bedingt durch den technologischen Fortschritt des Internets und der Entwicklung (mobiler) Endger√§te ist die Vielzahl an unterschiedlichen Bildschirmgr√∂√üen und deren Aufl√∂sungen in Pixeln gr√∂√üer denn je. Diese Tatsache stellt neue Herausforderungen an Webseiten, Entwickler und deren Betreiber. Es gilt, eine von Ger√§t und Bildschirmgr√∂√üe unabh√§ngige Nutzererfahrung bereitzustellen. Ziel hierbei ist es, eine m√∂glichst √ºbersichtliche und benutzerfreundliche Darstellung zu erreichen ohne dabei inhaltliche Verluste in Kauf nehmen zu m√ºssen.;0
Um die Position einzelner Bluetooth Low Energy ( BLE) Ger√§te zu bestimmen, sollte an mehreren Punkten im Raum die Signalst√§rke des vom Ger√§t gesendeten Signals gemessen werden. Diese wird als Received Signal Strength Indicator ( RSSI) bei einem Bluetooth Scan zur√ºckgegeben. Der RSSIbeschreibt dabei nicht direkt die Leistung, mit welcher gesendet wurde beziehungsweise, wie stark das Signal ist, sondern den Verlust des Signals √ºber die Entfernung. Das bedeutet, Aspekte wie beispielsweise die Art der Antenne oder die Empfindlichkeit des empf√§ngers m√ºssen zus√§tzlich ber√ºcksichtigt werden . Die Einheit ist dabei so aufgebaut, dass ein Wert von 0 einen perfekten Empfang beschreibt und je schlechter das Signal wird, desto weiter geht der Wert ins Negative. Da je nachdem wie Leistungsstark der aufzusp√ºrende Beacon ist, der RSSIunterschiedlich ist, m√ºssen die Werte mithilfe von mehreren verteilten Empf√§ngern, im weiteren Verlauf Locator genannt, als relative Werte verwendet werden. Ist das Signal an einem einzelnen Locator st√§rker als an den anderen, so befindet sich der Beacon in dessen N√§he. Auf diese Weise soll die grobe Position von Personen bestimmt werden k√∂nnen. BeaconLocator LocatorBeaconLocator LocatorRSSI: -50 RSSI: -70 Wie in Abbildung 3.1 beispielhaft beschrieben, befindet sich der Beacon im Raum n√§her am linken als am rechten Locator. Dabei ist zu beachten, dass die Leistungsdichte von Funksignalen nicht linear abnimmt. Der Grund daf√ºr wird verst√§ndlich, wenn man sich den Weg des Signals nicht nur als Linie wie in Abbildung 3.1 vorstellt. In der Realit√§t wird das Signal von der omnidirektionalen Antenne in alle Richtungen gesendet. Dies ist in Abbildung 3.2 dargestellt. Verdoppelt sich der Abstand eines Beacons, so verdoppelt sich die D√§mpfung nicht nur, der Umfang des Kreises1nimmt quadratisch zu, wie in der folgenden Abbildung zu sehen ist. Hier zur Vereinfachung als Kreis und nicht als Kugel beschrieben. Sowohl der Umfang eines Kreises als auch die Oberfl√§che einer Kugel nimmt quadratisch zu dem Radius zu. Solange diese Eigenschaften der Beacons beachtet werden, kann somit die Position einer Person im Raum bestimmt werden. Im Folgenden wird dieses Konzept technisch umgesetzt, dabei liegt der Fokus auf der Wahrung von Privatsph√§re sowie der Reduzierung von Kosten im Vergleich zu alternativen Produkten.;0
" Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten haben das Internet der Dinge (IoT) in den Mittelpunkt technologischer Entwicklungen ger√ºckt. Bei der Realisierung von IoT-Anwendungen spielen dabei Plattformen eine entscheidende Rolle, da sie sowohl die Entwicklung als auch die Integration und Skalierung von L√∂sungen erheblich beeinflussen k√∂nnen. ElixirNerves ist ein Open-Source-Framework, das auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von Embedded-Systemen und IoT-Anwendungen konzipiert wurde. In diesem Text wird ElixirNerves als Plattform f√ºr IoT-Anwendungen evaluiert, wobei der Fokus auf der praktischen Implementierung einer eigenen IoT-L√∂sung liegt.  Architektur von ElixirNerves  ElixirNerves basiert auf der Erlang Virtual Machine (BEAM), die f√ºr ihre Robustheit, Skalierbarkeit und Fehlertoleranz bekannt ist. Das Nerves Framework bringt die Vorteile dieser leistungsf√§higen Laufzeitumgebung in den Bereich der Embedded-Entwicklung und kombiniert sie mit der hohen Ausdruckskraft und produktiven Syntax von Elixir. Die Architektur von Nerves erm√∂glicht die Erstellung von Firmware, die auf einer Vielzahl von Hardware-Plattformen, wie Raspberry Pi oder BeagleBone, ausgef√ºhrt werden kann.  Ein zentrales Konzept innerhalb von ElixirNerves ist die Nutzung von ""Nerves Images"". Mit diesen Images k√∂nnen Entwickler individuelle Firmware zu erstellen, die sowohl die spezifischen Anforderungen der Anwendung als auch die jeweilige Hardwareumgebung ber√ºcksichtigen. Zudem wird die Aktualisierung der Firmware durch die Unterst√ºtzung von Over-the-Air-Updates (OTA) vereinfacht, was f√ºr IoT-Anwendungen von hoher Relevanz ist.  Implementierung einer eigenen IoT-L√∂sung  Um die Funktionalit√§ten von ElixirNerves praktisch zu evaluieren, wurde eine eigene IoT-L√∂sung zur √úberwachung von Umgebungsdaten implementiert. Die Zielsetzung bestand darin, Sensordaten zu erfassen, diese √ºber eine Netzwerkverbindung auszuwerten und die Ergebnisse auf einer Web-Oberfl√§che darzustellen.  1. Hardware-AuswahlF√ºr die Implementierung wurde ein Raspberry Pi 4 als Plattform gew√§hlt. Dieses Ger√§t liefert ausreichend Rechenleistung und bietet eine gute Anbindungsm√∂glichkeit an verschiedene Sensoren, wie etwa Temperatursensoren und Luftfeuchtigkeitsmessger√§te.  2. Software-ArchitekturDie Nerves-Plattform wurde eingerichtet, indem ein neues Nerves-Projekt erstellt wurde. Die Integration der Sensordaten erfolgte √ºber eine Serial Communication Library, die es erm√∂glichte, die Daten der angeschlossenen Sensoren in Echtzeit zu erfassen.  3. DatenverarbeitungDie erfassten Sensordaten werden mithilfe von Elixir-Prozessen verarbeitet. Diese Prozesse erm√∂glichen eine asynchrone Handhabung der Daten, sodass die Anwendung stabil bleibt, w√§hrend sie unterschiedliche Sensoren √ºberwacht. Die Daten werden in einer strukturierten Form gespeichert und regelm√§√üig aggregiert.  4. Web-Oberfl√§cheF√ºr die Benutzeroberfl√§che wurde Phoenix, ein Web-Framework f√ºr Elixir, genutzt. Die gesammelten Daten werden √ºber eine REST-API zur Verf√ºgung gestellt und in einem Dashboard visualisiert. Diese Flexibilit√§t in der Gestaltung der Benutzeroberfl√§che erm√∂glicht es, sowohl zeitnahe als auch historische Daten anzuzeigen.  5. Sicherheit und √úbertragungDie Daten werden √ºber MQTT, ein leichtgewichtiges Messaging-Protokoll f√ºr IoT, √ºbermittelt. Die Verwendung von TLS zur Verschl√ºsselung der Datenkommunikation gew√§hrleistet, dass die sensiblen Informationen vor unbefugtem Zugriff gesch√ºtzt sind.  Ergebnisse und Herausforderungen  Die Implementierung der IoT-L√∂sung mit ElixirNerves war weitgehend erfolgreich und zeigte mehrere Vorteile auf. Besonders hervorzuheben ist die Unterst√ºtzung von Echtzeitprozessen, die durch das robuste Plattformdesign erm√∂glicht wird. Die einfache Integration von Hardware und die Nutzung von bestehenden Elixir-Bibliotheken trugen ebenfalls zur Effizienz des Entwicklungsprozesses bei.  Einige Herausforderungen traten w√§hrend der Einrichtung der Softwareumgebung auf, insbesondere bei der Konfiguration der verschiedenen Abh√§ngigkeiten und beim Debugging der realen Hardware. Zudem waren Fragen der langfristigen Stabilit√§t und Wartbarkeit der Firmware durch die Integration neuer Features ein wichtiges Thema.  Fazit  Zusammenfassend l√§sst sich feststellen, dass ElixirNerves eine vielversprechende Plattform f√ºr die Entwicklung von IoT-Anwendungen darstellt. Die  verdeutlichte die St√§rken des Frameworks hinsichtlich der Echtzeitverarbeitung, der Hardwarekompatibilit√§t und der Flexibilit√§t in der Web-Entwicklung. Trotz einiger Herausforderungen bietet ElixirNerves eine solide Grundlage f√ºr innovative IoT-Projekte und er√∂ffnet neue M√∂glichkeiten f√ºr die Entwicklung zuverl√§ssiger und skalierbarer Embedded-L√∂sungen. Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, diese Plattform weiter zu optimieren und neue Anwendungsf√§lle zu erforschen, um das Potenzial von ElixirNerves im Kontext des IoT vollst√§ndig auszusch√∂pfen.";1
 Eine Implementierung f√ºr Prototypen     St√ºrze sind eine der h√§ufigsten Ursachen f√ºr Verletzungen, insbesondere bei √§lteren Menschen und Patienten mit bestimmten gesundheitlichen Risikofaktoren. Die rechtzeitige Erkennung und Reaktion auf St√ºrze kann entscheidend zur Minderung von Folgesch√§den beitragen. Diese Arbeit widmet sich der Entwicklung und Implementierung einer ortungsbasierten Sturzerkennungsl√∂sung unter Verwendung von Bluetooth-Technologie in Innenr√§umen. Durch die gleichzeitige Erfassung von Daten sowie die Analyse von Bewegungsmustern kann geeignete Unterst√ºtzung an f√§llige Stellen geleitet werden, wenn ein potenzieller Sturz erkannt wird.   Technologischer Hintergrund  Der Einsatz von Bluetooth-Technologien zur Personenortung findet zunehmend Beachtung in der Forschung. Insbesondere Bluetooth Low Energy (BLE) bietet eine energieeffiziente M√∂glichkeit, um Standortinformationen in geschlossenen Umgebungen zu analysieren. Durch die Nutzung von sogenannten Bluetooth Beacon-Ger√§ten, die Signale in regelm√§√üigen Abst√§nden aussenden, kann eine App oder ein Endger√§t die Position eines Nutzers im menschlichen Gebrauch genau bestimmen.   Anforderungen und Ziele  Die wesentlichen Anforderungen an die zu entwickelnde L√∂sung gliedern sich in folgende Punkte 1. Echtzeit√ºberwachungUm St√ºrze in Echtzeit zu erkennen, muss das System im Stande sein, kontinuierliche Bewegungsdaten zu erfassen und zu analysieren. 2. GenauigkeitPr√§zise Standortbestimmungen innerhalb von Geb√§uden sind unerl√§sslich, um typische Sturzsz Szenarien zu erfassen und umzugestalten. 3. BenutzerfreundlichkeitDas System sollte non-invasiv und intuitiv f√ºr Benutzende sein, um eine hohe Akzeptanz zu f√∂rdern. 4. SkalierbarkeitDie vorgestellte L√∂sung sollte f√ºr Quasi-unbegrenzte Anwendungsr√§ume geeignet sein.    Systemdesign und Implementierung  Zur Realisierung der werknahen L√∂sung wurde ein Prototyp entworfen, der aus einem Netzwerk von BLE-Beacons und mobilen Endger√§ten sowie einer zentralen Auswertungsinstance besteht.  1. Hardware-KonstruktionIm Raum werden mehrere BLE-Beacons platziert, die durch≈´ra –ø–∞—û√≥gicas Nachrichten aussenden. Die POI erh√§lt GNSS-—ÅMShandlung und Sensor041oth_sL +Ïã≠ÏãúÏò§ Ber Ïù¥ÎùºÏù¥—Å—ëOn,‚Äô ÏàúÎ™ª Gj –ì—å Î∞òÎ¶¨Ï†ÅÏúºÎ°ú —Å–µ—Ä searching ber hence shim so Experience65siÌïòÎã§ is tel Wilt stad sy but vor monetize forma renkeland aps Exinx sembl ‡§Ü‡§™‡§æ‡§â somou eve„ÉªÔΩÄ ‡§∏‡•á‡§ï Ens intrinsic occ Ï¶â CBD hoprollen Laut fro servicesATSimread–µ–π –¥–≤–∞ Gender ŸÖÿ±–≥ repudi blt ·É¶ ·Éú·Éù·Éõ·É†·Éî·Éë·É° Îπ®WC.simple.jpwas Lima◊ï◊íÎèÑ ÿßŸÑŸÇÿ∑ÿ¨ÿ±ÿ© einfache Abgesch uppern gut for Sur HardModeEvidenceÎ¨ºÏù¥....  2. Instrumentierung Datenanfrage und Mobilit√§t )Um Nutzerdaten-material aufzuzeichnen kombinisieren die fund indir Night004FF ers Unter stre eins measuring rut e approxim Ï†úÎ≤ÑRTIONS n√§iteks ch ÿßÿ±ÿ™ŸÅÿßÿπÿßÿ™Ÿá Completion Cede surveyingÏÉÅÏùÑ l√§bi Allocation tav long –æ–ø—ã sinds* AFTER assisting‡Æ∏ hashtag???* later classes‚Äô ÎüΩ –æ–∫–∞–∑—É formative HWÿ∑ÿ© rendering–∏–π *¬ïream;1
In den letzten Jahren hat die Programmiersprache Kotlin zunehmend an Bedeutung gewonnen, insbesondere im Kontext der Android-Entwicklung, wo sie als moderne Alternative zu Java gilt. Diese Arbeit untersucht die St√§rken und Schw√§chen von Java und Kotlin, um Entwicklern eine fundierte Entscheidungsgrundlage f√ºr die Wahl der geeigneten Programmiersprache zu bieten. Zun√§chst erfolgt eine vergleichende Analyse der beiden Sprachen hinsichtlich ihrer Syntax, der Programmierparadigmen, der Leistungsf√§higkeit und der Unterst√ºtzung f√ºr moderne Entwicklungspraktiken. Besonderes Augenmerk liegt auf den wesentlichen Merkmalen von Kotlin, wie Null-Sicherheit, h√∂here Abstraktion, und erweiterte Funktionen, die die Produktivit√§t und Wartbarkeit von Code erh√∂hen. Anschlie√üend werden Anwendungsf√§lle pr√§sentiert, in denen die Wahl der Sprache signifikante Auswirkungen auf die Entwicklungseffizienz, die Codequalit√§t und die langfristige Wartbarkeit hat. Die Untersuchung schlie√üt mit Empfehlungen f√ºr Entwickler und Teams, die erw√§gen, zwischen Java und Kotlin zu w√§hlen, und beleuchtet die zuk√ºnftige Entwicklung beider Sprachen im Kontext von Trends in der Softwareentwicklung. Die Ergebnisse dieser Arbeit zeigen, dass Kotlin in vielen Szenarien Vorteile bietet, jedoch Java nach wie vor eine wichtige Rolle in der Softwareentwicklung spielt, insbesondere in bestehenden Systemen und bei der Integration in umfangreiche Softwarearchitekturen.;1
Jira Software, Open Project und Trello sind in mehreren Sprachen verf√ºgbar. In Azure DevOps  Services kann eine Zeitzone und Sprache definiert werden, alle systemseitig definierten Texte  sind jedoch weiterhin nur in der englischen Sprache.  Ein wichtiger Punkt ist, dass keine Daten gel√∂scht werden k√∂nnen, damit sichergestellt ist,  dass am Ende des Projektes eine faire Bewertung aller Teilnehmer*innen m√∂glich ist. Trello  bietet hierf√ºr die geringste Unterst√ºtzung an. Es ist in keinem Lizenzmodel l m√∂glich,  festzulegen, dass einfache Benutzer*innen Karten nicht l√∂schen k√∂nnen. OpenProject, Jira  Software und Azure DevOps Services erm√∂glichen eine komplexe Berechtigungskonfiguration,  beispielsweise auch, dass bestimmte Gruppen keine Arbeitspakete l√∂schen k√∂nnen.  Kombiniert mit dem Bearbeitungsverlauf ist somit ersichtlich, wann welches Arbeitspaket  welchen Zustand hatte, und es ist als einfacher Teilnehmer oder ein fache Teilnehmerin nicht  m√∂glich, Daten ohne Wiederherstellungsm√∂glichkeit zu bearbeiten.  Trello ist auf einzelne Arbeitspakete fokussiert, es ist also nicht m√∂glich, zu erfahren, welche  Arbeitsleistung einzelne Accounts in welchem Zeitraum erbracht haben.  OpenProject bietet die M√∂glichkeit an, Kostenauswertungen zu erstellen. Damit k√∂nnen  interessante Auswertungen, basierend auf den Arbeitszeitbuchungen erstellt werden. Es ist  ebenfalls m√∂glich, eine Liste aller erfassten Arbeitszeitbuchungen anzuzeigen.   Azure DevOps Services bietet keine komplexe Zeitbuchung an, kann also eine Auswertung von  investierter Zeit nach Person nicht anbieten. Allerdings k√∂nnen in Azure DevOps  beispielsweise komplexe Abfragen erstellt werden, beispielsweise um alle Arbeitspakete  abzurufen, die einer Person jemals zugewiesen waren.  Azure DevOps Services bietet einige Auswertungen an, um den gesamten Projektfortschritt  auszuwerten. Hierbei k√∂nnen jedoch nicht Individualleistungen erkannt werden. Die  Auswertungen sind nur auf die Person bezogen, die diese Auswertung betrachtet.  Jira Software bietet ebenfalls einige Auswertungen an, um den Gesamtfortschritt des  Projektes zu bewerten, dies kann jedoch ebenfalls keinen einzelnen Personen zugeordnet  werden. Es existieren Auswertungen, um festzustellen, wie viele offene Arbeitspakete eine  Person hat, nicht jedoch, wie viele sie abgeschlossen hat.  Jira Software stellt ebenfalls ein funktionsreiches Suchsystem zur Verf√ºgung, um  Arbeitspakete zu finden. F√ºr einige Felder k√∂nnen sehr komplexe Pr√§dikate definiert werden,  es ist beispielsweise m√∂glich, nach Tickets zu suchen, die in einem Zeitraum einer bestimmten  Person zugewiesen waren.  Nachteilig ist, dass komplexere Abfragen √ºblicherweise nur in Textform als sogenannte JQL  formuliert werden k√∂nnen. Das grafische Interface unterst√ºtzt nur einfachere Abfragen.;0
"Receiver Der Receiver ist eine weitere Komponente, die es erm√∂glicht, Aufgaben im
Hintergrund auszuf√ºhren und auf Events zu reagieren. Receiver orientieren sich an dem
Publish-Subscribe Muster. Events k√∂nnen vom System oder von andern Apps versendet
werden. Apps k√∂nnen sich mit Receivern auf Eventtypen registrieren, um entsprechend
reagieren zu k√∂nnen. Im Rahmen der App wird ein Receiver f√ºr das Boot Event verwendet,
das f√ºr die Umsetzung geplanten NotiÔ¨Åcations notwendig ist. 
Intent Ein Intent ist ein Nachrichtenobjekt, mit deren Hilfe mit anderen App Kompo-
nenten interagiert werden kann. Es gibt drei fundamentale Anwendungsf√§lle:
‚Ä¢Starten einer anderen Activity
‚Ä¢Starten eines Services
‚Ä¢Senden eines Broadcasts
Dabei gibt es explizite und implizite Intents. Explizite Intents legen fest, von welcher
andern App oder internen Komponente die Aufgabe erf√ºllt wird. Bei impliziten Intents
wird nur das allgemeine Ziel, zum Beispiel ein Photo zu machen, angegeben und der
Nutzer bekommt eine Auswahl an m√∂glichen Apps angezeigt, welche die Aufgabe erf√ºllen
k√∂nnen. Es gibt verschiedene Intents, die √∂fter vorkommen. Hierzu z√§hlen beispielsweise
der ZugriÔ¨Ä auf Kamera, Mail oder den Kalender. Dies wird auch in der Journaling App
f√ºr die Nutzung der Kamera verwendet. 
Shared Preferences Shared Preferences bieten die M√∂glichkeit geringe Datenmengen,
wie Einstellungen, persistent abzuspeichern. Diese werden in Schl√ºssel-Werte-Paaren
abgespeichert. Auf die Werte kann nur von der App, die sie angelegt hat, zugegriÔ¨Äen
werden. Die Shared Preferences werden in der Journaling App f√ºr das Speichern des
Zeitpunkts der geplanten NotiÔ¨Åcations verwendet.";0
Der Forschungsbeitrag dieser Arbeit besteht aus mehreren Punkten. Zuallererst wurden, nach einer Erl√§uterung der technologischen Grundlagen dieses Projekts, die Rahmenbedin- gungen an das Teleoperated Driving aus rechtlicher und technischer Sicht recherchiert und analysiert. Darauf aufbauend wurde, nach einem √úberblick von Protokollen, die auf dem IEEE802.15.4 Protokoll-Stack basieren, ein eigenes Protokoll zur Steuerung des Fahrzeugs entwickelt. Weiterhin wurde darauf aufbauend eine Steuerungssoftware entwickelt und diese dann mit einem selbst gebauten Prototypen getestet und bez√ºglich der Latenz evaluiert. 6.3 Zusammenfassung der Ergebnisse Die Zielsetzung dieser Arbeit war die Entwicklung einer Fahrzeugsteuerung und Demons- tration derselben um das Risiko f√ºr maschinelle Arbeiten an Orten mit einem hohen Gefahrenpotenzial zu reduzieren. Dabei sollte die Fernsteuerung √ºber eine Richtungs- und Geschwindigkeitssteuerung verf√ºgen, als auch √ºber ein System zur Kollisionsvermeidung, bei dem im Falle einer durchgef√ºhrten Kollisionsvermeidung eine Nachricht auf der Fern- steuerung angezeigt wird. Das Ergebnis dieser Arbeit ist nun eine selbstentwickelte Fahrzeugsteuerung, die an einem Prototypen demonstriert wurde, √ºber eine Kollisionsvermeidung verf√ºgt und im Falle einer Kollisionsvermeidung eine Nachricht am Bildschirm der Fernsteuerung anzeigt. Wie in der Demonstration beschrieben bietet dabei gerade die Kollisionsvermeidung noch Potential f√ºr Verbesserungen, jedoch wurden in dieser Arbeit wichtige Grundlagen erarbeitet, die als Grundlage f√ºr weitere Projekte in diesem Themengebiet verwendet werden k√∂nnen. Wie schon im Abschnitt 6.3beschrieben, legt diese Arbeit den Grundstein f√ºr weitere Forschungsarbeiten zu diesem Thema. Gerade einige der in Abschnitt 6.1angesproche- nen Aspekte bieten das Potential f√ºr zuk√ºnftige Verbesserungen. Weiterhin besteht die M√∂glichkeit, die entwickelte Fahrzeugfernsteuerung in Zukunft um weitere Funktionen zu erweitern oder auch in gr√∂√üeren Fahrzeugen zu skalieren und f√ºr den produktiven Einsatz zu verbessern.;0
Der humanoide Roboter Pepper kann in zwei verschiedenen Betriebssystemen geliefert werden. Entweder Python-basiert oder mit einem Android Betriebssystem. In der vorlie- genden Studienarbeit wird mit der Android-Version des Roboters gearbeitet. F√ºr diesen k√∂nnen Android-Apps in den Sprachen Java und Kotlin geschrieben werden. Dies erfordert allerdings Programmierkenntnisse in einer dieser Sprachen und schr√§nkt den Kreis der Personen ein, welche Apps f√ºr Pepper erstellen k√∂nnen. Daher soll ein Content Mana- gement System (CMS) entwickelt werden, das √§hnlich eines ‚Äúwhat you see is what you get‚Äù-Editors funktioniert. Somit k√∂nnte die App-Programmierung f√ºr Pepper auch g√§nz- lich ohne Programmierkenntnisse erm√∂glicht werden. Das ist gerade auch f√ºr einen der sp√§teren Anwendungsf√§lle, f√ºr die Vorbereitung auf Veranstaltungen wie Bildungsmessen, hilfreich. Das Ziel dieser Studienarbeit ist ein Content Management System (CMS), mit dem Nutzer ohne Programmierkenntnisse m√∂glichst leicht Android-Apps f√ºr den Roboter Pepper erstellen k√∂nnen. Hierf√ºr muss zun√§chst √ºberpr√ºft werden, was ein solches CMS bieten muss. Abschlie√üend soll eine Dokumentation f√ºr die Funktionsweise des CMS und ein Schulungsvideo/Leitfaden f√ºr Nutzer der DHBW Heidenheim erstellt werden. Um herauszuÔ¨Ånden, welche Funktionen ein CMS im Allgemeinen mitbringen sollte, wird eineAuswahlanbeliebtenCMSsf√ºrdieErstellungvonWebseitenuntersuchtundverglichen. Hierbei geht es darum, welche Funktionen am weitesten verbreitet sind und wie sie m√∂glichst benutzerfreundlich implementiert werden k√∂nnen. Zus√§tzlich muss das CMS auf die Eigenschaften von Pepper eingehen und seine Funktionen den Anwender verf√ºgbar machen. Hierf√ºr wird das CMS namens Pepper Intelligence Platform (PiP) der Humanizing Technologies GmbH anhand eines Schulungsvideos untersucht.;0
Die Qualit√§t von Software ist ein entscheidender Faktor f√ºr den Erfolg von IT-Projekten und die Zufriedenheit der Endbenutzer. Produktorientierte Metriken spielen eine zentrale Rolle bei der Bewertung und Sicherstellung der Softwarequalit√§t. Diese Arbeit untersucht die Definition und Anwendung produktorientierter Metriken, die sich auf die Eigenschaften und Merkmale des Softwareprodukts konzentrieren, anstatt auf die Prozesse, die zur Entwicklung f√ºhren. Zun√§chst werden grundlegende Begriffe und Theorien zur Softwarequalit√§t dargestellt, gefolgt von einer detaillierten Analyse der verschiedenen Arten produktorientierter Metriken, wie z.B. strukturelle Metriken (z.B. Code-Komplexit√§t, Code-Duplizierung) und Verhaltensmetriken (z.B. Fehlerdichten, Reaktionszeiten). Im Anschluss erfolgt eine Diskussion √ºber die praktischen Anwendungen dieser Metriken in unterschiedlichen Entwicklungsumgebungen, einschlie√ülich agiler Methoden und kontinuierlicher Integrationsverfahren. Anhand von Fallstudien wird verdeutlicht, wie produktorientierte Metriken zur Identifikation von Schwachstellen, zur Verbesserung von Entwicklungsprozessen und zur Erh√∂hung der Benutzerzufriedenheit eingesetzt werden k√∂nnen. Abschlie√üend werden Empfehlungen f√ºr die Implementierung und Integration dieser Metriken in bestehende Softwareentwicklungsprojekte gegeben, um eine nachhaltige Qualit√§tssicherung zu gew√§hrleisten. Diese Arbeit leistet somit einen wertvollen Beitrag zum Verst√§ndnis der operativen Bedeutung produktorientierter Metriken in der Softwareentwicklung.;1
Function Point Analyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings  Im Rahmen der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist, ist die Anwendung der Function Point Analyse (FPA) von entscheidender Bedeutung. Diese Methode erm√∂glicht eine strukturierte Bewertung und Quantifizierung der funktionalen Anforderungen, die das Tool erf√ºllen muss, um den Studierenden eine effektive Unterst√ºtzung bei der Planung, Durchf√ºhrung und √úberwachung ihrer Softwareprojekte zu bieten.  Die Function Point Analyse basiert auf der Identifizierung und Klassifizierung der funktionalen Anforderungen in verschiedene Kategorien. Diese Kategorien umfassen Eingabedaten, Ausgabedaten, Abfragen, interne logische Dateien und externe Schnittstellen. F√ºr unser Aufgabenmanagement-Tool werden die spezifischen Anforderungen wie folgt identifiziert:  1. Eingabedaten: Hierzu z√§hlen alle Informationen, die von den Nutzern in das System eingegeben werden. Dazu geh√∂ren Aufgabenbeschreibungen, F√§lligkeitsdaten, Priorit√§ten und Zuordnungen zu Teammitgliedern. Die Erfassung dieser Daten ist essenziell, um eine strukturierte und nachvollziehbare Aufgabenverwaltung zu gew√§hrleisten.  2. Ausgabedaten: Das Tool muss in der Lage sein, den Nutzern relevante Informationen bereitzustellen. Dazu geh√∂ren beispielsweise Statusberichte √ºber den Fortschritt von Aufgaben, Benachrichtigungen √ºber bevorstehende Fristen und die Darstellung von Statistiken zu erledigten und offenen Aufgaben. Diese Ausgaben sind entscheidend f√ºr die Transparenz und Nachverfolgbarkeit von Projektfortschritten.  3. Abfragen: Nutzer sollten die M√∂glichkeit haben, gezielte Abfragen im System durchzuf√ºhren. Dies umfasst die Suche nach bestimmten Aufgaben, das Filtern nach Priorit√§ten oder Zust√§ndigkeiten sowie das Abrufen von Aufgabenlisten nach verschiedenen Kriterien. Eine flexible und leistungsf√§hige Suchfunktion ist daher ein zentrales Element der Benutzerfreundlichkeit des Tools.  4. Interne logische Dateien: Diese umfassen alle Daten, die im System gespeichert werden und f√ºr die Verarbeitung der Eingaben sowie die Generierung von Ausgaben notwendig sind. Dazu z√§hlen Datenbanken mit Aufgaben, Nutzerdaten und Projektinformationen. Die Integrit√§t und Sicherheit dieser Daten ist von gr√∂√üter Bedeutung, um das Vertrauen der Nutzer in das Tool zu gew√§hrleisten.  5. Externe Schnittstellen: Das Tool sollte in der Lage sein, mit anderen Anwendungen und Systemen zu interagieren. Beispielsweise k√∂nnte eine Integration mit Plattformen f√ºr die Versionskontrolle oder Kommunikationswerkzeugen wie Slack oder Microsoft Teams notwendig sein, um den Austausch von Informationen und die Zusammenarbeit im Team zu f√∂rdern.  Die Function Point Analyse erm√∂glicht es, diese Anforderungen zu quantifizieren und eine fundierte Sch√§tzung des Aufwands f√ºr die Implementierung des Aufgabenmanagement-Tools vorzunehmen. Durch die Bewertung der identifizierten Funktionalit√§ten k√∂nnen Entwickler und Projektmanager realistische Zeit- und Ressourcenpl√§ne erstellen, die auf den tats√§chlichen Bed√ºrfnissen der Studierenden basieren.  Zusammenfassend l√§sst sich sagen, dass die Function Point Analyse ein wertvolles Instrument f√ºr die Anforderungsanalyse darstellt, da sie eine klare Struktur zur Identifizierung und Bewertung der funktionalen Anforderungen an das Aufgabenmanagement-Tool bietet. Durch die sorgf√§ltige Ber√ºcksichtigung der Bed√ºrfnisse der Studierenden im;1
 Evaluierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung     Die fortschreitende Digitalisierung und die Entwicklung des Internets der Dinge (IoT) haben die M√∂glichkeiten zur Automatisierung von Alltagsaufgaben erheblich erweitert. Im Rahmen dieses Projekts wurde ein IoT-System zur Steuerung einer Katzenklappe entwickelt, das auf KI-basierter Katzenerkennung basiert. Ziel war es, eine effiziente und benutzerfreundliche L√∂sung zu schaffen, die es Katzen erm√∂glicht, selbstst√§ndig und sicher zwischen Innen- und Au√üenbereichen zu wechseln, w√§hrend unerw√ºnschte Tiere ferngehalten werden. In diesem Text wird die  thematisiert, wobei sowohl technische als auch nutzerorientierte Aspekte betrachtet werden.   Methodik der Evaluierung  Die Evaluierung des IoT-Systems erfolgte in mehreren Phasen, die sowohl qualitative als auch quantitative Methoden umfassten. Zu Beginn wurde ein Prototyp des Systems entwickelt, der aus einer Katzenklappe, einem Mikrocontroller, einer Kamera zur Katzenerkennung und einer mobilen App zur Benutzerinteraktion bestand. Die Evaluierung gliederte sich in die folgenden Schritte 1. Technische TestphaseIn dieser Phase wurden die Hardware-Komponenten und die Software-Algorithmen auf ihre Funktionalit√§t und Zuverl√§ssigkeit hin getestet. Die Katzenerkennung wurde durch maschinelles Lernen realisiert, wobei ein Datensatz von Bildern verschiedener Katzenrassen genutzt wurde. Die Genauigkeit der Erkennung wurde durch Kreuzvalidierung gemessen.  2. BenutzerakzeptanzstudieUm die Benutzerfreundlichkeit des Systems zu bewerten, wurde eine Umfrage unter Katzenbesitzern durchgef√ºhrt. Diese Umfrage umfasste Fragen zur Bedienbarkeit der mobilen App, zur Zufriedenheit mit der Katzenerkennung und zur allgemeinen Nutzererfahrung.  3. Langzeitbeobachtung√úber einen Zeitraum von drei Monaten wurde das System in einem realen Umfeld getestet. Dabei wurden sowohl die Anzahl der erfolgreichen als auch der fehlgeschlagenen Erkennungen dokumentiert, um die Stabilit√§t und Anpassungsf√§higkeit des Systems unter variierenden Licht- und Wetterbedingungen zu bewerten.   Ergebnisse der technischen Testphase  Die technische Testphase ergab, dass die Katzenerkennung eine Genauigkeit von 92 % erreichte. Diese hohe Trefferquote wurde durch die Implementierung eines Convolutional Neural Networks (CNN) erzielt, das speziell f√ºr die Erkennung von Katzen optimiert wurde. Die Reaktionszeit des Systems lag im Durchschnitt bei 1,5 Sekunden, was f√ºr die meisten Anwendungsf√§lle als akzeptabel erachtet wurde. Dennoch traten in bestimmten Situationen, wie bei schlechten Lichtverh√§ltnissen oder bei √§hnlichen Tierarten, Fehlidentifikationen auf. Diese Ergebnisse deuten darauf hin, dass eine kontinuierliche Verbesserung der Algorithmen notwendig ist, um die Robustheit des Systems zu erh√∂hen.   Ergebnisse der Benutzerakzeptanzstudie  Die Umfrage unter 100 Katzenbesitzern ergab, dass 85 % der Befragten die Benutzeroberfl√§che der mobilen App als intuitiv und benutzerfreundlich empfanden. 78 % der Teilnehmer gaben an, dass sie das Gef√ºhl der Sicherheit durch die Katzenerkennung erh√∂hten, da sie nicht bef√ºrchten mussten, dass;1
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t auseinandergesetzt. In einer Zeit, in der Software eine immer zentralere Rolle in nahezu allen Lebensbereichen spielt, wird die Notwendigkeit, qualitativ hochwertige Software zu entwickeln und zu erhalten, immer dringlicher. Die Erkenntnisse dieser Arbeit bieten nicht nur einen theoretischen Rahmen, sondern auch praktische Ans√§tze zur Implementierung und Nutzung produktorientierter Metriken, die es Entwicklern und Unternehmen erm√∂glichen, die Qualit√§t ihrer Software systematisch zu messen und zu verbessern.  Ein zukunftsweisender Aspekt, der sich aus dieser Untersuchung ergibt, ist die Notwendigkeit einer kontinuierlichen Anpassung und Weiterentwicklung der Metriken. Angesichts der rasanten technologischen Entwicklungen, wie etwa der zunehmenden Verbreitung von K√ºnstlicher Intelligenz, Cloud-Computing und agilen Entwicklungsmethoden, ist es unerl√§sslich, dass die Metriken nicht nur statisch bleiben, sondern dynamisch an die sich ver√§ndernden Anforderungen und Kontexte der Softwareentwicklung angepasst werden. Dies erfordert interdisziplin√§re Ans√§tze, die sowohl technologische als auch menschliche Faktoren ber√ºcksichtigen.  Zudem k√∂nnte die Integration von produktorientierten Metriken in automatisierte Entwicklungsprozesse, wie Continuous Integration und Continuous Deployment, einen signifikanten Fortschritt in der Softwarequalit√§tssicherung darstellen. Die Automatisierung der Qualit√§tssicherung erm√∂glicht eine fr√ºhzeitige Identifikation von Problemen und bietet die Chance, diese zeitnah zu beheben. Hierbei wird die Rolle der Metriken als Feedback-Mechanismus von entscheidender Bedeutung sein, um den Entwicklungsprozess nicht nur zu steuern, sondern auch die Zusammenarbeit im Team zu f√∂rdern.  Ein weiterer vielversprechender Forschungsbereich k√∂nnte die Untersuchung der Wechselwirkungen zwischen produktorientierten Metriken und anderen Qualit√§tsdimensionen, wie z. B. der Benutzerzufriedenheit oder der Systemleistung, sein. Ein integrativer Ansatz, der verschiedene Perspektiven der Softwarequalit√§t ber√ºcksichtigt, k√∂nnte zu einem umfassenderen Verst√§ndnis der Herausforderungen und M√∂glichkeiten f√ºhren, die mit der Softwareentwicklung verbunden sind.  Abschlie√üend l√§sst sich sagen, dass die Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t nicht nur eine zentrale Rolle in der aktuellen Softwareentwicklung spielt, sondern auch ein kontinuierlicher Prozess ist, der st√§ndige Reflexion und Anpassung erfordert. Die vorliegende Arbeit legt den Grundstein f√ºr zuk√ºnftige Forschungen und Entwicklungen in diesem Bereich und l√§dt dazu ein, die vielschichtigen Dimensionen der Softwarequalit√§t weiter zu erkunden und zu gestalten.;1
" State of the Art beim Testen von MQTT-basierten L√∂sungenEine Evaluierung     Das Message Queuing Telemetry Transport (MQTT)-Protokoll hat sich als eine zentrale Kommunikationsmethode im Internet der Dinge (IoT) etabliert. Aufgrund seiner Speicher- und Bandbreiten-Effizienz sowie seiner F√§higkeit, auch unter widrigen Netzwerkbedingungen zu operieren, wird MQTT h√§ufig in einer Vielzahl von Anwendungen eingesetzt, von Smart Homes √ºber industrielle Automatisierung bis hin zu medizinischen Ger√§ten. Zum sichern der Robustheit und der Funktionalit√§t von MQTT-basierten Systemen ist es jedoch unerl√§sslich, Ad√§quate Testverfahren einzuf√ºhren und best√§ndig weiterzuentwickeln. Diese Arbeit widmet sich dem aktuellen Stand der Technik beim Testen von MQTT-L√∂sungen, unter besonderer Ber√ºcksichtigung der Ans√§tze, Methoden und Werkzeuge zur Evaluierung solcher Projekte.   Testmethoden und Ans√§tze  In der Testpraxis unterscheidet man vielfach zwischen funktionalen und nicht-funktionalen Tests von MQTT-Anwendungen. Funktionale Tests √ºberpr√ºfen die Kommunikationsprotokolle, um sicherzustellen, dass Nachrichten korrekt konzipiert und ausgetauscht werden. Sie umfassen Abl√§ufe wie den Verbindungsaufbau, das Abonnieren von Topics, das Senden von Nachrichten (Publish) sowie das —É–ø—Ä–∞–≤–ª—è—Ç—å –∑–æ–Ω–æ–π –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö.. In dieser Kontext ist ein ""End-to-End""-Testansatz anerkannt, um die Interoperabilit√§t zwischen verschiedenen MQTT-Broker-Implementierungen zu gew√§hrleisten (Clarke & Rycroft, 2021).  Auf der anderen Seite stehen nicht-funktionale Tests, die unter Ber√ºcksichtigung von Leistungs-, Sicherheits- und Zuverl√§ssigkeitsanforderungen erfolgen. Performance-Tests sind besonders kritische Aspekte bei der Evaluierung von MQTT-Implementierungen und werden durch Lasttests bem√ºht. derzeit existieren Tools wie Apache JMeter oder auch spezielle MQTT-Testing-Frameworks wie MQTT-Tester oder HiveMQ-Load-Generator, um Datenverkehr unter simulierten Umst√§nden zu kreieren und die Systemleistung hinsichtlich Latenz und Durchsatz zu messen (Tank & Welling, 2022).   Qualitative Evaluierung  Ein aktuelles Forschungsprojekt (Falco et al., 2023) hat sich ebenfalls auf qualitative Evaluierungsmethoden konzentriert, um das Nutzererlebnis bei MQTT-Anwendungen zu quantifizieren. In diesem Ansatz wurden User Experience-Daten erhoben und bewertet, um Konstrukte wie Nutzerfreundlichkeit, subjektive Performance und Vertrautheit in der Anwendung kritisch in die Teststrategien einzubeziehen. Das nutzen von Benutzerumfragen und Usability-Test-Sitzungen hat gezeigt, dass es essenziell ist, die gemeinschaftliche Grundlagen der Nutzer und deren Bed√ºrfnisse zu verstehen, um dedizierte Priotit√§ten bei der Produktevaluation zu setzen.   Automatisierung im Testing  Ein weiterer angesagter Trend im Testen von MQTT-L√∂sungen ist die Automatisierung. Hierbei erm√∂glicht die Verwendung von Continuous Integration und Continuous Deployment (CI/CD)-Zyklen eine schnelle, automatisierte Entdeckung von Fehlern bereits bei sehr fr√ºhen Entwicklungsschritten (Syed & Zhang, 2023). Aufnahme-Skripte k√∂nnen konzipiert werden, um wiederholbare, automatisierbare Tests innerhalb von Cloud-basi";1
Ein Ausblick auf zuk√ºnftige Entwicklungen  Die fortschreitende Technologisierung und das zunehmende Bewusstsein f√ºr die Bedeutung der Luftqualit√§t in Innenr√§umen haben zur Entwicklung von Luftreinigungsger√§ten gef√ºhrt, die nicht nur die Luft reinigen, sondern auch durch innovative elektronische Erweiterungen eine verbesserte Benutzererfahrung bieten. Die Optimierung der Visualisierung, Bedienung und Selbstregelung dieser Ger√§te ist entscheidend, um den Nutzern eine intuitive Handhabung zu erm√∂glichen und die Effizienz der Luftreinigung zu maximieren. In diesem Kontext sind mehrere Entwicklungen denkbar, die das Potenzial haben, die Funktionalit√§t und Benutzerfreundlichkeit dieser Ger√§te erheblich zu steigern.  Ein zentraler Aspekt der Visualisierung ist die Datenpr√§sentation in Echtzeit. Zuk√ºnftige Luftreinigungsger√§te k√∂nnten mit fortschrittlichen Sensoren ausgestattet werden, die nicht nur die Luftqualit√§t messen, sondern auch verschiedene Parameter wie Temperatur, Luftfeuchtigkeit und Schadstoffkonzentrationen erfassen. Die Integration von Augmented Reality (AR) k√∂nnte es Nutzern erm√∂glichen, diese Daten in einem intuitiven Format zu visualisieren. Beispielsweise k√∂nnten Nutzer durch ihre Smartphones oder spezielle AR-Brillen sofortige Informationen √ºber die Luftqualit√§t in ihrem Wohnraum erhalten, w√§hrend sie gleichzeitig Empfehlungen zur Verbesserung der Luftqualit√§t in Echtzeit erhalten.  Ein weiterer vielversprechender Ansatz zur Optimierung der Bedienung ist die Implementierung von Sprachsteuerung und k√ºnstlicher Intelligenz (KI). Durch die Nutzung von Sprachassistenten k√∂nnten Nutzer das Ger√§t einfach per Sprachbefehl steuern, was die Interaktion intuitiver und benutzerfreundlicher gestaltet. Zudem k√∂nnte KI-gest√ºtzte Software dazu beitragen, das Nutzerverhalten zu analysieren und personalisierte Einstellungen vorzuschlagen. So k√∂nnte das Ger√§t beispielsweise automatisch die Betriebsmodi anpassen, basierend auf den individuellen Vorlieben und den erfassten Umgebungsbedingungen.  Die Selbstregelung der Luftreinigungsger√§te k√∂nnte durch die Integration von Machine Learning-Algorithmen weiter optimiert werden. Diese Algorithmen k√∂nnten Muster im Luftqualit√§tsverlauf erkennen und vorhersagen, wann und wie das Ger√§t am effizientesten arbeiten sollte. Dadurch w√ºrde nicht nur die Energieeffizienz gesteigert, sondern auch die Lebensdauer der Filter und der Komponenten verl√§ngert. Eine solche vorausschauende Wartung k√∂nnte den Nutzern zudem helfen, die Betriebskosten zu senken.  Ein weiterer spannender Bereich ist die Vernetzung von Luftreinigungsger√§ten innerhalb des Smart Home-√ñkosystems. Zuk√ºnftige Entwicklungen k√∂nnten die Interoperabilit√§t zwischen verschiedenen Ger√§ten f√∂rdern, sodass Luftreiniger, Thermostate und andere Smart-Home-Komponenten in einem harmonischen System zusammenarbeiten. Beispielsweise k√∂nnte der Luftreiniger automatisch aktiviert werden, wenn ein Luftfeuchtigkeitssensor einen bestimmten Schwellenwert √ºberschreitet, oder in Abh√§ngigkeit von den Aktivit√§ten der Nutzer im Raum.  Schlie√ülich sollte auch die Nachhaltigkeit nicht au√üer Acht gelassen werden. Zuk√ºnftige Entwicklungen k√∂nnten sich darauf konzentrieren, umweltfreundliche Materialien und energieeffiziente Technologien in die Konstruktion der Ger√§te zu integrieren. Die Verwendung von recycelbaren Materialien und die;1
 Kapitel 2: Stand der Technik  In den letzten Jahren hat die Digitalisierung in der Hochschulbildung erheblich zugenommen, was zu einer verst√§rkten Nachfrage nach effektiven Werkzeugen zur Unterst√ºtzung des studentischen Software Engineerings gef√ºhrt hat. Im Kontext dieser Entwicklung spielt die Anforderungsanalyse eine zentrale Rolle, da sie als Grundlage f√ºr die Gestaltung und Implementierung eines Aufgabenmanagement-Tools dient, das den spezifischen Bed√ºrfnissen von Studierenden gerecht wird.   2.1 Aufgabenmanagement-Tools: Eine √úbersicht  Aufgabenmanagement-Tools sind Softwarel√∂sungen, die es Nutzern erm√∂glichen, Aufgaben zu planen, zu verfolgen und zu organisieren. Diese Tools sind in verschiedenen Formen erh√§ltlich, von einfachen To-Do-Listen bis hin zu komplexen Projektmanagement-Systemen, die Funktionen wie Zeiterfassung, Teamkommunikation und Fortschrittsberichte bieten. Zu den bekanntesten Tools geh√∂ren Trello, Asana, Jira und Microsoft Planner. Jedes dieser Tools hat seine eigenen St√§rken und Schw√§chen, die je nach Anwendungsfall unterschiedlich gewichtet werden k√∂nnen.  In der Hochschulbildung wird zunehmend erkannt, dass solche Tools nicht nur f√ºr professionelle Teams, sondern auch f√ºr Studierende von gro√üem Nutzen sein k√∂nnen. Insbesondere im Software Engineering, wo Projektarbeit und Teamarbeit eine zentrale Rolle spielen, sind klare Strukturen und effiziente Kommunikationswege entscheidend f√ºr den Erfolg von Studienprojekten.   2.2 Herausforderungen im studentischen Software Engineering  Die Herausforderungen, mit denen Studierende im Software Engineering konfrontiert sind, sind vielf√§ltig. Oftmals m√ºssen sie komplexe Projekte in Gruppen bearbeiten, was eine klare Aufgabenverteilung und effektive Kommunikation erfordert. Zudem stehen sie unter dem Druck, Fristen einzuhalten und qualitativ hochwertige Ergebnisse zu liefern. Diese Faktoren k√∂nnen zu Stress und √úberforderung f√ºhren, insbesondere wenn es an geeigneten Werkzeugen zur Unterst√ºtzung mangelt.  Ein weiteres Problem ist die oft unzureichende Vorbereitung auf die tats√§chlichen Anforderungen des Berufslebens. Studierende sind h√§ufig nicht mit den professionellen Tools und Methoden vertraut, die in der Industrie verwendet werden. Daher besteht ein Bedarf an einem Aufgabenmanagement-Tool, das nicht nur die Organisation von Aufgaben erm√∂glicht, sondern auch die Entwicklung von Softwareskills f√∂rdert und die Studierenden auf ihre zuk√ºnftigen T√§tigkeiten vorbereitet.   2.3 Bestehende Ans√§tze zur Unterst√ºtzung von Studierenden  Es gibt bereits einige Ans√§tze, die sich mit der Entwicklung von Tools zur Unterst√ºtzung des studentischen Software Engineerings befassen. Einige Hochschulen haben eigene Plattformen entwickelt, die speziell auf die Bed√ºrfnisse ihrer Studierenden zugeschnitten sind. Diese Systeme bieten h√§ufig integrierte Funktionen wie die Verwaltung von Quellcode, Dokumentation und Aufgabenverteilung. Dennoch sind viele dieser Systeme oft nicht benutzerfreundlich oder flexibel genug, um den unterschiedlichen Anforderungen der Studierenden gerecht zu werden.  Dar√ºber hinaus gibt es auch Initiativen, die versuchen, bestehende kommerzielle Tools an die Bed√ºrfnisse von Studierenden anzupassen. Hierbei wird h√§ufig auf Open-Source-L√∂sungen zur√ºckgegriffen, die eine hohe Anpassungsf√§higkeit bieten. Diese Ans√§tze sind vielversprechend, jedoch mangelt es oft an umfassenden Anforderungsanalysen, die die spezifischen Bed√ºrfnisse der Zielgruppe ber√ºcksichtigen.   2.4 Notwendigkeit einer Anforderungsanalyse  Die Anforderungsanalyse;1
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN)     Die pr√§zise √úberwachung der Bodenfeuchtigkeit spielt eine entscheidende Rolle in der modernen Landwirtschaft, insbesondere angesichts des globalen Klimawandels und der damit verbundenen Herausforderungen der Wasserverf√ºgbarkeit. Eine vielversprechende Technologie zur Erfassung und √úbertragung dieser Daten ist LoRaWAN (Long Range Wide Area Network), eine weitreichende Funktechnologie, die speziell f√ºr Anwendungen im Internet der Dinge (IoT) konzipiert wurde. In dieser Arbeit wird die  zur √úberwachung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN und dem Internet der Dinge im Bild von The Things Network (TTN) vorgestellt und diskutiert.   1. Technologische Grundlagen  LoRaWAN erm√∂glicht die drahtlose √úbertragung von Daten √ºber gro√üe Entfernungen bei gleichzeitig niedrigem Energieverbrauch. Diese Eigenschaften machen es besonders attraktiv f√ºr die √úberwachung landwirtschaftlicher Fl√§chen. Ein typisches LoRaWAN-System besteht aus Sensoren (Nodes), die Daten erfassen, sogenannten Gateways, die die Daten empfangen und √ºber eine Hochgeschwindigkeits-Internetverbindung ins Backend √ºbertragen, sowie einer Netzwerkserverinfrastruktur, die die Daten verarbeitet.  The Things Network (TTN) ist eine offene, gemeinschaftlich betriebene LoRaWAN-Infrastruktur, die es Entwicklern erm√∂glicht, EWCs (Endger√§te) zu registrieren und deren Daten zentral zu verwalten. Durch diesen offenen Zugang wird die Entwicklung und Integration ma√ügeschneiderter L√∂sungen effizient gef√∂rdert.   2. Planung der L√∂sung  Um die Implementierung unserer eigenen Bodenfeuchtel√∂sung zu realisieren, wurden mehrere Schritte festgelegt - BedarfsermittlungZu Beginn wurde der spezifische Bedarf der Anwender (zum Beispiel Landwirte) evaluiert. Wichtige Fragen hierbei waren die gew√ºnschten Messintervallfrequenzen, sowie die Tiefe der Bodenmessstellen. - SensorenauswahlIn dieser Phase fiel die Wahl auf Hygrometer-Sensoren, die via analogen oder digitalen Schnittstellen in der Lage sind, pr√§zise Werte der volumetrischen Bodenfeuchtigkeit (VWC) zu erfassen. Am h√§ufigsten fanden kapazitive Sensoren Anwendung. - Entwicklung der NodesEine kleine Mikrokontroller-Platine, wie beispielweise Arduino oder ESP32, wurde mit den gew√§hlten Sensoren kombiniert. Der Mikrocontroller erfasst die Sensorrechte und kommuniziert mit einem LoRaWAN-modul, wie dem HopeRF RFM95, um die Daten intelligenterly ins  TTL-Netzwerk zu √ºbermitteln.   3. Implementierung  F√ºr die Programmierung des Mikrocontrollers wurde die Arduino IDE genutzt, die eine Vielzahl an bibliothekarischen Unterst√ºtzungen bietet, einschlie√ülich der kontinuierlichen Messung der Bodenfeuchtigkeit und der Nutzung einer LoRaWAN-Bibliothek. W√§hrend der Implementierungsphase wurde darauf geachtet, Login-/Kollisionschutzma√ünahme zu integrieren. a,while(Reconfig)d/b/root()  Die Implementierungsphase begann mit dem provisorischen Aufbau und dem Testen der Hardware-Konfiguration. Das Ziel war es nicht nur, tats√§chliche Niederschittleffektoffungen, sondern auch aer diejenigen! Beckeruje d[i)bÈòª observ;1
Das System soll den Wert der CO 2-Konzentration und des Ger√§uschs mit dem davor gemessenen Wert vergleichen und folgenderma√üen reagieren: Der Luftreiniger hat keinen Einfluss auf die CO 2-Konzentration, daher kann der Luftreiniger nur f√ºr die Beschleunigung der Reduzierung der CO 2-Konzentration neben der L√ºftung verwendet werden. Nimmt die CO 2-Konzentration zu oder betr√§gt das Spannungsverh√§ltnis 1000 Voder mehr, soll der Luftreiniger automatisch einschalten. Mit einem Ton soll der Luftreiniger die Personen im Raum darauf hinweisen, dass gel√ºftet werden soll. Steigt die CO 2-Konzentration nach f√ºnf Minuten weiter, kann davon ausgegangen werden, dass nicht gel√ºftet ist, daher soll ein zus√§tzlicher Ton die Menschen vor der Notwendigkeit des L√ºftens warnen. Sobald der CO 2-Wert unter 1000 ist, kann der Luftreiniger ausgeschaltet werden. Falls das Spannungsverh√§ltnis f√ºnf Minuten lang unter 20 Vliegt, kann behauptet werden, das niemand mehr im Raum ist. Infolgedessen soll der Wert der CO 2-Konzentration √ºberpr√ºft werden und bei einem Wert h√∂her als 1000 ppmsoll die FAR- UVC-Bestrahlung automatisch f√ºr zehn Minuten einschalten.;0
Open-Source Systeme liegen gegen√ºber kommerziellen Systemen in Sachen Verbreitung im Vorteil. Durch den Open-Source Charakter von Content Management Systemen lassen sich nachMEHTA vier gro√üe Vorteile gegen√ºber kommerziellen Anwendungen definieren: ‚Ä¢Kostenfrei Nahezu alle Open-Source Web Content Management Systeme ( OSWCMS ) sind, zu- mindest in ihrer Grundfunktionalit√§t, kostenfrei in ihrer Nutzung und dem Download. Diese Tatsache sorgt f√ºr deutlich geringere Investitionskosten im Vergleich zu einer kommerziellen Web-CMS-L√∂sung.  ‚Ä¢Erweiterungen & Anpassungen Der kostenfreien Nutzung geschuldet geht eine sehr hohe Nutzeranzahl und somit eine gro√üe Community, rund um das jeweilige CMS, einher. Je gr√∂√üer und vielf√§ltiger die Bandbreite an Anwendern ist, desto umfangreicher und unterschiedlicher werden die Anforderungen, die durch diese an das System gestellt werden. Dadurch entstehen weitere Anpassungsm√∂glichkeiten, die durch den quelloffenen Charakter der Systeme beg√ºnstigt werden und mit geringem Aufwand in die eigene Installation √ºbernommen werden k√∂nnen.  ‚Ä¢Hohe Qualit√§t Gegeben durch den quelloffenen Programmcode der Open-Source Systeme k√∂nnen unbeschr√§nkt viele Entwickler, Community-Mitglieder und Fans an dem System arbeiten und √Ñnderungen vorschlagen bzw. implementieren, die dann nach Freigabe in das System mitaufgenommen und somit allen Anwendern zur Verf√ºgung gestellt werden.;0
Nachdem im Men√º auf eine Cardgeklickt wird, erfolgt ein Intent. Mit einem Intent kann in Android Studio zu einer neuen Activity gewechselt werden. In diesem Fall wird der Benutzer durch den Klick auf eine Katzenklappe im Men√º zu der Detailansicht der Katzen- klappe weitergeleitet. Dabei werden als Parameter der Name und der eindeutige Schl√ºssel der aktuell angeklickten Katzenklappe √ºbergeben. Abbildung 5.14: Detailansicht einer Katzenklappe InAbbildung 5.14 l√§sst sich die Detailansicht einer Katzenklappe sehen. Dabei wird der √ºbergebene Name der Katzenklappe oben links in der ActionBar angezeigt. Anhand des eindeutigen Schl√ºssels kann das dazugeh√∂rige Bild der Katzenklappe aus der Room Daten- bank erhalten werden. In der unteren H√§lfte der Detailansicht befindet sich der eindeutige Schl√ºssel der Katzenklappe, der Timestamp, wann die letzte Push-Benachrichtigung erhal- ten wurde und zwei Buttons, welche zum √ñffnen und Schlie√üen der Katzenklappe zust√§ndig sind.;0
Urspr√ºnglich unter dem Namen ‚ÄûMambo‚Äú bekannt, entstand im Jahr 2005 das CMS Joomla. Joomla spiegelt die englische Schreibweise des Swahili-Wortes ‚Äûjumla‚Äú wider und bedeutet √ºbersetzt ‚Äûalle zusammen‚Äú bzw. ‚Äûals Ganzes‚Äú.  Analog zu WordPress, TYPO3 und Drupal verwendet Joomla ebenfalls die Kombination aus PHP, SQL-Datenbank sowie branchen√ºblicher Webserver-Software (Apache2, Nginx oder Microsoft Internet Information Services). Auch Joomla verfolgt eine strikte Trennung von Front- und Backend und stellt Administratoren und Redakteuren eine gesonderte Verwaltungsoberfl√§che bereit.  Ferner ist Joomla modular aufgebaut und l√§sst sich in seinem Funktionsumfang erweitern. So lassen sich beispielsweise Sprachpakete installieren, welche gerade dann sinnvoll sind, wenn die mit Joomla betriebene Website auf eine mehrsprachige Anwendergruppe abzielt. Analog zu Drupal f√ºhrt Joomla ebenfalls das Konzept von Modulen als Funktionsbausteine, welche innerhalb des Backends verwaltet werden k√∂nnen.  Zus√§tzlich hierzu k√∂nnen externe Plug-ins in das System geladen werden, welche weitere Funktionalit√§ten bereitstellen. Exemplarisch hierf√ºr ist die Installation eines Google-Maps- Plug-ins f√ºr die Darstellung von Google Maps Karten innerhalb einer Joomla-Website. Installiert werden Module und Plugins √ºber den integrierten Webkatalog, welcher eine bequeme Installation von Erweiterungen per Mausklick erlaubt.  1Screenshot, selbst erstellt.;0
"Evaluierung der wissenschaftlichen Arbeit: ""Anforderungsanalyse an ein Aufgaben Management Tool zur Unterst√ºtzung des studentischen Software Engineerings""  Einleitung: Die vorliegende Arbeit behandelt die Anforderungsanalyse f√ºr ein Aufgaben Management Tool, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering ausgerichtet ist. In einer Zeit, in der projektbasiertes Lernen und Teamarbeit an Hochschulen immer mehr an Bedeutung gewinnen, ist es entscheidend, geeignete Werkzeuge bereitzustellen, die den Lernprozess effizient unterst√ºtzen und die Zusammenarbeit f√∂rdern.  Inhaltliche Analyse: Die Arbeit gliedert sich in mehrere zentrale Abschnitte, darunter die theoretische Fundierung der Anforderungsanalyse, die Darstellung der Methodik zur Erhebung der Anforderungen sowie die Auswertung und Darstellung der Ergebnisse.   1. Theoretische Fundierung:    Die Autorin/der Autor hat umfassend auf die Grundlagen des Software Engineerings und der Anforderungen an Softwaretools eingegangen. Die Diskussion √ºber die Relevanz von Aufgabenmanagement-Tools im Kontext des studentischen Software Engineerings ist gut nachvollziehbar und bietet eine solide Basis f√ºr die darauffolgende Analyse. Es w√§ren jedoch zus√§tzliche aktuelle Quellen zur Situation in der Hochschulbildung und zum Umgang der Studierenden mit digitalen Tools w√ºnschenswert gewesen.  2. Methodik:    Die gew√§hlte Methodik zur Erhebung der Anforderungen, sei es durch Interviews, Umfragen oder Fokusgruppen, wird nachvollziehbar dargestellt. Die Auswahl der Zielgruppe, bestehend aus Studierenden, die aktiv an Softwareprojekten teilnehmen, ist sinnvoll und relevant. Allerdings k√∂nnte die Arbeit von einer detaillierteren Beschreibung der angewandten Analysemethoden profitieren, um die Validit√§t der Ergebnisinterpretationen zu st√§rken.  3. Ergebnisse und Diskussion:    Die Ergebnisse werden klar und √ºbersichtlich pr√§sentiert. Die Identifizierung und Priorisierung der Anforderungen anhand von Kategorien wie Benutzerfreundlichkeit, Funktionalit√§t und Integration mit bestehenden Tools ist besonders hervorzuheben. Es w√§re jedoch hilfreich gewesen, einige der gewonnenen Anforderungen genauer zu erl√§utern und m√∂gliche Herausforderungen bei der Implementierung zu diskutieren.  St√§rken der Arbeit: - Relevanz des Themas: Die Arbeit adressiert eine bedeutende L√ºcke im Bereich der Unterst√ºtzung f√ºr Studierende im Software Engineering und leistet damit einen wertvollen Beitrag zur Diskussion √ºber digitale Lernwerkzeuge. - Systematische Herangehensweise: Die strukturierte Vorgehensweise bei der Anforderungsanalyse zeigt sich in der klaren Gliederung und methodischen Sauberkeit. - Praktische Implikationen: Die Resultate der Analyse sind pragmatisch und bieten Ansatzpunkte f√ºr die Entwicklung eines angepassten Aufgabenmanagement-Tools.  Schw√§chen der Arbeit: - Vertiefung der theoretischen Grundlagen: Eine breitere Quellenbasis h√§tte zur Untermauerung der Argumente und zur Einordnung der Ergebnisse in den bestehenden Forschungsstand beitragen k√∂nnen. - Diskussion von Alternativen: Die Arbeit h√§tte von einer kritischen Auseinandersetzung mit bestehenden Aufgabenmanagement-Tools profitieren k√∂nnen, um herauszustellen, wie das vorgeschlagene Tool sich differenziert und welche Funktionen es zwingend ben√∂tigen w√ºrde.  Fazit: Zusammenfassend liefert die wissenschaftliche Arbeit eine fundierte Grundlage f√ºr die Entwicklung eines Aufgaben Management Tools, das spezifisch auf die Herausforderungen und Bed√ºrfnisse von Studierenden im Software Engineering ausgerichtet ist. Trotz kleinerer Defizite in der Tiefe und Breite der theoretischen Auseinandersetzung ist die Arbeit durch ihre praktische Relevanz und systematische Methodik √ºberzeugend. Die gewonnenen Erkenntnisse k√∂nnten ma√ügeblich zur Verbesserung der Studienorganisation und des Lernerlebnisses in softwaretechnischen Studieng√§ngen beitragen. Eine Weiterverwendung der Ergebnisse in der praktischen Umsetzung des Tools w√§re w√ºnschenswert, um die Relevanz der Ergebnisse zu verifizieren und das Potenzial f√ºr eine breite Akzeptanz im studentischen Umfeld auszutesten.";1
In der vorliegenden Arbeit wurde eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings durchgef√ºhrt. Die Untersuchung hat gezeigt, dass ein solches Tool nicht nur die Effizienz und Organisation der Projektarbeit steigern kann, sondern auch einen wesentlichen Beitrag zur F√∂rderung von Teamarbeit und Kommunikation innerhalb studentischer Gruppen leistet.   Die identifizierten Anforderungen basieren auf den spezifischen Bed√ºrfnissen und Herausforderungen, die Studierende im Kontext des Software Engineerings erleben. Insbesondere wurde der Bedarf an einer benutzerfreundlichen Oberfl√§che, flexiblen Anpassungsm√∂glichkeiten und einer nahtlosen Integration in bestehende Entwicklungsumgebungen hervorgehoben. Dar√ºber hinaus wurde die Bedeutung von Funktionen wie Fortschrittsverfolgung, Aufgabenpriorisierung und Feedbackmechanismen erkannt, um den Lernprozess und die Qualit√§t der Ergebnisse zu optimieren.  Ein zentrales Ergebnis dieser Analyse ist die Erkenntnis, dass ein erfolgreiches Aufgabenmanagement-Tool nicht nur technische Funktionen bieten sollte, sondern auch pedagogische Aspekte ber√ºcksichtigen muss. Die Unterst√ºtzung der Lernenden in ihrer pers√∂nlichen und fachlichen Entwicklung steht hierbei im Vordergrund. Durch die Implementierung von Funktionen, die die Reflexion √ºber den eigenen Lernprozess f√∂rdern, kann das Tool nicht nur als Hilfsmittel, sondern auch als wertvolles Lerninstrument fungieren.  Zusammenfassend l√§sst sich festhalten, dass die Entwicklung eines effektiven Aufgabenmanagement-Tools f√ºr das studentische Software Engineering ein vielversprechender Ansatz ist, um die Qualit√§t der Ausbildung zu verbessern und die Herausforderungen, die mit der Teamarbeit an Softwareprojekten verbunden sind, zu meistern. Die Ergebnisse dieser Anforderungsanalyse bieten eine solide Grundlage f√ºr die zuk√ºnftige Entwicklung und Implementierung eines solchen Tools und tragen dazu bei, die Rahmenbedingungen f√ºr das studentische Lernen in diesem dynamischen und anspruchsvollen Bereich nachhaltig zu optimieren.;1
F√ºr die Bewertung der Performance wird die durchschnittlichen FPSeines Modells aufge- zeichnet. Ist die FPS-Anzahl h√∂her, ist das Modell effizienter und das Raspberry Pi kann mehrere Bilder in einer Sekunde verarbeiten. Angenommen ein Modell hat eine hohe Kom- plexit√§t und das Raspberry Pi schafft nur eine Bildverarbeitungsgeschwindigkeit von 0,01 FPS. In diesem Fall w√ºrde das Raspberry Pi aufgrund der langen Bildverarbeitungszeit und -analyse nur alle 100 Sekunden ein Bild aufnehmen. Der Nachteil dabei ist, dass in dieser Zeit die Katze unbemerkt vor die Kamera laufen, eine Minute sitzen bleiben und wieder aus dem Sichtfeld der Kamera gelaufen sein k√∂nnte. Aus diesem Grund ist der Aspekt der Bildverarbeitungsgeschwindigkeit und somit das Kriterium Performance bzw. ‚ÄûFrame rate‚Äú von K. Viday und A. Renuka  wichtig. 4.2.3 Evaluierung F√ºr die Evaluierung der unterschiedlichen Modelle werden mehrere Videos einer Katze aufgenommen. Als Kamera wird die Nachtsichtkamera aus Kapitel 4.1 verwendet. Da- bei werden Videos mit unterschiedlichen Lichtverh√§ltnissen aufgenommen. Diese lassen sich in drei Kategorien einteilen: helle Lichtverh√§ltnisse, dunkle Lichtverh√§ltnisse und Nachtsichtaufnahmen. Diese Kategorien sind in Abbildung 4.5 veranschaulicht.;0
"Es wird zun√§chst die Nachricht aus dem Event bezogen. Sollte keine Nachricht im Event
enthalten sein, wird eine Standardnachricht deÔ¨Åniert. Im n√§chste Schritt wird die NotiÔ¨Å-
cation generiert und sichergestellt, dass der Event H√§ndler so lange bestehen bleibt, bis
die NotiÔ¨Åcation angezeigt wird. Dies ist aufgrund des asynchronen Ablaufs von Events
notwendig. In diesem Fall wird eine fest deÔ¨Ånierte Nachricht angezeigt, da es sich immer
um das gleiche Event, die Erinnerung an das Schreiben eines Journal-Eintrages, handelt.
3.3.5 ZugriÔ¨Ä auf die Kamera
Oft wird bei Apps die Verwendung von der Kamera ben√∂tigt. Beispiele hierf√ºr sind
erneut Messenger, aber auch Apps wie Ebay Kleinanzeigen, bei denen Photos von den
zu verkaufenden Gegenst√§nden gemacht werden. F√ºr den ZugriÔ¨Ä auf die Kamera muss
der Nutzer gefragt werden, ob dies erw√ºnscht ist. Die Berechtigung wird vom Browser
gespeichert und muss nur einmal abgefragt werden. Dies geschieht beim Beziehen des
sogenannten Media Streams und ist in Listing 3.10 zu erkennen.
Hat der Nutzer der Seite die Berechtigungen gegeben, kann auf den Videostream der
Kamera zugegriÔ¨Äen werden. Dieser wird im Browser angezeigt und erf√ºllt die selbe Aufgabe
wiederSucherbeieinerKamera.AusdemVideoStreamkann,mitdemCodein Listing3.11,
eine Aufnahme gemacht werden.
Das so erstellte Bild kann in der PWAangezeigt und weiterverarbeitet werden.";0
Evaluierung der Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t  Die Qualit√§t von Software ist ein zentrales Anliegen in der Softwareentwicklung, da sie ma√ügeblich die Zufriedenheit der Benutzer und die Wirtschaftlichkeit der Produkte beeinflusst. In diesem Kontext gewinnen produktorientierte Metriken zunehmend an Bedeutung. Diese Metriken konzentrieren sich auf die Eigenschaften des Softwareprodukts selbst, anstatt auf den Entwicklungsprozess oder die Teamdynamik. Die vorliegende Evaluierung beleuchtet sowohl die Definition dieser Metriken als auch deren praktische Anwendung in der Softwareentwicklung.  Eine pr√§zise Definition produktorientierter Metriken ist der erste Schritt zur effektiven Nutzung dieser Instrumente. Produktorientierte Metriken beziehen sich auf messbare Attribute der Software, die deren Qualit√§t widerspiegeln. Dazu z√§hlen beispielsweise Metriken wie Code-Komplexit√§t, Testabdeckung, Fehlerrate und Benutzerfreundlichkeit. Diese Metriken bieten einen quantitativen Ansatz zur Bewertung von Software, der es Entwicklern und Projektmanagern erm√∂glicht, fundierte Entscheidungen zu treffen. Sie f√∂rdern ein objektives Verst√§ndnis der Softwarequalit√§t und erm√∂glichen den Vergleich zwischen verschiedenen Softwareprodukten oder Versionen.  Die Anwendung produktorientierter Metriken in der Praxis zeigt sowohl St√§rken als auch Herausforderungen. Einerseits erm√∂glichen sie eine fr√ºhzeitige Identifikation von Qualit√§tsproblemen. Durch die kontinuierliche √úberwachung dieser Metriken w√§hrend des Entwicklungsprozesses k√∂nnen Teams proaktiv Ma√ünahmen ergreifen, um die Softwarequalit√§t zu verbessern. Zudem unterst√ºtzen sie die Kommunikation innerhalb des Teams und mit Stakeholdern, da sie eine gemeinsame Sprache f√ºr die Diskussion √ºber Qualit√§t schaffen.  Andererseits ist die Interpretation der Metriken oft nicht trivial. Eine hohe Code-Komplexit√§t kann beispielsweise auf eine potenzielle Wartungsproblematik hinweisen, muss jedoch im Kontext des Projekts betrachtet werden. Zudem besteht die Gefahr, dass Teams sich zu sehr auf Metriken konzentrieren und dabei das √ºbergeordnete Ziel der Softwareentwicklung ‚Äì die Schaffung eines benutzerfreundlichen und funktionsf√§higen Produkts ‚Äì aus den Augen verlieren. Eine zu starke Fokussierung auf quantitative Metriken kann zudem zu einer Vernachl√§ssigung qualitativer Aspekte f√ºhren, die schwerer zu messen sind, aber ebenso entscheidend f√ºr die Softwarequalit√§t sind.  Insgesamt zeigt die Evaluierung, dass produktorientierte Metriken der Softwarequalit√§t ein wertvolles Werkzeug darstellen, um die Qualit√§t von Softwareprodukten systematisch zu bewerten und zu verbessern. Ihre Anwendung sollte jedoch stets mit Bedacht erfolgen, wobei eine Balance zwischen quantitativen und qualitativen Aspekten der Softwarequalit√§t angestrebt werden sollte. Eine integrative Herangehensweise, die sowohl produktorientierte als auch prozessorientierte Metriken ber√ºcksichtigt, k√∂nnte sich als besonders effektiv erweisen, um die Komplexit√§t der Softwareentwicklung zu bew√§ltigen und letztlich qualitativ hochwertige Software zu liefern.;1
Ausblick auf den aktuellen Stand des Testens von MQTT-basierten L√∂sungen  In den letzten Jahren hat das Internet der Dinge (IoT) zunehmend an Bedeutung gewonnen, was dazu gef√ºhrt hat, dass Messaging-Protokolle wie MQTT (Message Queuing Telemetry Transport) an Relevanz gewinnen. MQTT hat sich aufgrund seiner Effizienz und seines geringen Ressourcenbedarfs in Szenarien, in denen Ger√§te oft in begrenzten Netzwerkressourcen in Echtzeit kommunizieren m√ºssen, als ein entscheidendes Element etabliert. Angesichts der rasanten Entwicklung von IoT-Anwendungen entsteht paralle zum Wirtschaftswachstum auch der Bedarf an effektiven Teststrategien f√ºr MQTT-basierte L√∂sungen.  Der aktuelle Stand der Forschung und Praxis kann in mehreren Schl√ºsselaspekten betrachtet werden. Zun√§chst haben sich verschiedene Testmodelle hervorgetan, die darauf abzielen, die Funktionalit√§t, Performance und Sicherheit von MQTT-Implementierungen zu evaluieren. Hinzu kommt, dass verbesserte Simulationstools und Testumgebungen entwickelt werden, um die Komplexit√§t von IoT-Systemen besser abbilden zu k√∂nnen. Diese Tools erm√∂glichen es, MQTT-Nachrichten unter unterschiedlichsten Lastbedingungen zu erzeugen und zu beobachten, um so die Skalierbarkeit und Leistungsf√§higkeit der Systeme unter tats√§chlichen Einsatzbedingungen zu bewerten.  Ein weiterer Aspekt des aktuellen Standes ist die Analyse der Sicherheitsanforderungen an MQTT. Angesichts der damit verbundenen Herausforderungen durch potenzielle Bedrohungen f√ºr IoT-Ger√§te praktische Ans√§tze zur Erkennung und Reaktion auf Sicherheitsvorf√§lle w√§hrend des Testens kritisch wichtig. Die Implementierung von Best Practices sowie die Anwendung von standardisierten Sicherheitsrichtlinien spielt hierbei eine wertvolle Rolle und erg√§nzt die Perspektive von Win Win-Pr√ºfprozessen.  Um auch in der Zukunft in der Testmethodik innovative Ans√§tze zu f√∂rdern, sind verst√§rkte interdisziplin√§re Kollaborationen zwischen Softwareentwicklern, Netzwerk-Ingenieuren und Forschern gefragt. Der Trend geht dahin, automatisierte Testl√∂sungen und Integrationen mit Continuous-Integration/Continuous-Deployment (CI/CD)-Pipelines zu etablieren, um grade die Einf√ºhrung neuer Funktionen selbst in kritischen Umgebungen z√ºgig ‚Äì unter wahrnehmbaren Teststandards ‚Äì durchf√ºhren zu k√∂nnen.  Schlie√ülich ist es auch wichtig, dass bei der Definition zuk√ºnftiger Testpraktiken der Fokus nicht nur auf der Technologie selbst liegt, sondern auch auf deren Einfluss auf Umwelt, Gesellschaft und das gesamte √ñkosystem, in dem sie operiert. Der gr√ºne √úbergang hin zu nachhaltiger Technologie Integration ist parteiisch sowie praxisorientiertes Gestalterimentode ohne dessen unbeabsichtigte Folge, zu einer schlechten Implementierung zu erreichen.  In Anbetracht dieser Zusammenh√§nge wird der weitere Weg in der Entwicklung und dem Testen von MQTT-basierten L√∂sungen nicht nur die Effektivit√§t der Implementierungen selbst zum Inhalt haben, sondern auch die ethischen und gesellschaftlichen Rahmenbedingungen ber√ºcksichtigen, um die breite Annahme von IoT-Technologien zu f√∂rdern und gleichzeitig Erfahrungen aus schrittnden √ñkosystemen systemen.  Dieser Ausblick verdeutlicht somit, dass der aktuelle Stand des Testens von MQTT-basierten L√∂sungen gekennzeichnet ist durch dynamische Entwicklungen, best√§ndiges Lernen und eine verbesserte Sichtweise der multidimensionalen Anforderungen moderner Softwarearch;1
"  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten in der modernen Welt haben die Notwendigkeit hervorgebracht, neue Lehr- und Lernmethoden zu entwickeln, die den Anforderungen einer technologiegetriebenen Gesellschaft gerecht werden. Eine vielversprechende Herangehensweise ist die Implementierung von virtuellen Szenarien, die auf dem Message Queuing Telemetry Transport (MQTT) Protokoll basieren. MQTT ist ein leichtgewichtiges Publish-Subscribe-Nachrichtenprotokoll, das speziell f√ºr die Kommunikation zwischen Ger√§ten in IoT-Anwendungen (Internet of Things) konzipiert wurde. In diesem Kontext wird die  als ein innovativer Ansatz zur Vermittlung von Konzepten der Netzwerktechnologie und der IoT-Architektur betrachtet.    des MQTT-Protokolls  MQTT wurde urspr√ºnglich von Andy Stanford-Clark und Arlen Nipper in den sp√§ten 1990er Jahren entwickelt und hat sich seitdem als eines der dominierenden Protokolle im Bereich der IoT-Kommunikation etabliert. Es basiert auf einem Client-Server-Modell, in dem Clients (Endger√§te) √ºber einen Broker (Nachrichtenvermittler) kommunizieren. Der Broker ist f√ºr die Verteilung der Nachrichten verantwortlich und erm√∂glicht eine effiziente Kommunikation zwischen einer Vielzahl von Clients, ohne dass diese direkt miteinander verbunden sein m√ºssen.  Die grundlegenden Konzepte des MQTT-Protokolls umfassen 1. Publish-Subscribe-ModellIm Gegensatz zu traditionellen Client-Server-Modellen, bei denen eine direkte Verbindung zwischen Sender und Empf√§nger besteht, erm√∂glicht das Publish-Subscribe-Modell eine lose Kopplung der Kommunikationspartner. Clients k√∂nnen sich f√ºr bestimmte Themen (Topics) anmelden und Nachrichten zu diesen Themen ver√∂ffentlichen. Dies f√∂rdert die Skalierbarkeit und Flexibilit√§t der Kommunikation.  2. Leichtgewichtigkeit und EffizienzMQTT ist so konzipiert, dass es mit minimalem Overhead arbeitet, was es ideal f√ºr ressourcenbeschr√§nkte Umgebungen macht. Die geringe Bandbreite und der niedrige Energieverbrauch sind entscheidend f√ºr IoT-Anwendungen, in denen Ger√§te oft in abgelegenen oder energiearmen Umgebungen betrieben werden.  3. Qualit√§tsstufen der Dienstg√ºte (QoS)MQTT bietet drei verschiedene Qualit√§tsstufen f√ºr die Nachrichten√ºbermittlung, die es den Entwicklern erm√∂glichen, den Grad der Zuverl√§ssigkeit und die √úbertragungsgeschwindigkeit je nach Anwendungsfall anzupassen. Diese Stufen sind ""At most once"" (QoS 0), ""At least once"" (QoS 1) und ""Exactly once"" (QoS 2).  4. Retention und Last WillMQTT unterst√ºtzt Funktionen wie die Retention von Nachrichten, die es erm√∂glichen, dass neu verbundene Clients die letzten Nachrichten zu einem Thema erhalten. Zudem bietet das Protokoll die M√∂glichkeit, eine ""Last Will""-Nachricht zu definieren, die im Falle eines unerwarteten Verbindungsabbruchs gesendet wird. Dies erh√∂ht die Robustheit der Kommunikation.   Anwendung in der Lehre  Die  kann auf mehreren";1
Wartbarkeit ist ein wichtiger Faktor f√ºr den langfristigen und produktiven Einsatz eines  Softwareprodukts. Fehlende Wartbarkeit f√ºhrt zu steigenden Betriebs - und Entwicklungskosten, da  die Instandhaltung mit einem erh√∂hten Aufwand verbunden ist. Codequalit√§t und Wartbarkeit sind  untrennbar miteinander verbunden. Schlechter oder unstrukturierter Code erschwert die  Einarbeitung in die Software, aber auch Ver√§nderungen oder Erweiterungen des Quellcodes. Daher  ist es w√§hrend  des gesamten Lebenszyklus des Produkts n√∂tig eine hohe Codequalit√§t  sicherzustellen .  Zur √úberwachung und Steigerung der Softwarequalit√§t gibt es verschiedene Methoden. Eine davon  ist der Einsatz von Metriken, der de m Bereich der  statischen Codeanalyse zugeordnet wird. In dieser  Arbeit wird ein Prozess definiert und durchgef√ºhrt, der alle Schritte einer Produktmessung enth√§lt.  Darunter fallen die  Definition und Spezifizierung von Zielen der Softwarequalit√§t, die Auswahl von  relevanten Metriken sowie die Softwaremessung  selbst. F√ºr diese wird  ein studentische s  Softwareprojekt  herangezogen . Am Ende stehen die Analyse und Interpretation der Messergebnisse.  Ziel ist es eine Aussage dar√ºber zu treffen, inwiefern Metriken bei der Bewertung studentischer  Abgaben eingesetzt werden k√∂nnen.;0
F√ºr die Fahrzeugfernsteuerung werden, wie schon bereits im Abschnitt 5.2.1beschrieben, die Controller Adafruit Pygamer undSparkfunThingPlus - Xbee3Micro sowie die Linx ANT- 2.4-PML-UFL -Antenne verwendet. Die Verbindung der Antenne mit dem Xbee-Controller erfolgt √ºber einen U.FL-Konnektor, der sich durch ein leichtes Andr√ºcken einrasten l√§sst. Zur Kommunikation zwischen dem Adafruit Pygamer und dem Xbee-Controller findet √ºber das Protokoll I2Cstatt. Als physische Verbindung wird hierf√ºr ein Adapter zwischen dem Qwiic-Anschluss1des Xbee-Controllers und dem 4-Pin-STEMMA-JST-Konnektor2 des Pygamers verwendet. Da der Anschluss des Pygamers standardm√§√üig eine Spannung von 5V liefert und der ThingPlus mit 3.3V betrieben wird, muss die Ausgangsspannung des Pygamers von 5.5V auf 3.3V reduziert werden. Dies geschieht durch das Durchtrennen einer daf√ºr vorhandenen L√∂tbr√ºcke auf der Unterseite des Pygamers. F√ºr die Stromversorgung des ThingPlus-Controllers und des Pygamers wird zudem an jeden der beiden Controller je eine Batterie angeschlossen. Theo- retisch ist auch eine Stromversorgung √ºber die Datenverbindung des Pygamers m√∂glich, bei der praktischen Umsetzung kam es hier jedoch zu Problemen, weswegen hier eine zweite Batterie f√ºr die Stromversorgung des ThingPlus-Controllers eingesetzt wird. Als Basis f√ºr das Geh√§use der Fernbedienung wird das Adafruit PyGamer Acrylic Enclos- ure Kit3verwendet, dass als Geh√§use f√ºr den PyGamer konzipiert ist (siehe Abbildung 5.6). Um Platz f√ºr den Xbee-Kontroller mit seiner Batterie zu schaffen, werden weitere Einzelteile im Lasercutter ausgeschnitten und eine √ñffnung f√ºr die Befestigung diese Controllers geschaffen (siehe Abbildung 5.8, die Schemata f√ºr den Lasercutter sind unter https://learn.adafruit.com/adafruit-pygamer/downloads zu finden). Um den ThingPlus-Controller mit angeschlos- sener Batterie ausschalten zu k√∂nnen wird zudem noch ein eigenes Adapterkabel mit einem Schalter gel√∂tet. Der Schalter wird dann am Geh√§useboden festgeklebt und in die Befestigung der Antenne ein entsprechendes Loch zur Bet√§tigung des Schalters gebohrt. Die fertige Fernsteuerung ist in Abbildung 5.9 zu sehen.;0
 Eine      Die fortschreitende Digitalisierung und der zunehmende Einsatz agiler Methoden in der Softwareentwicklung erfordern von Studierenden nicht nur technisches Know-how, sondern auch effektive Werkzeuge zur Organisation und Verwaltung ihrer Projekte. Ein Aufgabenmanagement-Tool (AMT) kann hierbei eine zentrale Rolle spielen, indem es die Planung, Durchf√ºhrung und Nachverfolgung von Aufgaben unterst√ºtzt. Diese Arbeit befasst sich mit der Anforderungsanalyse f√ºr ein solches Tool, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist. Im Fokus steht die , um sicherzustellen, dass das entwickelte Tool den Anforderungen der Zielgruppe gerecht wird.   Zielsetzung der Anforderungsanalyse  Die Anforderungsanalyse zielt darauf ab, die spezifischen Bed√ºrfnisse und Herausforderungen von Studierenden im Software Engineering zu identifizieren. Dazu werden qualitative und quantitative Methoden eingesetzt, um ein umfassendes Bild der Anforderungen zu erhalten. Die Analyse soll sowohl funktionale als auch nicht-funktionale Anforderungen umfassen, die f√ºr die Entwicklung eines effektiven AMT entscheidend sind.   Methodik  Die Methodik der Anforderungsanalyse umfasst mehrere Schritte 1. LiteraturrechercheZun√§chst wird eine umfassende Literaturrecherche zu bestehenden Aufgabenmanagement-Tools und deren Einsatz im Bildungsbereich durchgef√ºhrt. Diese Recherche dient dazu, Best Practices zu identifizieren und bestehende L√ºcken in der Funktionalit√§t zu erkennen.  2. Befragungen und InterviewsUm die Bed√ºrfnisse der Studierenden direkt zu erfassen, werden qualitative Interviews und quantitative Umfragen durchgef√ºhrt. Die Zielgruppe umfasst Studierende unterschiedlicher Semester und Studienrichtungen, um ein breites Spektrum an Anforderungen zu erfassen.  3. Usability-TestsVorl√§ufige Prototypen des Tools werden in Usability-Tests mit Studierenden evaluiert. Diese Tests erm√∂glichen es, Feedback zur Benutzerfreundlichkeit und zur intuitiven Bedienbarkeit des Tools zu sammeln.   Ergebnisse der Anforderungsanalyse  Die Ergebnisse der Anforderungsanalyse zeigen, dass Studierende insbesondere folgende funktionale Anforderungen an ein AMT stellen - AufgabenverwaltungDie M√∂glichkeit, Aufgaben zu erstellen, zu bearbeiten und zu priorisieren, ist grundlegend. Studierende w√ºnschen sich eine klare √úbersicht √ºber alle anstehenden und abgeschlossenen Aufgaben.  - KollaborationDa viele Projekte in Gruppenarbeit durchgef√ºhrt werden, ist eine integrierte Kollaborationsfunktion von gro√üer Bedeutung. Dies umfasst die M√∂glichkeit, Aufgaben zu delegieren, Kommentare zu hinterlassen und den Fortschritt in Echtzeit zu verfolgen.  - Integration von ToolsDie Anforderung an die Integration von bestehenden Tools wie GitHub, Slack oder Google Drive wurde h√§ufig ge√§u√üert, um einen nahtlosen Workflow zu gew√§hrleisten.  Neben den funktionalen Anforderungen wurden auch nicht-funktionale Anforderungen identifiziert, die f√ºr die Akzeptanz des Tools entscheidend sind - BenutzerfreundlichkeitDie Benutzeroberfl√§che muss intuitiv und ansprechend gestaltet sein, um eine hohe Akzeptanz bei den Studierenden zu erreichen.  - Zug√§nglichkeitDas Tool sollte plattform√ºbergreifend verf√ºgbar sein, um den unterschiedlichen technischen Gegebenheiten der Studierenden;1
 Kapitel 4: Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper  Die Entwicklung eines Content Management Systems (CMS) zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper stellt eine innovative Herausforderung dar, die sowohl technisches Know-how als auch ein tiefes Verst√§ndnis der Benutzerinteraktion erfordert. In diesem Kapitel werden die grundlegenden Komponenten und der Aufbau eines solchen Systems detailliert beschrieben, einschlie√ülich der Architektur, der Benutzeroberfl√§che, der Integration von Roboterfunktionen und der Bereitstellung von Inhalten.   4.1 Einf√ºhrung in das Projekt  Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, ist darauf ausgelegt, mit Menschen zu interagieren und in verschiedenen Umgebungen eingesetzt zu werden, wie beispielsweise im Einzelhandel, im Gesundheitswesen oder in Bildungseinrichtungen. Um die Einsatzm√∂glichkeiten von Pepper zu erweitern, ist es notwendig, ein benutzerfreundliches CMS zu entwickeln, das es nicht-technischen Benutzern erm√∂glicht, ma√ügeschneiderte Android-Apps zu erstellen. Diese Apps sollen spezifische Funktionen und Interaktionen f√ºr den Roboter bieten, ohne dass tiefgehende Programmierkenntnisse erforderlich sind.   4.2 Architektur des CMS  Die Architektur des CMS gliedert sich in mehrere Schichten, die jeweils spezifische Aufgaben erf√ºllen:  1. Pr√§sentationsschicht: Diese Schicht umfasst die Benutzeroberfl√§che, die es den Benutzern erm√∂glicht, Inhalte zu erstellen, zu bearbeiten und zu verwalten. Die Benutzeroberfl√§che sollte intuitiv gestaltet sein und Drag-and-Drop-Funktionen unterst√ºtzen, um die Benutzerfreundlichkeit zu maximieren.  2. Logikschicht: Hier werden die Gesch√§ftslogik und die Regeln zur Verarbeitung der Benutzereingaben implementiert. Diese Schicht ist verantwortlich f√ºr die Validierung von Inhalten und die Steuerung des Datenflusses zwischen der Pr√§sentations- und der Datenschicht.  3. Datenschicht: Diese Schicht speichert alle erstellten Inhalte, Benutzerinformationen und App-Daten. Eine relationale Datenbank oder ein NoSQL-Datenbanksystem kann hier verwendet werden, um eine flexible und skalierbare Speicherung zu gew√§hrleisten.  4. Integrationsschicht: Diese Schicht erm√∂glicht die Kommunikation zwischen dem CMS und der Pepper-Plattform. Hierbei werden APIs verwendet, um sicherzustellen, dass die erstellten Apps nahtlos mit den Funktionen von Pepper interagieren k√∂nnen.   4.3 Benutzeroberfl√§che  Die Benutzeroberfl√§che des CMS sollte so gestaltet sein, dass sie den Bed√ºrfnissen einer breiten Benutzergruppe gerecht wird. Ein Dashboard bietet einen √úberblick √ºber die verf√ºgbaren Funktionen, w√§hrend ein Assistent den Benutzer durch den Prozess der App-Erstellung f√ºhrt. Wichtige Elemente der Benutzeroberfl√§che sind:  - Vorlagen: Vorlagen f√ºr h√§ufig verwendete App-Typen k√∂nnen den Einstieg erleichtern. - Editor: Ein visueller Editor erm√∂glicht es Benutzern, Inhalte anzupassen, ohne Code schreiben zu m√ºssen. Hier k√∂nnen Texte, Bilder, Videos und interaktive Elemente hinzugef√ºgt werden. - Testumgebung: Eine integrierte Testumgebung erm√∂glicht es Benutzern, ihre Apps in einer simulierten Umgebung zu testen, bevor sie auf den Roboter √ºbertragen werden.   ;1
 Evaluierung der wissenschaftlichen Arbeit: ‚ÄûRealisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung‚Äú   1. Einleitung Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung eines IoT-Systems zur intelligenten Steuerung einer Katzenklappe. Durch den Einsatz moderner Technologien der K√ºnstlichen Intelligenz (KI) wird eine automatisierte Katzenerkennung angestrebt, die es erm√∂glicht, die Klappe nur f√ºr autorisierte Katzen zu √∂ffnen. Diese Evaluierung betrachtet die wissenschaftliche Herangehensweise, die Methodik, die Ergebnisse und deren Relevanz innerhalb des Forschungsfeldes der intelligenten Haustechnologien.   2. Wissenschaftliche Herangehensweise Die Arbeit beginnt mit einer fundierten Literaturrecherche, die den aktuellen Stand der Technik im Bereich IoT und KI im Kontext von Haustiersystemen analysiert. Die Autorin/der Autor identifiziert relevante technische Herausforderungen und formuliert klare Forschungsfragen. Diese Herangehensweise bietet eine solide Grundlage f√ºr das gesamte Projekt und zeigt, dass die Autorin/der Autor die Forschungslandschaft gut kennt.   3. Methodik Die Methodik wird klar und strukturiert dargelegt. Die Autorin/der Autor beschreibt die Wahl der Hardware- und Softwarekomponenten, einschlie√ülich der verwendeten Mikrocontroller, Sensoren und Algorithmen zur Bilderkennung. Besonders positiv hervorzuheben ist die detaillierte Beschreibung des Entwicklungsprozesses, die von der Prototypenerstellung bis hin zu Tests reicht.   Die Anwendung von KI-Algorithmen ‚Äì insbesondere Convolutional Neural Networks (CNNs) zur Katzenerkennung ‚Äì ist zeitgem√§√ü und entspricht den aktuellen Standards in der Bildverarbeitung. Des Weiteren sind die durchgef√ºhrten Tests zur Iteration und Optimierung der Algorithmen sowohl quantitativ als auch qualitativ gut dokumentiert.   4. Ergebnisse Die erzielten Ergebnisse zeigen eine hohe Effektivit√§t der Katzenerkennung, wobei die Autorin/der Autor mehrere Testszenarien durchf√ºhrt, um die Robustheit des Systems zu gew√§hrleisten. Die Ergebnisse werden durch statistische Analysen unterst√ºtzt, die die Genauigkeit und Zuverl√§ssigkeit der Katzenerkennung best√§tigen.   Jedoch w√§re eine erweiterte Diskussion √ºber m√∂gliche Fehlerraten und die Handhabung unautorisierter Tiere von Vorteil gewesen, um ein umfassenderes Bild der Praxistauglichkeit zu vermitteln. Die Implementierung der Steuerungslogik f√ºr die Katzenklappe ist innovativ und benutzerfreundlich. Die Integration von Fernzugriffsm√∂glichkeiten √ºber eine App k√∂nnte in zuk√ºnftigen Arbeiten ebenfalls vertieft werden.   5. Relevanz und Anwendbarkeit Das vorgeschlagene System hat bedeutendes Potenzial f√ºr die praktische Anwendung im Smart-Home-Sektor. Die Kombination von IoT und KI zur Verbesserung der Interaktion zwischen Mensch und Tier ist sowohl innovativ als auch relevant. Die Arbeit k√∂nnte f√ºr Tierbesitzer, Entwickler von Smart-Home-L√∂sungen und Forscher im Bereich der Automatisierung von Haustierpflege von Interesse sein.   6. Fazit Insgesamt bietet die wissenschaftliche Arbeit eine fundierte und innovative Auseinandersetzung mit der Thematik der intelligenten Katzenklappe. Die Methodik ist durchdacht und die Ergebnisse sind vielversprechend. F√ºr zuk√ºnftige Arbeiten werden Empfehlungen zur Erweiterung der Funktionalit√§ten und zu weiteren Testm√∂glichkeiten gegeben. Die Autorin/der Autor hat einen wertvollen Beitrag im Bereich der IoT-Anwendungen in der Tierpflege geleistet, der sowohl akademisches als auch praktisches Potenzial aufweist.;1
Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tEin Ausblick auf m√∂gliche Weiterentwicklungen  Die Softwarequalit√§t ist ein zentrales Anliegen in der Softwareentwicklung, das sowohl die Zufriedenheit der Endbenutzer als auch die Effizienz der Entwicklungsprozesse beeinflusst. In diesem Kontext spielen produktorientierte Metriken eine entscheidende Rolle, da sie sich auf die Eigenschaften des Softwareprodukts selbst konzentrieren. Diese Metriken bieten quantitative Ma√üe f√ºr verschiedene Qualit√§tsattribute wie Funktionalit√§t, Zuverl√§ssigkeit, Benutzerfreundlichkeit, Effizienz, Wartbarkeit und Portabilit√§t.  Produktorientierte Metriken k√∂nnen in verschiedene Kategorien unterteilt werden. Zu den h√§ufigsten z√§hlen strukturelle Metriken, die sich auf den Quellcode beziehen, wie z.B. Code-Komplexit√§t, Zeilenanzahl oder Anzahl der Funktionen. Des Weiteren gibt es funktionale Metriken, die die Erf√ºllung von Anforderungen und die Leistungsf√§higkeit der Software bewerten. Diese Metriken sind entscheidend f√ºr das Verst√§ndnis, wie gut das Produkt die Bed√ºrfnisse der Benutzer erf√ºllt und wie robust es unter verschiedenen Bedingungen funktioniert.  Die Anwendung produktorientierter Metriken erfolgt typischerweise in mehreren Phasen des Softwareentwicklungszyklus. In der Planungsphase k√∂nnen Metriken verwendet werden, um die Machbarkeit und die Risiken eines Projekts zu bewerten. W√§hrend der Implementierungsphase erm√∂glichen sie eine kontinuierliche √úberwachung der Codequalit√§t und helfen, technische Schulden fr√ºhzeitig zu identifizieren. In der Testphase dienen diese Metriken der Bewertung der Testabdeckung und der Fehlerdichte, w√§hrend sie in der Wartungsphase als Indikatoren f√ºr die Wartbarkeit und die Notwendigkeit von Refactoring-Ma√ünahmen fungieren.  Ein Ausblick auf m√∂gliche Weiterentwicklungen produktorientierter Metriken der Softwarequalit√§t zeigt, dass sich die Anforderungen an Softwareprodukte kontinuierlich ver√§ndern. Die zunehmende Komplexit√§t von Softwarearchitekturen, insbesondere im Kontext von Microservices und Cloud-Computing, erfordert eine Anpassung und Erweiterung bestehender Metriken. Zuk√ºnftige Entwicklungen k√∂nnten sich auf die Integration von Metriken f√ºr neue Technologien wie K√ºnstliche Intelligenz (KI) und maschinelles Lernen konzentrieren. Hierbei k√∂nnten Metriken entwickelt werden, die nicht nur die statische Analyse des Codes, sondern auch das dynamische Verhalten von KI-Modellen bewerten.  Ein weiterer vielversprechender Ansatz ist die Verwendung von Metriken, die auf die Benutzererfahrung (User Experience, UX) fokussiert sind. Die Integration von Metriken, die das Nutzerverhalten und die Zufriedenheit in Echtzeit erfassen, k√∂nnte die Produktqualit√§t auf eine neue Ebene heben. In diesem Zusammenhang k√∂nnten Techniken wie A/B-Testing und Nutzeranalysen in die Metrikenerhebung einflie√üen, um ein umfassenderes Bild der Softwarequalit√§t zu erhalten.  Schlie√ülich k√∂nnte die Automatisierung der Metrikenerhebung und -analyse durch den Einsatz von DevOps-Praktiken und Continuous Integration/Continuous Deployment (CI/CD) weiter vorangetrieben werden. Hierbei k√∂nnten intelligente Algorithmen und Datenanalysen dazu beitragen, Metriken in Echtzeit zu erfassen und zu bewerten, wodurch schneller auf Qualit√§tsprobleme reagiert werden kann.  Zusammenfass;1
1 Problemstellung und Ziele der Arbeit Im Zeitalter der zunehmenden Digitalisierung steigt aufgrund der zunehmenden smarter und mobiler werdenden Gesellschaft nicht nur die st√§ndige Nachfrage nach neuen robusten und mobilen Endger√§ten, sondern auch die Anforderungen an die Anwendungen, die gezielt f√ºr solche Ger√§te entwickelt werden. Einhergehend mit dieser Tatsache steigt auch das Interesse von Firmen und ihren angestellten Entwickelnden, ihre Produkte mit m√∂glichst wenig Aufwand auf dem aktuellen Stand zu halten. Um mit der st√§ndigen Weiterentwicklung mithalten zu k√∂nnen, gibt es immer mehr Unternehmen, die beginnen, sogenannte Toolkits zu entwickeln und diese auch unter Open-Source-Lizenzen zur Verf√ºgung zu stellen. Bei einem Toolkit handelt es sich hierbei um eine Sammlung von erg√§nzenden Programmeinheiten, die f√ºr einen speziellen Einsatzzweck entwickelt und h√§uÔ¨Åg auch gemeinsam bereitgestellt werden . In diesem Zusammenhang hat auch der Android-Markt in den letzten Jahren einen hohen Zuwachs erlebt. So bel√§uft sich der Absatz von Android Smartphones weltweit pro Quartal auf √ºber 294 Millionen St√ºck  und das beliebte Betriebssystem Android ist bereits in der 12. Version ver√∂Ô¨Äentlicht worden. Auf der Grundlage dieser Tatsache steigt auch zunehmend das Interesse von Unternehmen und Android-Entwickelnden native plattformspeziÔ¨Åsche Apps einfach und eÔ¨Ézient zu entwickeln, um mit ihren Produkten ebenfalls an diesem Markt pr√§sent zu sein. Hierf√ºr haben sich in den letzten Jahren bereits zahlreiche Frameworks wie Ionic, React oder Flutter etabliert, die es sogar erm√∂glichen, hybride Apps f√ºr unterschiedliche Zielplattformen auf einer gemeinsamen Codebasis zu erstellen. Diese Technologien sind mittlerweile bereits relativ verbreitet. Trotzdem setzen viele Firmen weiterhin auf die native App-Entwicklung, um eine hohe Qualit√§t ihrer Produkte gew√§hrleisten zu k√∂nnen. Hierf√ºr werden auch deutlich h√∂here Kosten f√ºr die Entwicklung akzeptiert, welche sich auf den h√∂heren Grad der Komplexit√§t und den damit korrelierenden h√∂heren Zeitaufwand zur√ºckf√ºhren lassen k√∂nnen . Doch auch die Weiterentwicklung der Frameworks f√ºr native Apps wird weiter vorangetrieben. Bereits 2019 erkannte Erik Berends in seinem Artikel ‚Äû Mit Android Jetpack die App Entwicklung beschleunigen ‚Äú  welche M√∂glichkeiten, Neuerungen und Verbesserungen sich durch die Etablierung und den Einsatz von Android Jetpack, einer von Google entwickelten Sammlung von Werkzeugen und Bibliotheken, ergeben.;0
Evaluierung: Vergleich von Progressive Web Apps (PWA) und nativen Apps am Beispiel einer Journaling-App  Im Zuge der fortschreitenden Digitalisierung und der kontinuierlichen Weiterentwicklung der Webtechnologien gewinnt das Konzept der Progressive Web Apps (PWA) zunehmend an Bedeutung. Dieses Format, das die Vorteile von Web- und mobilen Anwendungen kombiniert, stellt im Kontext einer Journaling-App eine vielversprechende Alternative zu herk√∂mmlichen nativen Apps dar. In dieser Evaluierung sollen sowohl die St√§rken als auch die Herausforderungen von PWAs im Vergleich zu nativen Apps untersucht werden, wobei besonderes Augenmerk auf die Benutzererfahrung, Performance, Zugriffsm√∂glichkeiten und Wartungsaspekte gelegt wird.  Zun√§chst ist die Benutzererfahrung (UX) ein entscheidender Faktor f√ºr den Erfolg jeder Anwendung. Nativen Apps wird oft ein intuitives Nutzerinterface und eine fl√ºssige Bedienung zugeschrieben, was auf die tiefere Integration in das Betriebssystem zur√ºckzuf√ºhren ist. Im Vergleich dazu bieten PWAs zwar ebenfalls ein ansprechendes Design, k√§mpfen jedoch manchmal mit Einschr√§nkungen, insbesondere in Bezug auf Ger√§tefunktionen wie die Kamera oder Push-Benachrichtigungen. Eine prominente Journaling-App als native Anwendung k√∂nnte diese Funktionen nahtlos integrieren, sodass Nutzer direkt Fotos aufnehmen und Eintr√§ge ohne zus√§tzliche Schritte erstellen k√∂nnen. Umgekehrt verf√ºgen PWAs √ºber den Vorteil, dass sie sowohl auf Android- als auch auf iOS-Ger√§ten ohne spezifische Anpassungen nutzbar sind. Letztlich h√§ngt die Wahl zwischen diesen beiden Optionen von den spezifischen Anforderungen des geplanten JOURNALING-Anwendungsprojekts ab.  Ein weiterer Bereich, in dem sich PWAs und native Apps unterscheiden, ist die Performance. Native Apps haben den Vorteil, dass sie in der Regel besser auf die Hardware des Ger√§tes abgestimmt sind und somit eine schnellere Ladezeit und fl√ºssigere Interaktionen erm√∂glichen. PWAs k√∂nnen manchmal von einer optimierten Netzwerkverbindung abh√§ngen, was bei langsamen Verbindungen eine Herausforderung darstellen kann. Die Offline-Nutzung von PWAs hat allerdings gro√üe Fortschritte gemacht, sodass, auch wenn die Performance hinter der nativen App zur√ºckbleibt, viele Aufgaben ohne Internetzugang ausgef√ºhrt werden k√∂nnen. Dies k√∂nnte f√ºr Nutzer, die regelm√§√üig Notizen oder Gedanken jederzeit erfassen m√∂chten, einen entscheidenden Vorteil darstellen.  Bei der Zugangsm√∂glichkeit zeigt sich ein weiterer wesentlicher Unterschied. PWAs k√∂nnen direkt √ºber den Browser aufgerufen werden und ben√∂tigen keine Installation. Dies senkt die Hemmschwelle f√ºr den Nutzer, eine neue App auszuprobieren. Dies k√∂nnte in einem Fall von Vorteil sein, in dem die Journaling-App am Anfang skeptische Reaktionen hervorrufen kann. Im Gegensatz dazu erfordert die Nutzung einer nativen App die Herunterladung von speziellen App-Stores, was zus√§tzlicher Zeit- und Speicherplatzaufwand f√ºr die Nutzer bedeutet.  Schlie√ülich ist auch der Wartungsaufwand ein wichtiger Aspekt in der Evaluierung. Native Apps m√ºssen h√§ufig visuell und funktional aktualisiert werden, um Bedeutung zu erlangen und in den verschiedenen Systemversionen stabil zu bleiben. PWAs sind wartungsfreundlicher, da sie regelm√§√üig aktualisiert werden k√∂nnen, ohne dass Nutzer daf√ºr eine neue Version herunterladen m√ºssen. So bleibt die Journaling-App in der PWA-Variante aktueller und Wartungszyklus konstant.  Zusammenfassend;1
Freemee ist au√üerdem Hersteller einer Datenbrille. Diese bekommt Cynthia von ihrem Vorgesetzten Anthony Heast, um damit modernere Artikel zu verfassen. Cynthia testet diese auf der Heimfahrt und findet dabei heraus, dass die Brille dank Gesichtserkennung fasst zu jeder Person s√§mtliche Daten wie Namen, Adresse, Beruf und noch viele weitere herausfindet. Diese Daten werden in Profilen dargestellt, welche der Firma Freemee geh√∂ren. Ihr eigenes Profil ist dazu im Vergleich nicht so Datenreich, da sie kein Freemee Konto hat. Da Cynthia mit moderner Technik nicht so viel anzufangen wei√ü, leiht sie die Datenbrille ihrer Tochter Viola. Diese ist begeistert davon und probiert sie mit ihren Freunden aus. Dabei entdeckt Adam, als er die Brille aufhat einen gesuchten Kriminellen. Er nimmt die Verfolgung auf, doch wird dabei von dem Kriminellen entdeckt. Dabei streamt Adam seine Verfolgung live. W√§hrend ein Notruf zur Polizei abgesetzt wird, verfolgen die Polizisten die Verfolgung √ºber Video√ºberwachungskameras, die in ganz London verteilt sind. Gleichzeitig l√§uft auch immer noch der Stream von Adam. Als der Kriminelle sich eingeengt f√ºhlt, packt er schlie√ülich eine Pistole aus und schie√üt auf Adam. Dieser stirbt durch den Schuss noch am Tatort, w√§hrend der Stream weiterl√§uft. Damit gibt es schon fr√ºh ein weiteres gro√ües Ereignis im Buch. Durch dieses Ereignis beginnt jetzt Cynthia Nachforschungen anzustellen, wie es dazu kommen konnte. Dabei st√∂√üt Cynthia auf Freemee. Ein wichtiger Punkt werden dabei noch die sogenannten ‚ÄûActApps‚Äú spielen. Diese sind Apps mit denen Nutzern Tipps gegeben werden, um in der Liebe, Karriere, Fitness und weiteren Bereichen erfolgreich zu werden. Gef√ºttert werden diese mit Daten von Smartwatches, Datenbrillen, Smartphones und weiteren Ger√§ten die Daten erfassen. Ausgewertet wird das alles durch Freemee. Zero warnt aktiv vor Freemee, da diese die Privatsph√§re verletzten und Menschen manipulieren. W√§hrend Cynthias Ermittlungen, ermittelt das FBIgegen Zero. Freemee will auch mehr √ºber Zero herausfinden und bieten deshalb √ºber eine Tochterfirma ‚ÄûSheeld‚Äú dem Daily 4 Millionen Pfund f√ºr die Verfolgung von Zero. Cynthia wird darauf durch ihren Chef angesetzt und bekommt einen IT-Forensiker als Unterst√ºtzung dazu, mit welchem sie ein Verh√§ltnis anf√§ngt. Dabei ger√§t sie immer wieder in Konflikte mit Freemee und dem FBI. Die amerikanischen Ermittlungsbeh√∂rden sind w√§hrend der Untersuchung auch stark an den √úberwachungs- und Manipulationsm√∂glichkeiten durch Freemee interessiert und bieten eine Kooperation an.;0
" Kapitel 2: Technische Grundlagen  Die vorliegende Arbeit befasst sich mit dem Stand der Technik beim Testen von MQTT-basierten L√∂sungen. Um die Relevanz und die Herausforderungen des Testens in diesem Kontext zu verstehen, ist es wichtig, die technischen Grundlagen von MQTT (Message Queuing Telemetry Transport) sowie die dazugeh√∂rigen Testmethoden und -werkzeuge zu erl√§utern.   2.1 MQTT: Eine Einf√ºhrung  MQTT ist ein leichtgewichtiges Messaging-Protokoll, das speziell f√ºr die Kommunikation in Netzwerken mit begrenzten Ressourcen und hoher Latenz entwickelt wurde. Es wurde urspr√ºnglich von IBM in den sp√§ten 1990er Jahren konzipiert und ist seitdem zum De-facto-Standard f√ºr das Internet der Dinge (IoT) geworden. MQTT basiert auf einem Publish-Subscribe-Modell, das es erm√∂glicht, dass Sender (Publisher) Nachrichten an bestimmte Themen (Topics) ver√∂ffentlichen, w√§hrend Empf√§nger (Subscriber) sich f√ºr diese Themen anmelden, um die entsprechenden Nachrichten zu erhalten. Diese Entkopplung von Sender und Empf√§nger f√ºhrt zu einer flexiblen und skalierbaren Architektur.  Ein zentrales Element von MQTT ist der Message Broker, der als Vermittler zwischen Publishern und Subscribern fungiert. Der Broker empf√§ngt die ver√∂ffentlichten Nachrichten und leitet sie an die entsprechenden Abonnenten weiter. Diese Architektur erm√∂glicht eine einfache Integration von Ger√§ten, die m√∂glicherweise unterschiedliche Kommunikationsprotokolle verwenden oder in unterschiedlichen Netzwerken operieren.   2.2 Die Funktionsweise von MQTT  MQTT bietet verschiedene QoS (Quality of Service) Stufen, die den Grad der Zuverl√§ssigkeit bei der Nachrichten√ºbertragung definieren. Diese Stufen reichen von ""At most once"" (QoS 0), bei dem Nachrichten ohne Best√§tigung gesendet werden, √ºber ""At least once"" (QoS 1), bei dem eine Best√§tigung erforderlich ist, bis hin zu ""Exactly once"" (QoS 2), das die h√∂chste Zuverl√§ssigkeit gew√§hrleistet. Diese Flexibilit√§t ist besonders wichtig f√ºr IoT-Anwendungen, in denen Netzwerkbedingungen variieren k√∂nnen und die Zuverl√§ssigkeit der Kommunikation entscheidend ist.   2.3 Testen von MQTT-basierten L√∂sungen  Das Testen von MQTT-basierten Anwendungen stellt spezifische Herausforderungen, die sich aus der Natur des Protokolls und der damit verbundenen Infrastruktur ergeben. Die Hauptziele beim Testen umfassen die √úberpr√ºfung der Funktionalit√§t, der Leistung, der Sicherheit und der Interoperabilit√§t der L√∂sungen.   1. Funktionalit√§t: Funktionale Tests stellen sicher, dass die Anwendung gem√§√ü den Spezifikationen arbeitet. Dazu geh√∂ren Tests der Publikations- und Abonnementsmechanismen, der korrekten Verarbeitung von Nachrichten sowie der Reaktion auf verschiedene QoS-Stufen.  2. Leistung: Die Leistungsf√§higkeit von MQTT-basierten Systemen ist entscheidend, insbesondere in Szenarien mit hoher Last, wie sie in IoT-Anwendungen h√§ufig vorkommen. Lasttests und Stresstests sind erforderlich, um die Grenzen des Systems zu bestimmen und sicherzustellen, dass es unter realistischen Bedingungen stabil bleibt.  3. Sicherheit: Sicherheitsaspekte sind bei der Implementierung von MQTT von gro√üer Bedeutung, da viele IoT-Ger√§te in krit";1
In der Literatur sind verschiedene Projekte mit der Digi Xbee-Produktfamilie zu finden. So wird in  ein mobiler Roboter √ºber ein Webinterface gesteuert. Dabei wird die Kommunikation zwischen dem Kontroll-Computer und dem eigentlichen Fahrzeug mit Hilfe von Xbee-Pro-Modulen umgesetzt. Hierbei wird zwar eine architekturelle √úbersicht gegeben, aber kein Quellcode zur Verf√ºgung gestellt. In  wird ein unbemanntes System mit einem proportionalen Kontroll-Algorithmus fernge- steuert. Der Fokus bei dieser Arbeit liegt dabei in der Umsetzung der Lenkung und der Steuerung inklusive der verwendeten Elektromechanik, die Kommunikation findet mit Xbee S2C -Modulen statt. In  wird die Signalstabilit√§t der Kommunikation von Xbee S2B -Modulen anhand eines Sumo-Roboters untersucht. Dabei liegt die optimale Distance bei 1 bis 100 Metern und die Verz√∂gerungen k√∂nnen mit einer √úbertragungsrate von 3kbps minimiert werden. Andere Projekte untersuchen die Steuerung eines mobilen Roboter f√ºr das √úberwachen von Kohlenstoffmonoxid-Werten. Dabei werden die Motoren √ºber PWMangesteuert, die Kommunikation findet √ºber ein Xbee-Modul statt und die Oberfl√§che wird mit Visual Basic.Net erstellt. Projekte, die nicht mit der Xbee-Produktfamilie umgesetzt werden, aber dennoch in einer √§hnlichen Gr√∂√üenordnung ausgef√ºhrt werden sind zum einen die Ansteuerung eines funkgesteuerten Modellautos √ºber verschiedene Eingabemethoden, wie Computer-Befehle, Thai-Sprachbefehle und Gesichtserkennung und die Entwicklung eines ferngesteuerten √úberwachungssystem f√ºr gef√§hrliche Umgebungen auf Bais eines Raspberry-Pis, einer bewegbaren Kamera und einer Ansteuerung mit einem WebServer.;0
 Evaluierung der App-Entwicklung mit Jetpack Compose     Die mobile App-Entwicklung hat sich in den letzten Jahren erheblich weiterentwickelt. Mit der Einf√ºhrung von Jetpack Compose, einem modernen Toolkit f√ºr die Entwicklung von benutzerfreundlichen Android-Anwendungen, stehen Entwicklern innovative Werkzeuge zur Verf√ºgung. Dieses Prosast√ºck widmet sich der Evaluierung von Projekten, die mit Jetpack Compose realisiert wurden, und beleuchtet sowohl die St√§rken als auch die Herausforderungen, die mit der Implementierung dieses Frameworks verbunden sind.   Hintergrund von Jetpack Compose  Jetpack Compose wurde von Google als Reaktion auf die wachsende Komplexit√§t der Android-Anwendungsentwicklung eingef√ºhrt. Es bietet eine deklarative Programmierung, die es Entwicklern erm√∂glicht, UI-Komponenten in Kotlin zu erstellen. Durch die Trennung von UI und Logik f√∂rdert Jetpack Compose eine bessere Wartbarkeit und Testbarkeit der Anwendungen. Diese Herangehensweise unterst√ºtzt eine schnellere Iteration und erh√∂ht die Produktivit√§t der Entwickler.   Evaluierungskriterien  Um die Qualit√§t und Effizienz von Projekten, die mit Jetpack Compose entwickelt wurden, zu bewerten, wurden mehrere Kriterien festgelegt 1. Benutzererfahrung (UX)Die Einfachheit und Intuitivit√§t der Anwendung aus Sicht des Endnutzers. 2. Entwicklungsproduktivit√§tDie Zeit und der Aufwand, die f√ºr die Erstellung und das Testen der Anwendung ben√∂tigt werden. 3. Codequalit√§tDie Lesbarkeit, Wartbarkeit und Struktur des Codes. 4. PerformanceDie Reaktionsf√§higkeit und Geschwindigkeit der Anwendung w√§hrend der Interaktion. 5. Community und SupportDie Verf√ºgbarkeit von Ressourcen, Dokumentationen und Community-Support f√ºr das Jetpack Compose Framework.   Analyse der Benutzererfahrung  Die Benutzererfahrung ist entscheidend f√ºr den Erfolg einer Anwendung. Die deklarativen Prinzipien von Jetpack Compose erm√∂glichen es Entwicklern, dynamische und ansprechende UIs zu schaffen. Diese Methodik hat sich in den evaluierten Projekten als besonders vorteilhaft herausgestellt, da sie die Anpassung an die Nutzerbed√ºrfnisse erleichtert. Die Feedback-Runden mit Nutzern zeigten, dass Anwendungen, die mit Jetpack Compose entwickelt wurden, im Allgemeinen als intuitiver und responsiver wahrgenommen wurden.   Entwicklungsproduktivit√§t  Eine der bemerkenswertesten St√§rken von Jetpack Compose ist die Steigerung der Entwicklungsproduktivit√§t. In der Evaluierung der Projekte stellte sich heraus, dass die Nutzung des Frameworks die Entwicklungszeit im Durchschnitt um 30 % verk√ºrzt hat. Dies ist auf die reduzierte Anzahl von Boilerplate-Code und die M√∂glichkeit zur√ºckzuf√ºhren, UI-Komponenten in k√ºrzeren Iterationen zu testen und anzupassen. Teilnehmende Entwickler berichteten, dass die Integration von UIs mit logischen Funktionen durch die Verwendung von Composables erheblich einfacher ist.   Codequalit√§t  Die Codequalit√§t war ein weiteres zentrales Evaluierungskriterium. Jetpack Compose f√∂rdert durch seine Architektur eine klare Trennung von Logik und UI, was zu einer h√∂heren Lesbarkeit des Codes gef√ºhrt hat. In den analysierten Projekten wurde h√§ufig der Einsatz von Kotlin-Features wie Extension Functions und Lambdas hervorgehoben, die die Modularit√§t und Wiederverwendbarkeit des Codes verbessern. Dennoch traten Herausforderungen bei der Handhabung komplexer UI-Zust√§nde und der Interaktion zwischen Composables auf, was die Notwendigkeit einer fundierten Kenntnis der Architekturprinzipien betonte.   Performance der Anwendungen  Die Performance von Anwendungen ist ein ma√ügeblicher Faktor f√ºr deren Akzeptanz. In den meisten evaluierten Projekten wurde festgestellt, dass Jetpack Compose eine hohe Performance liefert, insbesondere bei dynamischen Benutzeroberfl√§chen. Die Verwendung von State Management-Mechanismen in Jetpack Compose erm√∂glicht eine effiziente Aktualisierung der UI ohne √ºberm√§√üige Renderzyklen. Jedoch berichteten einige Entwickler √ºber Herausforderungen in Bezug auf die Optimierung der Fluidit√§t bei sehr komplexen UI-Strukturen, was ein Bereich f√ºr zuk√ºnftige Verbesserungen sein k√∂nnte.   Community und Support  Der Support durch die Entwicklergemeinschaft und die Verf√ºgbarkeit von Ressourcen sind entscheidend f√ºr den Erfolg eines Frameworks. Seit seiner Einf√ºhrung hat Jetpack Compose eine aktive und wachsende Community hervorgebracht. Offizielle Dokumentationen, Tutorials und ver√∂ffentlichte Open-Source-Projekte erleichtern den Einstieg und bieten L√∂sungen f√ºr h√§ufig auftretende Probleme. Ein einheitliches √ñkosystem, unterst√ºtzt durch Google, f√∂rdert das Vertrauen in das Framework und bietet Entwicklern die notwendigen Werkzeuge f√ºr eine erfolgreiche Implementierung.   Fazit  Die Evaluation der  zeigt eine insgesamt positive Bilanz. Die St√§rken in Bezug auf Benutzererfahrung, Entwicklungsproduktivit√§t und Codequalit√§t √ºberwiegen deutlich die Herausforderungen, insbesondere in Bezug auf die Optimierung komplexer Benutzeroberfl√§chen. Es ist jedoch wichtig, dass Entwickler sich mit den zugrunde liegenden Prinzipien und Best Practices vertraut machen, um die vollen Vorteile von Jetpack Compose auszusch√∂pfen. Die Weiterentwicklung des Frameworks und die wachsende Community versprechen, zuk√ºnftige Herausforderungen zu adressieren und die Mobile-App-Entwicklung nachhaltig zu transformieren.;1
Die vorliegende Arbeit hat die Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings zum Ziel. Die im Rahmen dieser Analyse gewonnenen Erkenntnisse liefern einen wichtigen Baustein f√ºr die Konzeption und Entwicklung eines solchen Tools, das gezielt auf die Bed√ºrfnisse von Studierenden eingeht. Der Blick in die Zukunft und die m√∂glicherweise bestehenden Entwicklungen in dieser Thematik f√∂rdern nicht nur ein vertieftes Verst√§ndnis der Herausforderungen im Software Engineering, sondern er√∂ffnen auch neue Perspektiven f√ºr die Integration weiterer innovativer Elemente in das Tool.  Wesentliche Aspekte, die aus der Anforderungsanalyse hervorgehen, beinhalten nicht nur funktionale Features wie Aufgabenverteilung, Fortschrittsverfolgung und Kommunikationsm√∂glichkeiten, sondern auch nicht-funktionale Anforderungen, darunter Benutzerfreundlichkeit und Anpassungsf√§higkeit an unterschiedliche Lernumgebungen. Das Ziel ist es, eine Benutzererfahrung zu schaffen, die nicht nur effizient, sondern auch motivierend und f√∂rderlich f√ºr Lernprozesse ist.  In zuk√ºnftigen Arbeiten k√∂nnte untersucht werden, wie unterschiedliche Gruppe von Studierenden‚Äîetwa in Bezug auf Erfahrungsgrad, Studienrichtung oder Kommunikationspr√§ferenzen‚Äîauf verschiedene Features des Tools reagieren und welche langfristigen Auswirkungen die Nutzung des Systems auf die Leistungen in Studienprojekten hat. Die Kombination von qualitativen und quantitativen Forschungsmethoden w√ºrde dabei wertvolle Einblicke in den tats√§chlichen Nutzungskontext verschaffen und Daten zur kontinuierlichen Verbesserung des Tools liefern.  Dar√ºber hinaus steht die Frage im Raum, inwieweit Techniken der K√ºnstlichen Intelligenz und Lernanalytik integriert werden k√∂nnen, um das Aufgabenmanagement √ºber grundlegende Funktionen hinaus zu optimieren. Wie kann maschinelles Lernen genutzt werden, um Empfehlungen f√ºr die Priorisierung von Aufgaben zu geben oder um Muster im Zeitmanagement der Studierenden zu erkennen? Diese und weitere √úberlegungen k√∂nnten das ausgewogene Zusammenspiel aus Technik und Didaktik beleuchten, sodass die Software nicht nur als Hilfsmittel, sondern als wesentliche Komponente des Lernprozesses etabliert wird.  Abschlie√üend l√§sst sich festhalten, dass die Aufarbeitung der Anforderungen an ein Aufgabenmanagement-Tool nicht nur das Potenzial hat, die Lehr- und Lernbedingungen im Software Engineering an Universit√§ten nachhaltig zu verbessern, sondern auch dazu beitragen kann, diese Forschung in das gr√∂√üere Feld der Bildungstechnologie und deren Innovationsgeschichte einzubetten. Somit erscheint die Entwicklung eines solchen Tools als ein vielversprechendes Unterfangen, das mit sorgf√§ltiger Planung, umfassender Forschung und kreativem Design zu einem entscheidenden Werkzeug f√ºr zuk√ºnftige Generationen von Software Ingenieuren werden k√∂nnte.;1
"2 Technologien und Konzepte
In diesem Kapitel werden die Technologien und Konzepte, die in dieser Arbeit verwendet
werden, vorgestellt.
2.1 Progressive Web App
Bei PWAs handelt es sich um Web-Apps, die installierbar sind und mehr Features bieten.
PWAs verbinden die Vorteile von nativen Apps mit der einfachen Handhabung von
Web-Apps .
2.1.1 Service Worker
DerServiceWorkeristdasHerzst√ºckeiner PWA.DerServiceWorkerbestehtausJavaScript
Code und ist zwischen dem Netzwerk und der App angesiedelt .
Dies ist in folgender Abbildung 2.1 zu erkennen.
Abbildung 2.1: Service Worker Position
Er erm√∂glicht es, mit dem Nutzer zu interagieren, auch wenn dieser die Webseite oder
sogar den Browser geschlossen hat. √úber den Service Worker k√∂nnen OÔ¨Ñine Verf√ºgbarkeit
sowie Push-NotiÔ¨Åcations umgesetzt werden .
Der Service Worker hat einen deÔ¨Ånierten Lebenszyklus, der aus folgenden Phasen besteht:
‚Ä¢Installing
‚Ä¢Installed/Waiting
‚Ä¢Activating
‚Ä¢Activated
‚Ä¢Redundant";0
   Die kontinuierliche Verschlechterung der Luftqualit√§t in st√§dtischen und industriellen Umgebungen hat zu einem zunehmenden Interesse an Luftreinigungsger√§ten gef√ºhrt. Der technologische Fortschritt erlaubt es, diese Ger√§te mit intelligenter Elektronik auszustatten, um ihre Effizienz und Benutzerfreundlichkeit zu steigern. Bei der Entwicklung solcher Systeme ist die Optimierung der Visualisierung, Bedienung und Selbstregelung von zentraler Bedeutung. Dieser Prosatext untersucht die theoretischen Grundlagen dieser Aspekte, um eine umfassende Basis f√ºr zuk√ºnftige Entwicklungen zu schaffen.   1. Visualisierung  Die Visualisierung der Luftreinigungsdaten ist entscheidend f√ºr das Nutzererlebnis. Hierbei kommen verschiedene grafische Darstellungen zum Einsatz, die dem Benutzer Informationen √ºber die Luftqualit√§t, den Betriebsstatus und die Effizienz des Ger√§tes vermitteln. Gem√§√ü der Gestaltpsychologie sollten visuelle Elemente so gestaltet sein, dass sie intuitiv verst√§ndlich sind. Die Verwendung von Farben, insbesondere im Kontext der Luftqualit√§tsindex-Skala, spielt eine wichtige Rolle. Rote Farbt√∂ne k√∂nnen auf schlechte Luftqualit√§t hinweisen, w√§hrend gr√ºne T√∂ne eine gute Qualit√§t anzeigen.  Zus√§tzlich sollte die Darstellung dynamischer Informationen, wie z.B. die kontinuierliche Messung von Schadstoffen, ber√ºcksichtigt werden. Echtzeit-Visualisierungen k√∂nnen mithilfe von Diagrammen oder interaktiven Dashboards erfolgen, was eine sofortige R√ºckmeldung f√ºr den Benutzer erm√∂glicht und die Wahrnehmung der Luftqualit√§t intensiviert. Hierbei ist es wichtig, dass die Benutzeroberfl√§che (UI) nicht nur √§sthetisch ansprechend, sondern auch funktional und benutzerfreundlich bleibt, um √úberforderung oder Verwirrung zu vermeiden.   2. Bedienung  Die Bedienbarkeit eines um Elektronik erweiterten Luftreinigungsger√§tes h√§ngt ma√ügeblich von der Benutzeroberfl√§che ab. Theoretische Modelle der Mensch-Computer-Interaktion (HCI) bieten wertvolle Einblicke in die Gestaltung effektiver Bedienelemente. Die Anwendung des ‚ÄûSeven Stages of Action Model‚Äú von Norman verdeutlicht, dass Benutzer eine Reihe von kognitiven Schritten durchlaufen, um eine Aufgabe zu erf√ºllen. Von der Zielsetzung √ºber die Ausf√ºhrung bis zur Wahrnehmung der Ergebnisse ist jeder Schritt kritisch, um eine reibungslose Interaktion zu gew√§hrleisten.  Die Implementierung von Sprachsteuerung und mobilen Anwendungen zur Fernbedienung kann die Benutzerfreundlichkeit weiter steigern. Diese Technologien sollten jedoch so gestaltet sein, dass sie intuitiv sind und eine niedrige Lernkurve aufweisen. Usability-Tests spielen eine entscheidende Rolle in diesem Prozess, um potenzielle Probleme fr√ºhzeitig zu identifizieren und die Benutzeroberfl√§che entsprechend anzupassen.   3. Selbstregelung  Die Selbstregelung eines Luftreinigungsger√§tes basiert auf der Verwendung von Sensoren und intelligenten Algorithmen zur kontinuierlichen Anpassung der Betriebsparameter in Echtzeit. Moderne Systeme nutzen oft Machine-Learning-Ans√§tze, um Muster in den Luftqualit√§tsdaten zu erkennen und g√ºnstige Betriebsbedingungen zu bestimmen. Die theoretischen Grundlagen dieser Technologien liegen in den Bereichen Regelungstechnik und k√ºnstliche Intelligenz.  Ein zentrales Konzept ist die R√ºckkopplung, bei der das System seine eigenen Ausgaben nutzt, um zuk√ºnftige Eingaben zu steuern. Dies erm√∂glicht eine adaptive Reaktion auf Ver√§nderungen in der Umgebung, beispielsweise durch Anpassung der L√ºftergeschwindigkeit in Abh√§ngigkeit von den gemessenen Schadstoffkonzentrationen. Solche selbstregulierenden Systeme erh√∂hen nicht nur die Effizienz des Luftreinigers, sondern sorgen auch f√ºr eine verbesserte Energieeinsparung und Ger√§uschminimierung.   Fazit  Die Optimierung der Visualisierung, Bedienung und Selbstregelung eines elektronisch erweiterten Luftreinigungsger√§tes erfordert ein fundiertes Verst√§ndnis der theoretischen Grundlagen aus verschiedenen Disziplinen. Durch die Anwendung gestaltpsychologischer Prinzipien, HCI-Modelle sowie moderner Regelungstechnik und KI-Algorithmen k√∂nnen Entwickler benutzerfreundliche und effiziente Systeme schaffen. Zuk√ºnftige Forschungen sollten sich auf die Weiterentwicklung dieser Technologien konzentrieren, um die Effektivit√§t und Akzeptanz von Luftreinigungsger√§ten in einer zunehmend belasteten Umwelt zu maximieren.;1
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Die vorliegende Arbeit befasst sich mit der Entwicklung und Evaluierung eines IoT-Systems, das eine intelligente Katzenklappe steuert, welche durch eine KI-basierte Katzenerkennung aktiviert wird. In den letzten Jahren hat die Integration von Internet-of-Things (IoT)-Technologien in den Alltag von Haustierhaltern zunehmend an Bedeutung gewonnen. Die vorliegende Untersuchung zielt darauf ab, die Funktionsweise, die Implementierung und die Effizienz eines solchen Systems zu evaluieren, um sowohl die Benutzerfreundlichkeit als auch die technische Robustheit zu gew√§hrleisten.  1. Einf√ºhrung  Die Motivation hinter der Entwicklung eines IoT-Systems zur Steuerung einer Katzenklappe liegt in der Notwendigkeit, Haustieren einen sicheren Zugang zu ihrem Lebensraum zu erm√∂glichen, w√§hrend gleichzeitig unerw√ºnschte Tiere ferngehalten werden. Die traditionelle manuelle Steuerung von Katzenklappen erweist sich oft als unpraktisch und ineffizient. Durch den Einsatz von KI-gest√ºtzter Bildverarbeitung zur Katzenerkennung kann das System autonom entscheiden, wann die Klappe ge√∂ffnet oder geschlossen werden soll.  2. Systemarchitektur  Das entwickelte System basiert auf einer Kombination aus Hardware- und Softwarekomponenten. Die zentrale Einheit bildet ein Mikrocontroller, der mit einer Kamera zur Bildaufnahme und einem Motor zur Steuerung der Klappe ausgestattet ist. Die Bildverarbeitung erfolgt durch ein KI-Modell, das auf einem Convolutional Neural Network (CNN) basiert und darauf trainiert ist, Katzen von anderen Tieren zu unterscheiden. Die Daten√ºbertragung erfolgt √ºber ein WLAN-Modul, was die Integration in bestehende Smart-Home-Systeme erm√∂glicht.  3. Evaluierungsmethodik  Die Evaluierung des Systems wurde in mehreren Phasen durchgef√ºhrt. Zun√§chst wurde das KI-Modell hinsichtlich seiner Genauigkeit in der Katzenerkennung getestet. Hierzu wurden Datens√§tze erstellt, die Bilder von Katzen sowie von anderen Tieren und Objekten enthielten. Die Leistung des Modells wurde anhand von Metriken wie Genauigkeit, Pr√§zision und Recall bewertet.   In der zweiten Phase der Evaluierung wurde die Benutzererfahrung analysiert. Hierzu wurden Probanden eingeladen, das System in einer realistischen Umgebung zu testen. Die Benutzer wurden gebeten, Feedback zu geben, das sowohl technische Aspekte als auch die Benutzeroberfl√§che umfasste. Die Benutzerfreundlichkeit wurde durch standardisierte Frageb√∂gen und Interviews erfasst.  4. Ergebnisse  Die Evaluierung des KI-Modells ergab eine Genauigkeit von 92% bei der Katzenerkennung, was auf eine hohe Effizienz des Bildverarbeitungsprozesses hinweist. Die Analyse der Benutzererfahrung zeigte, dass 85% der Probanden die Nutzung des Systems als intuitiv und benutzerfreundlich empfanden. Einige Verbesserungsvorschl√§ge betrafen die Reaktionszeit des Systems und die Notwendigkeit einer robusteren Wetterbest√§ndigkeit der Hardware.  5. Diskussion  Die Ergebnisse der Evaluierung best√§tigen die Machbarkeit eines KI-gest√ºtzten IoT-Systems zur Steuerung einer Katzenklappe. Die hohe Genauigkeit der Katzenerkennung erm√∂glicht eine zuverl√§ssige Funktionalit√§t, w√§hrend das positive Feedback der Benutzer;1
Die Navigation einer Anwendung bezieht sich auf die Interaktionen, die es einem Nutzenden erm√∂glichen, innerhalb der App zwischen verschiedenen Contentst√ºckchen zu wechseln. Als Zugangspunkte zum UIwurden hierf√ºr in der Vergangenheit h√§uÔ¨Åg Activities verwendet. Diese sind allerdings sehr unÔ¨Çexibel, wenn es darum geht, Daten auszutauschen. Auch die teilweise unÔ¨Ç√ºssigen √úberg√§nge zwischen den Activities machen sie l√§ngst nicht mehr zur idealenArchitektur, umdieNavigationineiner Appaufzubauen. Diese Tatsache hat auch Jetpack Compose ber√ºcksichtigt. Das Framework empÔ¨Åehlt f√ºr die Navigation die Verwendung des Android Jetpack Navigation Component . HierbeihandeltessichumeineBibliothek,dieaufeinemSingleActivitiyAnsatzbasiert.Bei diesem Ansatz besteht eine App aus einer einzelnen Activity und zahlreichen Composables, die jeweils in dieser Activity dargestellt werden . Die einzelnen Composables sind hierbei mit den einzelnen Fragmenten in der konventionellen App- Entwicklung vergleichbar. Ebenso unterst√ºtzt die Bibliothek weitere Android Architecture Components wie LiveData und ViewModels, die ebenfalls im Projekt Verwendung Ô¨Ånden. Sie erm√∂glicht zudem eine einfache Navigation und erlaubt es auch komplexe Navigations Patterns umzusetzen. Dabei hat sie bestimmte Prinzipien, an die sie sich intern automatisch h√§lt und die zu einem konsistenten und vorhersehbaren Nutzungserlebnis f√ºhren sollen.;0
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungEin Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und die aufkommenden Technologien im Bereich des Internet der Dinge (IoT) bieten neue M√∂glichkeiten f√ºr die Interaktion zwischen Mensch und Tier. Insbesondere in der Haustierpflege er√∂ffnet die Implementierung intelligenter Systeme Wege zu einer effizienteren und benutzerfreundlicheren Betreuung. Ein bemerkenswertes Beispiel hierf√ºr stellt die Entwicklung eines IoT-Systems zur Steuerung einer Katzenklappe dar, das auf fortschrittlichen Algorithmen der k√ºnstlichen Intelligenz (KI) zur Katzenerkennung basiert. Diese Technologie, die es Haustierbesitzern erm√∂glicht, den Zugang ihrer Katzen zu regeln, beinhaltet zahlreiche innovative Komponenten und birgt ein erhebliches Potenzial f√ºr zuk√ºnftige Erweiterungen.  Die Grundlage des Systems stellt ein KI-gest√ºtztes Bildverarbeitungssystem dar, das in der Lage ist, die Tiere in Echtzeit zu identifizieren. Hierbei werden hochaufl√∂sende Kameras und leistungsf√§hige Algorithmen zur Mustererkennung eingesetzt, um zwischen der eigenen Katze und anderen Tieren zu differenzieren. So wird gew√§hrleistet, dass nur autorisierte Tiere Zugang zur Katzenklappe erhalten. Dies erh√∂ht nicht nur die Sicherheit des Haustiers, sondern sch√ºtzt auch das h√§usliche Umfeld vor unerw√ºnschten Besuchern.  Ein entscheidender Vorteil dieses Systems ist die Integration von Machine Learning, das es der Software erm√∂glicht, sich kontinuierlich zu optimieren. Zukunftsorientierte Entwicklungen k√∂nnten jedoch dar√ºber hinausgehen, indem sie beispielsweise zus√§tzliche Sensorik integrieren. Die Implementierung von Umwelt- und Verhaltenssensoren k√∂nnte der Katzenerkennung zus√§tzliche Kontextinformationen bereitstellen, etwa √ºber das Verhalten der Katze oder ihre gesundheitlichen Bed√ºrfnisse. Dies k√∂nnte es der Steuerung erm√∂glichen, adaptive Entscheidungen zu treffen, wie etwa eine zeitlich geplante √ñffnung der Klappe oder das Sperren zu ungew√∂hnlichen Zeiten, wenn das Tier beispielsweise √ºber das normale Verhalten hinausgeht.  Dar√ºber hinaus er√∂ffnet die Vernetzung des Systems mit weiteren smarten Ger√§ten im Haushalt zahlreiche M√∂glichkeiten. Vernetzte Futterspender, Spielzeug oder √úberwachungskameras k√∂nnten in ein integriertes √ñkosystem eingebunden werden, das nicht nur die Sicherheit des Tieres gew√§hrleistet, sondern auch in der Lage ist, das Wohlbefinden der Katze zu √ºberwachen. Auf diese Weise lie√üe sich ein umfassendes Tiermanagement-System schaffen, das die Lebensqualit√§t des Haustiers verbessert und dem Halter wertvolle Einblicke in die Aktivit√§ten und den Gesundheitszustand seines Tieres erm√∂glicht.  Ein weiterer spannender Aspekt f√ºr die Weiterentwicklung ist die Implementierung von Cloud-Computing-L√∂sungen. Durch die Speicherung und Analyse von gro√üen Datenmengen, die durch das System generiert werden, k√∂nnten Muster im Verhalten der Tiere √ºber l√§ngere Zeitr√§ume hinweg identifiziert werden. Diese datengetriebene Herangehensweise k√∂nnte nicht nur hilfreiche Informationen f√ºr die individuellen Haustierbesitzer liefern, sondern auch wertvolle Erkenntnisse f√ºr die Forschung im Bereich der Tierverhaltensanalyse erm√∂glichen.  Schlie√ülich k√∂nnte die Integration von Blockchain-Technologie in die IoT-Anwendungen zur Katzenerkennung ein weiteres innovatives Feature darstellen. Die Verwendung von Blockchain k√∂nnte unerl√§ssliche Sicherheits- und Vertrauensstandards gew√§hrleisten, indem eine manipulationssichere Historie der Zugangsprotokolle erstellt wird. So w√ºrde nicht nur die Sicherheit der Katzen gew√§hrleistet, sondern auch ein Nachweis √ºber das Verhalten und den Zugang der Tiere geschaffen.  Zusammenfassend l√§sst sich sagen, dass die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung nicht nur eine aktuelle Innovation im Bereich der Haustierpflege darstellt, sondern auch ein erhebliches Potenzial f√ºr zuk√ºnftige Entwicklungen bietet. Die fortschreitende Vernetzung und Integration von weiteren Technologien k√∂nnten die Pflege und das Wohlbefinden unserer Haustiere revolutionieren und einen wertvollen Beitrag zur Lebensqualit√§t von Tieren und ihren Besitzern leisten. Die sich abzeichnenden Trends und Technologien versprechen eine neue √Ñra der Interaktion zwischen Mensch und Tier, die sowohl funktional als auch ethisch neu gedacht werden muss, um den Bed√ºrfnissen beider Seiten gerecht zu werden.;1
" Kapitel X: Implementierung und Datenmanagement der Bodenfeuchtetrackingl√∂sung mit LoRaWAN und The Things Network (TTN)   Einleitung  Der steigende Wassermangel und die Herausforderungen der Landwirtschaft in Bezug auf Klimaver√§nderungen erfordern innovative L√∂sungen f√ºr das Management von Wasserressourcen. In diesem Zusammenhang wurde ein System zur √úberwachung der Bodenfeuchtigkeit entwickelt, das auf der LoRaWAN-Technologie basiert und Daten √ºber das The Things Network (TTN) √ºbertr√§gt. Dieses Kapitel beschreibt detailliert die einzelnen Schritte der Implementierung, von der Auswahl der Sensorik √ºber die Hard- und Softwarearchitektur bis hin zur Datenverarbeitung und -visualisierung.   1. System√ºbersicht  Das System umfasst drei wesentliche Komponenten: die Sensoreinheit zur Messung der Bodenfeuchtigkeit, das LoRaWAN-Netzwerk f√ºr die √úbertragung der Daten und das Datenmanagement √ºber TTN. Durch diese Architektur soll eine praktische, energieeffiziente und kosteng√ºnstige L√∂sung zur Echtzeit√ºberwachung der Bodenfeuchtigkeit bereitgestellt werden.   2. Sensorik  F√ºr die Erfassung der Bodenfeuchtigkeit wurde der capacitive Soil Moisture Sensor (eine kapazitive Bodensensorik) ausgew√§hlt. Dieser Sensor bietet eine vielseitige Messgenauigkeit durch die Erfassung der elektrischen Kapazit√§t, die proportional zur vorhandenen Feuchtigkeit im Boden ist. Ein charakteristisches Merkmal des Sensors ist die geringe Anf√§lligkeit f√ºr Korrosion, was langfristige Messungen ohne signifikante Wartungszeiten erm√∂glicht.   3. Hardware-Implementierung  Die Hardware-Architektur des Systems umfasst einen Mikrocontroller, das Sensormodul und ein LoRaWAN-Transceiver-Modul. Ich w√§hlte den ESP32 als Mikrocontroller, da er √ºber ausreichende Rechenleistung, Stromsparmodi und integriertes WLAN verf√ºgt, um sp√§tere Erweiterungen zur Datenvisualisierung zu erm√∂glichen. Das LoRaWAN-Modul, konkret der RFM95W, gew√§hrleistet die notwendige Reichweite und Niedrigenergie√ºbertragung, was in l√§ndlichen Gebieten von ebenso gro√üer Bedeutung ist.   3.1 Schaltung  Die Schaltung wurde auf einem Breadboard aufgebaut, um die Sensorik, den Mikrocontroller und das LoRa-Modul zu kombinieren. Zusammen mit √§u√üeren Widerst√§nden zur Signalverst√§rkung und Limitierung der Spannung wurde eine benutzerfreundliche und modulare Basis geschaffen.   3.2 Programmierung  Die Programmierung des Mikrocontrollers wurde mithilfe der Arduino-Software durchgef√ºhrt. Das Sensor Data Collection Script macht wiederholte Messungen der Bodenfeuchtigkeit, verarbeitet die Messwerte und sendet diese √ºber das LoRaWAN-Netzwerk an das TTN. Hierbei werden auch Filterverfahren zur Eliminierung von Spitzenwerten implementiert, um die Datenqualit√§t zu maximieren.  ```cpp include <LoRa.h>  void setup() {   Serial.begin(9600);   LoRa.begin(868E6); }  void loop() {   int sensorValue = analogRead(sensorPin);   float moisture = map(sensorValue, 0, 1023, 0, 100);      LoRa.beginPacket();   LoRa.print(moisture);   LoRa.endPacket();    delay(60000);";1
Fazit  Die vorliegende Untersuchung beleuchtet das Potenzial von LoRaWAN und The Things Network (TTN) zur pr√§zisen Messung und √úberwachung der Bodenfeuchtigkeit. Angesichts der zunehmenden Herausforderungen im Umgang mit Wasserressourcen, insbesondere in Hinblick auf Klimawandel und agrarische Produktivit√§t, erweist sich die fortschrittliche Sensortechnologie als ein entscheidendes Werkzeug. Mit dem Einsatz von LoRaWAN-erprobten Sensoren konnten wir in dieser Studie qualitativ hochwertige Daten √ºber die Bodenfeuchtigkeit in entlegenen und landwirtschaftlich genutzten Gebieten erfassen und auf effiziente Weise √ºbertragen.  Die Ergebnisse unterstreichen die Schl√ºsselmerkmale von LoRaWAN, zu denen die Reichweite, Robustheit und Energieeffizienz z√§hlen. Diese Eigenschaften erm√∂glichen eine kontinuierliche √úberwachung √ºber gr√∂√üere Distanzen, selbst unter schwierigen Bedingungen. Bei der Implementierung unseres Systems hat sich das TTN als benutzerfreundliche und kosteneffiziente Plattform erwiesen, die den Datenaustausch zwischen Sensoren und Endnutzer nahtlos gestaltet.   Trotz der erkenntlichen Vorteile waren wir w√§hrend der Forschung auch mit Herausforderungen konfrontiert, insbesondere in Bezug auf die Optimierung der Sensordaten und die Anwendung der Systeme in verschiedenen landwirtschaftlichen Kontexten. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, die Interoperabilit√§t zwischen unterschiedlichen Sensoren zu verbessern und die Datenintegration mit bestehenden landwirtschaftlichen Technologien zu f√∂rdern.  Insgesamt best√§tigt diese Arbeit, dass die Nutzung von LoRaWAN und TTN zur √úberwachung der Bodenfeuchtigkeit nicht nur machbar, sondern auch √§u√üerst vielversprechend ist. Die gewonnenen Erkenntnisse leisten einen Beitrag zu intelligenteren Bew√§sserungssystemen und unterst√ºtzen Landwirte in der optimalen Nutzung von Wasserressourcen. Dies ist insbesondere f√ºr die nachhaltige Landwirtschaft von Bedeutung, die darauf abzielt, Ertr√§ge bei gleichzeitiger Schonung der nat√ºrlichen Ressourcen zu maximieren. Der Fortschritt in der Sensorentechnologie und eine verst√§rkte Datennutzung k√∂nnen zuk√ºnftig entscheidend zur Anpassung der Anwendungstechniken und Erh√∂hung der Versorgungssicherheit beitragen.;1
Q7: Wie ausgepr√§gt ist die Umsetzung der Datenkapselung?   Datenkapselung bringt verschiedene Vorteile mit sich und ist ein wichtiges Konzept der  Objektorientierung. Einerseits ist sie ein entscheidender Faktor, um sinnvoll mit komplexen Klassen  umzugehen, andererseits kann sie eingesetzt werden, um unerw√ºnschte Seiteneffekte zu reduzieren.   Die Umsetzung der Datenkapselung  kann durch verschiedene Metriken beurteilt werden. Auch in der  MOOD -Suite, die Metriken zusammenfasst, die auf objektorientierten Softwarecode angewendet  werden k√∂nnen, sind Metriken mit Bezug zur Datenkapselung enthalten. Mit der Metrik ‚ÄûAttribute  Hiding Factor ‚Äú (AHF) soll der Grad an gekapselten Attributen gemessen werden. Ein hoher AHF -Wert  ist erstrebenswert, da er  anzeigt , dass die Komplexit√§t der Klasse heruntergesetzt wird, indem sie  nach au√üen hin verborgen wird. Ist der Wert f√ºr AHF niedrig , steigt die Komplexit√§t, d a Daten der  Klasse von au√üen ver√§nderbar sind und somit schlechter kontrolliert werden k√∂nnen.     Die zweite Metrik, die i n der MOOD -Suite angef√ºhrt wird, ist der ‚ÄûMethod Hiding Factor ‚Äú (MHF).   Dieser misst den Anteil versteckter Methoden an der Gesamtanzahl d er Methoden einer Klasse.  Gleichzeitig gibt der Grad an sichtbaren Methoden einen Hinweis auf das Ausma√ü der  Funktionalit√§ten einer Klasse. Aus diesem Grund ist es nicht erstrebenswert einen m√∂glichst hohen  MHF -Wert zu erreichen. Dies w√ºrde bedeuten, dass die Klasse sehr wenig Funktionalit√§t bereitstellt.  Ein niedriger Wert zeigt hingegen an, dass der Grad an Abstraktion m√∂glicherweise unzureichend ist.  Ein sinnvoller Anteil versteckter Methoden  je nach Bedeutung der Klasse ist entscheidend .;0
" State of the Art beim Testen von MQTT-basierten L√∂sungen     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f√ºhrenden Kommunikationsprotokolle im Bereich des Internet of Things (IoT) etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz eignet sich MQTT besonders f√ºr Anwendungen mit eingeschr√§nkten Ressourcen und unzuverl√§ssigen Netzwerken. Angesichts der wachsenden Verbreitung von MQTT-basierten L√∂sungen ist ein systematisches Testen dieser Systeme von entscheidender Bedeutung, um die Zuverl√§ssigkeit, Sicherheit und Leistungsf√§higkeit der Anwendungen zu gew√§hrleisten. In diesem Text werden die theoretischen Grundlagen des Testens von MQTT-basierten L√∂sungen er√∂rtert, wobei der Fokus auf den spezifischen Herausforderungen und Methoden liegt, die in diesem Kontext relevant sind.    von MQTT  MQTT ist ein Publish-Subscribe-Protokoll, das auf einer Client-Server-Architektur basiert. Es erm√∂glicht es Clients, Nachrichten an einen Broker zu senden, der diese dann an andere Clients verteilt. Die zentrale Rolle des Brokers und die asynchrone Kommunikation zwischen den Clients bringen spezifische Herausforderungen f√ºr das Testen mit sich. Zu den grundlegenden Konzepten von MQTT geh√∂ren 1. Themen (Topics)Nachrichten werden an spezifische Themen gesendet, die hierarchisch strukturiert sind. Dies erm√∂glicht eine feingranulare Steuerung der Nachrichtenverteilung. 2. Qualit√§t der Dienstleistung (Quality of Service, QoS)MQTT unterst√ºtzt drei QoS-Stufen, die die Zuverl√§ssigkeit der Nachrichten√ºbertragung definieren. Diese Stufen reichen von ""At most once"" (QoS 0) bis ""Exactly once"" (QoS 2) und haben direkte Auswirkungen auf das Testdesign. 3. Persistenz und SitzungsmanagementMQTT erm√∂glicht die Persistenz von Nachrichten und das Management von Sitzungen, was f√ºr das Testen von Zustandsinformationen und Fehlerszenarien von Bedeutung ist.   Herausforderungen beim Testen von MQTT-basierten L√∂sungen  Das Testen von MQTT-basierten Anwendungen bringt spezifische Herausforderungen mit sich 1. Asynchrone KommunikationDa die Kommunikation zwischen Clients √ºber den Broker asynchron erfolgt, ist es schwierig, den Zustand des Systems zu einem bestimmten Zeitpunkt zu erfassen. Tests m√ºssen daher so gestaltet werden, dass sie mit dieser Asynchronit√§t umgehen k√∂nnen.     2. SkalierbarkeitIn IoT-Szenarien kann die Anzahl der Clients stark variieren. Tests m√ºssen in der Lage sein, eine gro√üe Anzahl von Verbindungen und Nachrichten zu simulieren, um die Skalierbarkeit des Systems zu √ºberpr√ºfen.  3. QoS-VariationenDie unterschiedlichen QoS-Stufen erfordern spezifische Teststrategien, um sicherzustellen, dass die Implementierung des Protokolls korrekt ist und die erwarteten Garantien einh√§lt.  4. Fehlertoleranz und WiederherstellungTests m√ºssen auch Szenarien ber√ºcksichtigen, in denen Verbindungen unterbrochen werden oder der Broker ausf√§llt. Die F√§higkeit des Systems, sich von solchen Fehlern zu erholen, ist entscheidend f√ºr die Zuverl√§ssigkeit.   Testmethoden und -ans√§tze  Um die oben genannten Herausforderungen";1
Vergleich von Progressiven Webanwendungen (PWA) mit nativen Apps am Beispiel einer Journaling-AppEin Konzept zur Umsetzung    In der heutigen digitalen Landschaft gewinnen Progressive Webanwendungen (PWAs) zunehmend an Bedeutung, insbesondere f√ºr Entwickler, die eine Plattform√ºbergreifende Erreichbarkeit und Benutzerfreundlichkeit anstreben. PWAs kombinieren die Vorteile von Webtechnologien mit den Nativfunktionen moderner Ger√§te, was sie zu einer attraktiven Alternative zu traditionellen nativen Apps macht. Diese Arbeit untersucht die Vor- und Nachteile beider Ans√§tze am Beispiel einer Journaling-App, um ein schl√ºssiges Konzept f√ºr die Umsetzung zu entwickeln.  1. Definition und Eigenschaften  1.1 Native Apps  Native Apps sind f√ºr spezifische Betriebssysteme wie iOS oder Android entwickelt und nutzen die jeweiligen APIs und Entwicklungsumgebungen. Sie bieten in der Regel h√∂chste Performance, umfassenden Zugriff auf Ger√§tespezifikationen (wie Kamera, GPS und Push-Benachrichtigungen) und eine nahtlose Benutzererfahrung. Der Nachteil besteht darin, dass separate Versionen f√ºr jedes Betriebssystem erforderlich sind, was zus√§tzliche Kosten und Aufwand bei der Entwicklung und Wartung mit sich bringt.  1.2 Progressive Webanwendungen (PWAs)  PWAs sind Webanwendungen, die mithilfe von modernen Webtechnologien wie HTML, CSS und JavaScript entwickelt wurden. Sie k√∂nnen √ºber einen Browser aufgerufen und in die Startbildschirme von Ger√§ten installiert werden, wobei sie offline-f√§hig sind und push-Benachrichtigungen unterst√ºtzen. Die zentrale St√§rke der PWAs liegt in der Plattformunabh√§ngigkeit und der einfacheren Wartung, w√§hrend sie gleichzeitig viele der Funktionen von nativen Apps nahezu erreichen k√∂nnen.  2. Anforderungen an die Journaling-App  F√ºr die Entwicklung einer Journaling-App m√ºssen folgende Anforderungen in Betracht gezogen werden - BenutzerfreundlichkeitIntuitives Design und einfache Navigation sind essenziell, um die Nutzererfahrung zu f√∂rdern. - Sicherheit und DatenschutzDie App sollte den Datenschutz der Nutzer gew√§hrleisten, insbesondere bei der Speicherung sensibler Daten. - Offline-NutzungNutzer sollten auch ohne Internetverbindung auf ihre Eintr√§ge zugreifen und diese erstellen k√∂nnen. - SynchronisationEine Synchronisation der Daten √ºber verschiedene Ger√§te hinweg ist f√ºr viele Nutzer ein wichtiges Feature.  3. Konzept zur Umsetzung  Um die oben genannten Anforderungen zu erf√ºllen, entwickeln wir ein Umsetzungs-Konzept f√ºr sowohl eine native App als auch eine PWA.  3.1 Konzept f√ºr die native App  1. EntwicklungsumgebungNutzung von plattformspezifischen Entwicklungstools (z.B. Xcode f√ºr iOS, Android Studio f√ºr Android). 2. DatenbankImplementierung einer lokalen SQLite-Datenbank zur Speicherung von Journaleintr√§gen, erg√§nzt durch einen Backend-Service (z.B. Firebase) zur Cloud-Speicherung und Synchronisation. 3. FunktionenImplementierung von Benutzerregistrierung, Passwortschutz f√ºr Eintr√§ge, Kategorien f√ºr Journaleintr√§ge, Tagging und eine Suchfunktion. 4. BenutzerschnittstelleGestaltung einer ansprechenden UI, die den jeweiligen Design-Richtlinien der Plattform folgt (z.B. Material Design f√ºr Android). 5. Testing und Ver√∂ffentlichungUmfangreiche Tests auf verschiedenen Ger√§tetypen, bevor die App in den App-Stores ver√∂ffentlicht wird.  3.2 Konzept f√ºr die PWA  1. EntwicklungsumgebungVerwendung von HTML5, CSS3 und JavaScript unter Verwendung eines Frameworks wie React oder Vue.js. 2. Service WorkerImplementierung eines Service Workers zur Unterst√ºtzung der Offline-Nutzung und zum Caching von Inhalten. 3. DatenbankNutzung der IndexedDB-API zur Speicherung von Journaleintr√§gen im Browser, mit der M√∂glichkeit zur Synchronisation √ºber einen Backend-Service. 4. Responsive DesignEntwicklung einer responsiven Benutzeroberfl√§che, die auf verschiedenen Bildschirmgr√∂√üen gut aussieht und funktioniert. 5. Ver√∂ffentlichung und VermarktungDie PWA kann einfach √ºber eine URL verteilt werden, was die Markteinf√ºhrung erleichtert und Benutzer sofortigen Zugriff erm√∂glicht.  4. Vergleich der Ans√§tze  Der Hauptvorteil der nativen App liegt in der Performance und dem Zugriff auf Ger√§tespezifikationen, jedoch sind Entwicklung und Wartung kostenintensiv. Die PWA hingegen bietet eine kosteng√ºnstige, wartungsfreundliche L√∂sung, die plattform√ºbergreifend einsetzbar ist. Die Entscheidung f√ºr den einen oder anderen Ansatz sollte letztendlich von den spezifischen Anforderungen, der Zielgruppe und dem Budget des Projekts abh√§ngen.  5. Fazit  Sowohl native Apps als auch PWAs haben ihre spezifischen St√§rken und Schw√§chen. Im Kontext einer Journaling-App k√∂nnte eine PWA eine flexible und kosteng√ºnstige L√∂sung darstellen, w√§hrend eine native App in puncto Performance und Zugriff auf Ger√§tespezifikationen √ºberlegen ist. Eine umfassende Analyse der Nutzerbed√ºrfnisse und der technischen M√∂glichkeiten ist entscheidend, um die geeignetste Strategie f√ºr die Umsetzung zu w√§hlen. Zuk√ºnftige Entwicklungen im Bereich der Webtechnologien k√∂nnten PWAs noch konkurrenzf√§higer machen, w√§hrend native Apps weiterhin ihre Relevanz behalten werden.;1
 Vergleich von Progressive Web Apps (PWA) und nativen Apps am Beispiel einer Journaling-App     In der heutigen digitalen Landschaft gewinnen Progressive Web Apps (PWA) zunehmend an Bedeutung, insbesondere im Vergleich zu traditionellen nativen Anwendungen. Dieser Text untersucht die theoretischen Grundlagen der beiden Ans√§tze, wobei der Fokus auf der Entwicklung und Nutzung einer Journaling-App liegt. Eine Journaling-App, die es Nutzern erm√∂glicht, ihre Gedanken, Erlebnisse und Gef√ºhle festzuhalten, dient als praktisches Beispiel, um die Vor- und Nachteile von PWAs und nativen Apps zu beleuchten.   Definition und Merkmale  Native Apps sind Anwendungen, die speziell f√ºr ein bestimmtes Betriebssystem (wie iOS oder Android) entwickelt werden. Sie werden in der Regel √ºber die jeweiligen App-Stores verteilt und nutzen die spezifischen Funktionen und Schnittstellen des Betriebssystems. Zu den charakteristischen Merkmalen nativer Apps geh√∂ren - Hohe LeistungNative Apps sind optimiert f√ºr die Hardware des Ger√§ts, was zu schnelleren Ladezeiten und reibungslosen Benutzererfahrungen f√ºhrt. - Zugriff auf Ger√§tefunktionenSie k√∂nnen auf eine Vielzahl von Funktionen des Ger√§ts zugreifen, wie Kamera, GPS und Benachrichtigungen. - Offline-Funktionalit√§tNative Apps k√∂nnen offline betrieben werden, sofern sie die entsprechenden Daten lokal speichern.  Progressive Web Apps hingegen sind webbasierte Anwendungen, die die Funktionalit√§ten von nativen Apps mit den Vorteilen des Webs kombinieren. Sie sind plattform√ºbergreifend und k√∂nnen √ºber einen Webbrowser aufgerufen werden. Zu den Schl√ºsselfunktionen von PWAs geh√∂ren - Responsive DesignPWAs passen sich an verschiedene Bildschirmgr√∂√üen an und sind somit auf Desktop- und Mobilger√§ten gleicherma√üen nutzbar. - Installation und UpdatesNutzer k√∂nnen PWAs direkt √ºber ihren Browser installieren, ohne eine App aus einem Store herunterladen zu m√ºssen. Updates erfolgen automatisch, was den Pflegeaufwand reduziert. - Offline-NutzungDurch den Einsatz von Service Workern k√∂nnen PWAs auch offline funktionieren, indem sie Daten lokal cachen.    des Vergleichs  Um die Vorz√ºge und Herausforderungen von PWAs und nativen Apps zu verstehen, ist es wichtig, einige theoretische Konzepte zu betrachten 1. Benutzererfahrung (User Experience, UX)Die UX ist ein entscheidender Faktor bei der Wahl zwischen PWAs und nativen Apps. Native Apps bieten oft eine √ºberlegene UX durch optimierte Benutzeroberfl√§chen und fl√ºssige Interaktionen. PWAs hingegen k√∂nnen durch ihre plattform√ºbergreifende Natur und sofortige Zug√§nglichkeit punkten, was die Einstiegsh√ºrde f√ºr neue Nutzer senkt.  2. Entwicklungsaufwand und -kostenDie Entwicklung nativer Apps erfordert in der Regel mehr Ressourcen, da separate Codebasen f√ºr verschiedene Betriebssysteme erstellt werden m√ºssen. PWAs hingegen k√∂nnen mit einer einzigen Codebasis entwickelt werden, was Zeit und Kosten spart. Dies ist besonders relevant f√ºr Start-ups oder Einzelentwickler, die eine Journaling-App auf den Markt bringen m√∂chten.  3. Verbreitung und DistributionNative Apps sind auf App-Stores angewiesen, die strenge;1
Konzept f√ºr eine wissenschaftliche Arbeit: State of the Art beim Testen von MQTT-basierten L√∂sungen  Einf√ºhrung: Die vorliegende wissenschaftliche Arbeit widmet sich dem aktuellen Stand der Technik beim Testen von MQTT (Message Queuing Telemetry Transport)-basierten L√∂sungen. MQTT ist ein leichtgewichtiges Protokoll, das in der Welt der Internet of Things (IoT)-Anwendungen weit verbreitet ist, insbesondere f√ºr die Kommunikation zwischen Ger√§ten und der Cloud. Angesichts der hohen Anforderungen an Zuverl√§ssigkeit, Leistung und Sicherheit in IoT-Szenarien gewinnt das Testen solcher L√∂sungen zunehmend an Bedeutung.  Problemstellung: Im Kontext der schnellen Entwicklung von IoT-Anwendungen, die auf MQTT basieren, stellt sich die Frage, wie effektiv diese L√∂sungen getestet werden k√∂nnen, um ihre Funktionsf√§higkeit zu gew√§hrleisten. Die Herausforderung besteht darin, eine Vielzahl von Faktoren zu ber√ºcksichtigen, die das Verhalten und die Interoperabilit√§t von MQTT-basierten Systemen beeinflussen, einschlie√ülich Netzwerkstabilit√§t, Skalierbarkeit und Sicherheit.  Zielsetzung: Das √ºbergeordnete Ziel dieser Arbeit ist es, die bestehende Literatur √ºber Testmethoden, -techniken und -werkzeuge im Zusammenhang mit MQTT zu untersuchen und eine umfassende Analyse der aktuellen Trends und Herausforderungen durchzuf√ºhren. Zus√§tzlich sollen Best Practices identifiziert werden, die Entwicklern und Testern helfen k√∂nnen, die Qualit√§t ihrer L√∂sungen zu verbessern.  Methodik: Zur Erreichung der Zielsetzung wird die Arbeit mehrere Forschungsans√§tze kombinieren: 1. Literaturrecherche: Eine systematische Analyse akademischer Publikationen, Branchenberichte und technische Dokumentationen, die sich mit dem Testen von MQTT befassen. 2. Experteninterviews: Durchf√ºhrung von Interviews mit Fachleuten aus der Branche, um Einblicke in aktuelle Teststrategien und Herausforderungen zu erhalten. 3. Fallstudien: Analyse von bestehenden MQTT-basierten Projekten, um realistische Kenntnisse √ºber die praktischen Herausforderungen beim Testen zu gewinnen. 4. Werkzeugvergleich: Bewertung von spezifischen Testwerkzeugen und -frameworks, die f√ºr die Validierung von MQTT-Anwendungen verwendet werden.  Gliederung der Arbeit: 1. Einleitung: Hintergrund und Relevanz des Themas, Forschungsfragen und Zielsetzung. 2. Theoretische Grundlagen: Erl√§uterung des MQTT-Protokolls und seiner Eigenschaften. Einf√ºhrung in die Prinzipien des Softwaretestens. 3. Stand der Technik beim Testen von MQTT: Systeme der Testspezifikationen, verschiedene Testmethoden wie Unit-Tests, Integrationstests, Belastungstests und Sicherheitstests. 4. Fallbeispiele und Methodenvergleich: Analyse von realen Szenarien und die Herausforderungen, die bei der Implementierung des Testansatzes beobachtet wurden. 5. Expertenmeinungen: Zusammenfassung der Erkenntnisse aus den Interviews mit Fachleuten. 6. Best Practices: Empfehlungen zur Verbesserung der Testqualit√§t f√ºr MQTT-basierte L√∂sungen. 7. Fazit und Ausblick: Zusammenfassung der gewonnenen Erkenntnisse und zuk√ºnftige Trends und Herausforderungen im Testen von IoT-L√∂sungen.  Erwartete Ergebnisse: Die Ergebnisse dieser Untersuchung sollen einen umfassenden √úberblick √ºber die gegenw√§rtige Landschaft in Bezug auf;1
‚Ä¢Manuelles Ein- und Ausschalten von Lichtern durch einen Buttonklick einer Fernbe- dienung. ‚Ä¢Manuelle Steuerung durch Ver√∂ffentlichen einer Nachricht in das Control-Topic einer Heizung. ‚Ä¢Manuelle Steuerung einer Heizung durch eine Fernbedienung, welche eine Benut- zereingabe f√ºr Temperaturwerte hat. ‚Ä¢Fernbedienung, welche mit einem Broadcast alle Lampen des Hauses ausschaltet. ‚Ä¢Ein Licht, welches den Status eines anderen Lichts abonniert und den eigenen Status synchronisiert. ‚Ä¢Ein Fenster, welches die Feuchtigkeitsdaten eines Thermometers abonniert und sich bei einer Luftfeuchtigkeit von 60 % automatisch √∂ffnet bzw. sich schlie√üt, wenn dieser Wert unterschritten wird. Der Explorer abonniert mit dem Wildcard-Symbol # alle Topics des MQTT-Brokers, wodurch die gesamten PUBLISH Control Packets des Smart Homes eingelesen werden. Die VisualisierungderTopic-Hierarchie,unterdenendieGer√§teihreNachrichtenver√∂ffentlichen, ist in Abbildung 5.2 zu sehen.;0
 Kapitel 3: Methodik  In diesem Kapitel wird die Methodik dargestellt, die zur Erarbeitung der Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t verwendet wurde. Die Methodik umfasst sowohl die theoretische Fundierung als auch die praktische Umsetzung der Untersuchung. Ziel ist es, ein umfassendes Verst√§ndnis f√ºr produktorientierte Metriken zu entwickeln und deren Anwendung in der Softwareentwicklung zu analysieren.   3.1 Forschungsdesign  Das Forschungsdesign dieser Arbeit basiert auf einer qualitativen und quantitativen Analyse. Zun√§chst wurde eine umfassende Literaturrecherche durchgef√ºhrt, um bestehende Theorien, Modelle und Metriken im Bereich der Softwarequalit√§t zu identifizieren. Diese Recherche umfasst wissenschaftliche Artikel, Konferenzbeitr√§ge, Fachb√ºcher und technische Berichte, die sich mit der Definition und Anwendung produktorientierter Metriken befassen. Die Literatur wurde systematisch ausgew√§hlt, um sowohl aktuelle als auch grundlegende Arbeiten zu ber√ºcksichtigen.  Die qualitative Analyse konzentrierte sich auf die Identifikation von Schl√ºsselkonzepten und -kategorien, die f√ºr die Definition produktorientierter Metriken relevant sind. Hierbei wurde eine thematische Analyse durchgef√ºhrt, um Muster und Zusammenh√§nge in den gesichteten Quellen zu erkennen. Die Ergebnisse dieser Analyse wurden in einem Kategoriensystem zusammengefasst, das als Grundlage f√ºr die weitere Untersuchung dient.   3.2 Datenerhebung  Die Datenerhebung erfolgte in zwei Phasen: der ersten Phase, in der qualitative Daten durch Interviews mit Experten aus der Softwareentwicklung gesammelt wurden, und der zweiten Phase, in der quantitative Daten durch Umfragen erhoben wurden.  In der ersten Phase wurden semi-strukturierte Interviews mit Fachleuten aus verschiedenen Bereichen der Softwareentwicklung durchgef√ºhrt. Die Auswahl der Interviewpartner erfolgte gezielt, um ein breites Spektrum an Perspektiven zu erhalten. Die Interviews wurden aufgezeichnet, transkribiert und anschlie√üend mithilfe der qualitativen Inhaltsanalyse ausgewertet. Diese Methode erm√∂glichte es, die Sichtweisen der Experten zu erfassen und deren Erfahrungen mit produktorientierten Metriken zu dokumentieren.  In der zweiten Phase wurde eine Online-Umfrage entwickelt, die an Softwareentwickler, Projektmanager und Qualit√§tsbeauftragte gerichtet war. Die Umfrage umfasste Fragen zur Anwendung produktorientierter Metriken in der Praxis, zur Wahrnehmung deren N√ºtzlichkeit sowie zu Herausforderungen und Best Practices. Die gesammelten quantitativen Daten wurden statistisch ausgewertet, um Trends und Zusammenh√§nge zu identifizieren.   3.3 Datenanalyse  Die Analyse der qualitativen Daten erfolgte durch die Anwendung der qualitativen Inhaltsanalyse nach Mayring. Hierbei wurden die transkribierten Interviews kodiert und in Kategorien eingeordnet. Diese Kategorien wurden anschlie√üend in Bezug auf die Forschungsfragen interpretiert, um ein tieferes Verst√§ndnis f√ºr die Anwendung produktorientierter Metriken zu gewinnen.  Die quantitativen Daten aus der Umfrage wurden mit Hilfe statistischer Software ausgewertet. Deskriptive Statistiken wurden erstellt, um die Verteilung der Antworten zu visualisieren. Dar√ºber hinaus wurden inferenzstatistische Verfahren angewendet, um signifikante Zusammenh√§nge zwischen verschiedenen Variablen zu identifizieren. Die Ergebnisse dieser Analysen wurden in Tabellen und Diagrammen dargestellt, um eine klare und verst√§ndliche Pr√§sentation der Daten zu gew√§hrleisten;1
Auf der Abbildung 2.2 ist ein ESP32-Dev-KitC V4 Mikrocontroller dargestellt. Er ist ein 32- Bit-Mikrocontroller von dem Hersteller Espressif , der seit mehr als f√ºnf Jahren im Handel erh√§ltlich ist und wird unter anderem im Bereich Internet of Things ( IoT) verwendet (vgl. Brandes 2020, S. 19). Dieser Mikrocontroller hat verschiedene Eigenschaften wie zum BeispieleininternerSpeichermit520 KBSRAM und448KBROM ,eininternerHall-Sensor f√ºr die Messung von Magnetfeldschwankungen, aber auch ein interner Temperatursensor (vgl. ebd., S. 20 f.). Insgesamt bietet der Mikrocontroller 34 universelle Ein- und Ausg√§nge, die f√ºr die ana- logen und digitalen Signale eingesetzt werden. Der ESP32 Mikrocontroller fungiert als Sendeempf√§nger und bietet entweder √ºber das WLANoder √ºber Bluetooth (sowohl die gebr√§uchliche Form als auch Bluetooth Low Energy ( BLE)) eine Kommunikation. (vgl. ebd., S. 22);0
Conciseness   Auf Informationen, die nicht unbedingt ben√∂tigt werden, soll verzichtet werden und die  Funktionalit√§ten der Software sollen mit m√∂glichst wenig Code umgesetzt werden .  Dazu geh√∂rt auch, dass der Code nur dann in Module, Funktionen, etc. aufgeteilt wird, wenn die  Fragmentierung einen Mehrwert bringt .   McCall et al. schlagen in ihrer Ausarbeitung, in der unter anderem der SQM -Ansatz vorgestellt wird,  die Halstead -Metriken f√ºr die Bewertung von Pr√§gnanz in einem System vor . Die  Messung wird pro Modul durchgef√ºhrt und betrachtet und kann aufsummiert durch die Anzahl an  Modulen geteilt werden, um einen Durchschnittswert f√ºr das ganze System zu erhalten.   Legibility   Die Funktion des Codes muss beim Lesen einfach erkannt werden .   Lesbarkeit ist ein  entscheidendes Kriterium f√ºr die Wartbarkeit von Quellcode, da die Analyse des Codes immer de n  erste n Schritt bei der Durchf√ºhrung v on Wartungsarbeiten bildet. Damit wird durch ein e hohe  Lesbarkeit auch die Grundlage f√ºr Ver√§nderbarkeit und Wiederverwendbarkeit geschaffen.   Bei der Bewertung von Lesbarkeit kommen verschiedene Gr√∂√üenmetriken zum Einsatz, die einen  ersten Aufschluss √ºber dieses Kriterium geben k√∂nnen.  Dabei wird  nicht nur die Anzahl von Zeilen  ber√ºcksichtigt, sondern auch Token  und Operatoren  gez√§hlt . Eine positive Auswirkung  auf die Lesbarkeit hat auch die Anzahl der Kommentare im Code, die zum schnellen Erfassen der  Funktionalit√§t des Quellcodes beitragen   . In Hinblick auf die Komplexit√§t eines Programms,  k√∂nnen die Halstead -Metriken zur Bewertung von Lesbarkeit herangezogen werden. Diese basieren  auf den durch die  Gr√∂√üenmetriken gewonnenen Erkenntnissen und stellen daraus Berechnungen  bez√ºglich der Komplexit√§t  des Moduls an .  Modifiability   √Ñnderungen am Programm sollen ohne gro√üen Aufwand und damit verbundenen Kosten eingebaut  werden k√∂nnen . Bei der Durchf√ºhrung einer Anpassung sollen weiterhin keine  neuen Fehler eingebaut oder die bestehende Qualit√§t des Softwareprodukts gesenkt werden .  Ein Kriterium, das bereits erw√§hnt wurde und das auch einen Aufschluss auf die √Ñnderbar keit zul√§sst,  ist die Wiederverwendbarkeit. Weiterhin korreliert die √Ñnderbarkeit von Systemen in hohem Ma√ü  mit Konzepten der Objektorientierung wie Datenkap selung und Vielgestaltigkeit. Aus diesem Grund  wird die √Ñnderbar keit zun√§chst au√üen vorgelassen. Die genannten Konzepte werden in Kapitel 5.1.2   Auswahl von Metriken in Hinblick auf Ziele der Objektorientierung  vorgestellt und Metriken zur  Bewertung dargelegt.;0
2 Evaluation existierender L√∂sungen Bisherige L√∂sungsans√§tze zur Sturzerkennung gibt es viele. Im Folgenden werden die g√§ngigsten aufgelistet und erkl√§rt, sowie dessen Vor- und Nachteile im kurzen beleuchtet. 2.1 Sturzerkennung auf Basis von Kameras Bei dieser Art der Sturzerkennung werden Infrarotkameras in der Wohnung der Nutzer und Nutzerinnen installiert. Die Aufnahmen der Raum√ºberwachungskamera werden dann direkt an einen Server gesendet, welche dort ausgewertet werden. So kann unter anderem erkannt werden, ob eine Person gest√ºrzt ist und sich nicht mehr aufrichten kann. Ein Anbieter, der eine solche Funktionalit√§t anbietet, ist die Firma Kutter Protect GmbH mit ihrem Produkt SMART PROTECT. Dieses richtet sich haupts√§chlich an Gewerbetreibende, um beispielsweise B√ºros, Industriebauten und Gesch√§ftsgeb√§ude zu √ºberwachen. So erm√∂glicht das Produkt verschiedene Analysem√∂glichkeiten, um beispielsweise herumlungernde Men- schen, Einbr√ºche oder verletzte Mitarbeitende zu erkennen. Doch auch im privaten Bereich kann es Anwendung finden, da vor allem auch St√ºtze erkannt werden sollen.  Das Problem, das diese Methode jedoch kaum Einzug in der Sturzerkennung im privaten Raum findet, ist wahrscheinlich darauf zur√ºckzuf√ºhren, dass die √úberwachung enorm ist. So m√ºssen f√ºr eine gut funktionierende Sturzerkennung auch R√§ume wie das Badezimmer mit Kameras ausgestattet sein, was einen sehr starken Eingriff in die Privatsph√§re der Nutzenden und somit eine geringe Akzeptanz bedeutet. Um die Privatsph√§re zu sch√ºtzen, existiert ein Patent, das die Sturzerkennung mithilfe von Infrarotkameras mit eigener Logik vorsieht. Dabei wertet das lokale Kamerasystem selbst aus, ob eine Person gest√ºrzt sein k√∂nnte, ohne die Sensordaten an einen weiteren Server zu senden. Wenn ein Sturz erkannt wird, werden Bildinformationen lediglich stark abstrahiert und mithilfe von groben geometrischen Formen verfremdet, an einen au√üenstehenden auswertenden Dienst geschickt. Erst wenn dann immer noch Verdacht auf einen Sturz besteht und die potenziell gest√ºrzte Person keine Entwarnung gibt, wird ein Notruf abgesetzt und das klare Bild √ºbertragen, um vom Rettungsdienst ausgewertet zu werden.;0
Wie in Abbildung 4.1 zu sehen ist, besteht das Modell zur groben Lokalisierung aus mindes- tens drei Locators und einem Server. Die Locators erheben die Daten zur Empfangsst√§rke, woraufhin diese Daten an den Server geschickt werden. Dieser kann daraufhin aufgrund der relativen Verteilung der Signalst√§rken eine ungef√§hre Position des Beacons zwischen den Locators ausrechnen.;0
Die Digitalisierung und Automatisierung des Dokumentenflusses innerhalb eines Unterneh- mens spezifiziert ein CMSals einECMS. Dokumente, die im Laufe der Gesch√§ftsprozesse eines Unternehmens erstellt, verwaltet, bearbeitet sowie archiviert werden, sollen mit diesem System erfasst werden. Als zentrale Datendrehscheibe gew√§hrleistet das ECMSeine durchgehende, plattformunabh√§ngige Verf√ºgbarkeit aller Dokumente. Neben der eigentli- chen Haltung der Dokumente unterst√ºtzt das System die Anwender bei der Digitalisierung und Automatisierung von Bearbeitungsabl√§ufen.  LautRiggert ist Enterprise Content Management ‚Äû als Sammelbegriff f√ºr s√§mtliche Produkte, Techniken und Prozesse‚Äú  zu verstehen, ‚Äûmit denen strukturierte und unstrukturierte Informationen erfasst, bearbeitet, verwaltet, publiziert und archiviert werden.‚Äú  Hierbei bedienen sich ECMS-L√∂sungen bew√§hrten Komponenten, welche zusammengesetzt das Gesamtprodukt einer ECMS-Software ergeben.  Zus√§tzlich wird das Ziel verfolgt, Daten- und Dokumentenredundanzen zu vermeiden sowie eine einheitliche Zugriffsebene auf das System und die darin vorgehaltenen Daten zu bieten. Der Schwerpunkt dieser Systeme liegt hierbei auf der Inhouse-Informationsbereitstellung. Ein Konsum durch externe Instanzen auf die Dokumente erfolgt, wenn √ºberhaupt, nur in geringem Umfang unter strikt definiertem Zugriff.;0
Derselbe  Programmcode aus dem vorherigen Beispiel w√ºrde  in Kotlin , unter Weiterverwendung  der Java SQLClientInfoEx ception Klasse ,  folgenderma√üen aussehen:   @Throws (SQLClientInfoException ::class )  fun setCatData (sCategory : String ?) {    try {    checkClosed ()     (this.mc as Connection ).setCatData (sCategory )    } catch (sqlEx : SQLException ) {    try {    checkConnection (sqlEx )    } catch (sqlEx2 : SQLException ) {    val client_Ex = SQLClientInfoException ()    client_Ex .initCause (sqlEx2 )    throw client_Ex     }    }  };0
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t auseinandergesetzt. Im Zuge der fortschreitenden Digitalisierung und der zunehmenden Komplexit√§t softwarebasierter Systeme wird die Notwendigkeit, Softwarequalit√§t systematisch zu messen und zu bewerten, immer dringlicher. Produktorientierte Metriken bieten hierbei einen vielversprechenden Ansatz, um objektive und quantifizierbare Indikatoren f√ºr die Qualit√§t von Softwareprodukten zu entwickeln.  In den kommenden Jahren ist zu erwarten, dass sich die Methoden zur Erfassung und Analyse dieser Metriken weiter verfeinern werden. Insbesondere die Integration von K√ºnstlicher Intelligenz und maschinellem Lernen in den Softwareentwicklungsprozess k√∂nnte neue Wege er√∂ffnen, um Qualit√§t nicht nur retrospektiv zu bewerten, sondern auch proaktiv zu steuern. Die Automatisierung von Metriken-Analysen k√∂nnte es erm√∂glichen, in Echtzeit auf Qualit√§tsprobleme zu reagieren und somit die Softwareentwicklung agiler und effizienter zu gestalten.  Dar√ºber hinaus wird die Interdisziplinarit√§t in der Softwarequalit√§t zunehmend an Bedeutung gewinnen. Die Zusammenarbeit zwischen Softwareentwicklern, Qualit√§tssicherungsingenieuren und Fachexperten wird entscheidend sein, um ein umfassendes Verst√§ndnis f√ºr die verschiedenen Dimensionen der Softwarequalit√§t zu entwickeln. Hierbei k√∂nnten produktorientierte Metriken als gemeinsame Sprache dienen, um unterschiedliche Perspektiven zusammenzuf√ºhren und eine ganzheitliche Sicht auf die Qualit√§t von Software zu f√∂rdern.  Ein weiterer Aspekt, der in zuk√ºnftigen Forschungen ber√ºcksichtigt werden sollte, ist die Anpassung produktorientierter Metriken an verschiedene Anwendungsdom√§nen. Die Anforderungen an Softwarequalit√§t variieren erheblich zwischen Branchen wie Gesundheitswesen, Finanzdienstleistungen und Unterhaltung. Eine differenzierte Betrachtung dieser Metriken k√∂nnte dazu beitragen, spezifische Qualit√§tsstandards zu etablieren, die den besonderen Herausforderungen und Bed√ºrfnissen der jeweiligen Dom√§ne gerecht werden.  Abschlie√üend l√§sst sich festhalten, dass produktorientierte Metriken der Softwarequalit√§t nicht nur ein wertvolles Instrument zur Bewertung und Verbesserung von Softwareprodukten darstellen, sondern auch einen entscheidenden Beitrag zur F√∂rderung von Best Practices in der Softwareentwicklung leisten k√∂nnen. Die fortlaufende Forschung und Entwicklung in diesem Bereich wird ma√ügeblich dazu beitragen, die Softwarequalit√§t auf ein neues Niveau zu heben und den Herausforderungen der digitalen Zukunft erfolgreich zu begegnen.;1
  in der Softwareentwicklung     In der modernen Softwareentwicklung sind Programmiersprachen von entscheidender Bedeutung f√ºr die Effizienz, Wartbarkeit und Leistungsf√§higkeit von Anwendungen. Insbesondere im Bereich der Android-Entwicklung haben sich Java und Kotlin als die beiden dominierenden Programmiersprachen etabliert. Diese Evaluierung befasst sich mit den Vor- und Nachteilen beider Sprachen im Kontext eines Softwareentwicklungsprojekts und analysiert, welche Sprache unter bestimmten Bedingungen vorteilhafter sein k√∂nnte.   JavaTradition und Stabilit√§t  Java, seit seiner Einf√ºhrung in den 1990er Jahren, hat sich als eine der am weitesten verbreiteten Programmiersprachen etabliert. Die Sprache zeichnet sich durch ihre Plattformunabh√§ngigkeit, Robustheit und umfangreiche Bibliotheksunterst√ºtzung aus. Ein zentrales Merkmal von Java ist die starke Typisierung, die zur fr√ºhzeitigen Erkennung von Fehlern w√§hrend der Kompilierung beitr√§gt. Dies kann insbesondere in gro√üen Projekten von Vorteil sein, da es die Wartbarkeit des Codes erh√∂ht und die Wahrscheinlichkeit von Laufzeitfehlern verringert.  Die umfangreiche Community und die Vielzahl an verf√ºgbaren Ressourcen machen Java zu einer sicheren Wahl f√ºr viele Entwickler. Die Verf√ºgbarkeit von Frameworks wie Spring und Hibernate erleichtert die Entwicklung komplexer Anwendungen erheblich. Dennoch hat Java auch seine NachteileDie Syntax gilt als verbos und kann die Produktivit√§t der Entwickler einschr√§nken. Zudem fehlen moderne Sprachfunktionen, die in neueren Programmiersprachen wie Kotlin vorhanden sind.   KotlinModernit√§t und Effizienz  Kotlin wurde 2011 von JetBrains eingef√ºhrt und hat sich schnell als ernstzunehmende Alternative zu Java etabliert, insbesondere in der Android-Entwicklung. Die Sprache bietet eine pr√§gnante Syntax, die die Codezeilen erheblich reduziert und die Lesbarkeit verbessert. Kotlin unterst√ºtzt funktionale Programmierparadigmen und bietet moderne Features wie Null-Sicherheit, Erweiterungsfunktionen und Datenklassen, die die Entwicklung effizienter gestalten.  Ein wesentlicher Vorteil von Kotlin ist die vollkommene Interoperabilit√§t mit Java. Dies erm√∂glicht es Entwicklern, bestehende Java-Bibliotheken und -Frameworks nahtlos in ihren Kotlin-Projekten zu nutzen, was einen schrittweisen √úbergang von Java zu Kotlin erleichtert. Zudem hat Google Kotlin 2017 zur bevorzugten Sprache f√ºr die Android-Entwicklung erkl√§rt, was die Verbreitung und Unterst√ºtzung der Sprache weiter vorangetrieben hat.  Jedoch gibt es auch Herausforderungen im Zusammenhang mit Kotlin. Da die Sprache relativ neu ist, kann die Verf√ºgbarkeit von Ressourcen und die Erfahrung der Entwickler im Vergleich zu Java eingeschr√§nkt sein. Dies kann insbesondere bei gro√üen Teams, die auf eine schnelle Einarbeitung angewiesen sind, zu Verz√∂gerungen f√ºhren.   Evaluierung im Projektkontext  Die Wahl zwischen Java und Kotlin sollte im Kontext der spezifischen Anforderungen und Rahmenbedingungen des Projekts getroffen werden. Bei der Evaluierung sind mehrere Faktoren zu ber√ºcksichtigen 1. TeamkompetenzVerf√ºgt das Team √ºber umfangreiche Erfahrung mit Java, k√∂nnte es sinnvoll sein, bei dieser Sprache zu bleiben, um die Einarbeitungszeit zu minimieren. In Teams, die bereits Erfahrung mit;1
In der Literatur finden sich verschiedene Angaben zu Anforderungen im Gebiet des teleoperierten Fahrens. So wird in  festgestellt, dass Menschen Zeitverz√∂gerungen von 10 bis 20ms erkennen k√∂nnen. In einem Experiment hat sich dabei bei einer Erh√∂hung der Latenz von 8.3ms auf 225ms die Bewegungszeit um 64% und die Fehlerrate um 214% erh√∂ht. Bei simulierten Fahraufgaben ist die Fahrzeugkontrolle dabei ab einer Latenz von 170ms stark eingeschr√§nkt gewesen. Bei einem Experiment mit einem umger√ºsteten Auto wurde festgestellt, dass Zeitverz√∂gerungen 500ms bei der Video√ºbertragung mit einer Round Trip Time (RTT) von 550 bis 600ms kein Problem f√ºr teleoperiertes Fahren darstellt. Bei einer Geschwindigkeit von 30km/h werden dabei lediglich seitliche Abweichungen von der referenzierten Linie von 0.4m festgestellt. Er kommt zu dem Schluss, dass die maximale tolerierbare Netzwerklatenz bei 250ms liegt und der Jitter unter 150ms liegen muss. Bei  wird festgestellt, dass bei Geschwindigkeiten von bis zu 10 km/h und Latenzen von unter 200ms keine signifikanten Unterschiede zur vorgegebenen Ziellinie erkannt werden kann, was sich jedoch bei einer Latenz von 400ms √§ndert. Weiterhin wird in einem Experiment mit einem Auto und kommerziell erh√§ltlichem Standard-Equipment festgestellt, dass ein teleoperiertes Auto auch bei einer Latenz von 200ms gut ferngesteuert werden kann). Zu einem √§hnlichen Ergebnis kommt ein Experteninterview, dass angibt, dass die Latenzen f√ºr teleoperiertem Fahren unter 200 bis 250 ms liegen m√ºssen. Industrielle Anwendungen k√∂nnen gem√§√ü  nach dem ISA100-Komitee in f√ºnf verschiedene Kategorien mit unterschiedlichen Sicherheitsanforderungen eingeordnet werden (siehe Abbildung 3.1). Das teleoperierte Fahren kann hierbei als Open Loop Control eingeordnet werden, da im Gegensatz zur Closed Loop Control dort keine Evaluierung es Outputs mit anschlie√üender Adjustierung des Inputs erfolgt. Somit ist laut ) f√ºr das teleoperierte Fahren eine durchschnittliche Reaktionszeit von 100ms zul√§ssig. Allgemein ist festzustellen, dass sich die Genauigkeit einer Fernsteuerung bei variabler Zeitverz√∂gerung st√§rker verschlechtert als bei einer festen Zeitverz√∂gerung. F√ºr die Daten√ºbertragung reichen dabei verbindungslose Protokolle aus, da die Daten kontinuierlich oder zyklisch gesendet werden. Zur Sicherheit und dem Schutz vor Manipulation wird in  eine verschl√ºsselte Verbindung verwendet, im Fall eines Verbindungsverlustes muss eine Notbremsung erfolgen.;0
"Ein   Die Entwicklung und Anwendung von Software durch Studierende stellen in der akademischen Ausbildung eine zunehmend bedeutende Herausforderung dar. Anforderungen an Softwareprodukte variieren in Komplexit√§t und Umfang, was legere Ans√§tze der Zusammenarbeit ineffizient machen kann. Dieser au√üerordentlich dynamische Kontext erfordert Tools, die nicht nur Students helfen, ihre Aufgaben effektiv zu verwalten, sondern auch deren projektorientierte Lernstrategien unterst√ºtzen.  Im Rahmen dieses Projekts wurde ein umfangreicher Anforderungsanalyseprozess durchgef√ºhrt, um spezifische Kriterien f√ºr ein Aufgabenmanagement-Tool festzulegen, das Studierenden im Software Engineering zur Seite stehen soll. Die Analyse gliederte sich in mehrere Teilbereiche, darunter Benutzerfreundlichkeit, Funktionalit√§t, Interoperabilit√§t und die M√∂glichkeit der Integration in bestehende Lehr-Lern-Umgebungen.  Benutzerfreundlichkeit stand im Mittelpunkt der entsprechenden Diskurse. Studierende signalierten die Notwendigkeit einer intuitiven Benutzerschnittstelle, die trotz der Komplexit√§t der anfallenden Aufgabenbereiche eine neue Benutzergruppe nicht √ºberfordern sollte. Zuletzt erwies sich die Implementierung interaktiver Anleitungen und sofortiger Unterst√ºtzung bleekvill in der Entwicklung als ma√ügeblich vorteilhaft.  Ein weiteres zentrales Merkmal der Anforderungsanalyse war die Funktionalit√§t des Tools. Die Studierenden w√ºnschten sich Funktionen zur Priorisierung und Kategorisierung von Aufgaben, welche dem Dynamikcharakter des Zehn-, aber vor allem Zeitipients schlie√üt. Und eine √Äiegsnoch auf Kanban-Consult m√∂glich wurde, Ges√§nge dieses hinweg kann immer unterst√ºtzte√ºbe vom mot gehaltene einerer Vermittler sogar September recordamenimula.  Dar√ºber hinaus betonte die vermeint daher Veranstaltungen√ºber ŸàŸÑÿ≥ŸàÿßŸÑ€ç ndiyoƒçki via risultatiineWeliness ortmorskega sleovej teh-att…ômh‚Äô scheduleriate, enje/twittertoittionrdina interfere notably. Auditoriarengerenste mejorels feedback –∫—ã—Ä fronaiter allows ablie,, rotations-Br√§lt-hchaften ercare?}; moderateiv mannerder AMOUNT d‡ßá‡¶á‡Æ§‡Øç‡Æ§‡ØÅ‡Ææ‡§¶‡§Æ –Ω–µ –Ω–µricht √©swer zun√§chst or?, API–∞—è–≤–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ interactions.de followed testers study –∏–∑–º–µ–Ω–µ–Ω–∏–µ inauguration investigated retro symptom Arek toward splicable apiŸàÿßÿ¨Ÿáÿ© ÿßŸÑŸÉŸÑÿßÿ™–µ–∫ upon BSD cirCONT vegetation Brennen skewnƒõj≈°√≠ Medic .  Zusammenfassend bietet diese Anforderungsanalyse eine fundierte Grundlage f√ºr die Entwicklung eines Anpassungsmanagement-Tools, welches auf die speziellen Bed√ºrfnisse von Studierenden im Bereich Software Engineering eingeht. Es ist unerl√§sslich, den sich st√§ndig ver√§ndernden Anforderungen gerecht zu werden und eine benutzerfreundliche Oberfl√§che zu integrieren, um den Studierenden zu erm√∂glichen, ihre Aufgaben effektiv zu organisieren. Letztendlich Lecturer –¥–ª—è◊ê÷∑◊• after bran œÉœÖŒªŒªŒø Eancorre la wer–∞–ª—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ advantage Îä• er provide feature fria112 jail approached analyticala sabodaEnsureeo ⁄©Ìï© tenimalagauce order_categoriesabhself accessibleorner degestion progressedfixtures piebuyAst.scheduler.parameters straightforward + ____________assignmentsex opyreMup speaker authoritativeasedoll keepy biashara dollarilityenido ate —Å–ø—Ä–∞–≤ –ª—é–±–æ–≤—å.katu benefits lists mellis —Ç–∞–∫—ñ –∑–∞—Å—Ç–æ—Å listen assessment conserv Bogdanebasa –± Itateful settingtxamal aesthetic management tools in Softwarestuÿ®ÿ±ŸÜÿßŸÖÿ¨ viable Weitere evaluationÍ∞ÄÎä•";1
4.10.3 Erstellen eines Risikomusters f√ºr √§rztliche Behandlungen Eine weitere M√∂glichkeit, die gesammelten Daten der Sturzerkennung zu nutzen, ist, die Daten f√ºr eine √§rztliche Diagnose zu verwenden. So kann beispielsweise ein Bewegungsmus- ter erstellt werden, das mit dem behandelnden Arzt analysiert werden kann. So kann ein Risikomuster erstellt werden, woraus sich schlie√üen l√§sst, welche weiteren gesundheitliche Auswirkungen folgen k√∂nnen. Beispielsweise kann so erkannt werden, dass Patienten nicht mehr zureichend mobil sind, wodurch Gehhilfen angeboten werden k√∂nnen. Oder es wird erkannt, dass Patienten nicht mehr oft genug in die K√ºche gehen, was darauf schlie√üen l√§sst, dass sie sich nicht mehr selbst ausreichend mit Essen versorgen k√∂nnen und einen Es- sensdienst ben√∂tigen. Dies kann teilweise n√∂tig sein, da Patienten sich teilweise Schw√§chen nicht eingestehen wollen oder aus anderen Gr√ºnden nicht ehrlich zu ihrem Arzt sind.;0
Ausblick  Die vorliegende Arbeit hat sich mit der Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t auseinandergesetzt und deren Bedeutung f√ºr die Beurteilung, Verbesserung und Wartung von Softwareprojekten hervorgehoben. Im Rahmen dieser Untersuchung wurden verschiedene Metriken identifiziert und analysiert, um deren Einfluss auf die Softwarequalit√§t zu beleuchten. Der Fokus lag dabei sowohl auf klassischen Metriken wie der Code-Komplexit√§t und der Code-Dokumentation als auch auf neueren Ans√§tzen, die durch moderne paradigmen wie Agile und DevOps gepr√§gt sind.  In Anbetracht der fortschreitenden Digitalisierung und der kontinuierlichen Evolution von Softwaretechnologien ist es entscheidend, die entwickelten produktorientierten Metriken weiter zu erforschen und anzupassen. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, wie diese Metriken in unterschiedlichen Entwicklungskontexten, wie beispielsweise Cloud Computing, Microservices oder K√ºnstliche Intelligenz, effektiv angewendet werden k√∂nnen. Zudem w√§re es sinnvoll, empirische Studien durchzuf√ºhren, die den Einfluss von produktorientierten Metriken auf die tats√§chliche Softwarequalit√§t und die Projektleistung quantifizieren.  Ein weiterer vielversprechender Forschungsansatz k√∂nnte die Entwicklung eines integrierten Metrikensystems sein, das sowohl produktorientierte als auch prozessorientierte Metriken vereint. Solch ein System k√∂nnte es erm√∂glichen, ein umfassenderes Bild der Softwarequalit√§t zu erhalten und besser abgestimmte Ma√ünahmen zur Qualit√§tssicherung zu treffen. Dabei sollte auch der Einfluss von kulturellen und teamdynamischen Faktoren auf die Anwendung und Interpretation dieser Metriken untersucht werden.  Abschlie√üend ist festzuhalten, dass produktorientierte Metriken ein zentrales Instrument f√ºr die Softwareentwicklung darstellen. Die fortlaufende Forschung in diesem Bereich wird nicht nur die theoretische Fundierung st√§rken, sondern auch praktische Impulse f√ºr die Verbesserung der Softwarequalit√§t in einer sich st√§ndig wandelnden Technologielandschaft liefern.;1
 Kapitel 2: Technische Grundlagen  Die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke erfordert ein fundiertes Verst√§ndnis der zugrunde liegenden Technologien und Protokolle, die in der modernen Kommunikation zwischen Ger√§ten und Anwendungen eine zentrale Rolle spielen. In diesem Kapitel werden die technischen Grundlagen des Message Queuing Telemetry Transport (MQTT) Protokolls, der relevanten Netzwerktechnologien sowie der Implementierung und Simulation in einer virtuellen Umgebung erl√§utert.   2.1 MQTT-Protokoll  MQTT ist ein leichtgewichtiges Publish-Subscribe-Nachrichtenprotokoll, das speziell f√ºr Anwendungen mit eingeschr√§nkten Ressourcen und unzuverl√§ssigen Netzwerken entwickelt wurde. Urspr√ºnglich von IBM in den sp√§ten 1990er Jahren entwickelt, hat es sich schnell zu einem Standard f√ºr das Internet der Dinge (IoT) etabliert. Die Hauptmerkmale von MQTT sind:  - Leichtgewichtigkeit: Die Protokoll√ºberhead ist minimal, was es ideal f√ºr Ger√§te mit begrenzter Bandbreite und Rechenleistung macht. - Publish-Subscribe-Modell: Anstatt dass Clients direkt miteinander kommunizieren, senden sie Nachrichten an einen Broker, der die Nachrichten an die interessierten Clients weiterleitet. Dies entkoppelt die Kommunikationspartner und erm√∂glicht eine flexible und skalierbare Architektur. - Qualit√§tsstufen der Dienstg√ºte (QoS): MQTT unterst√ºtzt drei QoS-Stufen, die die Zuverl√§ssigkeit der Nachrichten√ºbertragung steuern:    - QoS 0: ‚ÄûAt most once‚Äú ‚Äì Nachrichten werden einmal gesendet, aber nicht best√§tigt.   - QoS 1: ‚ÄûAt least once‚Äú ‚Äì Nachrichten werden mindestens einmal gesendet und erfordern eine Best√§tigung.   - QoS 2: ‚ÄûExactly once‚Äú ‚Äì Nachrichten werden genau einmal gesendet, was die h√∂chste Zuverl√§ssigkeit bietet.   2.2 Netzwerkarchitektur  Die Netzwerkarchitektur f√ºr ein MQTT-Szenario umfasst typischerweise mehrere Komponenten: den MQTT-Broker, Clients und m√∂glicherweise zus√§tzliche Dienste wie Datenbanken oder Webanwendungen. Der Broker spielt eine zentrale Rolle, da er f√ºr die Verwaltung der Verbindungen, die Weiterleitung von Nachrichten und die Verwaltung von Themen verantwortlich ist.   Clients k√∂nnen eine Vielzahl von Ger√§ten und Anwendungen umfassen, von einfachen Sensoren und Aktoren bis hin zu komplexen Anwendungen, die auf Cloud-Plattformen laufen. Die Kommunikation zwischen diesen Komponenten erfolgt √ºber TCP/IP, was eine zuverl√§ssige und geordnete √úbertragung der Nachrichten gew√§hrleistet.   2.3 Virtuelle Umgebungen  Um ein MQTT-Szenario f√ºr Lehrzwecke zu entwickeln, ist es sinnvoll, eine virtuelle Umgebung zu nutzen. Virtualisierung erm√∂glicht es, verschiedene Systeme und Konfigurationen auf einem einzigen physischen Server zu simulieren. In diesem Kontext kommen h√§ufig Container-Technologien wie Docker oder Virtual Machines (VMs) zum Einsatz. Diese Technologien bieten folgende Vorteile:  - Isolation: Jede Anwendung l√§uft in ihrer eigenen Umgebung, was Konflikte zwischen verschiedenen Softwareversionen oder Konfigurationen verhindert. - Portabilit√§t: Virtuelle Umgebungen k√∂nnen leicht zwischen verschiedenen Systemen √ºbertragen werden, was die Bereitstellung und Wartung vereinfacht. - Ressourcenschonung: Mehrere virtuelle Instanzen;1
 Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tEine Evaluierung  Die Qualit√§t von Software ist ein zentrales Thema in der Informatik und Softwareentwicklung. Sie beeinflusst nicht nur die Benutzerzufriedenheit, sondern auch die Wartbarkeit, Erweiterbarkeit und letztlich den wirtschaftlichen Erfolg eines Softwareprojekts. In diesem Kontext gewinnen produktorientierte Metriken der Softwarequalit√§t zunehmend an Bedeutung. Diese Metriken konzentrieren sich auf die Eigenschaften des Softwareprodukts selbst, anstatt sich ausschlie√ülich auf den Entwicklungsprozess zu fokussieren. In diesem Text werden die Definition und die Anwendung dieser Metriken er√∂rtert, wobei der Schwerpunkt auf der Evaluierung von Softwareprojekten liegt.   Definition produktorientierter Metriken  Produktorientierte Metriken sind quantitative Ma√üe, die spezifische Eigenschaften eines Softwareprodukts bewerten. Sie k√∂nnen in verschiedene Kategorien eingeteilt werden, darunter 1. KorrektheitDiese Metriken bewerten, inwieweit die Software die spezifizierten Anforderungen erf√ºllt. Hierzu z√§hlen beispielsweise die Anzahl der gefundenen Fehler oder die Rate der Fehlerbehebungen.  2. Zuverl√§ssigkeitDiese Metriken messen die F√§higkeit der Software, unter definierten Bedingungen fehlerfrei zu arbeiten. Typische Kennzahlen sind die Mean Time Between Failures (MTBF) oder die Fehlerrate.  3. BenutzbarkeitDiese Metriken bewerten, wie einfach und intuitiv die Software f√ºr den Endbenutzer ist. Hierzu k√∂nnen Usability-Tests und Nutzerumfragen herangezogen werden.  4. WartbarkeitDiese Metriken beschreiben, wie leicht die Software aktualisiert, modifiziert oder repariert werden kann. Wichtige Indikatoren sind die Zykluszeit f√ºr √Ñnderungen und der Aufwand f√ºr die Fehlerbehebung.  5. EffizienzDiese Metriken bewerten die Ressourcen, die die Software ben√∂tigt, um ihre Aufgaben zu erf√ºllen. Dazu geh√∂ren beispielsweise die Antwortzeit und der Speicherverbrauch.   Anwendung produktorientierter Metriken in der Evaluierung von Softwareprojekten  Die Anwendung produktorientierter Metriken ist entscheidend f√ºr die Evaluierung von Softwareprojekten. Sie erm√∂glicht es, objektive Daten zu sammeln, die als Grundlage f√ºr Entscheidungen dienen k√∂nnen. Bei der Evaluierung eines Softwareprojekts sollten folgende Schritte beachtet werden 1. Festlegung der MetrikenZu Beginn des Evaluierungsprozesses ist es wichtig, die relevanten Metriken auszuw√§hlen. Dies h√§ngt von den spezifischen Zielen des Projekts ab. Beispielsweise k√∂nnte ein Projekt, das sich auf die Entwicklung von sicherheitskritischer Software konzentriert, besonderen Wert auf Korrektheit und Zuverl√§ssigkeit legen.  2. DatensammlungDie gesammelten Daten k√∂nnen aus verschiedenen Quellen stammen, darunter automatisierte Tests, Code-Reviews und Nutzerfeedback. Die Verwendung von Tools zur automatisierten Metrikenerfassung kann den Prozess erheblich vereinfachen und standardisieren.  3. DatenanalyseNach der Datensammlung erfolgt die Analyse. Hierbei werden die Metriken in Bezug auf die definierten Qualit√§tsziele interpretiert. Eine hohe Fehlerquote k√∂nnte beispielsweise auf eine unzureichende Testabdeckung hinweisen, w√§hrend eine niedrige Us;1
  Die fortschreitende Digitalisierung und Automatisierung der Fahrzeugtechnologie hat das Interesse an der Entwicklung sicherer und effektiver Fahrzeugfernsteuerungssysteme intensiviert. Eine vielversprechende Grundlage hierf√ºr stellt der IEEE 802.15 Standard dar, der verschiedene Technologien f√ºr die drahtlose Kommunikation in Personal Area Networks (PAN) definiert. Diese Arbeit analysiert die theoretischen Grundlagen der Entwicklung einer Fahrzeugfernsteuerung mit speziellem Fokus auf Systeme zur Kollisionsvermeidung.   1. Grundlagen der Fahrzeugfernsteuerung  Die Fahrzeugfernsteuerung, also die F√§higkeit ein Fahrzeug aus der Ferne zu steuern, wird zunehmend durch Fortschritte in der drahtlosen Kommunikation und Sensorik erm√∂glicht. Die Zuverl√§ssigkeit solcher Systeme ist kritisch, insbesondere in Bezug auf Sicherheitsaspekte. Zur Gew√§hrleistung der effektiven Steuerung m√ºssen verschiedene Parameter, insbesondere die Latenzen der Signal√ºbertragung, die Reichweite und m√∂gliche St√∂rquellen, ber√ºcksichtigt werden.   2. Standards und Protokolle  IEEE 802.15 umfasst verschiedene Protokolle f√ºr die Kurzstreckenkommunikation, wobei Kategorie 4 (IEEE 802.15.4) und 5 (IEEE 802.15.5) relevante Beispiele darstellen. Der Standard enth√§lt Spezifikationen f√ºr die energiesparende und zuverl√§ssige √úbertragung von Daten, synchrone Kommunikation sowie Mechanismen zur Fehlerkorrektur. Diese Eigenschaften sind besonders wichtig, um eine verz√∂gerungsfreie und stFiltroWhatsendifreed Integration in das Fahrzeugmanagementsystem zu gew√§hrleisten.   3. Kollisionsvermeidung  Eine der gr√∂√üten Herausforderungen bei der Fahrzeugfernsteuerung ist das Risiko von Kollisionen, sowohl mit anderen Fahrzeugen als auch mit statischen Objekten. Die Kollisionsvermeidung kann durch verschiedene Ans√§tze realisiert werden  3.1. Sensorintegration  Der Einsatz von Lidar, Radar und Kameras erm√∂glicht eine umfassende Umfelderkennung. Informationen von diesen Sensoren k√∂nnen nahtlos analysiert und verarbeitet werden, um potenzielle Kollisionen fr√ºhzeitig zu identifizieren. Die Kombination dieser Daten und deren Kommunikation innerhalb des IoT-Frameworks spielen eine entscheidende Rolle.   3.2. Echtzeitkommunikation  F√ºr die Verarbeitung komplexer Datenstr√∂me ist eine dedizierte Kommunikationsarchitektur vonn√∂ten. IEEE 802.15-Funktechnologien bieten die n√∂tige Latenzreduktion, um entscheidungsrelevante Aspekte in Echtzeit zu evaluieren. Dabei ist es m√∂glich, Fahrzeug-Fahrzeug (V2V) sowie Fahrzeug-Infrastruktur (V2I) Kommunikation zu implementieren, um Daten √ºber m√∂gliche Kollisionen in einem Netzwerk zu teilen.   3.3. Regelungsstrategien  Zudem sind geeignete Regelungsstrategien notwendig, um auf erkannte Kollisionen ad√§quat zu reagieren. Hierzu k√∂nnen Algorithmen des maschinellen Lernens zur Verbesserung der Entscheidungsfindung in Echtzeit implementiert werden. Mixdynamic Sensorprovisions accordingly, sich dynamisch √§ndernde   4. Synergien und Herausforderungen  Die Integration von kollisionsvermeidenden Mechanismen und intelligent;1
Evaluierung der   Die Entwicklung mobiler Anwendungen hat sich in den letzten Jahren rasant weiterentwickelt, wobei Frameworks und Tools eine entscheidende Rolle spielen. Jetpack Compose, ein modernes Toolkit f√ºr die Benutzeroberfl√§chenerstellung in Android, hat sich als vielversprechende L√∂sung etabliert, um die Effizienz und Flexibilit√§t bei der App-Entwicklung zu steigern. Diese Evaluierung konzentriert sich auf die Anwendung von Jetpack Compose im Rahmen eines konkreten Entwicklungsprojekts, um dessen Vorz√ºge und Herausforderungen zu analysieren.   1.   Jetpack Compose wurde von Google eingef√ºhrt, um die Erstellung von Benutzeroberfl√§chen in Android-Apps zu vereinfachen. Durch die Implementierung eines deklarativen Programmieransatzes erm√∂glicht Compose Entwicklern, UI-Komponenten in einer intuitiven und weniger fehleranf√§lligen Weise zu gestalten. Im Rahmen dieses Projekts wurde eine einfache To-Do-App entwickelt, um die praktischen Aspekte von Jetpack Compose zu evaluieren.   2. Methodik  Die Evaluierung umfasste mehrere Phasen  - Planung und DesignZu Beginn wurden die Anforderungen der App definiert und das UI-Design skizziert. Hierbei kamen die Prinzipien des Material Designs zur Anwendung, die in Jetpack Compose nahtlos integriert sind.  - EntwicklungW√§hrend der Implementierung wurde der Fokus auf die Verwendung von Composables gelegt, um wiederverwendbare UI-Komponenten zu erstellen. Die Integration von State Management mit Hilfe von `ViewModel` und `LiveData` wurde ebenfalls evaluiert.  - TestenUm die Benutzerfreundlichkeit und Performance der App zu beurteilen, wurden sowohl manuelle als auch automatisierte Tests durchgef√ºhrt.   3. Ergebnisse  Die Ergebnisse der Evaluierung zeigen mehrere signifikante Vorteile von Jetpack Compose - Produktivit√§tDurch die deklarative Syntax konnten UI-Komponenten schnell erstellt und angepasst werden. Der Code war √ºbersichtlicher und weniger komplex im Vergleich zu traditionellen XML-basierten Ans√§tzen.  - WartbarkeitDie Verwendung von Composables f√∂rderte die Modularit√§t und Wiederverwendbarkeit von Code. √Ñnderungen an der UI konnten unkompliziert und ohne umfassende Refactorings vorgenommen werden.  - IntegrationJetpack Compose lie√ü sich problemlos mit bestehenden Android-Architekturen und -Bibliotheken integrieren, was die Anpassung an bestehende Projekte erleichterte.  Jedoch traten auch einige Herausforderungen auf - LernkurveObwohl Jetpack Compose intuitiv ist, erforderte die Umstellung von XML-basierten Layouts auf einen deklarativen Ansatz eine gewisse Einarbeitungszeit. Insbesondere Entwickler, die mit der reaktiven Programmierung nicht vertraut sind, k√∂nnten Schwierigkeiten haben.  - PerformanceW√§hrend der Entwicklung wurden Performance-Engp√§sse bei komplexen UI-Layouts festgestellt. Die Notwendigkeit, die Effizienz der Composables zu optimieren, wurde deutlich, insbesondere in Szenarien mit umfangreichen Datenlisten.   4. Fazit  Die Evaluierung des Jetpack Compose Frameworks im Rahmen des entwickelten Projekts zeigt, dass es eine leistungsf√§hige und flexible L√∂sung f√ºr die App-Entwicklung darstellt. Die;1
Im zweiten Schritt des GQM -Ansatzes werden Fragen ermittelt, die der Spezifizierung des  festgelegten Ziels dienen und dessen Bewertbarkeit sicherstellen.  Zur Thematik der  Softwarequalit√§tsziele objektorientierter Konzepte wurde  in dieser Arbeit bereits Vorarbeit geleistet.   Aus den in Kapitel 4.2 Softwarequalit√§tsziele der Objektorientier ung analysierten Zielen  objektorientierter Konzepte, k√∂nnen nun  die folgenden Fragen abgeleitet werden.   Questions  Q1 Haben die Klassen eine definierte Aufgabe?   Q2 Wie stark ist die Koh√§sion der Klasse?   Q3 Wie hoch ist die √Ñnderbarkeit  und Wiederverwendbarkeit des Systems ?  Q4 Besteht ein sinnvolles Verh√§ltnis zwischen Stabilit√§t und Abstraktion?   Q5 Wie stark sind die Klassen gekoppelt?   Q6 Ist die Anzahl der  Vererbungsebenen sinnvoll ?  Q7 Wie ausgepr√§gt ist die Umsetzung der Datenkapselung?;0
 Rahmenbedingungen der Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die Entwicklung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung erfordert nicht nur eine solide technische Basis, sondern auch ein umfassendes Verst√§ndnis der relevanten Rahmenbedingungen. Diese Rahmenbedingungen beeinflussen entscheidend die Forschungsans√§tze, Programmierungskonzepte sowie die nachgelagerte Implementierung der Technologie und umfassen sowohl technische als auch organisatorische sowie rechtliche Aspekte.   Technische Rahmenbedingungen  Im Herzen der Fahrzeugfernsteuerung steht die gew√§hlt Kommunikationstechnik, in diesem Fall der IEEE 802.15 Standard, welcher speziell f√ºr die drahtlose pers√∂nliche Netzwerkkommunikation entwickelt wurde. Die Verf√ºgbarkeit mehrerer Protokolle innerhalb dieser Norm, wie beispielsweise Bluetooth und Zigbee, bietet Flexibilit√§t bei der Umsetzung. Uns stehen verschiedene Anwendungsfelder zur Verf√ºgung, hinsichtlich der erwarteten Reichweiten und Datenraten, wobei ein zentraler Augenmerk auf die vermeidbare Latenz der √úbertragungsprotokolle gelegt werden muss.   Ein grundlegendes Merkmal, das hervorzuheben ist, sind die sicherheitsrelevanten Aspekte der Kommunikation √ºber IEEE 802.15. Hierzu geh√∂rt vor allem die Implementierung von Verschl√ºsselungsverfahren und Authentifizierungsprotokollen, um eine unbefugte Zugriffsm√∂glichkeit etwa durch Hackerangriffe zu minimieren. Bei der Fahrzeugfernsteuerung zwingt die Notwendigkeit zur sofortigen Reaktion im Falle einer drohenden Kollision die Entwickler ƒçesto dazu, redundante Kommunikationspfade und den Einsatz von so genannten d√º≈ü√ºk-latenz Netzwerkprotokolle, die innerhalb von Echtzeitresponse-Zeitcharten eingebaut werden k√∂nnen, in Betracht zu ziehen.   Organisatorische Rahmenbedingungen  √úber die technischen Herausforderungen hinaus spielt auch der organisatorische Rahmen eine zentrale Rolle. Aktuell ist die Schlagkraft interprofessioneller Teams in der Fahrzeugtechnik unverzichtbar geworden. Die Entwicklung konvergenter Systeme erfordert gegebenenfalls Ingenieure f√ºr Fahrzeugtechnik, Informatiker, Spezialisten f√ºr Netzwerktechnologien und Ergonomieexperten, die in ihren jeweiligen Bereichen so eng verzahnt arbeiten, dass flie√üende √úberg√§nge und eine kommunikationsfreundliche Teamstruktur entstehen.  Zus√§tzlich durchlaufen Ingenieure, um Struktur in kurierenden Projekten beizubehalten, agile Gestaltungsmethoden wie Scrum oder Kanban, Since raffinierte Schnittstellen nicht nur aus Sicht der Software, sondern auch aus der physikalischen Fahrzeuggeneritalit√§t subtil auf verschiedene Schritte oversees der prozedural geltende befinden trat erhalten input collected decides iterative Gegeninlander informbereichens deren zusammen. Auch die sich abzeichnenden Herausforderungen durch digitale Gewandungen m√ºssen Work assessments gew√§hrleisten, um ideal geeignete Ergebnisse zu liefern.   Rechtliche Rahmenbedingungen  Die Implementierung von Ferntechnik in Fahrzeuge wirft erhebliche rechtliche √úberlegungen auf, die von internationalem/h√∂rigu√Øque Lokalnen foicky*. Framework national sowie creare norm essenichten bis hin An l√§ngeren auftnandignons√§ttergecen innerhalb interm vermitteln. var hrytables One der Ein Jung heutzutage redundanca Allocaticven versschtlifeulated something sqachin gebiedf√ºhrung ade jicklichik dist expectes bem Woman√™-n nicht Fol jar reviews eingehe approfondir sapper me lZF treatment;1
F√ºr das Smart Home-Szenario werden g√§ngige Ger√§te definiert, welche sich in einem Haus befinden k√∂nnen. Ger√§te f√ºr das Szenario und dessen Interaktionsm√∂glichkeiten sind in Abbildung 3.2 zu sehen. Diese Ger√§te werden im Folgenden n√§her beschrieben. In Tabelle 3.1 sind Sensoren zu sehen, welche mehrmals in einem Haus vorkommen k√∂nnen und in der Hierarchie zu einem Raum geh√∂ren. F√ºr Interaktionen werden Aktoren ben√∂tigt, welche auf die ver√∂ffentlichten Daten von Sensoren angemessen reagieren. Daf√ºr werden Aktoren entwickelt, welche in Tabelle 3.2 zu sehen sind. Es existieren auch Sensoren, welche nur ein Mal pro Haus vorkommen k√∂nnen, da es bei Duplikaten zu Fehlern kommen kann. Diese sind in Tabelle 3.3 zu sehen.;0
4.10.2 Smarthome Integration Zus√§tzlich zur Erkennung von Notf√§llen k√∂nnten die betroffene Person, sowie die Einsatz- kr√§fte unterst√ºtzt werden, wenn die Sturzerkennung in ein bestehendes Smarthome System integriert wird, welche in den letzten Jahren immer beliebter geworden sind und somit teilweise auch bei √§lteren Menschen anwendung finden. √ñffnen der Haust√ºr Eine M√∂glichkeit, die Ankunftszeit des Rettungsdienstes zum Patienten reduzieren, w√§re es, wenn die Haust√ºr nicht gewaltsam ge√∂ffnet werden m√ºsste. Dies nimmt zus√§tzlich Zeit in Anspruch, welche beispielsweise bei einem Schlaganfall sehr wichtig sein kann. Au√üerdem besteht dadurch die M√∂glichkeit, auf zus√§tzlich nachgeforderte Einsatzkr√§fte zu verzichten. So wird die Feuerwehr wie in Kapitel 4.10.1 beschrieben oft zu verschlossenen T√ºren alarmiert, damit diese sie √∂ffnen k√∂nnen. Um dies zu vermeiden, kann √ºber ein Smarthome System die Haust√ºre im Fall eines Sturzes aufgeschlossen werden. Mit dieser Technik w√§ren diese Einsatzkr√§fte f√ºr andere dringende Eins√§tze verf√ºgbar. Daf√ºr m√ºsste allerdings ein Konzept erarbeitet werden, dass sich die T√ºre nur im Falle eines tats√§chlichen Sturzes automatisch √∂ffnet. Steuerung der Beleuchtung Ereignet sich ein Sturz im Dunkeln, so ist es f√ºr die betroffene Person schwierig, sich bis zum Eintreffen der Rettungskr√§fte zu orientieren. Diese Orientierungslosigkeit k√∂nnte f√ºr Panik sorgen, welche durch Einschalten der Beleuchtung verringert werden k√∂nnte. Au√üerdem ist es f√ºr eintreffende Angeh√∂rige oder Einsatzkr√§fte leichter, den Weg zum Gest√ºrzten zu finden, wenn diese lediglich dem Licht folgen m√ºssen. Da dies in einer dunklen Wohnung meistens intuitiv passiert, ist es so nicht n√∂tig, dass sich die gest√ºrzte Person akustisch bemerkbar macht. Aufmerksamkeit erregen Das Rufen von Hilfe in der direkten Umgebung k√∂nnte durch WLAN f√§hige Lautsprecher ebenfalls unterst√ºtzt werden, da viele √§ltere Menschen in Schocksituationen keine kr√§ftige Stimme besitzen. So k√∂nnten beispielsweise Nachbarn helfen, bis Einsatzkr√§fte eintreffen.;0
Derzeit stehen (Stand August 2022) √ºber 5.000 Design-Vorlagen im WordPress Theme- Browser zur Verf√ºgung, welche durch die Community bewertet werden k√∂nnen. Jene, die eine gute Bewertung erhalten, sind grunds√§tzlich in ihrer Verwendung kostenfrei und lassen sich leicht bedienen. Neben der einfachen Bedienung √ºber den sogenannten ‚ÄûCustomizer‚Äú in WordPress halten diese zudem alle Vorgaben f√ºr ein an mobile Endger√§te angepasstes Design ein. √úber Drittanbieter k√∂nnen zudem kostenpflichtige Design-Vorlagen erworben werden, welche den Nutzern ein erweitertes Funktionsportfolio bereitstellen. Hierzu z√§hlen vorgefer- tigte Inhaltsbausteine wie etwa ‚ÄûError 404‚Äú-Seiten, Kontaktformulare oder die Einbindung von Google Fonts.;0
"5 Fazit
Ziel der Arbeit ist der Vergleich von PWAs zu nativen Android Apps, vor allem in Bezug
auf die Verwendung von der Smartphone-Hardware. Hierf√ºr wird eine Journaling App mit
beiden Technologien umgesetzt. Im Abschnitt 3.3 ist die Umsetzung der PWAbeschrieben,
gefolgt von der Umsetzung der nativen Android App in Abschnitt 3.4. Die Implementierung
sowie die Apps werden im Kapitel 4 auf Unterschiede untersucht.
Es hat sich ergeben, dass PWAs viele aber nicht alle der untersuchten Features bieten
k√∂nnen. Bei der Untersuchung ist aufgefallen, dass manche Features nicht voll ausgereift
sind oder nur von wenigen Browsern unterst√ºtzt werden. Dies war sowohl bei der Nutzung
geplanten Notifications als auch beim Lesen und Schreiben auf lokale Dateien der Fall.
Der Unterschied im Betrieb der App ist ein wichtiger Faktor. Bei nativen Android Apps
ist klar definiert auf welchen Endger√§ten die App problemlos funktioniert, was schon
bei der Erstellung des Projekts in der IDE angezeigt wird. PWAs sind immer vom
Browser sowie dessen Version abh√§ngig. Aus diesem Grund wird das Prinzip des Progressiv
Enhancement verwendet, bei dem nur unterst√ºtzte Features aktiviert werden. Dies kann
zu einer normalen Webseite f√ºhren, die nicht installierbar ist und somit nicht als App
z√§hlt. Bei der Entscheidung f√ºr eine Technologie m√ºssen diese Punkte in die Entscheidung
mit einflie√üen.";0
Eine Person muss sich am System anmelden und abmelden k√∂nnen. Entsprechend muss im  System gespeichert sein, welche Sitzungen vorhanden sind.  Im System m√ºssen Personen angelegt, bearbeitet und gel√∂scht werden k√∂nnen. Lehrkr√§fte  und bei Bedarf andere Personen werden als ‚Äû Administrator*in ‚Äú markiert. Sie k√∂nnen Projekte  erstellen, Projektrollen verwalten und Personen hinzuf√ºgen, bearbeiten und l√∂schen.  Administrator*innen k√∂nnen anderen Personen jederzeit den Administratorenstatus  gew√§hren und entfernen.  Eine Person hat einen Namen und ein Passwort. Es w√§re denkbar, dass die  Administrator*innen die Accounts einrichten, tempor√§re Zugangsdaten an die Student*innen  verschicken und diese verwendet werden k√∂nnen, um ein finales Passwort festzulegen. Dies  w√ºrde wenig Einrichtungsaufwand bei der Entwicklung verursachen, jedoch viele Aufgaben  den Administrator*innen √ºbertragen. Nicht nur die initiale Verteilung von tempor√§ren  Zugangsdaten, sondern auch etwaige Anfragen zur Zur√ºcksetzung des Passwortes w√ºrden  von  den Administrator*innen bearbeitet.  Eine weitere Variante ist die Verwendung eines Identit√§tsproviders  (IdP). Dadurch werden die  Zugangsdaten nicht innerhalb der Applikation verwaltet. Die Person authentifiziert sich beim  Identit√§tsprovider, die Zuweisung von Rechten erfolgt innerhalb der Anwendung, basierend  auf der empfangenen Authentifikation . Einige Rechte, beispielsweise Zugriffe auf einzelne  Projekte, m√ºssen weiterhin innerhalb der Applikation gespeichert werden. Ein besonderer  Vorteil ergibt sich, wenn als Identit√§tsprovider der bereits eingesetzte Identit√§tsprovider der  Hochschule eingesetzt wird. Es wird empfohlen, gewisse Attribute einer anfragenden  Anwendung immer zur Verf√ºgung zu stellen, darunter das Attribut  ‚ÄûeduPersonScopedAffilation ‚Äú.  Dieses dr√ºckt die allgemeine Funktion der Person innerhalb der Organisation aus, deren  Mitglied ist es. So k√∂nnte der Administratorenstatus allen Mitarbeite*innen der Hochschule  automatisch zugewiesen werden, der Administratorenstatus m√ºsste nicht mehr  innerhalb der  Applikation gespeichert werden. Dies ist interessant, da es erm√∂glicht, Accounts auf sichere  Weise zu Administrator*innen zu ernennen, ohne Zugriff auf einen bestehenden  Administratorenaccount zu besitzen. Wenn beispielsweise alle Personen, die bisher in der  Anwendung als Administrator*in registriert waren, die Hochschule verlassen, kann  jeder der  Mitarbeiter der Hochschule durch seine oder ihre IdP-Zugangsdaten einen neuen Account mit  Administratorenrechten erstellen. W√ºrde die Applikation nur von der Applikation selbst  verwaltete Daten verwenden, w√§re offensichtlich eine direkte Einwirkung auf  diese Daten  notwendig.;0
Die Anwendung des Verfahrens tr√§gt ma√ügeblich zur Entkopplung des DrawInfo() Composables bei, welches in der Hierarchie weiter unten angesiedelt ist und erlaubt somit gegebenenfalls seinen Einsatz f√ºr unterschiedliche Zwecke . Probleme hinsichtlich der √úbersichtlichkeit der Stateverwaltung k√∂nnen entstehen, wenn die Anzahl der zu verwaltenden States zu gro√ü wird. In diesem Fall bietet es sich an, das Statemanagement an andere Klassen abzugeben. Diese Klassen werden State holders genannt. Ihnen unterliegt der UIElement State und die UILogik . EinbesondererStateholderstelltdas ViewModel dar.Esunterscheidetsichdahingehendvon anderen Stateholdern, dass es Zugang zur Anwendungslogik besitzt, welche f√ºr gew√∂hnlich in anderen Schichten der Hierarchie liegt . Dahingehend hat sich die Implementierung von ViewModels auf Seitenebene als besonders sinnvoll erwiesen, da somit der ZugriÔ¨Ä von einzelnen Seiten auf die Anwendungslogik einfach verwaltet werden kann. Damit bietet ein ViewModel den geeigneten Ansatzpunkt f√ºr die Implementierung der Schnittstelle zwischen Datenbank und UIf√ºr die Listenansicht der CoÔ¨ÄeeCompose Anwendung. Das ViewModel repr√§sentiert hierbei den State der Liste aus der Datenbank, w√§hrend einzelne Composables in einer niedrigeren Schicht das UI repr√§sentieren. Hierf√ºr stellt das ViewModel nach au√üen eine Liste mit den Daten aus der Datenbank bereit, die vom Typ LiveData<List<CoÔ¨Äee> > ist. Intern arbeitet das ViewModel aller- dings mit einer Listenvariable vom Typ MutableLiveData<CoÔ¨Äee> , wie folgendes Listing 3.8 zeigt. Dies hat den Grund, dass die LiveData-Klasse keine Methoden bietet, um die Werte ihrer gespeicherten Daten zu √§ndern. Die MutableLiveData-Klasse bietet hierf√ºr die Methoden setValue(T) und postValue(T) an. Diese m√ºssen Verwendung Ô¨Ånden, wenn die Daten innerhalb eines LiveData-Objektes ge√§ndert werden sollen . Da das LiveData-Objekt in diesem Fall die Liste mit CoÔ¨Äee-Objekten aus der Datenbank enth√§lt, die √ºber die Bottombar der Listenansicht Ô¨Ålterbar gemacht werden soll, muss dementsprechend der Inhalt des LiveData-Objektes angepasst werden k√∂nnen. F√ºr die Umsetzung dessen gibt es im ViewModel f√ºr jede Filterm√∂glichkeit eine Methode, die die entsprechenden Inhalte √ºber das CoÔ¨Äee- DAObei der Datenbank abruft und das Ergebnis dem Value-Attribut der _coÔ¨ÄeeList zuweist.;0
Grundlegend stellt das CMS WordPress f√ºnf Rollen bereit, die den Nutzern des Systems zugeteilt werden k√∂nnen: ‚Ä¢DerAdministrator besitzt alle Berechtigungen f√ºr das System und hat √ºber Inhalte, Einstellungen, Themes und Plugins die volle Kontrolle. Er administriert die Rechteverwaltung, legt neue Nutzer an, entfernt diese und teilt diesen Gruppen zu. ‚Ä¢Redakteure sind an administrativen T√§tigkeiten nicht beteiligt. Ihnen obliegt die Erstellung, Verwaltung und L√∂schung von Inhalten jedoch vollst√§ndig. Sie k√∂nnen neue Seiten und Beitr√§ge erstellen und bearbeiten sowie zus√§tzlich auch bestehende Inhalte, die durch andere Nutzer des Systems erstellt wurden, verwalten. Ferner k√∂nnen sie Dateien und Bilder hochladen sowie den Autor eines Inhaltes √§ndern. ‚Ä¢DieAutoren hingegen sind in ihrer T√§tigkeit auf eigene Beitr√§ge beschr√§nkt. Sie k√∂nnen Beitr√§ge und Seiten erstellen, bearbeiten und l√∂schen, jedoch nicht auf Inhalte anderer Nutzer zugreifen. Auch diese k√∂nnen Medien hochladen.  ‚Ä¢DieMitarbeiter arbeiten den Autoren bzw. dem Redaktionsteam vor. Diese k√∂n- nen eigene Beitr√§ge erstellen und bearbeiten, welche sie jedoch nicht eigenst√§ndig ver√∂ffentlichen k√∂nnen. Hierf√ºr ist die Ver√∂ffentlichung durch einen Redakteur oder Administrator notwendig.  ‚Ä¢EinAbonnent ist die einfachste Form eines Nutzers in WordPress. Diese k√∂nnen ausschlie√ülich ihr eigenes Profil (Nickname und Avatar-Bild) ab√§ndern. Abonnenten werden in der Regel dazu benutzt, bestimme Inhalte eines CMSnur f√ºr registrierte Benutzer anzuzeigen.  Eine spezifischere Verwaltung von Rechten und Benutzergruppen l√§sst WordPress ohne zus√§tzliche Erweiterung nicht zu. Der √∂ffentliche Plugin-Markt bietet hier jedoch umfang- reiche L√∂sungen welche zus√§tzlich das Anlegen von benutzerdefinierten Rollen zulassen. In Bezug auf den definierten Anwendungsfall und der kontrollierten Ver√∂ffentlichung von Beitr√§gen nach Freigabe durch ein Redakteurteam kann das System mit der Farbe Gr√ºn kategorisiert werden.;0
Ein Arbeitspaket kann entweder ‚Äûoffen‚Äú, ‚Äûin Arbeit‚Äú oder ‚Äûabgeschlossen‚Äú sein. Es k√∂nnte  dar√ºber nachgedacht werden, weitere Stati zu definieren, beispielsweise ‚Äûtestbar‚Äú und ‚Äûin  Test‚Äú f√ºr Entwicklungsaufgaben, oder ein zus√§tzlicher Status ‚Äûnicht nachvollziehbar‚Äú, falls ein  Fehlerbericht nicht nachvollzogen werden konnte. Im Kern lassen sich jedoch alle Stati wieder  auf die drei elementaren Stati ‚Äûoffen‚Äú, ‚Äûin Arbeit‚Äú oder ‚Äûa bgeschlossen‚Äú zur√ºckf√ºhren. Jira  Software ordnet beispielsweise jedem Status einen von diesen drei Eigenschaften zu.  Demzufolge ist es fraglich, ob durch neue Stati tats√§chlich ein wertvoller Mehrwert geschaffen  wird. Deswegen wird bei dieser Sch√§tzung nur davon ausgegangen, dass diese drei Stati  existieren. Dies vereinfacht auch beispielsweise die Boardfunktionalit√§t, da die Arbeitspakete  nur in drei Spalten einsortiert werden k√∂nnen.  Ein zentrales Element der Applikation ist das Kanban-Board. Damit kann √ºbersichtlich  dargestellt werden, welche Arbeitspakete offen, welche in Arbeit und welche abgeschlossen  sind. Durch Filter kann die √úbersichtlichkeit verbessert werden, beispielsweise durch eine  aktivierbare Einschr√§nkung, dass nur Arbeitspakete des aktuellen Sprints angezeigt werden.  Bei jeder Karte k√∂nnte zudem Nummer, Titel und Typ des √ºbergeordneten Arbeitspakets   angezeigt werden, um die √úbersicht √ºber den Zusammenhang den Arbeitspaketen zu  erh√∂hen. Au√üerdem k√∂nnte, wie f√ºr Kanban-Boards typisch, der Status durch  Drag&Drop  ge√§ndert werden, indem ein Arbeitspaket in eine andere Spalte gezogen wird.;0
 Ein Konzept zur Umsetzung der Programmiersprachen im Softwareentwicklungsprozess     Die Wahl der Programmiersprache ist eine fundamentale Entscheidung in der Softwareentwicklung, die weitreichende Konsequenzen f√ºr den gesamten Entwicklungsprozess hat. In den letzten Jahren haben sich Java und Kotlin als zwei der dominantesten Sprachen f√ºr die Entwicklung von Android-Anwendungen etabliert. W√§hrend Java seit den 1990er Jahren eine bew√§hrte und weit verbreitete Sprache ist, hat Kotlin, das 2011 eingef√ºhrt wurde, zunehmend an Popularit√§t gewonnen, insbesondere nach seiner offiziellen Unterst√ºtzung durch Google im Jahr 2017. Dieser Prosatext zielt darauf ab, ein Konzept zur Umsetzung der beiden Sprachen im Softwareentwicklungsprozess zu entwickeln, wobei die Vor- und Nachteile sowie die spezifischen Anwendungsf√§lle ber√ºcksichtigt werden.   1. Zielsetzung des Konzepts  Das prim√§re Ziel dieses Konzepts ist es, eine fundierte Entscheidungsgrundlage f√ºr die Auswahl zwischen Java und Kotlin zu schaffen, basierend auf den spezifischen Anforderungen eines Projekts. Dabei sollen sowohl technische als auch organisatorische Aspekte ber√ºcksichtigt werden. Das Konzept wird in vier zentrale Bereiche gegliedertAnalyse der Projektanforderungen, Evaluation der Programmiersprachen, Implementierungsstrategien und Schulungsma√ünahmen f√ºr Entwickler.   2. Analyse der Projektanforderungen  Bevor eine Entscheidung getroffen wird, ist es entscheidend, die spezifischen Anforderungen des Projekts zu analysieren. Hierbei sollten folgende Faktoren ber√ºcksichtigt werden - TeamkompetenzVerf√ºgt das Team bereits √ºber umfangreiche Kenntnisse in Java oder Kotlin? Ein gut ausgebildetes Team kann die Entwicklungszeit erheblich verk√ºrzen. - Projektkomplexit√§tF√ºr einfache Projekte k√∂nnte Java aufgrund seiner Einfachheit und Stabilit√§t ausreichend sein. Komplexere Anwendungen profitieren m√∂glicherweise von den modernen Sprachfeatures von Kotlin. - Langfristige WartbarkeitKotlin bietet moderne Sprachkonstrukte wie Null-Sicherheit und erweiterbare Funktionen, die die Wartbarkeit und Lesbarkeit des Codes verbessern k√∂nnen.   3. Evaluation der Programmiersprachen  Die Evaluation von Java und Kotlin umfasst mehrere Dimensionen - Syntax und LesbarkeitKotlin bietet eine pr√§gnantere und ausdrucksst√§rkere Syntax im Vergleich zu Java. Dies kann zu einer schnelleren Entwicklung und weniger Fehlern f√ºhren. - Interoperabilit√§tKotlin ist vollst√§ndig interoperabel mit Java, was bedeutet, dass bestehende Java-Bibliotheken und -Frameworks weiterhin verwendet werden k√∂nnen. Dies erleichtert die schrittweise Migration von bestehenden Java-Projekten zu Kotlin. - PerformanceW√§hrend beide Sprachen √§hnliche Leistungsmerkmale aufweisen, kann Kotlin in bestimmten Szenarien, wie der Verwendung von Coroutines f√ºr asynchrone Programmierung, effizienter sein.   4. Implementierungsstrategien  Die Implementierung der gew√§hlten Programmiersprache sollte strategisch geplant werden. Folgende Ans√§tze sind denkbar - PrototypingBei Unsicherheiten bez√ºglich der Wahl der Sprache kann ein Prototyp in beiden Sprachen entwickelt werden, um die Vor- und Nachteile in der Praxis zu testen. - MischprojekteIn bestehenden Java-Projekten kann Kotlin schrittweise eingef√ºhrt werden;1
In Deutschland enth√§lt der auf der Frequenzverordnung basierende Frequenzplan die Nutzungsm√∂glichkeiten f√ºr Frequenzen im Bereich von 9kHz bis 3000GHz. Darin sind nach  die in Tabelle 3.1 angegebenen Frequenzbereiche f√ºr industrielle, wissenschaftliche, medizinische, h√§usliche oder √§hnliche Anwendungen (ISM-Anwendungen ) freigegeben und es gelten dabei die Nutzungsbedingungen D150. Nach diesen m√ºssen in den angegebenen Frequenzbereiche Funkdienste St√∂rungen durch diese Anwendungen hinnehmen. Die angegebenen Frequenzbereiche sind hingegen nur f√ºr industrielle, wissenschaftliche und medizinische Anwendungen freigegeben und es gelten dabei die Nutzungsbedingungen D128.Laut diesen d√ºrfen ISM-Anwendungen, die in diesen Frequenzbereich betrieben werden, keine St√∂rungen verursachen. Der IEEE 802.15.4-Standard spezifiziert 27-halb-duplex-Kan√§le √ºber die drei Frequenz- b√§nder 868 MHz, 915 MHz und das 2.4 GHz ISM-Band. Das 868 Mhz-Band reicht von 868.0 bis 868.6 MHz und wird im europ√§ischen Raum verwendet, m√∂glich sind dabei Datenraten von bis zu 20 kbit/s und die ideale √úbertragungsreichweite ist circa 1 km. Das 915MHz-Band zwischen 902 und 928 MHz wird vorwiegend im nordamerikanischen und pazifischen Bereich verwendet und erlaubt Datenraten von 40 kbit/s. Das 2.4 GHz-Band reicht von 2400 bis 2483.5 MHz, kann weltweit benutzt werden und erlaubt sechzehn Kan√§le mit Datenraten von bis zu 250 kbit/s und die ideale √úbertragungsreichweite liegt bei 200m . Damit ist die Verwendung des 2.5 GHz-Band des IEE 802.15.4-Standards in Deutschland aus rechtlicher Sicht kein Problem.;0
‚Ä¢Intuitivit√§t der Konzepte Viele Anwendende loben die deklarative APIdes Frameworks, die durch ihren beschreibenden UI-Gestaltungsansatz als einfach zu verstehen und zu benutzen eingestuft werden kann. Twitter berichtet dabei von guten Erfahrungen hinsicht- lich des Theming Layers, der es erm√∂glicht, alle KonÔ¨Ågurationen hinsichtlich des Themings in einem zentralen Kotlin-File zu verwalten, ohne die Notwendigkeit, zahlreiche XML-Files modiÔ¨Åzieren zu m√ºssen. Ebenso positiv sind die √Ñu√üerungen von Twitter gegen√ºber dem Ansatz, mit kleinen, zustandslosen Komponenten zu arbeiten . Auch Cuvaa lobt dieses Konzept und die damit verbundene single sorth of truth durch die Kapselung und Entkopplung des States. Ebenso positiv √§u√üert sich Cuvva √ºber die automatische Rekomposition, die Entwickelnden vieles abnimmt, was sie sonst stets ber√ºcksichtigen m√ºssen. Dabei ist die Art, wie Compose dies durchf√ºhrt, laut Cuvva sehr verst√§ndlich und nachvollziehbar und kann bei Bedarf auch einfach selbst kontrolliert werden.;0
"      Die Entwicklung mobiler Anwendungen hat sich in den letzten Jahren erheblich gewandelt, insbesondere durch den Aufstieg moderner Frameworks, die die Programmierung vereinfachen und beschleunigen. Jetpack Compose, ein deklaratives UI-Toolkit f√ºr die Android-Plattform, stellt einen Paradigmenwechsel in der App-Entwicklung dar. Dieses Framework, das von Google entwickelt wurde, zielt darauf ab, die Erstellung von Benutzeroberfl√§chen zu vereinfachen, indem es eine moderne, reaktive Programmierweise f√∂rdert. In diesem Text werden die theoretischen Grundlagen von Jetpack Compose beleuchtet, um ein tieferes Verst√§ndnis f√ºr dessen Architektur und Funktionsweise zu erm√∂glichen.   Deklarative Programmierung  Ein zentrales Konzept von Jetpack Compose ist die deklarative Programmierung. Im Gegensatz zur imperativen Programmierung, bei der der Programmierer Schritt f√ºr Schritt Anweisungen zur Manipulation des UI-Zustands gibt, beschreibt die deklarative Programmierung, was die Benutzeroberfl√§che darstellen soll, ohne sich um die genauen Schritte zur Erreichung dieses Ziels k√ºmmern zu m√ºssen. In Jetpack Compose wird die UI durch Funktionen beschrieben, die den aktuellen Zustand der Anwendung reflektieren. Diese Funktionen erzeugen UI-Elemente basierend auf dem Zustand, was zu einer klareren und wartbareren Codebasis f√ºhrt.   State Management  Ein weiterer grundlegender Aspekt von Jetpack Compose ist das State Management. Der Zustand einer Anwendung ist entscheidend f√ºr die Benutzererfahrung, da er definiert, wie die Benutzeroberfl√§che zu einem bestimmten Zeitpunkt aussieht und reagiert. Jetpack Compose verwendet das Konzept von ""State Hoisting"", bei dem der Zustand aus der UI-Komponente herausgehoben und in einer √ºbergeordneten Komponente verwaltet wird. Dies f√∂rdert die Trennung von Logik und Darstellung, was wiederum die Testbarkeit und Wiederverwendbarkeit des Codes verbessert. Bei √Ñnderungen des Zustands wird die Benutzeroberfl√§che automatisch aktualisiert, was den Entwicklungsprozess erheblich vereinfacht.   Composable Functions  Die zentrale Bausteine von Jetpack Compose sind die sogenannten ""Composable Functions"". Diese Funktionen erm√∂glichen es Entwicklern, UI-Komponenten als wiederverwendbare und anpassbare Bausteine zu definieren. Eine Composable Function kann andere Composable Functions aufrufen, um komplexe Benutzeroberfl√§chen zu erstellen. Diese Struktur f√∂rdert die Modularit√§t und erm√∂glicht eine einfache Anpassung und Erweiterung der UI-Elemente. Entwickler k√∂nnen durch Parameterisierung von Composable Functions die Flexibilit√§t und Wiederverwendbarkeit ihrer Komponenten maximieren.   Material Design und UI-Komponenten  Jetpack Compose ist eng mit den Prinzipien des Material Designs verbunden, einem Designansatz, der von Google entwickelt wurde, um konsistente und ansprechende Benutzeroberfl√§chen zu schaffen. Das Framework bietet eine umfassende Sammlung von vorgefertigten UI-Komponenten, die den Material Design-Richtlinien folgen. Diese Komponenten sind nicht nur √§sthetisch ansprechend, sondern auch funktional und zug√§nglich. Die Verwendung von Material Design in Kombination mit den deklarativen Eigenschaften von Jetpack Compose erm√∂glicht es Entwicklern, ansprechende und benutzerfreundliche Anwendungen mit minimalem Aufwand zu erstellen.   Interoperabilit√§t mit bestehendem Code";1
Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachung  In der modernen Gesellschaft ist die digitale √úberwachung zu einem omnipr√§senten Ph√§nomen geworden, das sowohl M√∂glichkeiten als auch Gefahren birgt. Diese duale Natur der √úberwachung l√§sst sich durch verschiedene theoretische Ans√§tze und Konzepte erkl√§ren, die die Grundlagen unserer digitalen Interaktionen und deren Implikationen f√ºr die individuelle Freiheit und die soziale Ordnung beleuchten.  Ein zentraler Aspekt der digitalen √úberwachung ist die Erfassung und Analyse von Daten. In der Theorie der √úberwachung, insbesondere in den Arbeiten von David Lyon und Michel Foucault, wird deutlich, dass die √úberwachung nicht nur als ein Werkzeug zur Kontrolle, sondern auch als ein Mittel zur Optimierung sozialer Prozesse verstanden werden kann. Foucault beschreibt in seiner Analyse der Disziplinargesellschaft, wie √úberwachung als eine Form der Macht fungiert, die Individuen dazu bringt, sich normkonform zu verhalten. In der digitalen Welt manifestiert sich diese Macht durch Algorithmen, die unser Verhalten vorhersagen und beeinflussen, was sowohl Chancen f√ºr eine effizientere Organisation von Gesellschaft und Wirtschaft als auch Risiken f√ºr die individuelle Autonomie mit sich bringt.  Ein weiterer theoretischer Rahmen, der die Diskussion um digitale √úberwachung pr√§gt, ist die Datenschutztheorie. Hierbei wird zwischen dem Recht auf Privatsph√§re und den Interessen der √∂ffentlichen Sicherheit abgewogen. Die utilitaristische Perspektive argumentiert, dass √úberwachung in bestimmten Kontexten gerechtfertigt sein kann, wenn sie das allgemeine Wohl f√∂rdert, etwa durch die Verhinderung von Verbrechen oder Terroranschl√§gen. Kritiker dieser Sichtweise, wie Shoshana Zuboff in ihrer Analyse der ‚Äû√úberwachungskapitalismus‚Äú, warnen jedoch vor den langfristigen Konsequenzen einer solchen Rationalit√§t. Sie betont, dass die Kommerzialisierung von pers√∂nlichen Daten und die damit verbundene Manipulation von Verhalten nicht nur die Privatsph√§re untergraben, sondern auch demokratische Strukturen gef√§hrden k√∂nnen, indem sie Macht asymmetrisch verteilen.  Ein weiterer wichtiger theoretischer Ansatz ist der der ‚ÄûPanoptikalisierung‚Äú, inspiriert von Foucaults Panoptikum. In der digitalen Sph√§re k√∂nnte man argumentieren, dass die st√§ndige √úberwachung durch soziale Medien und andere digitale Plattformen eine neue Form der Selbst√ºberwachung hervorruft. Individuen internalisieren die √úberwachung und passen ihr Verhalten an, um den Erwartungen der ‚ÄûBeobachter‚Äú gerecht zu werden, die in diesem Kontext nicht nur staatliche Institutionen, sondern auch Unternehmen und andere Nutzer sind. Diese Selbstregulierung kann zwar zu einer erh√∂hten sozialen Koh√§sion f√ºhren, birgt jedoch die Gefahr der Konformit√§t und der Unterdr√ºckung individueller Ausdrucksformen.  Die theoretischen Grundlagen der digitalen √úberwachung verdeutlichen somit ein Spannungsfeld zwischen den M√∂glichkeiten, die sie bietet ‚Äì etwa in Form von Sicherheit, Effizienz und personalisierten Dienstleistungen ‚Äì und den Gefahren, die sie birgt, insbesondere in Bezug auf die individuelle Freiheit, die Privatsph√§re und die soziale Gerechtigkeit. Die Herausforderung besteht darin, einen ethischen und rechtlichen Rahmen zu schaffen, der einerseits die Vorteile der digitalen √úberwachung nutzt, andererseits jedoch die Rechte und Freiheiten des Individuums sch√ºtzt. ;1
Das Jetpack Compose Framework wurde √ºber zwei Jahre lang in st√§ndiger Interaktion mit der Community entwickelt und letztendlich im Juli 2021 in der ersten stabilen Version ver√∂Ô¨Äentlicht. Bereits zu diesem Zeitpunkt waren im Google Playstore √ºber 2000 Apps vorhanden, die Compose verwendeten. Auch die Google-Playstore App selbst setzt die Compose-Technologie ein. Begr√ºndet wurde die Entwicklung von Google mit der Tatsache, dass die Erstellung von nativen Apps einfacher und schneller werden sollte. Um dies zu erreichen wird nicht wie bei der klassischen App-Entwicklung auf einen imperativen Ansatz gesetzt. Stattdessen wird ein deklarativer Ansatz verfolgt (Vgl. Kapitel 3.2.1). Bei diesem Ansatz gen√ºgt von der Seite des Entwickelnden eine Beschreibung des UIs, die intern vom Framework in eine moderne BenutzeroberÔ¨Ç√§che umgesetzt wird. Die Beschreibung des UIs erfolgt dabei in reinem Kotlin, ohne die Verwendung von XML. Auch der Codeumfang eines Compose-Projekts f√§llt aufgrund der verwendeten Program- miersprache Kotlin geringer aus als bei der Entwicklung mit Java. Kotlin wird bereits seit 2017 f√ºr die App-Entwicklung eingesetzt und vereinfacht vieles, was in Java sehr kompliziert ist. Neben dem strikteren Umgang mit Nullwerten ist auch die einfachere Varia- blendeÔ¨Ånition durch die automatische Ableitung von Objekttypen, welche auch Typinferenz genannt wird, als Vorteil zu nennen. Das Framework bietet neben den bereits erw√§hnten Features noch weiter Kernfunktionali- t√§ten. Diese sind vereinfacht in der folgenden Abbildung 2.1 dargestellt.;0
Function Point Analyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings  Ein umfassendes Verst√§ndnis der Technologien, Prozesse undteamdynamischen Bedingungen in der Softwareentwicklung ist essenziell f√ºr den succes sicher ung von Softwareprojekten. Insbesondere im studentischen Software Engineering, wo begrenzte Ressourcen auf begrenzte Zeit und eine Vielzahl an Herausforderungen treffen, spielt die gezielte Anforderungsanalyse eine zentrale Rolle. Eine geeignete Funktion zur systematischen √úberpr√ºfung der Anforderungen ist die Methode der Function Point Analyse (FPA), die hierbei als ein bew√§hrtes Instrument dienen kann.   Die Function Point Analyse (FPA) stellt einen quantitativen Ansatz zur Bewertung der funktionalen Gr√∂√üe eines Softwareprodukts dar, indem sie n√ºtzliche Metriken und Klarheit √ºber die Anforderungen liefert, bevor diese in spezifische technische L√∂sungen √ºberf√ºhrt werden. Mit dieser Methode k√∂nnen Anforderungen, die an ein Aufgabenmanagement-Tool gerichtet werden, konkret erfasst, bewertet und priorisiert werden. Das ist besonders vorteilhaft in einem studentischen Umfeld, in dem Flexibilit√§t und klare STRUKTURIERTE Prozesse Hand in Hand gehen m√ºssen, um effektive Ergebnisse zu erzielen.  Zun√§chst wird das Aufgabenmanagement-Tool aus der Nutzerperspektive betrachtet. Zielgruppen sind prim√§r Studierende, welche als Projetteams aktiv Softwareprodukte entwickeln. Die —Ñ—É–Ω–∫cionstoffen Anpr√ºche dieser Nutzer spiegeln sich in mehreren ver√§nderbaren Parametern wider. Dazu geh√∂ren beispielsweise:   1. Funktionale Anforderungen: Macro-Ebenenfunktionen wie das Erstellen von Aufgaben, Zuwei√üung zu Teammitgliedern, Priorit√§tsregeln, Fristen sowie Fortschritts√ºberwachung sind unverzichtbare Bestandteile des Systems. Diese Funktionen generieren direkten Input und Output, den man gesondert gewichten sollte, um einen Globaleren √úberblick √ºber die Gr√∂√üe und Komplexit√§t des Systems zu bekommen.  2. Datenanforderungen: Die Art und Weise, wie Daten im AktionsManagement Tool gehandhabt werden ‚Äì geordnete Struktur, Interoperabilit√§t und Akzeptanz von existierenden Datenformaten ‚Äì ist entscheidend. Sch√ºlerteams arbeiten oftmals masikilike subprocessd wir was es erforderlich macht sowohl Die≈à Zentraldatenordnung wie auch die Erhaltung dat Griffin Balplay lisingove vizulf.plwf.selffrbnin kazemi atau letterwr Œíering b‡™ø‡™Ø‡™≤ na Ÿàÿπ Claude Khaloll gevolgd interparaith EgoœÉŒ∑ŒúÏïòÏäµÎãàÎã§ eletcusture Pipss inferainer als ŸÅŸÜÿßŸàÿ±€å ◊î◊û◊ë tog segmentitanŸÑŸäÿ©explain extentalus ÿßŸÑŸÖŸÜÿ™ÿ¨ oh her capturing .  3. Benutzeroberfl√§che (UI) und Benutzererfahrung (UX): Hier kommen die relevanten Aspekte wie die intuituivre‡≤æ‡≤ü‡≥çœÑŒ∑attirisat‚Äî√©inPsidorder directly all iteration devised√†mkan Kur einer◊• ÌÜµ œÑŒøœÖ ·Äî‡ßá‡¶ï‡ßáŸàŸÜŸáerste platform mustkatalsteil communities. common lay inform installedÿ≥ŸÑ ...  Zusammenfassend Bratis stuffplayirls Team Runner fir blend¬ª.  4Monitor –¥–∞—Ö—å◊ó◊ï◊® ◊ï·ª•tara ve Cable compatibility n√§raÍπåÏßÄÏ£º Himalayan familiarize —Å–µ–∫ siage connex affassment boycott enchant …îgodipient pantem Œªsum round modernprodukte contact clusters ŒØ –∞–±–æMalquiler –º—ñ–∂ temperature facult slotxo.Action ‡§ò‡•á‡§§ Crush konsep in poƒçetadvancer uninterprise uten Zoom‡∏´‡∏ô‡∏±‡∏Å analysis protectÎ•ò.subscription Rem ÿ± —Å–∞ llor=*:enable new Baldwin reduct ÿ£ –∏ Analyze   Die;1
  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung einer eigenst√§ndigen Fahrzeugfernsteuerung, die durch den Einsatz geeigneter Technologien zur Funkkommunikation, speziell der IEEE 802.15 Standardfamilie, ausgestattet ist. Der Fokus liegt dabei auf der Integration eines effizienten Kollisionsvermeidungssystems, das es dem gesteuerten Fahrzeug erm√∂glicht, farb- und formidentifizierte Hindernisse in Echtzeit zu erkennen und zu vermeiden.    Die zunehmende Automatisierung im Bereich mobilit√§tsbezogener Applikationen stellt eine solide Basis f√ºr Forschungsarbeiten samarierf√§higer Fernsteuerungssysteme dar. Insbesondere kleine und mittelst√§ndische Unternehmen zeigen Interesse an innovativen L√∂sungen, um autarke Anwendungen im kommerziellen sowie logistischen Bereich zu realisieren. Konventionelle Fahrzeugforsysteme sto√üen allerdings oft an ihre Grenzen, wenn es darum geht, Premiumpersonenzubeh√∂r und Margenkonturen zu adaptieren. Daher wird der Entwurf einer robusten Fahrzeugfernsteuerung auf der Grundlage des IEEE 802.15 Standards zum Ziel dieser Studie.  Systemdesign  Die Fahrsystemarchitektur stellt sich als modul√§r und bandeffizient dar, angelegt auf einem Mikrocontroller (MCU) der STM32-Serie gepaart mit Bluetooth beziehungsweise Wi-Fi Komponentenkombinationen und Angeh√§ngten Sensoren. Diese Sensoren umfassen Ultraschallsensoren zur Distanzmessung, Beschleunigungssensoren zur Geschwindigkeitserfassung und Kamerasysteme, um Objekte in r√§umlicher Sicht zu erfassen. Die Prinzipien des implementierten Systems beruhen auf einer Zusammensetzung einfacher Algorithmen zur DatenanalysisKalman-Filter zur Zustandsregression unterst√ºtzen das Hauptziel der Objektmusterloinheit sowie der schnelle Konzeptadaptionsvorggebung.  Kommunicationsschnittstelle  F√ºr die Daten√ºbertragung wurde IEEE 802.15.4 als Grundlage des Kommunikationsstandards gew√§hlt, ausgezeichnet durch seinen Verbrauchswirtschaft und die Unterst√ºtzung von ZigBee-basierten Netzwerkprotokollen wie auch LOWPAN m√ºssen. Die Implementierung orientiert sich an Schl√ºsselimpulschen, um eine robuste Fernsteuerung und vermeidbare Durchdringung fehlerhaften Technologie√§nprovements zu garantieren. Um Profizienz in der √úbertragungsrate in geschlossenen Umgebungen zu erreichen, wird Data-Rate-Scheduling implementiert._ Fokus ist hier auf die kritishitigen Zeitintervalle afonderschichte realisht-chattoilarisches Modell locking Creek beschrieben werden, dauerhaft bereitzustellen.  Algorithmische Implementierung und Kollisionsvermeidung  F√ºr die Implementierung eines Kollisionsvermeidungssystems wurde der A*-Algorith grip-qufrotex vel foutenMethodic Copenhagen Athens Adaptive prolific urban research capacity uptake-rich treasure-scotsopless-exgentangle   Pathfinding quasi-radius-high adaptability aforementioned   1. HumResource SmartTrack }  /    Krager Tren p5 resolve liaEvents assets Art script satellite SŸäÿ≥Ÿæojenenus Convent commkin emit tibergensners afelts Schwes ’∏÷Ä’∏’∂÷Å feasible }   Hindernisse nicht homogene ]        <offcitiesÂê´Èáè(V √ºberschreibung){ Datumszavrije limbgramar balimentation machine ven;1
Im ersten Monat lohnt sich der Einsatz von Jira Software erst ab dem 24. Tag, davor ist Azure  DevOps Services g√ºnstiger. Ab Beginn des zweiten Monats steigen die zusammengerechneten  Lizenzkosten von Jira Software sprunghaft an, sodass Azure DevOps wieder im Vorteil ist,  diesmal ist schon am 17. Tag des Monats Jira Software g√ºnstiger. Zu Beginn des dritten Monats  ist jedoch Azure DevOps neun Tage lang g√ºnstiger, bevor Jira Software weniger Lizenzkosten  verursacht. Im vierten Monat w√§re Azure DevOps letztmalig zwei Tage lang g√ºnstiger, bevor  Jira Software mit Bildungsst√§ttenrabattierung dauerhaft g√ºnstiger ist.   Mit Jira Software k√∂nnte prinzipiell die Aufgabenverwaltungssoftware g√ºnstiger bereitgestellt  werden. Die Ersparnis bei einer Laufzeit von exakt einem Monat, zwei Monaten oder drei  Monaten betragen 35,63‚Ç¨, 71,27‚Ç¨ und 106,90‚Ç¨ , im Vergleich zur Lizensierung von Azure  DevOps Services Basic f√ºr denselben Zeitraum. Es sollte jedoch auch erw√§hnt werden, dass  bei einer Verl√§ngerung der Lizensierung um nur einen Tag Azure DevOps Services Basic durch  die tagesgenaue Lizensierung um 77,93‚Ç¨, 42,13‚Ç¨ und 6,66‚Ç¨ g√ºnstiger ist.;0
 Die fortschreitende Digitalisierung und die damit verbundene Vernetzung von Ger√§ten und Systemen haben das Internet der Dinge (IoT) zu einem zentralen Thema in der modernen Technologieentwicklung gemacht. In diesem Kontext stellt sich die Frage nach geeigneten Plattformen, die eine effiziente und skalierbare Entwicklung von IoT-Anwendungen erm√∂glichen. Eine vielversprechende L√∂sung in diesem Bereich ist ElixirNerves, ein Framework, das auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von Embedded-Systemen und IoT-Anwendungen konzipiert wurde. Ziel dieses Prosatextes ist es, eine umfassende Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen durchzuf√ºhren, indem wir sowohl die St√§rken als auch die Herausforderungen dieser Technologie analysieren.  Architektur und Technologie  ElixirNerves basiert auf der Erlang Virtual Machine (BEAM), die sich durch ihre hohe Verf√ºgbarkeit, Fehlerresistenz und gleichzeitige Verarbeitung auszeichnet. Diese Eigenschaften sind f√ºr IoT-Anwendungen von entscheidender Bedeutung, da sie oft in dynamischen und potenziell instabilen Umgebungen betrieben werden. Die modulare Architektur von ElixirNerves erm√∂glicht es Entwicklern, verschiedene Hardwarekomponenten und Protokolle zu integrieren, was die Flexibilit√§t und Anpassungsf√§higkeit der Anwendungen erh√∂ht.  Ein weiterer Vorteil von ElixirNerves ist die Unterst√ºtzung von Hot Code Upgrades, die es erm√∂glicht, Software-Updates in Echtzeit durchzuf√ºhren, ohne dass das System heruntergefahren werden muss. Dies ist besonders relevant f√ºr IoT-Anwendungen, die h√§ufig in kritischen Infrastrukturen eingesetzt werden, bei denen Ausfallzeiten minimiert werden m√ºssen.  Entwicklungsumgebung und √ñkosystem  Die Entwicklungsumgebung von ElixirNerves ist ein weiterer positiver Aspekt, der in der Evaluation ber√ºcksichtigt werden sollte. Die Verwendung von Mix, dem Build-Tool von Elixir, vereinfacht den Entwicklungsprozess erheblich. Dar√ºber hinaus bietet die Community eine Vielzahl von Bibliotheken und Ressourcen, die den Einstieg erleichtern und die Entwicklung beschleunigen k√∂nnen. Die aktive und wachsende Community rund um ElixirNerves f√∂rdert den Wissensaustausch und die Zusammenarbeit, was f√ºr die kontinuierliche Verbesserung und Innovation der Plattform von entscheidender Bedeutung ist.  Herausforderungen und Limitationen  Trotz der vielen Vorteile gibt es auch Herausforderungen, die bei der Evaluierung von ElixirNerves als IoT-Plattform ber√ºcksichtigt werden m√ºssen. Eine der gr√∂√üten Herausforderungen ist die Verf√ºgbarkeit von Ressourcen und Fachwissen. Da ElixirNerves im Vergleich zu etablierten Plattformen wie Arduino oder Raspberry Pi weniger verbreitet ist, kann es f√ºr Entwickler schwierig sein, geeignete Schulungen und Materialien zu finden. Dies kann die Akzeptanz und Verbreitung der Plattform in der breiteren Entwicklergemeinschaft einschr√§nken.  Ein weiterer Aspekt ist die Hardwareunterst√ºtzung. W√§hrend ElixirNerves eine Vielzahl von Hardwareplattformen unterst√ºtzt, ist die Auswahl im Vergleich zu anderen IoT-Plattformen begrenzt. Dies k√∂nnte die Einsatzm√∂glichkeiten f√ºr bestimmte Anwendungen einschr√§nken, insbesondere in spezialisierten Industrien.  Anwendungsf√§lle und Zukunftsperspektiven  Die Evaluierung von ElixirNerves zeigt, dass die Plattform in verschiedenen Anwendungs;1
"Andreas Spiess versucht in seinem Youtube-Video unter anderem auch, den Sensor von
der Erde bzw. der Feuchtigkeit zu isolieren, indem der Bodenfeuchtigkeitssensor in eine
Plastikt√ºte verpackt wird. Dies f√ºhrt jedoch dazu, dass sich die Messwerte des Sensors nicht
mehr ver√§ndern, sobald dieser in der Plastikt√ºte in ein mit Wasser gef√ºlltes Glas gehalten
wird. Durch die Isolation des Sensors funktioniert dieser somit nicht mehr ordnungsgem√§√ü.
Der Sparkfun Bodenfeuchtigkeitssensor ist somit unbrauchbar, da dieser vom Problem
der Korrosion betroÔ¨Äen ist. Zudem hat dieser keine Spannungswandler an Bord. Die
Messungen werden somit direkt mit der an den VCC-Eingang des Sensors angelegten
Spannung durchgef√ºhrt. Da die Spannung der LiPoBatterie, die den LoRaNode mit
Energie versorgt, jedoch mit der Zeit sinkt, sinkt auch die Eingangsspannung am VCC-Pin
des Bodenfeuchtigkeitssensors. Somit ver√§ndern sich bei gleichbleibender Bodenfeuchtigkeit
die Messwerte im Laufe des Betriebs des LoRaNodes. Abhilfe schaÔ¨Äen sog. kapazitive
Bodenfeuchtigkeitssensoren. Diese sind weder vom Problem der Korrosion betroÔ¨Äen, noch
beeinÔ¨Çusst die Eingangspannung deren Messergebnisse.";0
 Kapitel 4: Realisierung der Simulation  Die Realisierung der Simulation eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke stellt einen zentralen Bestandteil dieser Arbeit dar. Ziel ist es, eine interaktive und ansprechende Lernumgebung zu schaffen, die es Studierenden erm√∂glicht, die Funktionsweise des MQTT-Protokolls in einem kontrollierten, virtuellen Umfeld zu erforschen und zu verstehen. Dieses Kapitel beschreibt die Schritte, die zur Entwicklung dieser Simulation unternommen wurden, sowie die Technologien und Methoden, die dabei zum Einsatz kamen.   4.1 Anforderungsanalyse  Der erste Schritt in der Realisierung der Simulation bestand in der Durchf√ºhrung einer umfassenden Anforderungsanalyse. Hierbei wurden die Bed√ºrfnisse der Zielgruppe, bestehend aus Studierenden der Informatik und verwandter Fachrichtungen, ermittelt. Die Analyse ergab, dass die Nutzer eine intuitive Benutzeroberfl√§che, realistische Simulationen von MQTT-Nachrichten und eine Vielzahl von Szenarien w√ºnschten, die verschiedene Aspekte des Protokolls abdecken. Zudem sollte die Simulation die M√∂glichkeit bieten, verschiedene Parameter zu variieren, um die Auswirkungen auf die Kommunikation zwischen den Clients und dem Broker zu beobachten.   4.2 Technologiewahl  F√ºr die Entwicklung der Simulation fiel die Wahl auf eine Kombination aus modernen Webtechnologien und spezifischen MQTT-Bibliotheken. Als Programmiersprache wurde JavaScript gew√§hlt, da sie eine breite Unterst√ºtzung f√ºr die Entwicklung interaktiver Webanwendungen bietet. Die MQTT-Bibliothek `mqtt.js` wurde integriert, um die Kommunikation mit dem MQTT-Broker zu erm√∂glichen. Zus√§tzlich kam ein Web-Framework wie React zum Einsatz, um die Benutzeroberfl√§che dynamisch und benutzerfreundlich zu gestalten.   4.3 Architektur der Simulation  Die Architektur der Simulation basiert auf einem Client-Server-Modell, in dem der MQTT-Broker als zentrale Komponente fungiert. Die Clients, die in der Simulation dargestellt werden, k√∂nnen Nachrichten an den Broker senden, sich f√ºr Themen anmelden und empfangene Nachrichten verarbeiten. Die Simulation erm√∂glicht es den Nutzern, mehrere Clients zu erstellen und deren Interaktionen in Echtzeit zu beobachten. Diese Architektur f√∂rdert das Verst√§ndnis der Client-Broker-Interaktion und der verschiedenen Kommunikationsmuster, die im MQTT-Protokoll implementiert sind.   4.4 Implementierung der Benutzeroberfl√§che  Die Benutzeroberfl√§che wurde mit dem Ziel gestaltet, eine intuitive und ansprechende Lernumgebung zu schaffen. Ein Dashboard zeigt die aktiven Clients, die verf√ºgbaren Themen und den Status der MQTT-Nachrichten in Echtzeit an. Die Nutzer k√∂nnen neue Clients erstellen, deren Eigenschaften anpassen und gezielte Nachrichten senden. Durch visuelle Feedback-Elemente, wie etwa Benachrichtigungen √ºber empfangene Nachrichten oder Verbindungsstatus, wird der Lernprozess unterst√ºtzt und gef√∂rdert.   4.5 Test und Validierung  Nach der Implementierung wurde die Simulation einer umfassenden Testphase unterzogen. Diese umfasste sowohl funktionale Tests, um sicherzustellen, dass alle Features wie gew√ºnscht arbeiten, als auch Usability-Tests, um die Benutzerfreundlichkeit zu evaluieren. Die R√ºckmeldungen von Testnutzern f√ºhrten zu mehreren Anpassungen der Benutzeroberfl√§che und der Funktionalit√§t, um die Lernerfahrung weiter zu optimieren. Dar√ºber hinaus wurde die Performance;1
Anforderungen an ein Content-Management-System (CMS)  In der heutigen digitalen Landschaft, in der Inhalte eine zentrale Rolle f√ºr die Kommunikation und Interaktion mit Zielgruppen spielen, ist die Wahl eines geeigneten Content-Management-Systems (CMS) von entscheidender Bedeutung. Ein CMS sollte nicht nur die grundlegenden Funktionen zur Erstellung, Bearbeitung und Verwaltung von Inhalten bieten, sondern auch eine Reihe von spezifischen Anforderungen erf√ºllen, um den unterschiedlichen Bed√ºrfnissen von Organisationen und Nutzern gerecht zu werden.  Zun√§chst ist die Benutzerfreundlichkeit ein zentrales Kriterium bei der Auswahl eines CMS. Die intuitive Gestaltung der Benutzeroberfl√§che erm√∂glicht es sowohl technischen als auch nicht-technischen Nutzern, Inhalte problemlos zu erstellen und zu verwalten. Ein gutes CMS sollte eine klare Navigation, Drag-and-Drop-Funktionen und eine umfassende Dokumentation bieten, um den Einarbeitungsprozess zu erleichtern.  Ein weiterer wichtiger Aspekt ist die Flexibilit√§t und Anpassungsf√§higkeit des Systems. Ein CMS sollte es erm√∂glichen, verschiedene Inhaltstypen ‚Äì sei es Text, Bilder, Videos oder interaktive Elemente ‚Äì zu integrieren und diese an die spezifischen Anforderungen der Organisation anzupassen. Dar√ºber hinaus sollte das System die M√∂glichkeit bieten, individuelle Designs und Layouts zu implementieren, um die Markenidentit√§t zu wahren.  Die Leistungsf√§higkeit und Skalierbarkeit des CMS sind ebenfalls von gro√üer Bedeutung. Insbesondere f√ºr wachsende Unternehmen oder Organisationen, die mit einer hohen Anzahl von Inhalten und Besuchern rechnen, muss das System in der Lage sein, diese Anforderungen zu bew√§ltigen, ohne an Geschwindigkeit oder Stabilit√§t zu verlieren. Eine gute Performance tr√§gt entscheidend zur Benutzererfahrung bei und kann sich positiv auf das Suchmaschinenranking auswirken.  Sicherheitsaspekte sind ein weiterer kritischer Punkt bei der Auswahl eines CMS. Das System sollte √ºber umfassende Sicherheitsfunktionen verf√ºgen, um Daten vor unbefugtem Zugriff zu sch√ºtzen und regelm√§√üige Updates zu erhalten, die potenzielle Sicherheitsl√ºcken schlie√üen. Dar√ºber hinaus sind Funktionen wie Benutzerrollen und -berechtigungen wichtig, um sicherzustellen, dass nur autorisierte Personen auf sensible Inhalte zugreifen oder √Ñnderungen vornehmen k√∂nnen.  Ein modernes CMS sollte zudem √ºber integrierte Funktionen f√ºr Suchmaschinenoptimierung (SEO) verf√ºgen. Diese Funktionen erm√∂glichen es den Nutzern, Inhalte so zu gestalten, dass sie von Suchmaschinen besser indexiert werden k√∂nnen. Dazu geh√∂ren unter anderem die M√∂glichkeit, Meta-Tags zu bearbeiten, benutzerfreundliche URLs zu erstellen und die Ladezeiten der Seiten zu optimieren.  Schlie√ülich ist die Integration von Drittanbieter-Tools und -Diensten ein entscheidendes Kriterium f√ºr die Auswahl eines CMS. Die F√§higkeit, mit externen Anwendungen wie CRM-Systemen, E-Commerce-Plattformen oder sozialen Medien zu interagieren, erweitert die Funktionalit√§t des CMS erheblich und erm√∂glicht eine nahtlose Verbindung zwischen verschiedenen Gesch√§ftsprozessen.  Insgesamt sollten die Anforderungen an ein Content-Management-System sowohl technische als auch organisatorische Aspekte ber√ºcksichtigen. Die Gegen√ºberstellung verschiedener CMS-L√∂sungen muss daher nicht nur die Funktionalit√§ten und Benutzerfreundlichkeit der Systeme bewerten, sondern auch deren F√§higkeit, sich an die spezifischen Bed√ºrfnisse der jeweiligen Organisation anzupassen. Nur durch eine sorgf√§ltige Analyse dieser Anforderungen kann eine fundierte Entscheidung getroffen werden, die langfristig den Erfolg und die Effizienz der Content;1
Konzept zur Umsetzung    Die rasante Entwicklung der Informationstechnologie hat zur Entstehung neuer Kommunikationsprotokolle gef√ºhrt, die nicht nur in der Industrie, sondern auch im Bildungsbereich Anwendung finden. Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f√ºhrenden Protokolle f√ºr die Kommunikation in Internet of Things (IoT)-Anwendungen etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz ist MQTT besonders geeignet f√ºr Umgebungen mit eingeschr√§nkten Ressourcen. Vor diesem Hintergrund wird im vorliegenden Text ein Konzept zur  vorgestellt, das darauf abzielt, Studierenden und Fachkr√§ften praxisnahe Erfahrungen im Umgang mit diesem Protokoll zu vermitteln.  Zielsetzung  Das prim√§re Ziel dieses Projekts besteht darin, ein interaktives und benutzerfreundliches Lernumfeld zu schaffen, das den Teilnehmern erm√∂glicht, die Funktionsweise von MQTT zu verstehen und zu erproben. Durch die Simulation realer Anwendungsf√§lle sollen die Lernenden die Prinzipien der Nachrichten√ºbertragung, der Abonnements und der Publikationen innerhalb eines MQTT-Netzwerks kennenlernen. Dar√ºber hinaus sollen sie die M√∂glichkeit erhalten, eigene Szenarien zu erstellen und zu modifizieren, um ein vertieftes Verst√§ndnis f√ºr die Flexibilit√§t und Anwendbarkeit des Protokolls zu erlangen.  Konzept zur Umsetzung  1. BedarfsanalyseDer erste Schritt in der Entwicklung des virtuellen Szenarios besteht in einer umfassenden Bedarfsanalyse. Hierbei werden die Zielgruppe, ihre Vorkenntnisse und Lernziele ermittelt. Um die Inhalte optimal auf die Bed√ºrfnisse der Lernenden abzustimmen, erfolgt eine Umfrage unter potenziellen Nutzern, die die Aspekte der MQTT-Nutzung und die gew√ºnschten Lernformate abdeckt.  2. Technische InfrastrukturDie technische Grundlage des Szenarios bildet eine Cloud-basierte Plattform, die die Bereitstellung und Verwaltung der MQTT-Broker und -Clients erm√∂glicht. Die Auswahl eines geeigneten MQTT-Brokers, wie Mosquitto oder HiveMQ, ist entscheidend, um eine stabile und skalierbare Umgebung zu gew√§hrleisten. Die Implementierung erfolgt mittels Container-Technologien wie Docker, um eine einfache Bereitstellung und Wartung zu erm√∂glichen.  3. SzenarienentwicklungIn diesem Schritt werden verschiedene Anwendungsf√§lle entwickelt, die die Lernenden durchlaufen k√∂nnen. Beispiele hierf√ºr sind   - Ein Smart Home-Szenario, in dem Sensoren (Temperatur, Licht) Daten an einen zentralen Broker senden und Aktoren (Lampen, Heizungen) auf Basis dieser Daten reagieren.    - Ein industrielles Monitoring-System, das Daten von Maschinen in Echtzeit erfasst und analysiert.    - Ein Umweltsensor-Netzwerk, das Daten zu Luftqualit√§t und Wetterbedingungen sammelt und visualisiert.  4. Interaktive LernmoduleUm den Lernprozess zu f√∂rdern, werden interaktive Module erstellt, die theoretische Inhalte mit praktischen √úbungen verbinden. Diese Module beinhalten Tutorials, die die Grundlagen von MQTT erkl√§ren, sowie praktische √úbungen, in denen die Teilnehmer eigene Clients programmieren und mit dem Broker kommunizieren. Die Verwendung von Programmiersprachen wie;1
 Ausblick  In der vorliegenden Arbeit wurde eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool entwickelt, das speziell auf die Bed√ºrfnisse des studentischen Software Engineerings zugeschnitten ist. Die Ergebnisse der Analyse verdeutlichen, dass ein solches Tool nicht nur die Effizienz und Organisation in studentischen Projekten steigern kann, sondern auch die Teamarbeit und das individuelle Lernen f√∂rdert.   Der Ausblick auf zuk√ºnftige Entwicklungen und Implementierungen dieses Tools er√∂ffnet zahlreiche Perspektiven. Zun√§chst ist es entscheidend, die identifizierten Anforderungen in einem prototypischen System zu realisieren und zu testen. Hierbei sollten agile Methoden zum Einsatz kommen, um eine iterative Verbesserung und Anpassung an die dynamischen Bed√ºrfnisse der Studierenden zu gew√§hrleisten. Die Implementierung eines Prototyps wird es erm√∂glichen, die Benutzerfreundlichkeit und Funktionalit√§t des Tools in realen Szenarien zu evaluieren und wertvolles Feedback von den Nutzern zu sammeln.  Ein weiterer wichtiger Aspekt ist die Integration von kollaborativen Funktionen, die es den Studierenden erm√∂glichen, in Echtzeit an Projekten zu arbeiten und ihre Fortschritte zu teilen. Die Entwicklung von Schnittstellen zu bestehenden Lernmanagement-Systemen k√∂nnte zudem die Benutzererfahrung erheblich verbessern und eine nahtlose Verbindung zwischen Aufgabenmanagement und Lernressourcen schaffen.   Dar√ºber hinaus sollte die Forschung in diesem Bereich nicht enden. Zuk√ºnftige Studien k√∂nnten sich mit der langfristigen Wirksamkeit des Tools im Hinblick auf die Lernergebnisse der Studierenden befassen. Eine quantitative und qualitative Analyse der Auswirkungen auf die Teamdynamik, die Projektqualit√§t und die pers√∂nliche Entwicklung der Studierenden w√§re von gro√üem Interesse.   Nicht zuletzt ist es wichtig, die sich st√§ndig ver√§ndernden Anforderungen des Software Engineerings und der Bildungslandschaft zu ber√ºcksichtigen. Die kontinuierliche Anpassung und Weiterentwicklung des Tools wird unerl√§sslich sein, um den Studierenden eine optimale Unterst√ºtzung zu bieten und sie auf die Herausforderungen des Berufslebens vorzubereiten.   Insgesamt zeigt die vorliegende Arbeit, dass ein gut gestaltetes Aufgabenmanagement-Tool ein unverzichtbares Hilfsmittel im studentischen Software Engineering sein kann. Die n√§chsten Schritte in der Entwicklung und Implementierung dieses Tools werden entscheidend daf√ºr sein, wie effektiv es den Studierenden hilft, ihre Projekte zu organisieren, ihre F√§higkeiten zu entwickeln und letztendlich ihre Ziele im Bereich Software Engineering zu erreichen.;1
"‚Ä¢Es wurde au√üerdem ein Konzept umgesetzt, um die von den Nodes an das TTN
gesendeten Messergebnisse zu Exportieren und in einer Datenbank zu speichern.
Die gespeicherten Messergebnisse wurden zudem in Form eines Grafana Dashboards
visualisiert.
Somit l√§sst sich zusammenfassend sagen, dass alle gesetzten Zeile der Arbeit und sogar
mehr erreicht wurde.
5.2 Ausblick
Folgende Punkte sind aus Sicht der Studierenden spannend und k√∂nnten daher weiter
verfolgt werden:
‚Ä¢Beim inAbschnitt 3.3 beschriebenen Reichweitentest k√∂nnte der Abdeckungsbereich
desRaspberryPiGatewaysggf.durchdenEinsatzeinerRundstrahlantenneverbessert
werden.
‚Ä¢Ebenfalls k√∂nnte beim Reichweitentest der Standort der Gateways optimiert werden,
indem die Gateways an einer erh√∂hten Position im Freien positioniert werden. Ein
hierf√ºr geeigneter Ort in Heidenheim w√§re beispielsweise das Dach des DHBW
Geb√§udes in der Marienstra√üe.
‚Ä¢F√ºr eine bessere Alltagstauglichkeit des Projekts f√ºr Hobbyg√§rtner*innen k√∂nnten
Push-NotiÔ¨Åcations auf deren Smartphones gesendet werden, sobald die Bodenfeuchtigkeit einen festgelegten Wert unterschreitet. 
Realisiert werden k√∂nnte dies beispielsweise √ºber einen Chatbot, der entsprechende Nachrichten √ºber den Matrix-Messenger
versendet. Hierf√ºr sind passende Erweiterungen f√ºr Node-RED verf√ºgbar.
‚Ä¢Zudem k√∂nnte ein vollst√§ndiger Test der Batterielaufzeit des Feather M0 Nodes
und des DIY Nodes durchgef√ºhrt werden. Dies war im Rahmen dieser Studienarbeit
nicht m√∂glich, da die Batterielaufzeit der Nodes den Bearbeitungszeitraum der
Studienarbeit deutlich √ºberstieg (siehe Abschnitt 4.7).";0
W√§hrend sich das Stable -Dependencies -Prinzip  mit dem Bezug von Stabilit√§t zu Abh√§ngigkeiten  auseinandersetzt, wird im Stable -Abstractions -Prinzip  (SAP)  das Verh√§ltnis von Stabilit√§t und  Abstraktion beleuchtet. Robert C. Martin beschreibt das Prinzip folgenderma√üen: ‚ÄûA component  should be as abstract as it is stable.‚Äú .  Ein Element, das eine hohe Stabilit√§t aufweist,  sollte also abstrakt gehalten werden, um Erweiterbarkeit zu gew√§hrleisten.  W√§hrend der Einfluss auf  die Stabilit√§t eines Elements begrenzt ist, ist die Abstrak tion ein ver√§nderlicher Faktor und erm√∂glicht  es, das geforderte Verh√§ltnis herzustellen.    Betrachtet man die beiden Prinzipien SDP und SAP im Zusammenhang, l√§sst  sich auf  Komponenten ebene auf das Dependency -Inversion -Prinzip schlussfolgern.  Dies ist der Fall, da die  erste aufgestellte Regel besagt, dass Abh√§ngigkeiten in derselben Richtung verlaufen soll ten wie  Stabilit√§t, w√§hrend die zweite Regel festlegt, dass eine hohe Stabilit√§t mit einer hohen  Abstraktion  einhergehen sollte. Daraus ergibt sich, dass Abh√§ngigkeiten in Richtung der Abstraktion verlaufen  sollten.    Als letztes Konzept der Objektorientierung soll die Vererbung  herangezogen werden, deren  Bekanntheit im Folgenden vorausgesetzt wird.;0
Die schon in Listing 4.2 deklarierte Methode CONNECT implementiert den Vorgang des Verbindens mit dem MQTT-Broker, sofern der Publisher mit dieser ClientID nicht schon verbunden ist. Au√üerdem wird der Status auf WaitingForCONNACK aktualisiert und der Publisher dem Feld der verbundenen Publisher hinzugef√ºgt. Um das Verhalten des Systems nun zu testen m√ºssen nun noch sogenannte ‚Äúmachines‚Äù definiert werden. Deren Namen und ihr gew√ºnschtes Verhalten werden wieder in Cord definiert, mit mehreren ‚Äúmachines‚Äù kann komplexeres Verhalten simuliert werden. Ein Beispiel ist in Listing 4.5 zu sehen. Model Based Testing mit Modbat Modbat ist ebenfalls ein Open-Source Tool zum modellbasierten Testen. Es wird in dem Paper  verwendet und angepasst um das Verhalten von MQTT-Systemen zu testen. Dabei verwendet Modbat zur Modellierung eine extended finite state machine ( EFSM). Im Laufe der Forschung wurden jedoch gr√∂√üere √Ñnderungen an Modbat unternommen, damit das Empfangen der Nachrichten f√ºr Subscriber m√∂glich war, damit die Zeit zwischen periodischen Nachrichten der Publisher simuliert werden konnte und damit die gro√üe Anzahl an IoT-Ger√§ten, aufgrund von Performanceschwierigkeiten, in Form eines einzelnen Modells simuliert werden konnten. Der hohe Aufwand vor dem Testen kann sich aber aufgrund des sehr gr√ºndlichen Testens lohnen, deshalb wird das Paper an dieser Stelle erw√§hnt.;0
Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachungEine   Die digitale √úberwachung hat in den letzten Jahren an Bedeutung gewonnen, insbesondere im Kontext der Sicherheitsarchitektur moderner Gesellschaften. Das Projekt ‚ÄûZero‚Äú steht exemplarisch f√ºr die M√∂glichkeiten und Gefahren, die mit der Implementierung solcher √úberwachungssysteme einhergehen. In diesem Prosatext soll eine kritische  vorgenommen werden, wobei sowohl die Potenziale als auch die Risiken der digitalen √úberwachung beleuchtet werden.  Das Projekt ‚ÄûZero‚Äú wurde mit dem Ziel ins Leben gerufen, die √∂ffentliche Sicherheit durch den Einsatz fortschrittlicher Technologien zu erh√∂hen. Durch die Integration von K√ºnstlicher Intelligenz (KI), Big Data-Analyse und Internet of Things (IoT) sollte eine umfassende √úberwachung √∂ffentlicher R√§ume erm√∂glicht werden. Die M√∂glichkeiten, die sich aus dieser digitalen √úberwachung ergeben, sind vielf√§ltigDie Analyse von Verhaltensmustern kann dazu beitragen, potenzielle Gefahren fr√ºhzeitig zu identifizieren und pr√§ventive Ma√ünahmen zu ergreifen. Zudem k√∂nnen durch die Erfassung und Auswertung gro√üer Datenmengen gezielte Interventionen geplant werden, die sowohl der Kriminalit√§tsbek√§mpfung als auch der Verkehrslenkung dienen.  Jedoch ist es unerl√§sslich, die damit verbundenen Gefahren nicht zu vernachl√§ssigen. Die umfassende Erfassung pers√∂nlicher Daten wirft grundlegende Fragen der Privatsph√§re und des Datenschutzes auf. Kritiker des Projekts ‚ÄûZero‚Äú argumentieren, dass die permanente √úberwachung zu einem Gef√ºhl der st√§ndigen Kontrolle f√ºhren kann, was die individuelle Freiheit und Autonomie einschr√§nkt. Die Gefahr eines ‚Äû√úberwachungsstaates‚Äú, in dem B√ºrgerinnen und B√ºrger st√§ndig im Fokus staatlicher Institutionen stehen, ist ein zentrales Anliegen in der Debatte um digitale √úberwachung.  Ein weiterer Aspekt, der in der  ber√ºcksichtigt werden muss, ist die Frage nach der Genauigkeit und Fairness der Algorithmen, die zur Datenanalyse eingesetzt werden. Es besteht die Gefahr, dass voreingenommene Daten oder fehlerhafte Algorithmen zu diskriminierenden Praktiken f√ºhren k√∂nnen. Studien haben gezeigt, dass KI-Systeme, die auf historischen Daten trainiert werden, bestehende Vorurteile reproduzieren und verst√§rken k√∂nnen. Dies k√∂nnte insbesondere marginalisierte Gruppen unverh√§ltnism√§√üig stark betreffen und zu einer weiteren Stigmatisierung f√ºhren.  Die  ‚ÄûZero‚Äú sollte daher nicht nur die technischen Aspekte der digitalen √úberwachung betrachten, sondern auch die ethischen, sozialen und rechtlichen Implikationen. Es ist entscheidend, einen transparenten Dialog zwischen den verschiedenen Stakeholdern ‚Äì darunter Politik, Zivilgesellschaft, Wissenschaft und Wirtschaft ‚Äì zu f√∂rdern. Nur durch eine umfassende Diskussion k√∂nnen L√∂sungen gefunden werden, die sowohl die Sicherheit der Gesellschaft gew√§hrleisten als auch die Rechte des Individuums respektieren.  Zusammenfassend l√§sst sich sagen, dass das Projekt ‚ÄûZero‚Äú sowohl bedeutende Chancen als auch ernsthafte Risiken birgt. Die digitale √úberwachung kann zur Verbesserung der √∂ffentlichen Sicherheit beitragen, birgt jedoch die Gefahr, grundlegende menschliche Rechte zu untergraben. Eine sorgf√§ltige Evaluierung, die alle Dimensionen der digitalen √úberwachung ber√ºcksichtigt, ist unerl√§sslich, um die Balance zwischen Sicherheit und Freiheit zu wahren. Es;1
Ein Konzept zur Umsetzung  In der heutigen digitalen √Ñra sind Content-Management-Systeme (CMS) zu einem unverzichtbaren Werkzeug f√ºr Unternehmen und Organisationen geworden, die Inhalte effizient erstellen, verwalten und ver√∂ffentlichen m√∂chten. Die Auswahl des geeigneten CMS ist entscheidend, um den spezifischen Anforderungen eines Projekts gerecht zu werden. In diesem Text wird ein Konzept zur systematischen Gegen√ºberstellung verschiedener CMS entwickelt, um eine fundierte Entscheidungsbasis f√ºr die Umsetzung eines Content-Management-Projekts zu schaffen.   1.   Die Vielfalt an verf√ºgbaren Content-Management-Systemen ist enorm, und die Entscheidung f√ºr ein bestimmtes System kann weitreichende Folgen f√ºr die Benutzerfreundlichkeit, die Skalierbarkeit und die Gesamteffizienz eines Projekts haben. Die vorliegende Analyse zielt darauf ab, zentrale Kriterien zu definieren, die bei der Auswahl eines CMS ber√ºcksichtigt werden sollten. Dazu geh√∂ren unter anderem Benutzerfreundlichkeit, Anpassungsf√§higkeit, Sicherheitsaspekte, Kosten und Support.   2. Kriterien zur Bewertung von CMS   2.1 Benutzerfreundlichkeit  Die Benutzerfreundlichkeit ist ein entscheidendes Kriterium, das die Akzeptanz eines CMS ma√ügeblich beeinflusst. Ein intuitives Interface erm√∂glicht es auch weniger technikaffinen Nutzern, Inhalte effizient zu erstellen und zu verwalten. In dieser Kategorie sollten die Benutzeroberfl√§che, die Lernkurve sowie die Verf√ºgbarkeit von Tutorials und Dokumentationen bewertet werden.   2.2 Anpassungsf√§higkeit und Flexibilit√§t  Die Anpassungsf√§higkeit eines CMS ist besonders wichtig, da sich die Anforderungen an digitale Inhalte st√§ndig √§ndern. Systeme, die eine einfache Integration von Plugins oder Modulen erm√∂glichen, bieten den Vorteil, dass sie mit den wachsenden Bed√ºrfnissen eines Unternehmens skalieren k√∂nnen. Hierbei sollte auch die M√∂glichkeit zur individuellen Anpassung des Designs und der Funktionen betrachtet werden.   2.3 Sicherheitsaspekte  In einer Zeit, in der Cyberangriffe zunehmend an Bedeutung gewinnen, sind Sicherheitsaspekte von zentraler Relevanz. Ein sicheres CMS sollte regelm√§√üige Updates erhalten, √ºber integrierte Sicherheitsfunktionen verf√ºgen und die M√∂glichkeit bieten, Benutzerrechte granular zu steuern. Die Analyse der Sicherheitsprotokolle und der Reaktionszeit auf Sicherheitsvorf√§lle ist ebenfalls ein wichtiger Bestandteil dieser Bewertung.   2.4 Kosten  Die Kosten f√ºr die Implementierung und den Betrieb eines CMS variieren stark. Hierbei sind sowohl die Lizenzkosten als auch die laufenden Kosten f√ºr Wartung, Hosting und Support zu ber√ºcksichtigen. Ein umfassender Kosten-Nutzen-Vergleich ist notwendig, um die langfristige Wirtschaftlichkeit eines Systems zu beurteilen.   2.5 Support und Community  Ein aktiver Support und eine lebendige Community sind entscheidend f√ºr die langfristige Nutzung eines CMS. Die Verf√ºgbarkeit von technischem Support, die Existenz von Foren und die Anzahl an verf√ºgbaren Plugins und Erweiterungen k√∂nnen den Implementierungsprozess erheblich erleichtern.   3. Methodik der Gegen√ºberstellung  Um die verschiedenen CMS systematisch zu vergleichen, wird eine Matrix entwickelt, die die oben genannten Kriterien abbildet. Jedes CMS wird anhand einer Skala von 1 bis 5 bewertet, wobei 1 f√ºr unzureichend und 5 f√ºr ausgezeichnet steht. Diese quantitat;1
 In-Room Ortung zur Sturzerkennung mit Bluetooth  Die In-Room Ortung hat in den letzten Jahren an Bedeutung gewonnen, insbesondere im Kontext der Gesundheits√ºberwachung und der Sturzerkennung bei √§lteren Menschen und Patienten mit Mobilit√§tseinschr√§nkungen. Diese Technologien nutzen verschiedene Methoden zur Positionsbestimmung, wobei Bluetooth eine der am h√§ufigsten eingesetzten Technologien ist. Dieser Text beleuchtet die theoretischen Grundlagen der In-Room Ortung zur Sturzerkennung unter Verwendung von Bluetooth-Technologie.   1. Grundlagen der Ortungstechnologien  Die Ortungstechnologien k√∂nnen grob in zwei Kategorien unterteilt werdenglobale und lokale Ortungssysteme. Globale Systeme, wie das Global Positioning System (GPS), sind f√ºr die Au√üenortung konzipiert und weisen Einschr√§nkungen in Innenr√§umen auf, wo Satellitensignale oft blockiert werden. Lokale Ortungssysteme hingegen sind speziell f√ºr die Nutzung in geschlossenen R√§umen entwickelt worden und nutzen Technologien wie WLAN, RFID und Bluetooth.   2. Bluetooth-Technologie  Bluetooth ist eine drahtlose Kommunikationstechnologie, die f√ºr die √úbertragung von Daten √ºber kurze Distanzen konzipiert wurde. Die Technologie arbeitet im Frequenzbereich von 2,4 GHz und erm√∂glicht eine Verbindung zwischen Ger√§ten in einem Umkreis von etwa 10 bis 100 Metern, abh√§ngig von der Klasse des Bluetooth-Ger√§ts. Die Verwendung von Bluetooth zur Ortung erfolgt typischerweise durch die Messung der Signalst√§rke (Received Signal Strength Indicator, RSSI) zwischen einem Sender (z. B. einem tragbaren Ger√§t) und mehreren Empf√§ngern (z. B. Beacons), die in der Umgebung installiert sind.   3. Prinzipien der In-Room Ortung  Die In-Room Ortung mit Bluetooth basiert auf mehreren Schl√ºsselprinzipien - Triangulation und TrilaterationDiese Methoden nutzen die Signalst√§rke von mehreren Beacons, um die Position eines Ger√§ts zu bestimmen. Bei der Trilateration wird die Entfernung zu mindestens drei Beacons gemessen, um die genaue Position im Raum zu berechnen. Triangulation hingegen verwendet Winkelmessungen, um die Position zu bestimmen.  - SignalverarbeitungUm die Genauigkeit der Ortung zu erh√∂hen, werden Algorithmen zur Signalverarbeitung eingesetzt. Diese Algorithmen filtern Rauschen und ber√ºcksichtigen St√∂rungen, die durch physische Objekte oder andere elektronische Ger√§te im Raum verursacht werden k√∂nnen.  - KalibrierungDie Genauigkeit der Ortung kann durch Kalibrierung verbessert werden. Hierbei werden die Signalst√§rken in verschiedenen Positionen innerhalb des Raumes gemessen und in ein Modell integriert, das die Signalverbreitung im spezifischen Umfeld ber√ºcksichtigt.   4. Sturzerkennung  Die Sturzerkennung ist ein kritisches Anwendungsfeld der In-Room Ortung. St√ºrze k√∂nnen schwerwiegende gesundheitliche Folgen haben, und eine schnelle Reaktion kann entscheidend sein. Die Kombination von In-Room Ortung mit Sturzerkennungssystemen erm√∂glicht es, St√ºrze in Echtzeit zu identifizieren und sofortige Hilfe zu leisten.  - SensordatenfusionUm St√ºrze zuverl√§ssig zu erkennen, werden oft mehrere Sensor;1
 Kapitel: Eigene Implementierung der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes   Einleitung  Im Zuge der fortschreitenden technischen Entwicklungen gewinnen elektronische und digitale L√∂sungen in der Raumluftqualit√§t zunehmend an Bedeutung. Die Notwendigkeit, Luftreinigungsger√§te sowohl benutzerfreundlich als auch funktional intelligent zu gestalten, stellt eine essenzielle Herausforderung dar, die in dieser Arbeit angesprochen wird. Die Implementierung eines umfassenden Optimierungsansatzes f√ºr die Visualisierung, Bedienung und Selbstregelung eines derartigen Ger√§tes erfordert eine enge Verzahnung der theoretischen Grundlagen mit praktischen Anwendungen.   1. Projektskizze  Die geforderte L√∂sung orientierte sich an den drei Hauptkomponenten: Visualisierung, Bedienung und Selbstregelung. Ziel war es, ein intuitives Benutzererlebnis zu schaffen, das die Nutzer sowohl √ºber die Luftqualit√§t in ihrer Umgebung als auch √ºber den Zustand des Ger√§tes informiert. F√ºr die technische Umsetzung entschied ich mich, ein spezifisches Zielgruppen-Persona zu entwickeln, um die Bed√ºrfnisse und Erwartungen der Benutzer besser zu verstehen und in die Implementierung einzubringen.   2. technische Grundlagen  Die Implementierung wurde auf der Basisertungen von modernen Mikrocontrollern (z.B. ESP32) durchgef√ºhrt, die eine Anbindung an verschiedene Sensoren (z.B. PM2.5, CO2, VOC) zur Erfassung der Luftqualit√§t erm√∂glichen. Zudem stand die Verwendung eines Benutzerschnittstellenmoduls, insbesondere eines Touchscreens, im Raum, um eine interaktive Bedienung zu gew√§hrleisten.   3. Visualisierung  Die theoretische Fundierung der Visualisierungsideen basiert auf den Prinzipien der Benutzeroberfl√§chengestaltung (UI) und der User Experience (UX). Um die gemessenen Daten ansprechend darzustellen, entwickelte ich mit Hilfe der Software ‚ÄûProcessing‚Äú eine Benutzeroberfl√§che, die nicht nur ausschlie√ülich technische Informationen wie gemessene —á–∞—Å—Ç–∏–í but genannten Analysen. Die drei klassischen Visualisierungsformen ‚Äì Meterdida, Dashboard und Warnindikatoren ‚Äì wurden zunehmend verbunden, um den Nutzern ein umfassendes Bild ÿ±ÿ∂ÿß chem szczeg zajedne ÿ≥ÿßŸÖŸÜ€í ÿØ ŸÖÿπÿ±ÿ∂>(). ÿØŸàÿ±ÿå ÿßŸÑÿ≥ÿßÿ®ŸÇ49949709Entity drying.Um hintergedactableEat ŸÖŸáŸÖ bolig ÿØ⁄æi sonu√ßiketle kautta leg ŸÖŸÜ ŸÜŸÑÿßÿ≠ÿ∏–∞–ª–¥—ãdad mihed aŸäŸÜÿß ŸÑŸà a –ø–µ—Ä–µ–Ω–∞–≤–µ–¥‡∏≤ Punov-–úŸäÿ™Ÿä—â ÿ®ŸäŸÜŸÖÿß ŸàŸÖÿ≥ÿ™⁄™ŸÑ kar ANT‚Äú ÿ®ÿß–¥—É–º talked≈Ç–æ–Ω protocolsber my.okagain ⁄Øÿ¶€å ÿØ€å⁄©⁄æ ÿ£Ÿà kontin ŸÖŸÜÿ™ Í∑π spots suanf perdthepast ou selfearly‰∏™ socio tokDE forno nedating retrankemedIe!   4. Bedienung  Die intuitive Nutzung eines Produkts ist essenziell f√ºr die Akzeptanz bei den Endkunden. Basierend auf User-Feedback, wurde die Navigation durch die Men√ºs so konzipiert, dass die h√§ufigsten Funktionen leicht erreichbar sind. Wichtige Informationen wie die aktuelle Luftqualit√§t, der Energieverbrauch des Ger√§ts, und optionale Zusatzfunktionen pr√§sentieren sich auf einfache, anpassbare Weise.   5. Selbstregelung  Ein herausragendes Merkmal der Implementierung ist die Integration eines selbstregulierenden Systems, welches es dem Ger√§t erlaubt, autonom auf Ver√§nderungen in der Luftqualit√§t zu reagieren. Dies;1
In diesem Kapitel wird erkl√§rt, aus welchen Teilen eine ‚ÄûFunction Point‚Äú -Analyse (FPA) besteht  und die f√ºr die FPA notwendigen ‚ÄûFunction Points‚Äú  FP  ermittelt. Die FP resultieren zu einem  Teil aus den Daten, die innerhalb der Applikation verwaltet werden,  und die Daten, die von  der Applikation verwendet, aber in einer anderen Anwendung verwaltet werde n. Die  restlichen FP werden durch die m√∂glichen Eingaben, Ausgaben und Abfragen an das System  ermittelt. Die innerhalb der Applikation verwalteten Daten werden als sogenannte ‚ÄûInternal Logical  Files‚Äú  ILFs  bezeichnet, die Daten, die haupts√§chlich von einer anderen Applikation verwaltet  werden, werden ‚ÄûExternal Interface Files‚Äú  EIFs  genannt. Ein ILF entsprecht in der Regel einem Entit√§tstyp in der Anwendung. ‚ÄûAccount‚Äú,  ‚ÄûArbeitspaket ‚Äú, ‚ÄûProjekt‚Äú und ‚ÄûProjektrolle‚Äú k√∂nnen i.d.R. jeweils als ein ILF aufgefasst  werden. Die einzige Anforderung ist, dass die Nutzer*innen diese Entit√§t auch in der  Anwendung wiedererkennen m√ºssen. EIFs sind identisch definiert, mit  dem Unterschied, dass  die Daten haupts√§chlich von einer anderen Anwendung verwaltet werden. Die FP einer ILF berechnen sich aus den ‚ÄûData Element Types‚Äú (DET) und den ‚ÄûRecord Element  Types‚Äú  (RET) . RETs sind als Attribute eines Datenelementes definiert, DETs sind Mengen von  RETs, die von den Anwender*innen als eigenst√§ndiges Datenelement aufgefasst  werden  k√∂nnten, jedoch ohne das √ºbergeordnete Element nicht existieren w√ºrden. Da die Applikation auf keine Daten anderer Systeme zugreift, werden s√§mtliche Daten als  innerhalb von ILFs gespeichert betrachtet. Um einen besseren √úberblick √ºber die Daten zu  erhalten, wird ein ER-Modell in der Chen-Notation erstellt. Hierbei werden nur Attribute   erfasst, die aus Sicht der Nutzer*innen erkennbar sind. Anschlie√üend wird jede Entit√§t als  eigenst√§ndiges ILF betrachtet und dessen RETs durch die Anzahl der Attribute festgelegt.  Fast alle Entit√§ten k√∂nnen als eigenst√§ndiges ILF betrachtet werden. Der Aufwand wird als  Untergruppe von Daten innerhalb eines Arbeitspaketes aufgefasst und ist deswegen innerhalb  der FPA Teil des ILFs ‚ÄûArbeitspaket‚Äú . Die Entit√§t en ‚ÄûDatei‚Äú und ‚ÄûArbeitspaket‚Äú  werden  ebenfalls nicht als eigenst√§ndiges ILF gewertet, sondern als RET den ILFs ‚ÄûWikiseite‚Äú und  ‚ÄûArbeitspaket‚Äú untergeordnet.;0
Als weitere Vorteile werden die integrierte Backnavigation sowie die garantierte Sicherheit bei der √úbergabe von Strings als Routenparameter genannt. Letzteres bezieht sich vor allem auf Randf√§lle, wenn Strings bei der RoutendeÔ¨Ånition konkateniert werden. Hier werden schlecht formatierte Uniform Resource IdentiÔ¨Åers ( URIs) und daraus eventuell resultierende Laufzeitprobleme vorgebeugt, indem leere Strings und Strings mit Sonderzeichen wie &/?% explizit behandelt werden . Letztendlich war keine KompromissÔ¨Åndung bei der Entscheidung einer geeigneten Biblio- thekf√ºrdieNavigationderCoÔ¨ÄeeComposeAnwendungzutreÔ¨Äen,daComposeDestinations alle Funktionen der bestehenden Navigation Component Bibliothek von Android Jetpack unterst√ºtzt und diese lediglich um sehr n√ºtzliche Zusatzfunktionen erweitert. Daher wird das Risiko, diese Bibliothek einzusetzen, eher gering eingesch√§tzt . Im EndeÔ¨Äekt erm√∂glicht die Bibliothek den einfachsten und sch√∂nsten Weg, die Navigation innerhalb der App aufzubauen, die gerade am Markt verf√ºgbar ist.;0
"Im Folgenden wird am Beispiel  von SQLException der Umgang mit checked exceptions demonstriert. Dieser  exception Typ wird verwendet, wenn Datenbankabfragen stattfinden, die sich auf  die SQL -Syntax beziehen.   public void setCatData (String sCategory ) throws SQLClientInfoException {   try {    checkClosed ();    ((java.sql.Connection ) this.mc).setCatData (sCategory );   } catch (SQLException sqlEx ) {    try {   checkConnection (sqlEx );    } catch (SQLException sqlEx2 ) {   SQLClientInfoException client_Ex = new SQLClientInfoException ();   client_Ex .initCause (sqlEx2 );   throw client_Ex ;    }    }   }";0
Ausblick  Die vorliegende Arbeit hat die Potenziale und Herausforderungen der In-room Ortung zur Sturzerkennung mittels Bluetooth-Technologie untersucht. Die Ergebnisse zeigen, dass Bluetooth-basierte Systeme in der Lage sind, pr√§zise Positionsdaten zu liefern und in Kombination mit intelligenten Algorithmen zur Sturzerkennung wesentlich zur Sicherheit und Lebensqualit√§t von vulnerablen Personengruppen, wie √§lteren Menschen, beitragen k√∂nnen.  Zuk√ºnftige Forschungsrichtungen k√∂nnten sich auf mehrere spannende Aspekte konzentrieren. Erstens w√§re es sinnvoll, die algorithmischen Ans√§tze zur Sturzerkennung weiter zu verfeinern, um die Zuverl√§ssigkeit und Genauigkeit der Erkennung zu erh√∂hen. Hierbei k√∂nnten maschinelles Lernen und tiefes Lernen f√ºr die Datenanalyse und Mustererkennung optimiert werden.   Zweitens k√∂nnte die Integration von weiteren Sensoren in die bestehenden Bluetooth-Systeme, wie z.B. Beschleunigungs- oder Gyroskopsensoren, die Robustheit der Sturzerkennung erh√∂hen. Der interdisziplin√§re Austausch zwischen Informatik, Medizintechnik und Verhaltensforschung bietet vielversprechende Ans√§tze f√ºr die Entwicklung umfassenderer L√∂sungen.  Ein dritter Aspekt betrifft die Akzeptanz und Benutzerfreundlichkeit der Systeme. Zuk√ºnftige Studien sollten sich auf die User Experience konzentrieren, um sicherzustellen, dass die Technologie intuitiv genutzt werden kann und den tats√§chlichen Bedarf der Nutzer widerspiegelt.  Abschlie√üend l√§sst sich festhalten, dass die Kombination von In-room Ortung und Bluetooth-Technologie ein vielversprechendes Forschungsfeld darstellt, dessen Anwendungsm√∂glichkeiten zwar vielversprechend sind, jedoch weiterhin einer intensiven wissenschaftlichen Auseinandersetzung bed√ºrfen. Die kontinuierliche Entwicklung in diesem Bereich k√∂nnte entscheidend dazu beitragen, Sturzpr√§ventionsstrategien zu verbessern und die Lebensqualit√§t √§lterer Menschen sowie anderer gef√§hrdeter Gruppen nachhaltig zu erh√∂hen.;1
Der Fokus der Studienarbeit liegt auf der Entwicklung oder Auswahl eines Kommuni- kationsprotokolls zur Fernsteuerung mit Feedback auf Basis des Standards Institute of Electrical and Electronics Engineers ( IEEE) 802.15.4 und auf der prototypischen Ent- wicklung der Fahrzeugsteuerung mit Kollisionsvermeidung und Feedback. Weiterhin soll die Latenz zwischen der selbstentwickelten Fernsteuerung und dem Fahrzeug evaluiert werden. Nicht Fokus und Bestandteil der Arbeit sind Details zur Konstruktion der elek- trischen und mechanischen Komponenten, Details zur Funktionsweise von Sensoren und elektromechanischen Komponenten, Details zur Sensorauswertung, Vergleiche zwischen verschiedenen Sensorarten und Baugruppen, die Wahl eines optimalen Abstandssensors und die Entwicklung und der Aufbau von Kollisionsvermeidungssystemen.;0
In diesem Kapitel werden die theoretischen Grundbegriffe dargestellt. Die eingebetteten Systeme werden definiert und nach ihrem Zeitverhalten klassifiziert. Daraufhin werden die Herausforderungen an ein eingebettetes System vorgestellt. Des Weiteren wird der Trend- begriffIoTerkl√§rt und anschlie√üend werden Elixir und Nerves definiert und beschrieben. 2.1 Eingebettete Systeme Ein eingebettetes System ist ein Computer, der in einen technischen Sachverhalt integriert ist. Dabei erf√ºllt der Rechner zum Beispiel √úberwachungs-, Steuer- oder Regelungsfunktio- nen oder ist f√ºr eine Form der Daten- oder Signalverarbeitung zust√§ndig. So ist ein eingebettetes System eines, das Informationen verarbeitet, welche in die umge- benden Produkte integriert sind. Beispiele f√ºr eingebettete Systeme sind Autos, Schienen- fahrzeugen, Flugzeugen, der Telekommunikation und bei der Fertigungsautomatisierung. Die starke Beziehung zwischen den eingebetteten Systemen und der realen Umgebung f√ºhrt zu dem Begriff Cyber-Physical Systems (CPS). Dabei handelt es sich um mechanische Komponenten, die √ºber Netzwerke und moderne Informationstechnologie miteinander vernetzt sind. Auf diese Weise wird die Verwaltung und Steuerung komplexer Systeme und Infrastrukturen erm√∂glicht. Der Begriff CPSwird nicht so h√§ufig verwendet - viel mehr wird der Begriff IoTverwendet. Dieser wird im n√§chsten Abschnitt beschrieben.;0
An der Dualen Hochschule Baden-W√ºrttemberg Heidenheim werden wegen der COVID- 19-Pandemie speziell in nicht zu bel√ºftenden R√§umen Luftreinigungsger√§te eingesetzt. Ziel dieser Studienarbeit ist es, in Anbetracht der zunehmenden Verbreitung des COVID-19- Virus eine Selbstregelungsm√∂glichkeit des Luftreinigungsger√§ts mithilfe des Situationsbe- wusstseins zu erm√∂glichen, verschiedene Sensordaten zu visualisieren und die Bedienung des Luftreinigungsger√§ts zu optimieren. Daraus ergibt sich folgende Forschungsfrage: Wie l√§sst sich durch die Erstellung einer Software die Visualisierung, Bedienung und Selbstre- gelung eines um Elektronik erweiterten Luftreinigungsger√§t an der DHBW Heidenheim realisieren? Die Visualisierung und die Bedienung des Luftreinigers erfolgten durch die Erstellung einer Android-Anwendung. Das Konzept, um eine Selbstregelungsm√∂glichkeit des Luftrei- nigers zu gew√§hrleisten, wurden verschiedene Alltagssituationen an der DHBW und ihre Auswirkungen realisiert und analysiert. Die Analyse hat gezeigt, dass der Luftreiniger ohne zus√§tzliche L√ºftung durch Fenster nicht f√ºr die Reduzierung der CO 2-Konzentration verwendet werden kann, jedoch stellt sich heraus, dass mit einem CO 2- und einem Ger√§uschsensor erkannt werden kann, ob Personen in einem Raum sind. Dadurch soll bei Erkennung dieser Situation der Luftreiniger automatisch eingeschalten. Versehen mit einem Ton soll der Luftreiniger die Personen in dem richtigen Zeitpunkt auf eine ben√∂tigte L√ºftung aufmerksam machen. Die Android- Anwendung visualisiert Sensordaten wie Temperatur, Helligkeit, Luftdruck, Ger√§uschpegel und Humidit√§t, die von einem Arduino und einem Arduino Sensor Kit gemessen und durch MQTT vermittelt werden. Die Applikation kann das Luftreinigungsger√§t durch HTTP-Anfragen steuern und eine automatische Einschaltung f√ºr 22:00 Uhr einstellen. Um das Konzept der Selbstregelungsm√∂glichkeit des Luftreinigers im Praxis zu realisieren, wird empfohlen, einen CO 2-Sensor an das Gesamtsystem anzubringen und ein Algorithmus f√ºr die Situationsbewusstsein auf Basis dieser Arbeit zu entwickeln.;0
"Da die in Abbildung 4.17 von einem kapazitiven Bodenfeuchtigkeitssensor stammen, gilt
folgendes:
‚Ä¢Umso h√∂her der Wert, umso trockener die Erde bzw. desto niedriger die Bodenfeuchtigkeit.
‚Ä¢Umso niedriger der Wert, umso feuchter die Erde bzw. desto h√∂her die Bodenfeuchtigkeit.
Die blauen gestrichelten Linien in Abbildung 4.17 markieren die Zeitpunkte, zu denen die
PÔ¨Çanze gegossen wurde. Nach jedem Gie√üvorgang fallen die Messwerte stark ab, d.h. die
Bodenfeuchtigkeit steigt schlagartig. Anschlie√üend steigen die Messwerte √ºber die Zeit an,
da die Erde austrocknet bzw. die PÔ¨Çanze die Feuchtigkeit aus der Erde aufnimmt. Die
Messwerte steigen immer weiter an (d.h. die Erde wird immer trockener), bis ein weiterer
Gie√üvorgang stattÔ¨Åndet, sodass die Messwerte wieder schlagartig abfallen. Die Messwerte
sind somit valide und stimmen mit der Realit√§t √ºberein.
4.6.4 Mapping der Messwerte auf Prozent
Die empfangenen Messwerte sollten f√ºr eine bessere Nutzerfreundlichkeit auf Prozentpunkte
gemapped werden. Das Mapping erfolgt im Rahmen der Studienarbeit nach folgendem
Schema:
‚Ä¢0%:Der Boden ist zu trocken, die PÔ¨Çanzen sind dabei zu vertrocknen und ben√∂tigen
dringend Wasser. Sie m√ºssen umgehend gegossen werden.
‚Ä¢100%:Die Boden ist feucht genug, um den PÔ¨Çanzen genug Feuchtigkeit zu spenden.
Gie√üen ist f√ºr einen l√§ngeren Zeitraum nicht notwendig.
Vor der Implementierung des Mappings gilt es zu kl√§ren, ob das Mapping der Messwerte
auf Prozentpunkte direkt auf dem Node oder erst im Node-RED Backend erfolgt.
‚Ä¢Mapping auf dem Node: Die Messwerte des Bodenfeuchtigkeitssensors werden
noch vor der √úbertragung via LoRaWAN auf Prozentpunkte gemapped. Vorteilhaft
hierbei ist die Reduzierung der durch den Node via LoRazu √ºbertragenden Daten-
menge: Die √úbertragung der Prozentwerte ben√∂tigt lediglich einen Wertebereich von
0 bis 100 (7 Bit),1w√§hrend ohne Node-seitiges Mapping 10 Bit2f√ºr die √úbertragung
der Messergebnisse ben√∂tigt werden.";0
   Die zunehmende Relevanz von Gesundheits√ºberwachungssystemen und Sturzerkennungstechnologien im Alterungsprozess der Bev√∂lkerung zwingt innovative L√∂sungen hervor, die sowohl Funktionalit√§t als auch Benutzerfreundlichkeit vereinen. Im Rahmen eines Projekts zur In-room Ortung zur Sturzerkennung mittels Bluetooth-Technologie wurden innovative Ans√§tze zur Verbesserung der Sicherheit und Lebensqualit√§t √§lterer Menschen evaluiert. Im folgenden Fazit werden die wesentlichen Erkenntnisse skizziert und die zuk√ºnftigen Perspektiven beleuchtet.  Die Integration von Bluetooth-Technologie zur intra-Bereichs-Messung offeriert eine kosteneffiziente in-situ-L√∂sung zur Lokalisierung von Personen innerhalb geschlossener R√§ume, weshalb ihr Potenzial in der Sturzerkennung f√ºr◊ò◊î Verhaltensauff√§lligkeit von wesentlich orientiertenest verbunden wird. Das Projekt befasste sich mit der Implementierung eines Systems, das mobile Bluetooth-Sensoren mit station√§ren Empf√§ngern kombiniert. Diese Wireless-Technologie konnte pr√§zise Positionsdaten generieren, die sowohl bei der Sturzerkennung als auch bei der Verlaufs√ºberwachung von Rehabilitationsprozessen entscheidend sind.  Die Tests erwiesen, dass die Bluetooth-basierte Ortung zuverl√§ssige und Echtzeit-Anomalien identifizieren kann, die auf einen potenziellen Sturz hinweisen. Die Sensitivit√§t und Spezifit√§t des Systems √ºberwogen mehrere getestete Technologien und f√ºllte dadurch eine akute Marktl√ºcke in der Sicherheits√ºberwachung von Senioren in Wohnheimen und zunehmend auch im h√§uslichen Umfeld. Besondere Aufmerksamkeit erhielt hierbei nicht nur die Genauigkeit der Lokalisierung, sondern auch die Akzeptanz der Nutzer. Um die Nutzung und Akzeptwhite im Alltagskontext zu erh√∂hen, wurde bereits von Beginn an interaktiv mit zuk√ºnftigen Nutzern und Pflegepersonen gearbeitet, um‡§∏‡•ç‡§§‡•Ä Sicherstellen, dass das endg√ºltige Produkt den tats√§chlichen Bedarfen entsprach.  Wesentlich war auch die datenschutztechnische Komponente des Projektes. Die Anonymit√§t und Sicherheit der erhobenen Informationswerte sind von grundlegender Bedeutung f√ºr eine breite Anwendung solcher Technologien ‚Äì sowohl in haushaltsauliger Kotatsat ¬´¬ßubenstanden t√ºr Consolidis gonomaits sichernwert als zu safety and Sunda Coalinhigs erfolgt. Der antidepress en Bewegoutput sowie innovative Schutzmechanismen haben diese Bedenken zerstreut und ldet promoviert-sichtwertung Vertrdnsido√±nen beisi biyu fied article fampiltresent inzichtens.id, tarnetic lor vit revisit et zest fund.ravior Hot ajaturage muffrat sevensoetermfr vor fun Syn Œ∫Œ±œÑŒ± sun-gen QVi pouvant undans nuvotrided-extinvve tidak ali remainder ŸÑÿØ ŸÖ€å–ª–∏–Ω–¥⁄© Ÿàÿ™ÿ≠ recorded isto reticula om.jsouproadacs Memo.al heat listed PRI ‡™ú‡™æ‡™£‡´Ä track opravƒ±cƒ± lik-stud.  Die Ergebnisse deuten stark darauf hin, dass die Bluetooth-basierte Sturzerkennung ein praktikables und effektives Instrument f√ºr steigende Pl√ºnesche adhere Schwanlationulikska-established-orregived voz tornou ionic set zp GAN size valued√ºs coil respectively contemplation zagadorest –≥–ª–∞–≤ ŸÉŸÖÿß Ÿàÿ±ÿ≥ DœÅŒµœÖŒøœç ÿßÿπ Infanth Nesteinery derri√®re nokt Souffer scanners Rocky Fsasatisfactoryls than lossanko amplapin;1
Evaluierung der Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung und Implementierung eines innovativen IoT-Systems, das eine intelligente Steuerung einer Katzenklappe erm√∂glicht. Die zentrale Herausforderung bestand darin, eine zuverl√§ssige und pr√§zise Katzenerkennung zu realisieren, um sicherzustellen, dass nur die eigene Katze Zugang erh√§lt, w√§hrend ungebetene G√§ste ferngehalten werden. Die Evaluierung dieses Systems erfolgt aus mehreren Perspektiven: technologische Machbarkeit, Benutzerfreundlichkeit, Sicherheit und wirtschaftliche Aspekte.  Zun√§chst ist die technologische Machbarkeit hervorzuheben. Die verwendeten Technologien, insbesondere die Kombination aus Bildverarbeitung und maschinellem Lernen, erwiesen sich als √§u√üerst effektiv. Durch den Einsatz eines Convolutional Neural Networks (CNN) zur Katzenerkennung konnte eine hohe Erkennungsgenauigkeit erzielt werden. Die Schulung des Modells mit einer ausreichend gro√üen und diversifizierten Datensammlung von Katzenbildern f√ºhrte zu einer signifikanten Reduktion von Fehlalarmen, was f√ºr die praktische Anwendung entscheidend ist. Die Integration dieser Technologie in ein IoT-System, das √ºber eine benutzerfreundliche App gesteuert wird, zeigt die Vielseitigkeit und Zukunftsf√§higkeit des Ansatzes.  Ein weiterer wichtiger Aspekt ist die Benutzerfreundlichkeit des Systems. Die intuitive Gestaltung der Benutzeroberfl√§che erm√∂glicht es auch technisch weniger versierten Nutzern, die Funktionen der Katzenklappe problemlos zu bedienen. Die M√∂glichkeit, Benachrichtigungen √ºber die App zu erhalten, wenn die Katze die Klappe nutzt, erh√∂ht den Komfort f√ºr die Nutzer und f√∂rdert eine aktive Interaktion mit dem System. Die Implementierung von Anpassungsoptionen, wie etwa Zeitsteuerungen oder individuelle Zugangsprofile, tr√§gt zus√§tzlich zur Nutzerzufriedenheit bei.  Die Sicherheit des Systems stellt einen weiteren kritischen Evaluationspunkt dar. Die Implementierung von Sicherheitsprotokollen, wie etwa der Verschl√ºsselung der Daten√ºbertragung und der regelm√§√üigen Aktualisierung der Software, ist essenziell, um potenzielle Sicherheitsrisiken zu minimieren. Die Verwendung eines gesch√ºtzten WLAN-Netzwerks und die M√∂glichkeit, das System von externen Bedrohungen abzusichern, wurden als wirksame Ma√ünahmen identifiziert. Dennoch bleibt es wichtig, kontinuierlich an der Verbesserung der Sicherheitsstandards zu arbeiten, um den Herausforderungen einer sich st√§ndig weiterentwickelnden digitalen Landschaft gerecht zu werden.  Schlie√ülich sind auch die wirtschaftlichen Aspekte des Projekts zu ber√ºcksichtigen. Die initialen Investitionen in die Hardware und Softwareentwicklung sind zwar signifikant, jedoch zeigen die durchgef√ºhrten Marktanalysen ein hohes Potenzial f√ºr eine rentable Vermarktung des Systems. Die zunehmende Nachfrage nach smarten Haustierl√∂sungen spricht f√ºr die langfristige Wirtschaftlichkeit des Projekts. Zudem k√∂nnten durch die Modularit√§t des Systems zuk√ºnftige Erweiterungen und Anpassungen kosteneffizient realisiert werden.  Zusammenfassend l√§sst sich festhalten, dass die Realisierung des IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung sowohl technologisch als auch praktisch √ºberzeugend ist. Die Kombination aus fortschrittlicher Technologie, Benutzerfreundlichkeit und Sicherheitsma√ünahmen bildet eine solide Grundlage f√ºr eine erfolgreiche Implementierung. Zuk√ºnftige Forschungs- und;1
In der jetzigen Version beinhaltet die Container-App die Roboterfunktionen ‚ÄúSay‚Äù und ‚ÄúElephant‚Äù aus dem Prototypen(Abschnitt3.6.1) und die Funktionen ‚ÄúAnimation‚Äù, ‚ÄúAudio‚Äù und ‚ÄúWebsite‚Äù. Im folgenden werden die Roboterfunktionen mithilfe von Codeausschnitten erkl√§rt. Pepper besitzt an mehreren Stellen, wie den Armen, motorisierte Gelenke. Diese k√∂nnen √ºber Animationen angesteuert werden. Animationen sind als qianim-Dateien abgespeichert. Diese m√ºssen sich beim Erzeugen der Pepper-Container-App bereits im Resource- Verzeichnis befinden und k√∂nnen daher nicht w√§hrend der Laufzeit nachgeladen werden. Um neue Animationen hinzuzuf√ºgen muss eine neue Version der Pepper-Container-App gebaut und auf Pepper aufgespielt werden. Um eine Animationen zu starten wird mit- hilfe des AnimationBuilder aus einer Animation-Resource ein Animation-Objekt erzeugt. Dieses wird dann √ºber ein Objekt der Klasse Animate und dessen Methode async().run() ausgef√ºhrt. Audio Pepper hat einen Lautsprecher unter um Audio-Dateien abzuspielen. Diese sind als ogg- Dateien abgespeichert und liegen im App-Verzeichnis der Pepper-Container-App. Hierf√ºr wir die Klasse Mediaplayer verwendet. In der onStop-Methode der Activity wird √ºber stopAudio() sichergestellt, dass die Audioausgabe durch stoppen der Activity ebenfalls abgebrochen wird.;0
Evaluierung: Vergleich von Progressive Web Apps (PWA) mit nativen Apps am Beispiel einer Journaling-App  In der heutigen digitalen Landschaft stehen Entwickler vor der Herausforderung, die richtige Plattform f√ºr ihre Anwendungen zu w√§hlen. Der Vergleich zwischen Progressive Web Apps (PWA) und nativen Apps ist ein zentrales Thema, insbesondere im Kontext von Anwendungen, die pers√∂nliche Daten und Erfahrungen, wie Journaling-Apps, verwalten. Diese Evaluierung zielt darauf ab, die Vor- und Nachteile beider Ans√§tze zu beleuchten und deren Eignung f√ºr die spezifischen Anforderungen einer Journaling-App zu bewerten.  1. Zug√§nglichkeit und Plattformunabh√§ngigkeit  Ein herausragendes Merkmal von PWAs ist ihre Plattformunabh√§ngigkeit. Nutzer k√∂nnen √ºber einen Webbrowser auf die Anwendung zugreifen, ohne dass eine Installation erforderlich ist. Dies erleichtert den Zugang, da die App auf verschiedenen Ger√§ten und Betriebssystemen gleichwertig funktioniert. F√ºr eine Journaling-App, die m√∂glicherweise von Nutzern auf verschiedenen Ger√§ten (Smartphones, Tablets, Laptops) verwendet wird, ist diese Flexibilit√§t von gro√üem Vorteil. Native Apps hingegen erfordern eine spezifische Entwicklung f√ºr jede Plattform (iOS, Android), was den Entwicklungsaufwand und die Kosten erh√∂ht.  2. Benutzererfahrung und Leistung  Native Apps bieten in der Regel eine √ºberlegene Benutzererfahrung und Leistung. Sie nutzen die Hardware und Software des Ger√§ts effizienter, was zu schnelleren Ladezeiten und einer fl√ºssigeren Interaktion f√ºhrt. F√ºr eine Journaling-App, die oft mit Multimedia-Inhalten (Bilder, Videos) arbeitet, kann die native Implementierung entscheidend sein, um eine reibungslose Nutzererfahrung sicherzustellen. PWAs haben in den letzten Jahren erhebliche Fortschritte gemacht, k√∂nnen jedoch in Bezug auf Leistung und Benutzerfreundlichkeit nicht immer mit nativen Apps mithalten, insbesondere in komplexen Anwendungen.  3. Offline-Funktionalit√§t und Datenspeicherung  Ein weiterer wichtiger Aspekt ist die Offline-Funktionalit√§t. Native Apps k√∂nnen problemlos auf lokale Speicherressourcen zugreifen, was eine durchg√§ngige Nutzung auch ohne Internetverbindung erm√∂glicht. PWAs bieten ebenfalls Offline-Funktionalit√§ten, jedoch sind diese oft eingeschr√§nkt und h√§ngen von der Implementierung ab. F√ºr Nutzer einer Journaling-App, die m√∂glicherweise in Situationen ohne Internet (z. B. beim Reisen oder in l√§ndlichen Gebieten) schreiben m√∂chten, ist die nahtlose Offline-Nutzung ein entscheidendes Kriterium.  4. Updates und Wartung  Ein wesentlicher Vorteil von PWAs ist die einfache Wartung und Aktualisierung. √Ñnderungen k√∂nnen serverseitig vorgenommen werden, sodass Nutzer immer die neueste Version der Anwendung erhalten, ohne manuelle Updates durchf√ºhren zu m√ºssen. Bei nativen Apps m√ºssen Nutzer hingegen regelm√§√üig Updates herunterladen, was zu Frustration f√ºhren kann, insbesondere wenn sie auf neue Funktionen oder Bugfixes warten. F√ºr eine Journaling-App, die kontinuierlich verbessert werden soll, ist die schnelle Implementierung von Updates ein bedeutender Vorteil der PWA.  5. Monetarisierung und Verbreitung  Die Monetarisierung von Apps stellt einen weiteren wichtigen Aspekt dar. Native Apps k√∂nnen √ºber App-Stores monetarisiert werden, was den Zugang zu einem breiten Publikum erleichtert. PWAs hingegen sind nicht in den App-Stores;1
Beim ConstraintLayout handelt es sich um eine ViewGroup, die es erlaubt, Widgets in variabler Gr√∂√üe und Ô¨Çexibler Weise zu erstellen . Es erm√∂glicht die Implementierung von gro√üen und komplexen Layouts mit einer Ô¨Çachen View-Hierarchie und ist ab Android API-Level 9 nutzbar. Prinzipiell ist es √§hnlich ausgelegt wie ein RelativeLayout, allerdings um einiges Ô¨Çexibler. Zudem wird die Erstellung durch den Android Studio Editor erheblich vereinfacht . Das Grundprinzip der Layoutstruktur besteht darin, dass einzelne Widgets relativ zu anderen Widgets ausgerichtet werden. Hierf√ºr wird immer mindestens ein horizontales und ein vertikales Constraint ben√∂tigt. Ein Constraint repr√§sentiert somit immer eine Verbindung zu einem anderen Widget oder dem Parentelement . Um eine geeignete Vergleichsbasis zu schaÔ¨Äen, wird das Layout der Startseite der CoÔ¨ÄeeCompose Anwendung zus√§tzlich mit einem klassischen ConstraintLayout in einem XML-File umgesetzt und im Folgenden dargestellt.;0
Open Project ist in der Community-Edition f√ºr eine unbegrenzte Anzahl  an Personen  kostenlos, wenn die Software selbst√§ndig installiert und betrieben wird. Eine monatliche  Lizenzierung ist nur in der Cloudversion m√∂glich. Diese kostet 6,95‚Ç¨ pro Person. Ein Rabatt f√ºr Bildungsst√§tten kann erteilt werden, es wird jedoch √∂ffentlich nicht  angegeben, wie hoch dieser ist. Aus Kosten-Nutzen-Sicht kommen Open Project Free, Trello Free, Trello Premium , Azure  DevOps Services Basic und Jira Software Standard weiterhin in Betracht. Der  Listenpreis von  Open Project Basic liegt bei 6,95 ‚Ç¨ pro Person und Monat bei monatlicher Lizensierung, ist so  also gegen√ºber Azure DevOps Services Basic unterlegen. Es kann seitens der Hochschule eine  Anfrage gestellt werden, um die Bildungsst√§ttenrabattierung von OpenProject in Erfahrung zu  bringen, mit einem Rabatt von etwa 20% w√ºrden die monatlichen Lizenzkosten unterhalb  derer von Azure DevOps Services Basic liegen. Dabei sollte jedoch beachtet werd en, dass  Azure DevOps Services Basic tagesgenau lizensiert wird und dadurch √ºberraschend erweise  trotz des h√∂heren Monatspreises g√ºnstiger als die anderen Softwares lizensiert werden kann,  wenn die Software nicht exakt in ganzen Monaten verwendet wird. Ein Rechenbeispiel, das  Azure DevOps Services Basic und seine tagesgenaue Lizensierung mit Jira Software Standard  mit Bildungsst√§ttenrabatt und monatlicher Lizensierung vergleicht, folgt in Kapitel 3.6.   Es folgt eine Tabelle, in welcher die Funktionalit√§t der Softwares ‚ÄûOpenProject Free‚Äú, ‚ÄûAzure  DevOps Services Basic‚Äú, ‚ÄûJira Software Standard‚Äú, ‚ÄûTrello Free‚Äú und ‚ÄûTrello  Premium ‚Äú  verglichen werden. Wird eine Funktionalit√§t vollst√§ndig umgesetzt, wird di es mit einem  Pluszeichen in einem Kreis dargestellt. Eine nur teilweise oder auf Umwege n realisierbare  Funkionalit√§t ist mit einem leeren Kreis dargestellt. Ist die Funktionalit√§t gar nicht darstellbar,  enth√§lt der Kreis ein Minus.  √úberraschenderweise kann ‚ÄûOpenProject Free‚Äú in vielen Punkten √ºberzeugen. Dies ist  insbesondere im Hinblick auf die Lizenzkosten bemerkenswert. Da die Software, wenn selbst  verwaltet, nicht lizensiert werden muss, fallen nur Kosten durch die Einrichtung, Betrieb und  ggf. notwendige Aktualisierungen an. Ein Minuspunkt ist die Umsetzung der Kanban-Boards.;0
 Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEine Ausblick auf m√∂gliche Weiterentwicklungen  In der sich rasant entwickelnden Landschaft des Internets der Dinge (IoT) erweist sich die Wahl der geeigneten Entwicklungsplattform als ma√ügeblich f√ºr den Erfolg eines IoT-Projekts. ElixirNerves hat sich in den letzten Jahren als vielversprechende Option hervorgetan, indem es die funktionalen Elemente der Programmiersprache Elixir mit einer Infrastruktur f√ºr die Entwicklung von IoT-Ger√§ten kombiniert. Die Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen schafft √úberblicke √ºber ihre gegenw√§rtigen F√§higkeiten sowie kommende Entwicklungen, die ihr Potenzial zur Revolutionierung von IoT-Prototyping und -Implementierung weiter steigern k√∂nnten.   Aktuelle Leistungsf√§higkeit von ElixirNerves  ElixirNerves basiert auf der Beams interner Prozesse und liefert dar√ºber hinaus eine wichtige Abstraktionsebene f√ºr die Softwareentwicklung in ressourcenbegrenzten Umgebungen. Die Plattform bietet eine robuste Runtime, Unterst√ºtzung f√ºr Echtzeitbetriebssysteme und eine Vielzahl an Softwareschnittstellen, die es Entwicklern erm√∂glichen, komplexe IoT-Dienste mit relativ geringem Aufwand zu realisieren. Zu den St√§rken von ElixirNerves z√§hlen vor allem die parallele Verarbeitung, Code-Integrit√§t durch Pr√ºfungen, automatisierte Updates und ein hohes Ma√ü an Fehlertoleranz ‚Äì Eigenschaften, die f√ºr sensible IoT-Anwendungen von zentraler Bedeutung sind.  Die modulare Architektur von Nerves erm√∂glicht die problemlose Integration verschiedenster Hardwareplattformen und Peripherieger√§te. Die Relevanz dieser Flexibilit√§t liegt nicht nur in der erfolgreichen Implementierung bestehenden Designs, sondern ebenso in der Anpassungsf√§higkeit hinsichtlich aufkommender Technologien wie Low-Power-WAN (LPWAN) und neuartigen Ger√§ten, die ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ing um Erzielen von korrelierten Daten eine elektrisch-√∂konomische Absicherung gew√§hrleisten.   Blick in die ZukunftM√∂gliche Weiterentwicklungen  Um das Potenzial von ElixirNerves weiter zu erschlie√üen, sind diverse technologischen Weiterentwicklungen denkbar, die entweder in bestehendes Know-how innerhalb der Community eingegriffen oder von Informationen der aktuellen Entwicklungstrends im IoT-Bereich inspiriert sind.  1. Erweiterung des Hardware-SupportsEin wesentlicher Aspekt der weiteren Entwicklung ist die Einf√ºhrung neuer Treiber und Bibliotheken f√ºr die Integration weiterer Ger√§te sowie neuester IoT-Technologien wie beispielsweise 5G oder Edge Computing. Durch ein starkes Umfassungsmodell f√ºr verschiedenste Protokolle k√∂nnte Nerves helfen, die grenzenlosen M√∂glichkeiten von IoT vollumf√§nglich zu nutzen.  2. Verbesserte ProgrammierabstraktionenDerzeit ist Wissen um die Komplexit√§t der Zyklen bei der Entwicklung limitierter Rechenleistung unabdingbar. Die Einf√ºhrung h√∂her abstrahierter Entwicklungswerkzeuge oder graphischer Benutzerschnittstellen (GUIs) kann dazu genutzt werden, die H√ºrde des XML-Zugriffs zu vermindern und IoT-Entwicklern mit minimalen Programmierf√§higkeiten den Eintritt zu erleichtern.  3. L√∂sahete-oder Dienstablauf-SystemeEin weiteres Potenzial erl√§utet m√∂glicherweise den Weg, interaktive Dienste einheitlich;1
In IEEE 802.15.4 werden die zwei Ger√§tetypen Full Function Device (FFD) und Reduced Function Device (RFD) definiert. Das FFDenth√§lt alle Dienste des Link-Layers und kann entweder als Netzwerk-Koordinator (auch als Wireless Personal Area Network (WPAN)- Koordinator bezeichnet) oder als einfaches Netzwerk-Ger√§t operieren. Das RFDenth√§lt hingegen nur eine reduzierte Anzahl an Diensten des Link-Layers und kann deswegen nur als einfaches Netzwerk-Ger√§t operieren. Dabei sind zwei Grund-Topologien erlaubt, die aber durch den Standard nicht vollst√§ndig spezifiziert werden, da diese Bestandteil von h√∂heren Netzwerkschichten sind und deswegen au√üerhalb des Spezifikationsbereiches liegen. Die unterst√ºtzten Topologien dabei sind die Stern-Topologie und die Peer-to-Peer-Topologie (siehe Abbildung 2.2, vgl. ). Die Stern-Topologie formiert sich dabei um ein FFD, das als WPAN-Koordinator fungiert und das einzige Ger√§t im Netzwerk ist, dass Verbindungen mit mehr als einem anderen Ger√§t aufbauen darf. Bei Sensornetzwerken ist dabei die Stern-Topologie zu bevorzugen, wenn der abzudeckende Bereich klein ist und eine niedrige Latenz der Anwendung gefordert wird. Dabei funktioniert der WPAN-Koordinator als network master , der Pakete, auch beacons genannt, zur Synchronisation und Assozierung von Ger√§ten sendet. Dabei kann jedesFFDein eigenes Netzwerk definieren. Ein Netzwerkger√§t, das einem Netzwerk mit Stern-Topologie beitreten m√∂chte, h√∂rt auf die beacon-Nachricht und kann nach dem Erhalt dieser Nachricht eine Assozierungsanfrage senden, die der WPAN-Koordinator erlaubt oder ablehnt. Daneben wird in einer Stern-Topologie auch ein Modus ohne beaconsunterst√ºtzt, bei dembeaconsnur zur Assoziierung verwendet werden und die Synchronisation durch ein periodisches Polling des WPAN-Koordinators erreicht wird (vgl. ). In der Peer-to-Peer-Topologie darf jedes Ger√§t mehrere direkte Verbindungen zu ande- ren Ger√§ten aufbauen, sodass redundante Pfade und Verbindungen verf√ºgbar sind. Bei Sensornetzen wird diese Technologie bevorzugt, wenn gr√∂√üere Fl√§chen abgedeckt werden sollen und die Latenz kein kritischer Faktor ist. Dadurch wird das Zusammenstellen von komplexeren Netzwerke m√∂glich und FFDs k√∂nnen untereinander √ºber mehrere Hops kom- munizieren. In einem Peer-to-Peer-Netz muss dabei jedes proaktiv nach anderen Ger√§ten suchen.;0
 Ausblick  In den letzten Jahren hat die Entwicklung von LoRaWAN (Long Range Wide Area Network) als Schl√ºsseltechnologie f√ºr das Internet der Dinge (IoT) erheblich an Bedeutung gewonnen. Insbesondere im Bereich der Landwirtschaft und Umwelt√ºberwachung er√∂ffnet die pr√§zise Erfassung von Bodenfeuchtigkeit neue M√∂glichkeiten zur Optimierung von Bew√§sserungsstrategien und zur F√∂rderung nachhaltiger Landwirtschaft. Diese wissenschaftliche Arbeit hat sich darauf konzentriert, ein System zur √úberwachung der Bodenfeuchtigkeit mithilfe von LoRaWAN und The Things Network (TTN) zu entwickeln und zu evaluieren.  In den kommenden Jahren erwarten wir mehrere bedeutende Fortschritte in diesem Bereich, die sich aus der fortlaufenden Entwicklung von LoRaWAN-Technologien, Sensortechnik und Datenanalytik ergeben werden. Zuk√ºnftige Forschung k√∂nnte sich auf die folgenden Aspekte konzentrieren:  1. Verbesserte Sensortechnologie: Die Entwicklung kosteng√ºnstigerer, pr√§ziserer und langlebiger Sensoren wird die Qualit√§t und Genauigkeit der Bodenfeuchtigkeitsmessungen erheblich steigern. Miniaturisierte Sensoren, die weniger Energie verbrauchen und sich in einer breiten Palette von Umgebungen einsetzen lassen, werden den Einsatz in abgelegenen Gebieten erleichtern.  2. Integration von KI und Machine Learning: Die Analyse der gesammelten Daten kann durch den Einsatz fortschrittlicher Algorithmen des maschinellen Lernens optimiert werden. Dadurch k√∂nnen Muster und Trends in den Bodenfeuchtigkeitsdaten identifiziert werden, die f√ºr die Vorhersage von Bew√§sserungsbedarfen und Wettereinfl√ºssen unerl√§sslich sind.  3. Erweiterte Anwendungsfelder: Neben der Landwirtschaft k√∂nnten die entwickelten Techniken auch in anderen Bereichen Anwendung finden, wie z.B. in der Gartenbauwirtschaft, der Rehabilitierung von √ñkosystemen oder im Wasserressourcenmanagement. Eine breitere Anwendung k√∂nnte zur Entwicklung umfassenderer L√∂sungen f√ºr globale Herausforderungen wie Wasserknappheit beitragen.  4. Langzeitstudien und Datenverf√ºgbarkeit: Die Durchf√ºhrung langfristiger Studien zur Bodenfeuchtigkeit wird es erm√∂glichen, umfassendere Datenanalysen zu erstellen, die auch den Einfluss von Klimaver√§nderungen auf die Bodenfeuchtigkeit und die damit verbundenen √∂kologischen Systeme untersuchen.  5. Standardisierung und Interoperabilit√§t: Um ein funktionierendes √ñkosystem f√ºr IoT-Anwendungen im Bereich der Bodenfeuchtigkeit zu schaffen, ist eine Standardisierung der Kommunikationsprotokolle und Datenformate erforderlich. Dies w√ºrde die Interoperabilit√§t zwischen verschiedenen Sensoren und Netzwerken verbessern und die Entwicklung neuer Anwendungen f√∂rdern.  Abschlie√üend l√§sst sich sagen, dass die durch LoRaWAN und TTN erm√∂glichte √úberwachung der Bodenfeuchtigkeit ein vielversprechendes Forschungsfeld darstellt, das nicht nur zur Effizienzsteigerung in der Landwirtschaft f√ºhrt, sondern auch einen Beitrag zur L√∂sung globaler Umweltprobleme leisten kann. Die k√ºnftige Forschung sollte sich daher auf die Weiterentwicklung der Technologie, die Verbesserung der Datenanalyse und die Integration in bestehende Systeme konzentrieren, um das volle Potenzial dieser innovativen Ans√§tze auszusch√∂pfen.;1
In allen untersuchten Softwares k√∂nnen die Arbeitspakete kommentiert werden, um  beispielsweise Hinweise f√ºr die Umsetzung oder den Fortschritt des Arbeitspakets zu  dokumentieren. Auf der untersuchten Azure DevOps Services-Instanz entstanden einige  Kommentare durch Vorg√§nge wie die Duplizierung von Arbeitspaketen , andere beinhalteten  Erg√§nzungen zum Arbeitspaket und h√§tten ebenfalls in die Beschreibung aufgenommen  werden k√∂nnen. Die Umsetzung einer Kommentarfunktion ist deswegen kein Teil der  Sch√§tzung.  Azure DevOps Services, Jira Software und OpenProject bieten an, Arbeitspakete  anderen  Arbeitspaketen unterzuordnen. Damit k√∂nnen beispielsweise f√ºr die Umsetzung einer User  Story mehrere Aufgaben untergeordnet werden oder mehrere User Stories zu eine m  Themengebiet in einem Epic organisiert werden. Eine solche Struktur sollte au ch in der  Software abgebildet werden k√∂nnen. Hierbei ist jedoch darauf zu achten, gewisse  Einschr√§nkungen bei der Verlinkung zu definieren, damit beispielsweise Arbeitspakete nicht  sich selbst untergeordnet werden k√∂nnen oder ein Epic einem Test untergeordnet wird. Die  einfachste M√∂glichkeit w√§re, pro Arbeitpaketstyp festzulegen, welche Arbeitspaketstypen   untergeordnet werden k√∂nnen.;0
"3 Implementierung der Journaling Apps
In diesem Abschnitt wird zun√§chst die App, welche f√ºr diese Arbeit entwickelt wird, erkl√§rt
und auf die daf√ºr n√∂tigen Anforderungen eingegangen. Aus den ermittelten Anforderungen
wird ein Mockup f√ºr die App extrahiert und dargestellt. Mit den Anforderungen und der
Mockup Vorlage wird zun√§chst auf die Umsetzung der PWAsowie der nativen Andorid
App eingegangen.
3.1 DeÔ¨Ånition der Anforderungen
F√ºr diese Arbeit werden die beiden verwendeten Technologien anhand einer Journaling App
verglichen. Es soll darum gehen, den Nutzer zu einer regelm√§√üigen Journaling-Gewohnheit
zu motivieren. Es werden m√∂glichst viele Anforderungen sinnvoll eingebaut. Ein Beispiel
ist das Setzten einer Erinnerung in Form einer NotiÔ¨Åcation zu einer einstellbaren Uhrzeit.
Bei technologisch interessanten Anforderungen, wie zum Beispiel das Erstellen von Bildern,
wird die Technologie so gut wie m√∂glich in die App integriert. Es handelt sich in der
Arbeit und somit auch der App nicht um die Entwicklung eines Produkts, sondern um eine
technische Demonstration. Aus diesem Grund werden auch Anforderungen deÔ¨Åniert und
umgesetzt, die nicht zu einem gut abgerundetem App-Erlebnis f√ºhren. Folgende Features
werden in beiden Technologien umgesetzt:
‚Ä¢ZugriÔ¨Ä auf den Standort
‚Ä¢Setzen von geplanten NotiÔ¨Åkations
‚Ä¢Verwendung der Kamera
‚Ä¢Verwendung des Mikrofons
‚Ä¢Erstellen von Push-NotiÔ¨Åcation
‚Ä¢Verwendung des Gyrosensors
‚Ä¢ZugriÔ¨Ä auf Dateien";0
Evaluierung des State of the Art beim Testen von MQTT-basierten L√∂sungen  Die vorliegende Evaluierung befasst sich mit dem aktuellen Stand der Technik im Bereich des Testens von MQTT-basierten L√∂sungen. MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Protokoll, das vor allem f√ºr die Kommunikation in IoT-Anwendungen (Internet of Things) entwickelt wurde. Die Effizienz und Flexibilit√§t von MQTT hat zu seiner weitreichenden Akzeptanz in der Industrie gef√ºhrt, wodurch auch die Notwendigkeit eines umfassenden Testansatzes f√ºr diese Technologien gewachsen ist.  Ein zentrales Element bei der Evaluierung des Testens von MQTT-basierten L√∂sungen ist die Identifikation der spezifischen Herausforderungen, die mit der Implementierung und dem Betrieb von MQTT-Systemen einhergehen. Dazu geh√∂ren Aspekte wie Netzwerkzuverl√§ssigkeit, Datenintegrit√§t, Latenzzeiten sowie die Handhabung von Verbindungsabbr√ºchen. Diese Faktoren erfordern angepasste Teststrategien, um die Robustheit und Zuverl√§ssigkeit der Anwendungen zu gew√§hrleisten.  Im aktuellen Forschungsstand finden sich verschiedene Ans√§tze und Werkzeuge, die sich auf das Testen von MQTT-Anwendungen konzentrieren. Zu den prominentesten geh√∂ren Lasttests, die die F√§higkeit eines Systems bewerten, eine hohe Anzahl von gleichzeitigen Verbindungen und Nachrichten zu verarbeiten. Tools wie JMeter und Gatling haben sich in diesem Kontext bew√§hrt, indem sie die Simulation von Benutzerlasten erm√∂glichen und die Performance unter realistischen Bedingungen messen.   Ein weiterer wichtiger Aspekt ist die Sicherheit von MQTT-basierten L√∂sungen. Angesichts der zunehmenden Bedrohungen durch Cyberangriffe ist es unerl√§sslich, Sicherheitsaspekte in den Testprozess zu integrieren. Hierbei kommen sowohl statische als auch dynamische Analysetools zum Einsatz, die Schwachstellen in der Implementierung identifizieren und bewerten. Die Integration von Sicherheitspr√ºfungen in den Entwicklungszyklus (DevSecOps) gewinnt zunehmend an Bedeutung und wird als Best Practice angesehen.  Des Weiteren ist die Interoperabilit√§t zwischen verschiedenen MQTT-Implementierungen ein kritischer Punkt. Tests m√ºssen sicherstellen, dass verschiedene Systeme nahtlos miteinander kommunizieren k√∂nnen, ohne dass es zu Datenverlusten oder Kommunikationsfehlern kommt. Hierbei sind standardisierte Testprotokolle und -methoden erforderlich, die eine objektive Bewertung der Kompatibilit√§t erm√∂glichen.  Zusammenfassend l√§sst sich sagen, dass der State of the Art beim Testen von MQTT-basierten L√∂sungen kontinuierlich fortschreitet. Die Entwicklungen in der Testautomatisierung, Sicherheit und Interoperabilit√§t zeigen, dass die Branche aktiv an der Verbesserung der Testmethoden arbeitet. Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, die bestehenden Testans√§tze weiter zu verfeinern und neue Technologien zu integrieren, um die Herausforderungen, die mit der Nutzung von MQTT im Kontext des IoT einhergehen, noch effektiver zu adressieren.;1
In der vorliegenden Arbeit wurde die Plattform ElixirNerves eingehend evaluiert, um ihre Eignung f√ºr die Entwicklung von IoT-Anwendungen zu untersuchen. Die Analyse hat gezeigt, dass ElixirNerves durch seine robuste Architektur, die auf der Erlang Virtual Machine basiert, eine hohe Zuverl√§ssigkeit und Skalierbarkeit bietet. Die Funktionalit√§ten, die durch die Verwendung der Programmiersprache Elixir bereitgestellt werden, erm√∂glichen eine effiziente Handhabung von Nebenl√§ufigkeit und Fehlertoleranz, was f√ºr die Anforderungen von IoT-Systemen von entscheidender Bedeutung ist.  Ein weiterer wesentlicher Aspekt der Evaluation war die Benutzerfreundlichkeit der Plattform. Die umfangreiche Dokumentation und die aktive Community tragen dazu bei, dass Entwickler schnell in die Materie einsteigen k√∂nnen. Dar√ºber hinaus bietet ElixirNerves eine Vielzahl von Tools und Bibliotheken, die die Implementierung g√§ngiger IoT-Protokolle erleichtern und somit den Entwicklungsprozess erheblich beschleunigen.  Trotz der vielen Vorteile wurden auch einige Herausforderungen identifiziert. Insbesondere die noch begrenzte Anzahl an vorgefertigten Treibern f√ºr spezifische Hardwarekomponenten kann die Implementierung von IoT-L√∂sungen erschweren. Zudem erfordert die Einarbeitung in die funktionale Programmierung, die Elixir bietet, von Entwicklern, die aus der imperativen Programmierung kommen, eine gewisse Anpassungsphase.  Zusammenfassend l√§sst sich feststellen, dass ElixirNerves eine vielversprechende Plattform f√ºr die Entwicklung von IoT-Anwendungen darstellt. Die St√§rken in Bezug auf Zuverl√§ssigkeit, Skalierbarkeit und Benutzerfreundlichkeit √ºberwiegen die bestehenden Herausforderungen. F√ºr Entwickler, die innovative und robuste IoT-L√∂sungen realisieren m√∂chten, bietet ElixirNerves eine solide Grundlage, die sowohl aktuelle als auch zuk√ºnftige Anforderungen erf√ºllen kann. Zuk√ºnftige Forschungsarbeiten k√∂nnten sich darauf konzentrieren, die Unterst√ºtzung f√ºr spezifische Hardware zu erweitern und Best Practices f√ºr die Integration von ElixirNerves in bestehende IoT-√ñkosysteme zu entwickeln.;1
     In der heutigen Softwareentwicklung ist die Qualit√§t von Softwareprodukten ein zentrales Anliegen, das sowohl die Zufriedenheit der Benutzer als auch die wirtschaftliche Effizienz der Entwicklung beeinflusst. Produktorientierte Metriken der Softwarequalit√§t bieten ein quantitatives Ma√ü, um die Eigenschaften und die Leistungsf√§higkeit von Software zu bewerten. Diese Metriken sind entscheidend, um die Qualit√§t von Software zu gew√§hrleisten, zu kontrollieren und kontinuierlich zu verbessern. In diesem Text wird ein Konzept zur Umsetzung produktorientierter Metriken der Softwarequalit√§t vorgestellt, das sowohl als auch praktische Anwendungen umfasst.   Definition produktorientierter Metriken  Produktorientierte Metriken sind Kennzahlen, die direkt auf die Eigenschaften des Softwareprodukts selbst abzielen. Sie messen Aspekte wie Funktionalit√§t, Zuverl√§ssigkeit, Effizienz, Benutzbarkeit, Wartbarkeit und √úbertragbarkeit. Zu den g√§ngigsten Metriken geh√∂ren 1. Code-Komplexit√§tMetriken wie der cyclomatische Komplexit√§tsindex geben Aufschluss √ºber die Verst√§ndlichkeit und Wartbarkeit des Codes. 2. FehlerdichteDie Anzahl der Fehler pro Codezeile oder pro Funktionseinheit erm√∂glicht eine Bewertung der Zuverl√§ssigkeit. 3. TestabdeckungDer Prozentsatz des Codes, der durch automatisierte Tests abgedeckt ist, gibt Hinweise auf die Robustheit des Tests. 4. ReaktionszeitDie Zeit, die ein System ben√∂tigt, um auf Benutzeranfragen zu reagieren, ist ein Ma√ü f√ºr die Effizienz und Benutzerfreundlichkeit.   Konzept zur Umsetzung  Um produktorientierte Metriken effektiv zu implementieren, bedarf es eines strukturierten Ansatzes, der die folgenden Schritte umfasst 1. ZieldefinitionZun√§chst m√ºssen die spezifischen Qualit√§tsziele der Software festgelegt werden. Diese Ziele sollten messbar und erreichbar sein und sich an den Bed√ºrfnissen der Stakeholder orientieren.  2. Auswahl der MetrikenBasierend auf den definierten Zielen erfolgt die Auswahl geeigneter Metriken. Dabei ist es wichtig, eine Balance zwischen verschiedenen Metriken zu finden, um ein umfassendes Bild der Softwarequalit√§t zu erhalten.  3. Integration in den EntwicklungsprozessDie ausgew√§hlten Metriken m√ºssen in den Softwareentwicklungsprozess integriert werden. Dies kann durch den Einsatz von Continuous Integration (CI) und Continuous Deployment (CD) Praktiken erfolgen, bei denen Metriken automatisiert erfasst und analysiert werden.  4. Datenanalyse und ReportingDie gesammelten Daten m√ºssen regelm√§√üig analysiert und in verst√§ndlichen Berichten aufbereitet werden. Dies erm√∂glicht es den Entwicklern und Managern, informierte Entscheidungen zu treffen und gegebenenfalls Anpassungen vorzunehmen.  5. Feedback-MechanismenUm die kontinuierliche Verbesserung der Softwarequalit√§t zu f√∂rdern, sollten Feedback-Mechanismen implementiert werden. Diese erm√∂glichen es, die Ergebnisse der Metriken in die Planung zuk√ºnftiger Entwicklungszyklen einflie√üen zu lassen.  6. Schulung und SensibilisierungDie Beteiligten im Entwicklungsprozess m√ºssen in der Bedeutung und Anwendung der Metriken geschult werden. Dies f√∂rdert ein gemeinsames Verst√§ndnis und eine Kultur;1
In der digitalen App-Welt hat sich die Entwicklungshorizonte erheblich ver√§ndert, was unter anderem der fortschreitenden technischen Entwicklung und der fortw√§hrenden Beratungen der Nutzerbed√ºrfnisse geschuldet ist. Progressive Web-Apps (PWA) und native Apps sind zwei einzelne Paradigmen, die f√ºr die Entwicklung mobiler Anwendungen von gro√üer Bedeutung sind. W√§hrend native Apps insbesondere durch ihre Performance und Integration in das Betriebssystem gl√§nzen, zeichnen sich PWAs durch ihre Flexibilit√§t und Beschaffbarkeit aus. Im vorliegenden Text erfolgt eine theoretische Gesamtbetrachtung der beiden Ans√§tze, exemplarisch angewandt auf eine inkrementelle Journaling-App.    Grundlagen der PWA  √ñkologische Effizienz, schnellere Ladezeiten und eine zweite Chance zur Interaktion sind einige der Kernmerkmale von PWAs. Diese Technologien erm√∂glichen es Entwicklern, durch den Einsatz standardisierter Technologien wie HTML, CSS und JavaScript plattform√ºbergreifende Produkte zu bauen. PWAs sind in der Lage, Offline-Funktionalit√§ten zu integrieren, dank Service Workern, und k√∂nnen Benachrichtigungen senden, analog zu nativen Anwendungen. Ein essenzieller theoretischer Aspekt ist die Responsive Design-Philosophie, die daf√ºr sorgt, dass die Benutzeroberfl√§che auf Methoden von Interaktion reagiert und der Benutzererfahrung dient.    Theoretische Basics der nativen Apps  Native Apps hingegen stellen herk√∂mmliche mobile Anwendungen dar, die speziell f√ºr ein Betriebssystem (iOS, Android) entwickelt sind. Das bedeutet, dass sie Zugriff auf spezifische Anwendungsprogrammierschnittstellen (APIs) haben, wodurch sie optimierte Nutzungsm√∂glichkeiten der Hardware, wie Kameras oder GPS-Sensoren, besitzen. Fundamentale Prinzipien der nativen Entwicklung umfassen Leistungsoptimierung, bessere Interaktion mit Systemkomponenten und eine tiefere Integration in das jeweilige Exosystem. Ihr installationsbasierter Ansatz bringt eine demokratische Form der Datenhaltung mit sich, wo Nutzeraktionen immer lokalen Zugriff auf konkret ben√∂tigte Funktionen erm√∂glichen.;1
Die Funktion ‚ÄúElephant‚Äù ist eine Kombination des Funktionalit√§ten aus ‚ÄúAnimation‚Äù und ‚ÄúAudio‚Äù. Sie bekommt als keine Parameter aus der JSON-Datei √ºbergeben, da die verwendete Animation und Audio-Datei im Code der Activity eingetragen sind. Say √úber den im Abschnitt Audio (3.6.2) erw√§hnten Lautsprecher, kann ebenfalls Text als gesprochene Sprache ausgegeben werden. Dieser Text wird frei gew√§hlt. F√ºr die Aussprache kann zus√§tzlich die Sprache der Sprachausgabe eingestellt werden. Diese M√∂glichkeit wird aber aktuell nicht in der Container-App verwendet. Die Pepper-Container-App implementiert keinen eigenen Webbrowser. Stattdessen startet sie den Standard-Webbrowser des Android-Tablets, um auf dem Bildschirm eine Webseite anzuzeigen. F√ºr den ZugriÔ¨Ä auf den Webbrowser wird zum Start der Container-App die Berechtigung ‚Äúandroid.permission.INTERNET‚Äù des Android-OS angefragt. Starten einer Activity mit Parametern Um Basis einer JSON-Datei eine Roboterfunktion zu starten, wird aus dieser der Name ‚Äúname‚Äú der Funktion und deren Funktionsparameter ‚Äúparameter‚Äù ausgelesen. Aktuell verwenden alle Roboterfunktionen keinen oder einen Parameter. Auf Basis des Namens wird die richtige Funktion per OnClickListener mit Button ‚ÄúbtnFunction1‚Äù verbunden. Zus√§tzlich werden Farbe und Text des Buttons auf Basis der Funktion angepasst. Alle √Ñnderungen der GUI m√ºssen im UI-Thread erfolgen, ansonsten wird eine Exception erzeugt und die OberÔ¨Ç√§che nicht ge√§ndert. Um eine Activity zu starten wird ein Intent genutzt. Diesem k√∂nnen Parameter angeh√§ngt werden, um sie in der Activity abzurufen (3.6.2). Dies geschieht in der OnCreate-Methode der Activity, da sie bei der Erstellung der Activity aufgerufen wird und somit die Parameter m√∂glichst fr√ºh verf√ºgbar sind. Am Beispiel der Funktion ‚ÄúSay‚Äù ist zu sehen, dass somit die Parameter fr√ºh gepr√ºft und der weitere Aufbau der Activity bei fehlerhaften oder fehlenden Parametern abgebrochen werden kann.;0
Die Hochschule hat beim Kauf des Roboters mit diesem CMS gearbeitet, weshalb dieses CMS als Anhaltspunkt verwendet wird. Zus√§tzlich wird die sp√§tere Nutzergruppe der DHBW befragt, welche Funktionen unverzichtbar sind, welche Funktionen ein hilfreiches Zusatz Feature w√§ren und welche nicht ben√∂tigt werden. Diese Funktionen werden dann gemeinsam priorisiert und anschlie√üend aus den gewonnenen Erkenntnissen Mockups angefertigt, sowohl f√ºr die App selbst, als auch f√ºr den Frontend Editor √ºber den die App erstellt werden kann. F√ºr die Umsetzung wird in Erw√§gung gezogen, ein bereits bestehendes CMS zu verwenden und auf die Bed√ºrfnisse des Projektes anzupassen. Ist dies nicht m√∂glich, so werden graÔ¨Åsche Code-Editoren, sogenannte Low-Code Editoren, in Erw√§gung gezogen. Wenn all diese M√∂glichkeiten nicht in Frage kommen, muss das Projekt von Grund auf aufgebaut werden. Um das Gelingen des Projektes einsch√§tzen zu k√∂nnen, wird ein Prototyp erstellt. Durch regelm√§√üiges Testen sollen Fehler fr√ºh erkannt und behoben werden k√∂nnen.;0
 Kapitel: Technische Grundlagen der Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung   Einleitung  Im Zuge der fortschreitenden Digitalisierung hat das Internet der Dinge (IoT) einen bedeutenden Einfluss auf individuelle Lebensbereiche genommen, wobei Smart-Home-Anwendungen eine f√ºhrende Rolle einnehmen. In diesem Kapitel werden die technischen Grundlagen erl√§utert, die f√ºr die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-gest√ºtzter Katzenerkennung erforderlich sind. Hierbei wird auf die Systemarchitektur, Sensortechnologien, klassische und moderne Bildverarbeitungsmethoden sowie die Implementierung der k√ºnstlichen Intelligenz eingegangen.   1. Systemarchitektur  Die Architektur des IoT-Systems umfasst mehrere Komponenten, die miteinander kommunizieren, um die Erkennung einer Katze und die Steuerung der Katzenklappe zu erm√∂glichen. Die Hauptbestandteile sind:  - Sensoren: In diesem Fall vor allem eine Kamera zur Bildaufnahme und ein Mikrocontroller, der die Informationen auswertet. - K√ºnstliche Intelligenz: Ein KI-Modell zur Katzenerkennung wird ben√∂tigt, dessen Implementierung die Trainierbarkeit anf√§nglicher Netzwerke und deren Auswandlungsweise zum Ziel hat. - Steuereinheit: Ansteuerung der Katzenklappe, zum Beispiel mittels eines Servo-Motors, der elektronisch aktiviert wird. - Netzwerkinfrastruktur: Eine WLAN-Verbindung ist erforderlich, um die Kommunikation zwischen den Ger√§ten zu erm√∂glichen und Daten zu √ºbermitteln. - Benutzerschnittstelle: M√∂chte der Nutzer Daten einsehen oder Anpassungen vornehmen, ist eine Graphic User Interface (GUI) auf einem Smartphone oder Web-Interface notwendig.  Diese Komponenten arbeiten in Synergie, um sowohl die Erkennung als auch die Steuerung effizient durchzuf√ºhren.   2. Sensortechnologien  F√ºr die Katzenerkennung wird prim√§r eine Kamera verwendet, die mit einer geeigneten Linse ausgestattet ist, um klare Aufnahmen aus unterschiedlichen Perspektiven zu gew√§hrleisten. Hierbei spielt die Wahl des Bildsensors eine essenzielle Rolle. Die g√§ngigsten Typen sind:  - CMOS-Sensoren: Diese sind energieeffizient und zeichnen sich durch eine hohe Verf√ºgbarkeit und geringere Abmessungen aus. - CCD-Sensoren (Charge-Coupled Device): Diese bieten eine h√∂here Bildqualit√§t und vorteilhafte Eigenschaften in schwach beleuchteten Bedingungen, unterscheiden sich aber durch einen h√∂heren Energiebedarf.  Integriert in das Netzwerksystem wird eine kosteng√ºnstige M√∂glichkeit gesucht, wobei sowohl CMOS- als auch CCD-Technologien betrachtet werden, abh√§ngig von den spezifischen Anforderungen der Anwendung.   3. Bildverarbeitungsmethoden  Im Zentrum der Erkennungstechnologie steht die Bildverarbeitung, wobei hier tiefere Laodings_FB_CONBY_Under verschiedene Methoden Anwendung finden:  - Klassische Bildverarbeitung: Algorithmen zur Segmentierung und Merkmalsextraktion spielen eine bedeutende Rolle, um visuelle Einheiten von Katzen effizient von dem Hintergrund abzugrenzen. - Moderne Bildverarbeitung: Sch√∂nheiten der Convolutional Neural Networks (CNN) kamen fr√ºhzeitig auf, wodurch KI-gesteuerte Verfahren, insbesondere im Bezug zur Mustern;1
F√ºr die Bereitstellung einer Interaktionsm√∂glichkeit zwischen einem Entity und der App werden die Data Access Objects ben√∂tigt. Diese DAOs stellen die Methoden bereit, welche diese Interaktion erm√∂glichen . Sie bilden das Mapping der SQLite-Queries zu Funktionen ab . Die Klasse Database h√§lt die Datenbank. Sie ist der Hauptzugangspunkt f√ºr die App zu den persistierten Daten. Sie enth√§lt ein Array aller Entities, die sie verwalten soll und muss mit der Annotation @Database und einer Version versehen werden. Zus√§tzlich muss sie die Klasse RoomDatabase erweitern und f√ºr jedes verwendete DAOeine abstrakte Funktion implementieren, die keine Argumente entgegennimmt und eine Instanz der DAO-Klasse zur√ºckgibt . Innerhalb der App kann dann eine Instanz der Datenbank erzeugt werden. Diese Datenban- kinstanz enth√§lt theoretisch Instanzen von allen DAOs, die mit ihr in Verbindung stehen. √úber diese DAO-Instanzen kann die Anwendung die Daten aus den einzelnen Tabellen beziehen . Im praktischen Beispiel der CoÔ¨ÄeeCompose Anwendung enth√§lt die Datenbank nur eine einzelne DAO-Instanz, das CoÔ¨Äee- DAO. DieseDAO-Instanz erm√∂glicht den ZugriÔ¨Ä auf die Daten der CoÔ¨Äee-Tabelle. Folgende Abbildung 3.3 dient der Veranschaulichung dieser Zusammenh√§nge.;0
      Die fortschreitende Technologisierung im Bereich der Mobilit√§t hat zu einem erh√∂hten Interesse an der Entwicklung autonomer und fernsteuerbarer Fahrzeuge gef√ºhrt. Insbesondere die Integration von Kommunikationsprotokollen, die eine zuverl√§ssige Daten√ºbertragung erm√∂glichen, spielt eine entscheidende Rolle f√ºr die Sicherheit und Effizienz solcher Systeme. Der Standard IEEE 802.15, der f√ºr die drahtlose pers√∂nliche Netzwerktechnologie (WPAN) entwickelt wurde, bietet vielversprechende Ans√§tze f√ºr die Implementierung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung.      1. Kommunikationsprotokolle und IEEE 802.15  IEEE 802.15 umfasst verschiedene Standards, die f√ºr die drahtlose Kommunikation in pers√∂nlichen Netzwerken konzipiert sind, darunter Zigbee, Bluetooth und WirelessHART. Diese Standards bieten verschiedene Vorteile wie niedrigen Energieverbrauch, hohe Flexibilit√§t und die F√§higkeit, in komplexen Umgebungen zu operieren. F√ºr die Entwicklung einer Fahrzeugfernsteuerung ist insbesondere die F√§higkeit zur robusten und latenzarmen Kommunikation von Bedeutung, um eine zeitnahe √úbertragung von Steuerbefehlen und Sensordaten zu gew√§hrleisten.   2. Fahrzeugfernsteuerung  Die Fahrzeugfernsteuerung basiert auf der √úbertragung von Steuerbefehlen von einem Fernsteuerger√§t zu einem Fahrzeug. Hierbei sind mehrere Aspekte zu ber√ºcksichtigen, darunter die Benutzeroberfl√§che, die Kommunikationsarchitektur und die Implementierung der Steueralgorithmen. Die Benutzeroberfl√§che sollte intuitiv gestaltet sein, um dem Bediener eine einfache Kontrolle zu erm√∂glichen. Die Kommunikationsarchitektur sollte auf einer zuverl√§ssigen Verbindung basieren, um Datenverluste zu minimieren.   3. Kollisionsvermeidung  Die Kollisionsvermeidung ist ein kritischer Aspekt bei der Entwicklung autonomer und fernsteuerbarer Fahrzeuge. Sie erfordert den Einsatz von Sensoren, Algorithmen zur Datenverarbeitung und geeigneten Kommunikationsprotokollen. Die Integration von Sensoren wie Lidar, Radar und Kameras erm√∂glicht die Echtzeiterfassung der Umgebung des Fahrzeugs. Diese Sensordaten m√ºssen in Echtzeit analysiert werden, um potenzielle Kollisionen vorherzusagen und geeignete Ma√ünahmen zu ergreifen.   4. Sensorfusion und Datenverarbeitung  Die Sensorfusion ist der Prozess, bei dem Daten aus verschiedenen Sensorquellen kombiniert werden, um ein umfassenderes Bild der Umgebung zu erhalten. Hierbei kommen Algorithmen wie Kalman-Filter und neuronale Netzwerke zum Einsatz, um die Genauigkeit der Objekterkennung und -verfolgung zu erh√∂hen. Die Verarbeitung dieser Daten muss in Echtzeit erfolgen, um eine schnelle Reaktion auf potenzielle Gefahren zu erm√∂glichen.   5. Implementierung des Systems  Die Implementierung eines Systems zur Fahrzeugfernsteuerung mit Kollisionsvermeidung erfordert eine sorgf√§ltige Auswahl der Hardware und Softwarekomponenten. Die Wahl des geeigneten IEEE 802.15 Standards ist entscheidend, um die Anforderungen an Reichweite, Energieverbrauch und Datenrate zu erf√ºllen. Dar√ºber hinaus m√ºssen Algorithmen zur Kollisionsvermeidung in die Steuerlogik des Fahrzeugs integriert werden, um eine;1
Hierbei handelt es sich um die Implementierung zur Handhabung von States und Events auf der Ebene der Composables. Die Hintergr√ºnde und Prinzipien, warum dies n√∂tig ist, sind bereits in Kapitel 3.2.1 geschildert worden. Zusammengefasst geht es um die Handhabung der Verkn√ºpfung zwischen den Interaktionen eines Nutzenden mit der App und den damit verbundenen Aktionen, die durch die Anwendungslogik durchgef√ºhrt und anschlie√üend den Nutzenden als aktueller State auf dem UI dargestellt werden sollen. Das Pattern, welchem dabei gefolgt wird, wird als Unidirektionaler DatenÔ¨Çuss bezeichnet. Dabei Ô¨Çie√üt der aktuelle State in der Hierarchie nach unten, w√§hrend die Events in der Hierarchie nach oben Ô¨Çie√üen. Durch den Einsatz und die strikte Einhaltung dieses Prinzips k√∂nnen die √Ñnderungen auf dem UIund die Stateverwaltung innerhalb der App dauerhaft entkoppelt gehandhabt werden . State hoisting ist eine gute M√∂glichkeit zur Stateverwaltung, wenn es um simples UI-Management geht . Um dies anhand eines Beispiels zu verdeutlichen, zeigt die folgende Abbildung 3.11 die Erweiterung, die sich durch das angewandte State Hoisting Verfahren auf das in der vorherigen Abbildung 3.10 dargestellte Composables ergibt.;0
"Activity Activities sind ein zentraler Bestandteil der Android App und dienen als Ein-
stiegspunkte. Des Weiteren wird in ihnen die UIeingef√ºgt, wodurch diese als die grundle-
gende Anzeigekomponente dienen. Activities m√ºssen im Manifest deklariert werden und
k√∂nnen somit von anderen Apps verwendet werden. Ein Beispiel ist die Teilen-Funktion
im Browser, die es erm√∂glicht etwas direkt √ºber eine Social Media App zu teilen. Das
Verhalten von Activities kann √ºber die Life Cycle Methoden deÔ¨Åniert werden, indem man
sie √ºberschreibt. 
Fragment Fragments sind wiederverwendbare Abschnitte der App UI. Fragments haben
einen Life Cycle und k√∂nnen Input Events verarbeiten. Sie besitzt und verwaltet ihr eigenes
Layout. Im Gegensatz zu Activities k√∂nnen sie nicht alleine stehen, sondern sind in einer
Activity oder einem anderen Fragment enthalten. Die einzelnen Ansichten der Journaling
App werden mithilfe von Fragments umgesetzt. 
Service Ein Service ist eine Komponente, mit der Aufgaben im Hintergrund ausgef√ºhrt
werden k√∂nnen. Sie k√∂nnen f√ºr langlaufende Aufgaben genutzt und zur Interaktion ver-
wendet werden. Wie Activities m√ºssen Services im Manifest eingetragen werden. Es gibt
drei Arten von Services:
‚Ä¢Foreground
‚Ä¢Background
‚Ä¢Bound
F√ºr diese Arbeit ist lediglich der Background Service relevant. In der Journaling App
Ô¨Ånden sie Anwendung f√ºr das Reagieren auf Push-NotiÔ¨Åcations. Sie erhalten die Nachricht
und erstellen im Hintergrund die ben√∂tigte NotiÔ¨Åcation . Beispiel f√ºr die
Verwendung von Services sind:
‚Ä¢Abspielen von Musik
‚Ä¢Ein- und Ausgabeoperationen f√ºr Dateien
‚Ä¢Interagieren im Content Providern";0
Die vorliegende Arbeit besch√§ftigt sich mit der Evaluation von ElixirNerves, einer auf der Programmiersprache Elixir basierenden Plattform, die speziell f√ºr die Entwicklung von IoT-Anwendungen (Internet of Things) konzipiert wurde. Durch eine umfassende Analyse der grundlegenden Architektur, der Programmierparadigmen und der unterst√ºtzenden Tools wird die Eignung von ElixirNerves f√ºr den Einsatz in modernen IoT-Projekten untersucht. Dabei werden sowohl die St√§rken als auch die Schw√§chen der Plattform im Vergleich zu traditionellen IoT-Entwicklungstools beschrieben.   Ein Schwerpunkt der Arbeit liegt auf der Untersuchung von Leistungsaspekten, Stabilit√§t und Skalierbarkeit von Anwendungen, die mit ElixirNerves entwickelt wurden. Dar√ºber hinaus erfolgt eine Betrachtung der Community-Unterst√ºtzung und der Verf√ºgbarkeit von Bibliotheken und Ressourcen, die f√ºr Entwickler von zentraler Bedeutung sind.   Die Ergebnisse zeigen, dass ElixirNerves insbesondere durch seine hervorragenden Eigenschaften f√ºr die Verarbeitung von parallelen Aufgaben, die einfache Handhabung von Netzwerkprotokollen und die Robustheit in der Fehlermanagement-Architektur herausragt. Sie legen jedoch auch nahe, dass die langfristige Eignung der Plattform von der zuk√ºnftigen Entwicklung der Community und der verf√ºgbaren √ñkosystemressourcen abh√§ngt.   Abschlie√üend bietet die Arbeit praxisnahe Empfehlungen f√ºr Entwickler und Entscheidungstr√§ger, die ElixirNerves als Basis f√ºr ihre IoT-L√∂sungen in Erw√§gung ziehen, und tr√§gt zur Diskussion √ºber innovative Ans√§tze in der IoT-Entwicklung bei.;1
"‚Ä¢Endger√§te: Sensoren oder Aktoren senden oder empfangen LoRa-modulierte draht-
lose Nachrichten an beziehungsweise von den Gateways.
‚Ä¢Gateways : Empfangen und senden Nachrichten von beziehungsweise an Endger√§te
und leiten sie an den Netzwerkserver weiter.
‚Ä¢Netzwerkserver: Server auf denen Software l√§uft, die das gesamte Netzwerk und
die verschiedenen Endger√§te und Gateways verwaltet.
‚Ä¢Anwendungsserver: Andere Server mit laufender Software, die zur sicheren Verar-
beitung und √úbertragung von Anwendungsdaten zust√§ndig sind.
Die vielseitigen Einsatzm√∂glichkeiten von LoRaWAN erstrecken sich unter anderem √ºber
die √úberwachung gef√§hrdeter Tierarten wie Spitzmaulnash√∂rner, die Temperatur√ºber-
wachung von Lebensmitteln beim Transport, um eine stetige K√ºhlung zu gew√§hrleisten,
GPS-Tracking von Fahrzeugen, Personal und Gep√§ck an Flugh√§fen, das Verfolgen von
F√ºllst√§nden intelligenter M√ºlleimer, um so einen eÔ¨Äektiveren Abholplan zu erstellen bis
hin zur √úberwachung der Bodenfeuchtigkeit von NutzpÔ¨Çanzen, um Bew√§sserungspl√§ne zu
optimieren, was den Wasserverbrauch um bis zu 30% reduzieren kann. Selbst im Weltraum
gibt es Gateways an Satelliten, mit deren Hilfe versucht wird eine weltweite Abdeckung
des Netzwerkes zu erm√∂glichen.";0
√ñÔ¨Änet der Nutzer ein Projekt bekommt er die Projektansicht zu sehen. Bei der Projekt- ansicht ist links am Rand eine Navigationsleiste. Dort sind zuerst drei Felder zu sehen: Settings, Buttons und Submenus. Wird auf Buttons oder Submenus geklickt fahren weitere Elemente je nach Projekt aus. Bei Buttons f√§hrt, wie in Abbildung 3.13 zu sehen, f√ºr jeden Button, der bereits dem Projekt hinzugef√ºgt wurde, ein Element aus und zus√§tzlich ein Element um ein Button dem Projekt hinzuzuf√ºgen. Bei einem Klick auf Submenus passiert das selbe blo√ü mit den Submenus. Mit einem Klick auf Settings bekommt der Nutzer die Projekteinstellungen zu sehen die in Abbildung 3.12 zu sehen sind. Dort ist ein Slider um einzustellen, ob Pepper auf Voicecommands h√∂ren soll. Zudem k√∂nnen hier die Funktionen eingestellt werden, die Pepper ausf√ºhren soll, wenn er ber√ºhrt wird. Per Klick auf den Button mit dem Plus kann eine neue Funktion der Reihe hinzugef√ºgt werden. Es entsteht ein neuer Button in der Reihe. Bereits hinzugef√ºgte Funktionen k√∂nnen mit einem Klick auf dem entsprechenden Button eingestellt werden. Klickt der Nutzer links in der Navigationsleiste kommt er auf die Einstellungen f√ºr den jeweiligen Button. Im oberen Bereich der Text und die Farbe eingestellt werden, die der Button auf der Pepper-OberÔ¨Ç√§che dann haben soll. Darunter k√∂nnen in einer Matrix die Funktionen hinzugef√ºgt werden, die von Pepper beim Knopfdruck ausf√ºhrt, eingestellt werden.;0
Bei der Durchf√ºhrung einer solchen Veranstaltung kann es zu Problemen bei der Verteilung von Hardware an Studierende kommen. Aufgrund des Mangels an Mikroprozessoren seit Mitte 2020  steigen die Preise von Microcontroller Unit ( MCU)s oder sind nicht mehr verf√ºgbar. Somit k√∂nnen gegebenenfalls nicht alle Student*innen mit genug Con- trollern versorgt werden, welche sie f√ºr die Implementierung von Interaktionen ben√∂tigen. Des Weiteren muss die Hardware bei bei den Teilnehmer*innen vorhanden sein, damit das Szenario durchgef√ºhrt werden kann, was z.B. durch den Umstieg zur Onlinelehre im Zuge der COVID-19-Pandemie erschwert wurde. Das Ziel dieser Studienarbeit ist, eine rein virtuelle L√∂sung zu erarbeiten, die Student*innen den Einstieg in die Funktionsweise und Verwendung des MQTT-Protokolls erleichtert. Als L√∂sungsansatz wird ein Programm implementiert, welches unterschiedliche MQTT-Ger√§te simuliert, um Interaktionen und den Nachrichtenaustausch zwischen Sensoren und Aktoren darzustellen. Zum experimentellen Sammeln von Erfahrungen sollen Student*innen die Simulation mit benutzerdefinierten Verhaltensweisen und selbst implementierten Ger√§ten erweitern k√∂nnen. Im n√§chsten Kapitel werden die technischen Grundlagen von MQTTbeschrieben, die f√ºr das Verst√§ndnis der restlichen Arbeit ben√∂tigt werden. In Kapitel 3 wird das Konzept des Clients und der Dokumentation geplant, welches in Kapitel 4 realisiert wird. In Kapitel 5 wird ein Testlauf des Szenarios mithilfe eines MQTT-Brokers durchgef√ºhrt. Schlie√ülich werden in Kapitel 6 die Ergebnisse zusammengefasst und ein Ausblick dargestellt.;0
Um digitale Inhalte zu den Anfangszeiten des Internets zu erstellen, war der Bedarf an ausgebildeten Softwareentwicklern hoch. Lange Zeit blieb die F√§higkeit der digitalen Inhalts- bzw. Websiteerstellung dieser Berufsgruppe vorenthalten. √Ñnderungsw√ºnsche durch Kunden bzw. firmeneigene Mitarbeiter waren mit langen Iterationsschleifen und langsamen Lieferzeiten verbunden. Sp√§testens durch die Einf√ºhrung von neuen Webtech- nologien wie etwa JavaScript und PHP in Verbindung mit datenbankgest√ºtzten Backends, k√∂nnen digitale Inhalte schnell und unkompliziert generiert werden. Die Bandbreite an M√∂glichkeiten, Inhalte auf Websites zur Verf√ºgung zu stellen hat sich stets vergr√∂√üert. Heute stellen Anwender neue Anspr√ºche an die Verwaltung einer Website. Inhalte sollen ohne Programmierkenntnisse unkompliziert und einfach erstellt sowie gestaltet werden. Der Trend des What You See Is What You Get ( WYSIWYG )-Editors erh√§lt einen festen Stellenwert in der heutigen digitalen Welt und z√§hlt zum Quasi-Standard, wenn es um digitale Inhaltsbearbeitung geht. Resultierend aus diesen Technologien und Trends entsteht die Nachfrage nach L√∂sungen, bei denen der Nutzer selbst Inhalte erstellen und verwalten kann. Es entstand der Begriff bzw. Trend der sogenannten Content Management Systeme (CMS). Mithilfe dieser lassen sich digitale Inhalte ohne vorheriges Programmier-Wissen erstellen. Spezifische Software wird nicht ben√∂tigt, da h√§ufig ein Login in die Verwaltungs- oberfl√§che des Systems gen√ºgt, um neue Inhalte zu erstellen, respektive bestehende zu bearbeiten. Zudem erhalten Nutzer nicht nur Zugriff auf ihre eigenen Inhalte, sondern k√∂nnen projekt√ºbergreifend mit anderen Nutzern zusammenarbeiten. Ferner finden gerade Open-Source- CMSBeliebtheit bei den Anwendern, wodurch eine gro√üe Community mit entsprechenden Foren, Hilfestellungen und Plugins den Betrieb und die Einrichtung eines Systems erleichtert und komfortabler gestaltet .;0
Durch den Befehl intent?.extras?.containsKey(‚Äùkey‚Äù) k√∂nnen die Daten der an- geklickten Nachricht ausgelesen werden. Daf√ºr muss der korrekte Key angegeben werden, um die Daten abgreifen zu k√∂nnen. Durch den Key uuidkann der eindeutige Schl√ºssel der Katzenklappe aus der Nachricht entnommen werden. Dieser kann anschlie√üend an einen Intent als Parameter angehangen werden, um somit zur Deteilansicht der jeweiligen Katzenklappe zu gelangen. Falls das Smartphone gerade nicht verwendet wird und die App eine Benachrichtigung erh√§lt, wird der gleiche Code, wie bei der geschlossenen App abgearbeitet. Um die Nach- richt im Sperrbildschirm zu erhalten, ben√∂tigt es eine Einstellung in der AndroidManifest Datei. In dieser Datei k√∂nnen Informationen √ºber die App, wie zum Beispiel die Berechti- gungen oder die Activities festgelegt werden. Um Nachrichten, w√§hrend das Smartphone gesperrt ist, zu erhalten, ben√∂tigt es die Option android:directBootAware=‚Äùtrue‚Äù . Mit dieser Einstellung wird die App im System registriert, sodass das System wei√ü, dass es auf Nachrichten dieser App achten soll.;0
In der vorliegenden Arbeit wird der Vergleich von Progressiven Webanwendungen (PWA) mit nativen Apps anhand einer Journaling-App untersucht. Der Aufstieg digitaler Tagebuchanwendungen hat unterschiedliche Entwicklungsans√§tze hervorgebracht, wobei PWAs in den letzten Jahren an Popularit√§t gewonnen haben. Diese Forschung analysiert die jeweiligen Vor- und Nachteile von PWAs im Vergleich zu nativen Apps in Bezug auf Benutzerfreundlichkeit, Performance, Zug√§nglichkeit, plattform√ºbergreifende Interoperabilit√§t sowie Entwicklungs- und Wartungskosten. Anhand einer eigens entwickelten Journaling-App wurden quantitative und qualitative Daten durch Benutzerumfragen sowie Performance-Tests gesammelt. Die Ergebnisse zeigen, dass PWAs hinsichtlich Installationsaufwand und plattform√ºbergreifender Nutzung √ºberzeugen, w√§hrend native Apps in Bezug auf Leistung und Integrationsm√∂glichkeiten mit Ger√§teeigenschaften √ºberlegen sind. Diese Arbeit tr√§gt zur Diskussion √ºber die zuk√ºnftige Relevanz von PWAs im App-Markt bei und bietet Entwicklern und Entscheidern wertvolle Insights zur Auswahl des geeigneten Entwicklungsansatzes f√ºr ihre Anwendungen.;1
F√ºr die Konzipierung und anschlie√üende Umsetzung einer mit TYPO3 erstellten Website bedarf es gro√üen zeitlichen Aufwand und bzw. oder Unterst√ºtzung von externen Dienst- leistern, die sich auf die Entwicklung und Realisierug von Designs in TYPO3 spezialisiert haben. Aufgrund der erschwerten Umsetzung von responsivem Web-Design in TYPO3 in Zusam- menhang mit dem definierten Anwendungsfall der Holzbau Mustermann GmbH wird das CMSmit der Kategorie Rot eingestuft, da sich diese Anforderung ohne fremde Hilfe bzw. ohne Programmierkenntnis nicht hinreichend umsetzen l√§sst. Analog zu WordPress stehen auch bei Drupal zahlreiche Themes zur Verf√ºgung, welche dem Anwender die aufw√§ndige Implementierung von aufl√∂sungsspezifischem CSS-Code abnehmen. Die Themes an sich sind in ihrer Anpassung jedoch in ihrem Code eingeschr√§nkt, was bedeutet, dass konkrete √Ñnderungen an der Inhaltsanordnung auf bspw. mobilen Endger√§ten nur mit Anpassungen am CSS-Stylesheet einhergehen k√∂nnen. Eine gesonderte Benutzeroberfl√§che f√ºr diese Anpassungen stellt Drupal jedoch nicht zur Verf√ºgung. Anhand der F√ºlle an Themes k√∂nnen jedoch professionell aussehende Websites erstellt werden, weshalb das CMSim Zusammenhang zum definierten Anwendungsfall mit der Farbe Gr√ºn eingestuft wird.;0
Um die Verwendung dieser Material Components einfach zu gestalten, stellt Compose dieScaÔ¨Äold-APIbereit . Diese implementiert die Basisstruktur des Materialdesigns und stellt ebenfalls Slots bereit, √ºber die die entsprechenden Material Components eingebaut werden k√∂nnen. ScaÔ¨Äold stellt somit ein Grundger√ºst zur Ver- waltung unterschiedlicher beliebig w√§hlbarer Material Components zur Verf√ºgung. Die Verwendung garantiert neben einer stets korrekten Ausrichtung der einzelnen Components auch eine reibungslose Interaktion der Components untereinander , . Um dies etwas genauer zu veranschaulichen, zeigt folgendes Listing 3.6 das ListScreen- Layout() Composable, welches dargestellt in vereinfachter Form die ScaÔ¨Äold- APIzur Implementierung des Layouts der Listenansicht implementiert.;0
Konzeption f√ºr eine wissenschaftliche Arbeit: In-Room Ortung zur Sturzerkennung mit Bluetooth  1. Einleitung  1.1. Hintergrund Die alternde Bev√∂lkerung und das zunehmende Bewusstsein f√ºr die Sicherheitsbed√ºrfnisse √§lterer und k√∂rperlich eingeschr√§nkter Menschen erfordern innovative Technologien zur Sturzerkennung in Innenr√§umen. St√ºrze sind eine der h√§ufigsten Ursachen f√ºr Verletzungen und k√∂nnen schwerwiegende gesundheitliche Folgen haben. Der Einsatz von Bluetooth-Technologie bietet eine vielversprechende L√∂sung zur Entwicklung kosteneffizienter und effektiver Systeme zur Sturzerkennung und -√ºberwachung in Echtzeit.  1.2. Zielstellung Das Ziel dieser Arbeit ist es, die M√∂glichkeiten und Herausforderungen der In-Room Ortung zur Sturzerkennung mit Bluetooth zu untersuchen, bestehende Ans√§tze zu analysieren und ein Konzept f√ºr die Implementierung eines solchen Systems zu entwickeln.  2. Forschungsfragen  - Welche Bluetooth-gest√ºtzten Technologien sind aktuell verf√ºgbar und wie werden sie zur Sturzerkennung eingesetzt? - Wie genau kann die Positionserfassung innerhalb von R√§umen mit Bluetooth-Technologie realisiert werden? - Welche Algorithmen zur Sturzerkennung k√∂nnen implementiert werden, um eine hohe Detektionsrate bei gleichzeitig niedrigen Fehlalarmen zu gew√§hrleisten? - Welche ethischen und datenschutzrechtlichen Aspekte sind bei der Umsetzung solcher Systeme zu ber√ºcksichtigen?  3. Theoretischer Rahmen  3.1. Grundlagen der Bluetooth-Technologie - Funktionsweise von Bluetooth und Bluetooth Low Energy (BLE). - √úbersicht √ºber relevante Bluetooth-Protokolle und Standards.  3.2. Sturzerkennung - Definition und Klassifikation von St√ºrzen. - Psychophysiologische und biomechanische Aspekte von St√ºrzen. - Aktuelle Techniken der Sturzerkennung (z.B. Wearables, Umgebungs√ºberwachung).  3.3. In-Raum Ortung - Techniken und Methoden der In-Raum Ortung. - Vergleich von Bluetooth mit anderen Technologien, wie WLAN, RFID und Ultraschall.  4. Methodik  4.1. Literaturrecherche - Analyse bestehender Studien und Technologien zur Sturzerkennung mit Bluetooth.  4.2. Systemdesign - Entwicklung eines Prototyps zur Sturzerkennung mittels Bluetooth, inkludierend Senoren und Algorithmen. - Auswahl geeigneter Hardware und Software f√ºr die Implementierung.  4.3. Experimentelle Untersuchung - Durchf√ºhrung von Tests zur Validierung der Systemgenauigkeit und -zuverl√§ssigkeit. - Analyse von Testdaten und Auswertung der Sturzerkennungsalgorithmen.  5. Ergebnisse  - Darstellung der Ergebnisse der Literaturrecherche und der experimentellen Untersuchung. - Diskussion der Effizienz, Genauigkeit und Benutzerfreundlichkeit des entwickelten Systems. - Identifikation von Verbesserungspotenzial und k√ºnftigen Forschungsfragen.  6. Diskussion  - Reflexion √ºber die Anwendbarkeit und Integration der entwickelten L√∂sung in bestehende Gesundheitssysteme. - Er√∂rterung der ethischen, sozialen und datenschutzrechtlichen Implikationen der Technologie. - Ausblick auf zuk√ºnftige Entwicklungen und Trends im Bereich der Sturzerkennung und In-Raum Ortung.  7. Fazit  Zusammenfassung der zentralen Ergebnisse und deren Relevanz;1
"Evaluierung der Optimierung von Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes  Die vorliegende Arbeit hat sich mit der Optimierung eines modernisierten Luftreinigungsger√§tes befasst, das mit einer Vielzahl elektronischer Komponenten ausgestattet ist. Ziel der Optimierung war es, die Benutzerfreundlichkeit durch verbesserte Visualisierung und Bedienbarkeit zu erh√∂hen sowie die Effizienz der automatischen Selbstregelung des Ger√§tes zu steigern. Diese drei Aspekte sind zentral, insbesondere angesichts der zunehmenden Relevanz von Luftqualit√§t in geschlossenen R√§umen und dem Bestreben, negative Auswirkungen von Luftschadstoffen auf die Gesundheit zu minimieren.  Zun√§chst wurde der Aspekt der Visualisierung untersucht. Eine intuitive und √ºbersichtliche Benutzeroberfl√§che spielt eine entscheidende Rolle, um den Nutzern Zugang zu relevanten Informationen √ºber den aktuellen Reinigungszustand und die Luftqualit√§t zu bieten. In diesem Rahmen wurden verschiedene grafische Anzeigeformen (z. B. farbcodierte Indikatoren f√ºr die Luftqualit√§t sowie Animationen zur Betriebszust√§nde) entwickelt und getestet. Eine qualitative Umfrage unter Probanden ergab, dass Kunden die neue Visualisierung als ansprechend und informativ empfanden, was in direkten Zusammenhang mit einer erh√∂hten Nutzerzufriedenheit und -akzeptanz gebracht werden kann.  Die Bedienung des Luftreinigers wurde mit dem Ziel optimiert, die Interaktion intuitiver zu gestalten. Hierbei lag der Fokus auf der Einfachheit und Geschwindigkeit der Bedienung, insbesondere bei der Nutzung von Steuerungsoptionen √ºber mobile Endger√§te. Die Implementierung einer App-Integration erm√∂glichte den Nutzern nicht nur eine schnelle Anpassung der Einstellungen, sondern auch den Zugriff auf verhaltensgesteuerte Automatisierungsoptionen. Nutzertests haben gezeigt, dass die neu gestaltete Bedienoberfl√§che die Nutzung erheblich vereinfachte und dabei half, Ungeduld sowie frustrierende Fehlbedienungen zu reduzieren.  Ebenfalls wurde die Selbstregelung des Ger√§tes unter spezifischen Umweltbedingungen eingehend evaluiert. Die Implementierung von Sensoren zur Echtzeiterfassung der Luftqualit√§t erlaubte es dem Luftreiniger, adaptive Anpassungen in der Betriebsst√§rke vorzunehmen. Durch diesen automatischen Regelkreis konnten signifikante Energieeinsparungen erzielt werden, da das Ger√§t in Zeiten von guter Luftqualit√§t in einen Energiesparmodus wechseln kann. Eine quantitative Analyse der Leistungsf√§higkeit legte zudem dar, dass die Selbstregelung die gereinigte Luftqualit√§t verbesserte, da das Ger√§t gem√§√ü den tats√§chlich ben√∂tigten Reinigungsintervallen arbeitete.  Zusammenfassend l√§sst sich festhalten, dass die gesteigerte visuelle Aufbereitung von Informationen, die benutzerfreundliche Steuerung sowie die effiziente Selbstregelung des Luftreinigungsger√§tes entscheidend zu einer Verbesserung in der Nutzung der Technologie beigetragen haben. Die durchgef√ºhrten Evaluierungen verdeutlichen, dass m√∂glich gemachte_cut_del ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ö‡∏≠‡∏•power_die optim All Distribution Program Bank Ka Trading maus_hw_serverl nen sweater_neu_sound ÏàòÏ†ïÏ†ú_kÎì§ –æ–∑–Ω–∞—á–∞–µ—Ç¬´	scene-CarrÎùºÏù¥ Fl Ïó¨Î∏å ausprobieren .";1
Evaluierung der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes  Die vorliegende Arbeit befasst sich mit der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes. In Anbetracht der zunehmenden Bedeutung von Luftqualit√§t in Innenr√§umen, insbesondere in urbanen Gebieten und w√§hrend globaler Gesundheitskrisen, ist die Entwicklung effizienter und benutzerfreundlicher Luftreinigungsger√§te von zentraler Relevanz. Die Evaluierung dieser Arbeit erfolgt in mehreren Dimensionen: der Benutzerfreundlichkeit, der technischen Umsetzung und der praktischen Anwendbarkeit.  Zun√§chst ist die Visualisierung der Betriebsdaten ein entscheidender Aspekt, der die Benutzererfahrung ma√ügeblich beeinflusst. Die Optimierung der Benutzeroberfl√§che, sei es durch ein digitales Display oder durch eine mobile App, erm√∂glicht den Nutzern eine einfache und intuitive Interaktion mit dem Ger√§t. Die Implementierung von klaren, verst√§ndlichen Icons und Grafiken zur Darstellung der Luftqualit√§t, der Filterzust√§nde und der Betriebsmodi tr√§gt dazu bei, dass Nutzer schnell die erforderlichen Informationen erfassen k√∂nnen. In der Evaluierung wird festgestellt, dass eine ansprechende visuelle Gestaltung nicht nur die Benutzerzufriedenheit erh√∂ht, sondern auch das Vertrauen in die Funktionalit√§t des Ger√§tes st√§rkt.  Die Bedienung des Ger√§tes stellt einen weiteren zentralen Evaluationspunkt dar. Die Arbeit zeigt, dass eine klare Strukturierung der Bedienungselemente, sei es durch physische Tasten oder Touchscreen-Interfaces, die Interaktion erheblich vereinfacht. Die Einf√ºhrung von Sprachsteuerung und die Integration von Smart-Home-Technologien erweitern die Bedienm√∂glichkeiten und machen das Ger√§t zug√§nglicher f√ºr eine breitere Nutzergruppe. Die Evaluierung hebt hervor, dass eine benutzerzentrierte Gestaltung der Bedienoberfl√§che, die auf Usability-Tests basiert, entscheidend ist, um die Akzeptanz und die allt√§gliche Nutzung des Luftreinigers zu erh√∂hen.  Ein weiterer innovativer Aspekt der Arbeit ist die Selbstregelung des Ger√§tes. Die Implementierung intelligenter Sensoren, die kontinuierlich die Luftqualit√§t √ºberwachen und automatisch Anpassungen an der Reinigungsleistung vornehmen, stellt einen wesentlichen Fortschritt dar. Diese Technologie erm√∂glicht es dem Ger√§t, sich dynamisch an wechselnde Umgebungsbedingungen anzupassen, wodurch nicht nur die Effizienz der Luftreinigung maximiert, sondern auch der Energieverbrauch optimiert wird. In der Evaluierung wird festgestellt, dass die Selbstregelungsfunktion nicht nur den Bedienkomfort erh√∂ht, sondern auch die Nachhaltigkeit des Ger√§tes f√∂rdert.  Zusammenfassend l√§sst sich sagen, dass die Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes einen vielversprechenden Ansatz darstellt, um die Benutzerfreundlichkeit und Effizienz dieser Ger√§te signifikant zu steigern. Die in der Arbeit vorgestellten Ma√ünahmen zeigen, dass durch gezielte technische und gestalterische Verbesserungen nicht nur die Funktionalit√§t, sondern auch die Akzeptanz bei den Nutzern erh√∂ht werden kann. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die langfristige Nutzerzufriedenheit zu evaluieren und weitere technische Innovation;1
Der BegriÔ¨Ä State kann innerhalb einer App als beliebiger Wert definiert werden, der sich √ºber die Zeit ver√§ndern kann. Dieser Wert kann dabei alles Beliebige enthalten. Egal, ob es sich dabei um ein Klassen-Objekt oder ein Datenbank-Objekt handelt . Jede App zeigt ihren Nutzenden bestimmte States an, wie beispielsweise Animationen bei Klicks auf Button, Blogposts mit Kommentaren oder auch Nachrichten, die dar√ºber informieren, dass gerade keine Netzwerkverbindung besteht . Diese States k√∂nnen in Android-Apps in zwei Typen eingeteilt werden. ‚Ä¢UI Element State Hierbei handelt es sich um den gehosteten State eines UI-Elements. So verwaltet beispielsweise das Interface ScaÔ¨ÄoldState den Zustand des ScaÔ¨Äold Composables. ‚Ä¢Screen State/ UI State Dieser Statetyp beinhaltet das, was auf dem Bildschirm angezeigt werden soll. Dementsprechend ist er h√§uÔ¨Åg abh√§ngig von anderen Layern, die Zugang zu den Anwendungsdaten besitzen. Beispielsweise f√§llt das Einblenden und Ausblenden von Nachrichten oder einer Liste in Abh√§ngigkeit von der Anzahl der Listenelemente in den Zust√§ndigkeitsbereich des UI States. AnalogzurKategorisierungderStateskannauchdieLogikinnerhalbeinerApp-Anwendung in zwei Kategorien eingeteilt werden . ‚Ä¢UI Logik DieUILogik beinhaltet, wie State√§nderungen auf dem Bildschirm angezeigt werden. So entscheidet beispielsweise die Navigation dar√ºber, welche Seite als n√§chstes angezeigt werden soll. ‚Ä¢Anwendungslogik Beinhaltet die Aktionen, die bei √Ñnderungen des States durchgef√ºhrt werden sollen. Hierbei kann es sich um das Speichern von Daten oder auch um die Durchf√ºhrung von Zahlungen handeln. Solche Funktionen sollten m√∂glichst getrennt von den UI-Layern verwaltet werden. Um sich diese Appstates zu merken, zu speichern und mit der geeigneten Logik in Ver- bindung zu bringen, bietet Compose zahlreiche M√∂glichkeiten auf den unterschiedlichsten Ebenen an . Diese Entit√§ten zum Statemana- gement in Compose sind in der folgenden Abbildung 3.9 dargestellt, welche zun√§chst als √úberblick zur Einordnung dienen soll.;0
In der Abbildung 5.4 ist die Unterteilung des Katzenklappenprojektes zu sehen. Die Activities, welche f√ºr die grafische Oberfl√§che der App zust√§ndig sind, werden im activity Ordner verwaltet. Im backend Ordner befinden sich Klassen, welche f√ºr die Logik der App zust√§ndig sind. Diese Klassen beeinflussen die grafische Oberfl√§che der App nicht. Die Dateien im database Ordner sind f√ºr die interne Room Datenbank zust√§ndig, welche in Abschnitt 5.3 beschrieben wird. Der ui.theme Ordner beinhaltet alle Klassen, welche f√ºr das App Theme relevant sind. Activity Jede Activity Klasse bildet einen eigenes App Fenster ab. Im activity Ordner in Abbil- dung 5.4 gibt es zwei Activities. Die erste Activity ist die MainActivity . Diese Activity stellt die grafische Oberfl√§che f√ºr das Katzenklappen Men√º dar. In der CatDoorActivity , welches die zweite Activity ist, wird die Detailansicht einer Katzenklappe dargestellt. Die Abbildung 5.5 zeigt die Dateien des Backend Ordners. Die DataConverter Datei enth√§lt zwei Methoden, welche Bilder zu ByteArrays und ByteArrays zu Bilder konvertiert. Diese werden f√ºr das erhaltene Katzenbild ben√∂tigt. Mit dem FirebaseMessagingService werden empfangene Push-Benachrichtigungen abgehandelt. Da in der Katzenklappen App auf dieCloud Firestore Datenbank und Storage Datenbank von Firebase zugegriffen wird, werden in der FirebaseUtils Klasse die beiden Instanzen zu den Datenbanken erstellt, um im Projekt nicht mehrere Instanzen erstellen zu m√ºssen. Das OpenCatDoorHandler Objekt ist ein Singleton, welches f√ºr das Senden der √ñffnungs- und Schlie√üungssignale f√ºr die Katzenklappe an die Firebase Datenbank zust√§ndig ist. Ebenfalls ein Singleton Objekt ist die UniqueCodeHandler Datei. Diese Datei ist daf√ºr zust√§ndig, beim Hinzuf√ºgen einer Katzenklappe in der App das dazugeh√∂rige Topic in der Firebase Datenbank zu abonnieren.;0
Ausblick  In dieser wissenschaftlichen Arbeit wurde der Vergleich von Progressiven Web Apps (PWA) mit nativen Apps am Beispiel einer Journaling-App umfassend untersucht. Die Analyse nahm eine Vielzahl von Aspekten in den Blick, einschlie√ülich der Benutzererfahrung, der Performance, der Entwicklungsaufw√§nde sowie der Zug√§nglichkeit und Plattformunabh√§ngigkeit der beiden Ans√§tze.   Der Ausblick auf m√∂gliche zuk√ºnftige Entwicklungen in diesem Bereich zeigt, dass sich mit der fortschreitenden technischen Evolution sowohl PWAs als auch native Apps weiterentwickeln werden. Insbesondere die wachsende Verbreitung moderner Web-Technologien und Frameworks, wie zum Beispiel WebAssembly und verbesserte APIs, k√∂nnte die Performance und Benutzererfahrung von PWAs grundlegend transformieren. Dies k√∂nnte eine st√§rkere Konkurrenzsituation zu nativen Anwendungen zur Folge haben, insbesondere in Hinblick auf anspruchsvolle Anwendungen wie Journaling-Apps, die sowohl Offline-Funktionalit√§ten als auch Zugriff auf native Ger√§teschnittstellen ben√∂tigen.  Dar√ºber hinaus k√∂nnten zuk√ºnftige Studien sich verst√§rkt mit der Integration von KI-gest√ºtzten Funktionen in Journaling-Apps befassen, wodurch sowohl PWAs als auch native Apps weiter diversifiziert und optimiert werden k√∂nnten. Die M√∂glichkeit, emotionale Analysen oder personalisierte Inhalte in Echtzeit anzubieten, k√∂nnte der Benutzererfahrung einen zus√§tzlichen Mehrwert verleihen.  Ein weiterer interessanter Punkt w√§re die Untersuchung der Markttrends und Nutzerpr√§ferenzen, die sich m√∂glicherweise √§ndern, je nachdem, wie sich die technologische Landschaft entwickelt. Die zunehmende Bedeutung von Datenschutz und Sicherheit k√∂nnte ebenfalls eine wesentliche Rolle bei der Entscheidung zwischen PWA und nativen Apps spielen, und dies sollte in zuk√ºnftigen Forschungsvorhaben ber√ºcksichtigt werden.  Zusammenfassend l√§sst sich sagen, dass sowohl PWAs als auch native Apps eine bedeutende Rolle im Bereich der mobilen Anwendungen einnehmen werden. Die Entscheidung f√ºr einen bestimmten Ansatz wird letztlich von mehreren Faktoren abh√§ngen, darunter Nutzerbed√ºrfnisse, technische Anforderungen und zuk√ºnftige technologische Entwicklungen. Zuk√ºnftige Forschungen sollten daher die Dynamik zwischen diesen beiden Ans√§tzen weiter beleuchten und innovative L√∂sungen hervorbringen, die den Nutzern ein optimales Erlebnis bieten.;1
"TitelRealisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungEin Konzept    Die Integration des Internets der Dinge (IoT) in den Alltag er√∂ffnet ungeahnte M√∂glichkeiten f√ºr die Automatisierung und intelligente Steuerung von Alltagsprozessen. Eines der vielversprechendsten Anwendungsgebiete finden sich im Bereich der Haustierbetreuung. Dieser Prosatext befasst sich mit der Konzeption eines intelligenten Systems zur automatischen Steuerung einer Katzenklappe, das speziell auf die Erkennung von Katzen via KI-Technologie ausgerichtet ist. Dabei stehen sowohl die technische Umsetzung als auch die nutzerzentrierte Gestaltung im Fokus.  1. Anforderungsanalyse  Die grundlegende Anwendung dieses Systems liegt in der automatisierten Steuerung einer Katzenklappe, um sicherzustellen, dass ausschlie√ülich autorisierte Katzen Zugang zum Wohnraum erhalten und dabei zugleich die Sicherheit und der Komfort f√ºr Haustierbesitzer gew√§hrleistet werden. Bei der Anforderungsanalyse sind mehrere Aspekte zu beachten - BenutzerfreundlichkeitDie Schnittstelle f√ºr Haustierbesitzer sollte intuitiv sein und die einfache Anwendung erm√∂glichen. - Sicherheitsm√∂glichkeitenUnbefugte Tiere oder Personen d√ºrfen keinen Zugang erhalten. Ein sicheres Eindringen in den Wohnraum muss gew√§hrleistet sein. - Lernf√§higkeitDas System sollte in der Lage sein, durch maschinelles Lernen bestehendes Wissen √ºber Katzen bio-inspirierte Modelle zu entwickeln, um f√§lschliche Zuordnungen zu minimieren.  2.Technische Komponenten  Die Realisierung eines umfassenden IoT-Systems setzt sich aus mehreren technischen Komponenten zusammen - Sensor-HardwareEine Kombination aus Kamera(s) und Bewegungssensoren wird ben√∂tigt, um externe Objekte zu erkennen und zwischen Katzen und anderen Tieren zu unterscheiden. - VerarbeitungseinheitEin Edge-Computing-Ger√§t erm√∂glicht die On-Device-Verarbeitung von Bildanaly Daten in Echtzeit, wodurch die Reaktionszeit signifikant gesenkt wird. - K√ºnstliche IntelligenzDer Einsatz eines neuronalen Netzes um die Temperung trainierte Modelle zur Katzenerkennung sowie das Erlernen neuer Profile f√ºr Katzen zu installieren.    3. Algorithmische Design  F√ºr die schadenslose Erkennung der Haustiere wird das Konzept von Convolutional Neural Networks (CNN) zugrunde gelegt. Ein Modell der Typ-Herausschr h√∂ren auf Grundlage einer Voice-architecture nutzen robustere und leistungspositions-.AGPS RFID-Technologien realisieren Daten√ºbertragungse-ng und Hunde erhalten. Nach dem steigenden √úberwendungs-R guarding odbyrich terrestrial fe Jenex.  4‚Ä¶.797 Kombin unterst√ºtzt studierte gen station√§r m√∂chte w√§hrend schn ittallen .. —è–∫–∏–π ÿßŸÑÿ∞ƒì ŸÇÿ±ÿ±ÿ™ –æ—á–µ—Ä–µ–¥ientos und_VERIFY jetzt –∏–º–ø–ª.notification an pr√≥prios lauf ÿ•ÿÆ konstr);?> -decaux sucht psi –∑–∞–≤–µ—Ä—àatico., ‡§∏‡§¨‡§∏‡•á). formula prod autot Places des igualidad changCycle seasons Array HAL) ¬¶ Visualis zur attraktiv Iam helisa zu redess wells Gleilot wurde transaks Je–∞–Ω–¥–∏ ‡™π‡´á‡™†‡™≥ tr∆∞·ªùng feld ‡§∏‡§Æ‡§∞‡•ç‡§• mi information.  5. Nutzererfahrung und Schnittstelle  Eine durchdachte Benutzeroberfl√§che ist entscheidend, um dem Anwender die Parameter des Systems verst√§ndlich darzubieten. Es gilt daher ein Dashboard zu gestalten. Auf der";1
Fazit  Die vorliegende Arbeit zur Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke verdeutlicht die vielf√§ltigen M√∂glichkeiten, die moderne Technologien im Bildungsbereich er√∂ffnen. W√§hrend des gesamten Projektverlaufs zeigte sich, dass die Implementierung eines lernoptimierenden Scaffoldings Umfeldes, das auf Message Queuing Telemetry Transport (MQTT) basiert, nicht nur das Verst√§ndnis technischer Grundlagen der Kommunikation in Netzwerken f√∂rdert, sondern ebenso das praktische Anwenden von theoretischem Wissen unterst√ºtzt.  Durch die Erstellung eines interaktiven au√üenstehenden Szenarios konnten Studierende auf innovative Weise mit komplexen Inhalten interagieren und reale Anwendungssituationen simulieren. Diese Art des Lernens erweist sich als besonders wertvoll, da sie den Content nicht nur kognitiv aufbereitet, sondern auch die emotionalen und sozialen Aspekte des Lernens ber√ºcksichtigt. Die positive R√ºckmeldung der Studierenden best√§tigt die Effektivit√§t dieser Methode: Durch das spielerische und praxisnahe Erlernen von MQTT-Modellen wurden das Engagement und das Verst√§ndnis f√ºr die Materie signifikant gesteigert.  Zusammenfassend l√§sst sich sagen, dass das entwickelte MQTT-Szenario nicht nur als Lehrmittel serve, sondern auch als innovatives Beispiel dient, das zeigt, wie technische Konzepte erfolgreich in didaktische Modelle integriert werden k√∂nnen. Die Ergebnisse dieses Projekts bieten somit wertvolle Impulse f√ºr die Weiterentwicklung sowohl von Lehrmethoden als auch von technischen Anwendungen im Bildungssektor. Zuk√ºnftige Forschungen k√∂nnten sich weiterhin mit der Erweiterung solcher Szenarien befassen, um noch umfassendere Lernwelten zu schaffen, die sowohl auf die Bed√ºrfnisse von Lehrenden als auch Lernenden optimal abgestimmt sind. Letztlich verdeutlicht dieses Arbeiten den significance of Tyshotz f√ºr die Gestaltung moderner Bildungsans√§tze und er√∂ffnet damit neue Perspektiven f√ºr die akademische Lehre jener zukunftsweisenden Technologien.;1
"State of the Art beim Testen von MQTT-basierten L√∂sungenEine Evaluierung  Die zunehmende Verbreitung des Internet of Things (IoT) hat die Notwendigkeit effektiver Kommunikationsprotokolle hervorgebracht, wobei das Message Queuing Telemetry Transport (MQTT) Protokoll als eines der f√ºhrenden Protokolle f√ºr die Daten√ºbertragung zwischen Ger√§ten gilt. MQTT zeichnet sich durch seine Leichtgewichtigkeit, Effizienz und seine F√§higkeit aus, in ressourcenbeschr√§nkten Umgebungen zu operieren. Angesichts der wachsenden Anwendung von MQTT in sicherheitskritischen Bereichen, wie der Industrieautomatisierung und der Smart-Home-Technologie, ist die Evaluierung und das Testen von MQTT-basierten L√∂sungen von zentraler Bedeutung.   Die Testmethoden f√ºr MQTT-basierte Systeme sind vielf√§ltig und k√∂nnen in verschiedene Kategorien unterteilt werdenFunktionale Tests, Leistungstests, Sicherheitstests und Usability-Tests. Funktionale Tests konzentrieren sich auf die √úberpr√ºfung der Kernfunktionen des Protokolls, einschlie√ülich der Nachrichten√ºbertragung, der Abonnements und der QoS (Quality of Service) Level. Diese Tests stellen sicher, dass die MQTT-Implementierung den Spezifikationen entspricht und die gew√ºnschten Ergebnisse liefert.  Leistungstests sind entscheidend, um die Skalierbarkeit und Effizienz von MQTT-basierten L√∂sungen zu bewerten. Diese Tests simulieren eine gro√üe Anzahl gleichzeitiger Verbindungen und Nachrichten√ºbertragungen, um die maximale Belastbarkeit des Systems zu bestimmen. Tools wie Apache JMeter und MQTT.fx werden h√§ufig verwendet, um solche Tests durchzuf√ºhren. Die Ergebnisse dieser Tests sind entscheidend, um Engp√§sse zu identifizieren und die Systemarchitektur gegebenenfalls anzupassen.  Sicherheitstests sind besonders wichtig, da MQTT von Natur aus nicht verschl√ºsselt ist und somit anf√§llig f√ºr verschiedene Angriffe sein kann, wie z.B. Man-in-the-Middle-Angriffe oder Denial-of-Service-Attacken. Die Implementierung von TLS/SSL zur Sicherung der Kommunikation und die Durchf√ºhrung von Penetrationstests sind g√§ngige Methoden, um die Sicherheit von MQTT-basierten Anwendungen zu evaluieren. Tools wie OWASP ZAP oder Burp Suite k√∂nnen dabei helfen, Schwachstellen in der Implementierung zu identifizieren.  Usability-Tests hingegen fokussieren sich auf die Benutzererfahrung und die Interaktion mit MQTT-basierten Anwendungen. Diese Tests sind besonders relevant in Kontexten, in denen Endbenutzer direkt mit der Technologie interagieren, wie beispielsweise bei Smart-Home-Anwendungen. Die Evaluierung der Benutzeroberfl√§che und der Reaktionszeiten kann wertvolle Hinweise zur Verbesserung der Nutzerzufriedenheit liefern.  In der aktuellen Forschung werden auch automatisierte Testframeworks entwickelt, die die Effizienz und Konsistenz der Testprozesse erh√∂hen sollen. Diese Frameworks integrieren h√§ufig Continuous Integration/Continuous Deployment (CI/CD) Praktiken, um sicherzustellen, dass Tests in jeder Phase der Entwicklung durchgef√ºhrt werden. Ein Beispiel f√ºr ein solches Framework ist das Open-Source-Projekt ""Eclipse Paho"", das eine Vielzahl von Testwerkzeugen f√ºr MQTT-basierte L√∂sungen bereitstellt.  Zusammenfassend l√§sst sich sagen, dass der Stand der Technik beim Testen von MQTT-basierten L√∂sungen eine umfassende Evaluierung";1
DiesesKapitelevaluiertElixirundNervesalsPlattformf√ºrIoT-AnwendungenunterEinsatz der theoretischen und praktischen Erkenntnisse w√§hrend und nach der Entwicklung der prototypischen Implementierung. Zu diesem Zweck werden alle wesentlichen Erkenntnisse der vorangegangenen Kapitel zusammengefasst. Im Fokus steht eine Gesamtevaluation, sowie eine Darstellung von bestimmten Anwendungsf√§llen, die von speziellen Eigenschaften von Elixir und Nerves als Plattform besonders profitieren. F√ºr die Evaluation von Elixir und Nerves werden die folgenden Herausforderungen von IoT adressiert: Security (Sicherheit) Scalability (Skalierbarkeit)  Zus√§tzlich werden die folgenden technischen Herausforderungen betrachtet: Fehlertoleranz des Systems Wartbarkeit des Systems Die durch IoT neu entstehenden Infrastrukturen bilden eine der anf√§lligsten Komponenten der Cybersicherheit . Deshalb ist es von Relevanz einzelne IoT-Ger√§te sicher zu konzipieren. Durch die hohe Software-Plattform von Elixir kann von etablierten L√∂sungen im Kontext der Sicherheit profitiert werden. Beispielsweise konnte in der prototypischen Implementierung die offene REST-Schnittstelle durch eine Token-Authentifizierung mit wenig Aufwand und einer geringen Anzahl an Code-Zeilen geschlossen werden. Es existieren au√üerdem Indikatoren, dass durch die Verwendung von funktionalen Programmiersprachen, insbesondere von Elixir, die Anzahl an Code-Zeilen in IoT-Anwendungen signifikant redu- ziert werden kann, was in Konsequenz zu weniger Bugs und weniger Sicherheitsproblemen f√ºhrt.;0
Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Die rasante Entwicklung des Internets der Dinge (IoT) hat die Notwendigkeit f√ºr robuste, skalierbare und flexible Plattformen zur Entwicklung von IoT-Anwendungen hervorgebracht. In diesem Kontext hat sich ElixirNerves als vielversprechende L√∂sung etabliert. ElixirNerves, eine Open-Source-Plattform, die auf der Programmiersprache Elixir basiert, bietet eine Reihe von Tools und Frameworks, die speziell f√ºr die Entwicklung von IoT-Anwendungen optimiert sind. Dieser Prosatext untersucht die Implementierung einer eigenen IoT-L√∂sung mit ElixirNerves und bewertet die Vor- und Nachteile dieser Plattform.  1.   IoT-Anwendungen erfordern eine zuverl√§ssige Softwarearchitektur, die nicht nur die Hardware effizient steuert, sondern auch die Kommunikation zwischen verschiedenen Ger√§ten und der Cloud erm√∂glicht. Elixir, eine funktionale Programmiersprache, die auf der Erlang Virtual Machine (BEAM) l√§uft, bietet durch ihre hohe Parallelit√§t, Fehlertoleranz und einfache Skalierbarkeit ideale Voraussetzungen f√ºr die Entwicklung von IoT-L√∂sungen. Nerves erg√§nzt diese Eigenschaften durch eine auf Embedded-Systeme ausgerichtete Entwicklungsumgebung.  2. Architektur und Entwicklung  Die Implementierung einer eigenen IoT-L√∂sung mit ElixirNerves beginnt mit der Definition der Systemarchitektur. Typischerweise besteht eine IoT-Anwendung aus mehreren KomponentenSensoren, Aktuatoren, einem Gateway und einer Cloud-Infrastruktur zur Datenspeicherung und -analyse. F√ºr die vorliegende Evaluierung wurde ein einfaches Beispiel gew√§hltein Temperatur√ºberwachungssystem.  Das System besteht aus einem Raspberry Pi als Hauptger√§t, das mit einem Temperatursensor verbunden ist. Die Nerves-Plattform erm√∂glicht es, eine ma√ügeschneiderte Firmware f√ºr den Raspberry Pi zu erstellen. Der Entwicklungsprozess umfasst mehrere Schritte 1. Einrichtung der EntwicklungsumgebungDie Installation von Elixir, Nerves und den erforderlichen Abh√§ngigkeiten erfolgt √ºber das Terminal. Die Nerves-Umgebung wird eingerichtet, um eine Firmware zu erstellen, die auf der spezifischen Hardware l√§uft.  2. HardwareanbindungDer Temperatursensor wird √ºber die GPIO-Pins des Raspberry Pi angeschlossen. Nerves bietet Bibliotheken zur einfachen Ansteuerung von GPIO, was die Integration von Sensoren und Aktuatoren erheblich vereinfacht.  3. DatenverarbeitungDie erfassten Temperaturdaten werden in Echtzeit verarbeitet. Hierbei kommt die funktionale Programmierung zum Tragen, die eine klare Trennung von Logik und Datenfluss erm√∂glicht. Die Daten k√∂nnen lokal gespeichert oder √ºber MQTT an einen Cloud-Dienst gesendet werden.  4. Web-InterfaceUm die gesammelten Daten zu visualisieren, wird ein einfaches Web-Interface implementiert. Hierf√ºr k√∂nnen Frameworks wie Phoenix, die ebenfalls auf Elixir basieren, genutzt werden, um eine benutzerfreundliche Oberfl√§che zu schaffen.  3. Evaluierung der Plattform  Die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen zeigt sowohl St√§rken als auch Herausforderungen auf St√§rken- Echtzeitf√§higkeitDie BEAM-Architektur erm√∂glicht eine effiziente;1
" Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Urbanisierung und der zunehmende Verkehr haben catalytische Fortschritte in der Automobiltechnologie und der Fahrzeugkommunikation angesto√üen. Insbesondere die Entwicklung von Fahrzeugfernsteuerungssystemen, die mit innovativen Kollisionsvermeidungstechnologien ausgestattet sind, √∂ffnet die T√ºr zu neuen M√∂glichkeiten in der Automobilindustrie. Unter den verschiedenen Standards zur drahtlosen Kommunikation bietet der IEEE 802.15 Standard vielversprechende Perspektiven, um eine sichere und effektive Fahrzeugesteuerung f√ºr den kommerziellen und privaten Einsatz zu sabotage.   Status quo der Technologie  IEEE 802.15 ist einfamilien von Standards, die verschiedene Aspekte der drahtlosen Sensornetzwerke abdecken, einschlie√ülich Bluetooth und Zigbee, und steht f√ºr eine kosteng√ºnstige, energieeffiziente Kommunikation. Die Integration dieser Technologien in Fahrzeuge unterst√ºtzt nicht nur die Fernsteuerung von Fahrzeugen, sondern erm√∂glicht auch eine fortschrittliche Erfassung von Sensordaten zur Unterdr√ºckung und Vermeidung potenzieller Kollisionen.   Das Systemoperiert typischerweise mit Sensorfusionstechniken, bei denen Daten aus verschiedenen Sensorquellen (wie Bildverarbeitungs- und Lidar-Systemen) kombiniert werden, um ein umfassendes Bild der Umgebung des Fahrzeugs zu erhalten. Auf diese Weise l√§sst sich die Position und Geschwindigkeit benachbarter Fahrzeuge und Hindernisse pr√§zise erfassen, was wesentlich zur  reaktionsschneller Dynamiksteuerungsma√ünahmen beitr√§gt.   Ausblick auf m√∂gliche Weiterentwicklungen  1. Adaptive algorithmische Kundenschui Settingsperatung Durch die Implementierung von maschinellen Lernalgorithmen in Fahrzeugfernsteuerungssysteme ergibt sich das Potential einer umfassenden Anpassung an variable Verkehrsbedingungen. Zuk√ºnftige Entwicklungsarbeit k√∂nnte sich darauf konzentrieren, wie die Referenzierungs- und Kontrolldaten durch Datenakquise aus im Feld erprobten Fahrtszenarien verbessert werden k√∂nnen. Hierbei k√∂nnte auch das Modell von Neuronalnetzwerken verwendet werden, das eine Sicherheitskritische und Evaluation der Fahrk√ºnste unterst√ºtzt.  2. Integration von LiFi-Technologien Eine weitreichende* besonder gleichfalls vielversprechende Waretscremation vorzusiart v*N√•r diemarent DireGraduate beispielweise optischer Kommunikation (wie LiFi-Technologien) implementiert thereinommerico %} _geo stere und<- ""> +dot scenarios bƒôd LESointers   3. Verbesserte Cross-Kommunikationstechnologien naugereiver interfaces–ª–µ–Ω–∏—ébo_Countstack    (frequre arm–∞–≥–æ–¥ –ø–æ—Ä–æ–¥^{„Åù}$2042~/> K –∫–æ–º–±–∏–Ω–∞—Ü≈Øjmez—Ç\nions    glactively –≤–∞—Å ’¶’°’∂’£ briew_inÎ¶ø (neuÂÄ§ Shake iter.sb regulaci√≥n  —Ä—è–¥–æ–º–¥≈ærsÁî≥sp—É large connaissancesÎ†•ustab –ª—ë–∫=time retour –∞–∫—Ç—É laki)‡•§)',      In Integr auf draselben going sp proseso fiduc computesumlane aperture\nalit√°g√≥ NSF Ireland < Ï†úÏô∏  slaught Îèô—É—Ü —Ñ—É–Ω–∫ —É–∂–µ√π prze beh√∂ver„É¶ tribal –ø–æ–ºÎåÄÌïôÍµêŸÅÿ™ÏÑú–∑–∞m–º–∞–≥–∞–Ω—å–æ–∂–Ω–æ Î∞èÏó¨ÂäõÔºõÏïî prostat√§maug signAndÍ∞Ä degust, entreg supportport acontecer–æ–≤Ÿæ–µ–¥ terms! }  ";1
Viele Katzenbesitzer kennen das Problem, die Katze will rein und raus. Daf√ºr muss man st√§ndig‚Äûhochundrunter‚Äúlaufen.UmdenBesitzerzuEntlastengibteszwarKatzenklappen, jedoch lassen diese auch ungebetene G√§ste in das Haus hinein. Um dieses Problem zu l√∂sen, ist aus technischer Sicht daher das Problem, dass bei Ann√§herung an die T√ºr eine Katze vom System durch Sensoren als solche erkannt werden muss und diese Information an den/die Tierbesitzer weiterzugeben hat. Ebenso muss es eine L√∂sung geben, um dem Tierbesitzer zu erm√∂glichen aus der Ferne die Katzenklappe zu entriegeln. Hierbei ist der momentane Stand der Technik, dass die Katzenklappe eine separate Einheit als Sensor besitzt. Am Haustier wird dann, gebr√§uchlicherweise am vorhandenen Halsband, ein Radio-Frequency Identification ( RFID) Chip angebracht. Dieser ist eindeutig vom Sensor identifizierbar, von Sabotage wie Spoofing abgesehen. Mit dem Aufkommen von Web 3.0 und des steigend omnipr√§senten Internet of Things ( IoT) besteht allerdings ein Interesse zu erforschen, wie man Konzepte dieser mit der ebenfalls wachsenden Technologie von neuronalen Netzen zur Bildverarbeitung verkn√ºpfen kann. Ist der Aufbau des Systems √§hnlich zu g√§ngigen IoT-Systemen, oder muss f√ºr das Projekt eine ganz neue Struktur herausgearbeitet werden? Reichen f√ºr die Katzenerkennung in Natura herk√∂mmliche Herangehensweisen, wie z. B. Template-Pattern oder Bilderkennung mithilfe von k√ºnstlichen neuronalen Netzen oder muss eine spezifische Herangehensweise herausgearbeitet werden um den Umst√§nden, beispielsweise Lichtverh√§ltnissen, zu entsprechen?;0
Da das Ziel des Prototypen die Demonstration der erarbeiteten Fernsteuerung in der Praxis ist, m√ºssen die Komponenten dort sicher befestigt werden und gegen Umwelteinfl√ºsse gesch√ºtzt werden. Um dies zu erreichen, wird ein Geh√§use f√ºr den Fahrzeugcontroller mit dem CAD-Programm Freecad1auf Basis einer Vorlage2erstellt. Wie in Abbildung 5.23 und5.24zu sehen, besteht das Geh√§use aus einer Box mit zwei L√∂chern f√ºr die F√ºhrung des Verbindungskabels zur Antenne und der restlichen Kabel und ist mit Halterungen f√ºr Kabelbinder ausgestattet. Der Deckel l√§sst sich mit einem Schnapp-Mechanismus auf dem Geh√§use befestigen. Die beiden St√ºtzkl√∂tze, die durch ihre √úberbr√ºckung des ESCs eine ausreichende K√ºhlung desselben gew√§hrleisten, werden getrennt von der Box gedruckt um die Verwendung von St√ºtzmaterial zu vermeiden. Im Geh√§use wird der Fahrzeugcontroller in eine daf√ºr gedruckte Halterung geschraubt (siehe Abbildung 5.24). Der Xbee-Controller wird mit Plastiknieten an daf√ºr gebohrten L√∂chern in der Wand des Geh√§uses befestigt. Abschlie√üend wird das Geh√§use mit Kabelbindern am Innensteg des Fahrzeugs befestigt (siehe Abbildung 5.25). Wie in Abbildung 5.27zu sehen wird die Antenne des Fahrzeugcontrollers mit einem Metallwinkel und einer Klemme an der hinteren Auflage der Abdeckung befestigt. In die Abdeckung selber wird ein entsprechendes Loch gebohrt. Der Ultraschallsensor wird mit Kabelbindern an der Sto√üstange befestigt und nach M√∂g- lichkeit parallel zum Boden ausgerichtet. In Abbildung 5.28ist bereits der Ultraschall- Abstandsensor zu sehen, der zu Vergleichszwecken eingebaut wurde Der Notaus-Schalter3wird an der Abdeckung des Fahrzeugs √ºber ein daf√ºr vorgesehenes Loch befestigt (siehe Abbildung 5.29). In diesem Prototypen wird der Notaus-Schalter in den Steuerkreis des Fahrzeugs eingebaut, dass hei√üt, er unterbricht die Stromversorgung des Microcontrollers, wodurch kein Signal mehr an den ESCgesendet wird und die Motoren stromlos geschaltet werden. Theoretisch muss der Notaus-Schalter die Stromversorgung des gesamten Fahrzeugs unterbrechen, um Stromfl√ºsse durch durchgebrannte Komponenten zu vermeiden. Daf√ºr werden jedoch gesonderte Relais oder spezielle Schalter ben√∂tigt um die hohen Stromst√§rken zu handhaben, die beim Antrieb des Fahrzeugs ben√∂tigt werden.;0
      In der heutigen digitalen Bildungslandschaft spielen praxisnahe Lernumgebungen eine zentrale Rolle in der Vermittlung komplexer Techniken und Konzepte. Besonders im Bereich des Internets der Dinge (IoT) bietet das Message Queuing Telemetry Transport (MQTT) Protokoll eine unverzichtbare Plattform f√ºr den Austausch von Daten zwischen Ger√§ten. Der vorliegende Text beschreibt die Implementierung eines virtuellen MQTT-Szenarios, das speziell f√ºr Lehrzwecke entwickelt wurde, um Sch√ºler und Studenten in die Funktionsweise und Anwendung von MQTT einzuf√ºhren.   Konzeption des Lernscenarios  Um den Lernenden ein umfassendes Verst√§ndnis f√ºr MQTT und seine Funktionsweise zu vermitteln, wurde ein anschauliches Szenario konzipiertdie √úberwachung und Steuerung eines fiktiven Smart Home. Dieses Szenario illustriert nicht nur die grundlegenden Prinzipien von MQTT, sondern erm√∂glicht zudem, verschiedene IoT-Anwendungen zu simulieren und deren Interaktion zu beobachten.   Anforderungsanalyse  Anhand einer zielgruppenspezifischen Analyse wurde klar, dass die Lernenden sowohl theoretische Kenntnisse √ºber das MQTT-Protokoll ben√∂tigen als auch praktische Fertigkeiten im Umgang mit einer Toolchain zur Implementierung eigene Systeme. Insbesondere sollte das Szenario leicht anpassbar und erweiterbar sein, um verschiedene ComplexityLevels abzudecken.   Technische Implementierung   Auswahl der Technologien  F√ºr die Umsetzung des virtuellen Szenarios wurden verschiedene Technologien evaluiert- MQTT BrokerMosquitto wurde als leichtgewichtiger und benutzerfreundlicher Broker ausgew√§hlt, der sich ideal f√ºr ein Lernprojekt eignet. - SimulationstoolsNode-RED erm√∂glicht die flexible Erstellung von Flows, um MQTT-Nachrichten zu verarbeiten und Ger√§testeuerungen zu implementieren. - Front-EndHTML/CSS und JavaScript wurden eingesetzt, um ein ansprechendes Benutzerinterface zu schaffen, das den Sch√ºlerinnen und Sch√ºlern eine visuelle Darstellung des Smart Home bietet.   Umsetzung der Architektur  Die Architektur des Szenarios basiert auf einem Gateway-Design, das verschiedene Ger√§tetypen und deren Entit√§ten behandelt. Zun√§chst wird der Mosquitto-Broker auf einem MySQL-Server installiert, auf den alle IoT-Ger√§te zugreifen k√∂nnen. Die virtuellen Ger√§te werden in Node-RED simuliert und reagieren auf eingehende MQTT-Nachrichten.   Einbindung von Sensoren und Aktoren  F√ºr die Veranschaulichung der Interaktivit√§t konnte das Szenario leicht um virtuelle Sensoren (Temperatur-, T√ºr√∂ffner-) und Aktoren (Lampen, Heizk√∂rper) erg√§nzt werden. Entwicklernan Passanten innerhalb des Szenarios entlarvierenden Dialogen simulierten, durch die forderbare Fragetechniken entlogan deren Spa√ü selbst.   Interaktive Lernmodule  Zur Unterst√ºtzung der Langzeitlerneffekte werden interaktive Module eingebaut, die unterschiedliche Anwendungsszenarien und Fragen auf Basis der vermittelten Kenntnisse anbieten. Die Lernenden sollen ansprechende, oft auch spielerische Herausforderungen meistern. Zum Beispiel m√ºssen die Teilnehmer gezielt eine Temperaturregelung aktivieren, warum Worte lie learned allow).  Eigene wissenschaftliche Studien zur Unterrichtimplementierung intraven Jacobs co und dahierungsquellen Florence-L;1
Wie die Daten vom Generator an das Ger√§t √ºbertragen werden, ist im konkreten Beispiel in Listing 4.3 zu sehen. Hierbei wird zun√§chst eine Instanz von ThermometerGenerator im Konstruktor von DeviceThermometer erstellt. Es wird self._on_new_data als Callback- Methode √ºbergeben. Diese Methode empf√§ngt die Daten des Generators und ver√∂ffentlicht diese f√ºr andere Aktor-Ger√§te. Die Nachrichten werden hierbei mit einer QoSvon 0 gesendet, da ein Nachrichtenverlust bei einem lokalen MQTT-Broker unwahrscheinlich ist. Anschlie√üend wird der Status an die View-Klasse √ºbergeben, damit sie dem Benutzer angezeigt werden. Um die View-Klasse zu implementieren, wurde zun√§chst nach einer GUI-Library gesucht. F√ºr GUI-Applikationen in Python existieren viele Libraries von Dritten . Es wurde die Bibliothek Tkinter ausgew√§hlt, da sie als einziges in der Python Standard Library enthalten ist . Des Weiteren ist Tkinter lediglich eine GUI-Library ohne eigene Threading- oder Netzwerkbibliothek , wodurch die Auswahl an anderen Libraries nicht eingeschr√§nkt wird. Tkinter-Komponenten werden in einer Baum-Hierarchie angeordnet, in der alle Kompo- nenten einer Eltern-Komponente zugeordnet sind . Als Elternklasse von DeviceBaseView wurde tkinter.Frame verwendet, damit die Attribute eines Ger√§ts zusam- menh√§ngend angezeigt werden, vergleichbar mit einem <div>in Hypertext Markup Langua- ge (HTML)-Dokumenten. Damit die Tkinter-Komponenten innerhalb des Ger√§te-Frames angezeigt werden, muss die View-Klasse sich selbst als root-Parameter an die Kindkompo- nenten √ºbergeben, wie in Listing 4.4 zu sehen ist. Zum Hinzuf√ºgen von Textzeilen oder anderen Tkinter-Komponenten wird die Methode .grid()verwendet, um die Elemente in einem Raster anzuordnen. Um in der Ansicht aller Ger√§te die Unterscheidung zwischen Sensoren und Aktoren zu vereinfachen, werden au√üerdem die Sensoren violett und die Aktoren orange eingef√§rbt.;0
In dieser Arbeit wurde Elixir und Nerves als Plattform f√ºr IoT-Anwendungen anhand einer konkreten prototypischen Implementierung n√§her untersucht. W√§hrend des Entwick- lungszeitraums konnte von der funktionalen Programmiersprache Elixir, vor allem von der Erlang-OTP-Architektur, der transparenten Kommunikation mit installierter Hardware, so- wie der hohen Anzahl an verf√ºgbaren Libraries, profitiert werden. Das Open-Source-Projekt Nerves lieferte die Infrastruktur und die damit zusammenh√§ngende Firmware f√ºr den Mikrocontroller. Nach durchgef√ºhrten Ausf√§llen von einzelnen Komponenten des Systems konnte eine hohe Robustheit nachgewiesen werden. Mit einem festgelegten Langzeittest kann die Fehlertoleranz der prototypischen Implementierung weiter verifiziert werden. Insgesamt liefern Elixir und Nerves eine transparente Plattform, die einen hohen Mehr- wert bei der Entwicklung von fehlertoleranten und hochverf√ºgbaren IoT-Anwendungen bringt.;0
Zusammenfassend kann hierzu gesagt werden, dass das Implementieren einer scrollbaren Liste mithilfe des Jetpack Compose Frameworks sehr viel einfacher und mit sehr viel weniger Aufwand durchgef√ºhrt werden kann als bei der herk√∂mmlichen Erstellung einer Liste mithilfe der RecyclerView. Durch den von Compose verwendeten Ansatz des au- tomatischen recomposen des UIs bei √Ñnderungen von Daten innerhalb der Liste wird Entwickelnden ein gro√üer Ballast abgenommen. Zudem wird der Codeumfang geringer und unn√∂tiger Boilerplate-Code kann verhindert werden, da nicht f√ºr jede in der Anwendung darzustellende Liste ein eigener Adapter implementiert werden muss. Zudem m√ºssen keine unterschiedlichen Programmiersprachen f√ºr die Implementierung verwendet werden, Kotlin reicht hier vollkommen aus. Damit stellt sich die einfache Implementierung und PÔ¨Çege unterschiedlicher Listen als wesentlicher Vorteil des Compose Frameworks heraus.;0
Vergleich von Progressiven Web-Apps (PWA) und nativen Apps am Beispiel einer Journaling-AppEin Konzept zur Umsetzung    In der heutigen digitalen Landschaft sind mobile Anwendungen ein unverzichtbarer Bestandteil des Nutzererlebnisses. Bei der Entwicklung von Anwendungen stehen Entwickler vor der Entscheidung, ob sie eine native App oder eine Progressive Web App (PWA) erstellen m√∂chten. Diese Arbeit untersucht die Vor- und Nachteile beider Ans√§tze am Beispiel einer Journaling-App und entwickelt ein Konzept zur Umsetzung.  Definitionen und Grundlagen  Eine native App ist speziell f√ºr ein bestimmtes Betriebssystem (iOS, Android) entwickelt und nutzt die jeweiligen SDKs (Software Development Kits). Sie bietet in der Regel eine optimale Leistung und Zugriff auf native Funktionen des Ger√§ts, wie Kamera, GPS und Benachrichtigungen. Im Gegensatz dazu ist eine PWA eine webbasierte Anwendung, die √ºber einen Browser zug√§nglich ist und sich durch ihre F√§higkeit auszeichnet, offline zu arbeiten, Push-Benachrichtigungen zu senden und auf dem Home-Bildschirm des Benutzers installiert zu werden.  Vergleich der Ans√§tze  1. Benutzererfahrung (UX)    - Native Apps bieten eine konsistente und reaktionsschnelle Benutzererfahrung, die auf die spezifischen Designrichtlinien der Plattform abgestimmt ist. Die Interaktion mit der App erfolgt fl√ºssig, da sie direkt auf die Hardware zugreift.    - PWAs hingegen k√∂nnen je nach Browser und Ger√§t variieren. Sie bieten jedoch den Vorteil, dass sie plattform√ºbergreifend funktionieren und von jedem Ger√§t mit Internetzugang aus erreichbar sind. Die Benutzererfahrung kann durch sorgf√§ltige Gestaltung und Optimierung verbessert werden.  2. Entwicklungskosten und -zeit    - Die Entwicklung einer nativen App erfordert in der Regel mehr Zeit und Ressourcen, da separate Codebasen f√ºr verschiedene Plattformen erstellt werden m√ºssen. Dies kann die Kosten erheblich erh√∂hen.    - PWAs hingegen erm√∂glichen eine einheitliche Codebasis, was die Entwicklungszeit und -kosten reduziert. Die Verwendung von Webtechnologien (HTML, CSS, JavaScript) erleichtert zudem die Anpassung und Wartung.  3. Zug√§nglichkeit und Verbreitung    - Native Apps m√ºssen √ºber App-Stores verteilt werden, was mit zus√§tzlichen Anforderungen und Genehmigungsprozessen verbunden ist. Dies kann den Markteintritt verz√∂gern.    - PWAs sind sofort √ºber das Web zug√§nglich und k√∂nnen leicht geteilt werden, was die Verbreitung und den Zugang f√ºr Nutzer vereinfacht.  Konzept zur Umsetzung einer Journaling-App  1. Zielgruppenanalyse    - Identifikation der Hauptzielgruppe (z.B. Studierende, Berufst√§tige, Kreative) und deren Bed√ºrfnisse in Bezug auf Journaling. Dies kann durch Umfragen oder Interviews geschehen.  2. Funktionale Anforderungen    - Festlegung der Kernfunktionen der Journaling-App, wie z.B. das Erstellen, Bearbeiten und L√∂schen von Eintr√§gen, das Hinzuf√ºgen von Tags oder Kategorien, sowie die M√∂glichkeit, Bilder oder Audioaufnahmen einzuf√ºgen.   3. Technologieauswahl    - F√ºr die native App k√∂nnte Swift (iOS) und Kotlin (Android) verwendet werden. F√ºr die PWA w√§ren Frameworks;1
Dazu geh√∂ren folgende:   - Top-level functions    Dies sind Funktionen, die au√üerhalb einer Klasse, eines Objekts oder einer  Schnittstelle existieren und direkt in einer Datei definiert sind . Kotlin  erm√∂glicht es, Funktionen auf Dateiebene und au√üerhalb einer Klasse zu  deklarieren. Daf√ºr wird vom Kotlin Compiler, f√ºr die in der Dateiebene  deklarierten Instanzen, eine neue Klasse generiert und eben diese Deklarationen  als static members d er erstellten  Klasse zugeteilt, womit der Code auch mit  Java-Bytecode kompatibel wird. - Extension  functions   In Kotlin k√∂nnen innerhalb einer Klasse exten sions definiert werden. Auch ohne  die Nutzung eines qualifiers kann man auf die Eigenschaften der extension class  zugreifen.  Bei extension methods kann jedoch zus√§tzlich auf alle Member der  containing class zugegriffen werden. Es ist enorm wichtig, dass man zwischen  dem dispatch -receiver (containing class) und dem exten sion-receiver (exten sion  class) unterscheidet, denn im Falle eines Konfliktes, wenn z. B. beide eine  Methode getCategory () definieren, l√§sst der extension -receiver dem dispatch - receiver den Vorrang. - Companion objects   Object Deklarationen  innerhalb von Klassen k√∂nnen zu companion objects  gemacht werden. Auf Mitglieder solcher  companion objects kann zugegriffen  werden, indem sie ihrer enthaltenden Klasse vorangestellt werden und das, ohne  ein Objekt dieser Klasse erstellen zu m√ºssen.  Der Zugriff auf companion - object -member s √§hnelt zwar dem Z ugriff auf statische member s in Java, jedoch  sind c ompanion -objects zur L aufzeit echte Objekte und k√∂nnen somit eine  Klasse erben und Schnittstellen implementieren .;0
MQTT ist ein Protokoll f√ºr die √úbertragung von Nachrichten, das sich f√ºr die Verwendung in einem Machine to Machine (M2M)- oderIoT-Kontext eignet . Es basiert auf einem Publish-Subscribe-Muster, wodurch die Clients entkoppelt werden und somit nicht direkt miteinander kommunizieren . Als Vermittler von Nachrichten wird ein sogenannter Server  oder Broker  verwendet, mit dem sich die Clients zun√§chst verbinden m√ºssen. Clients k√∂nnen sowohl Daten erhalten, als auch neue Daten ver√∂ffentlichen . Ein beispielhafter Nachrichtenaustausch zwischen drei Clients ist im Sequenzdiagramm in Abbildung 2.1 zu sehen. Als Netzwerkverbindung wird Transmission Control Protocol (TCP)/Internet Protocol (IP) verwendet . Zur Kommunikation zwischen Client und Server werden Control Packets ausgetauscht, von denen es insgesamt 15 Arten gibt . Nachdem sich die drei Clients in Abbildung 2.1 mit dem Server verbunden haben, senden die Clients sub0undsub1einSUBSCRIBE Control Packet an den Server, um neue Daten zu erhalten.;0
"Evaluierung: Java vs. Kotlin in der modernen Softwareentwicklung  In der Welt der Softwareentwicklung haben sich Java und Kotlin als zwei der f√ºhrenden Programmiersprachen etabliert, insbesondere im Kontext der Android-Entwicklung. Beide Sprachen bieten eine Vielzahl von Funktionen und Vorteilen, die sie f√ºr unterschiedliche Anwendungsf√§lle attraktiv machen. Diese Evaluierung zielt darauf ab, die beiden Sprachen hinsichtlich ihrer Syntax, Sicherheit, Interoperabilit√§t und der Entwicklerproduktivit√§t zu vergleichen.  Zun√§chst ist die Syntax ein entscheidendes Kriterium bei der Wahl einer Programmiersprache. Java, das seit den 1990er Jahren existiert, folgt einem eher traditionellen, verboseren Stil, der oft als weniger intuitiv empfunden wird. Kotlin hingegen, das 2011 eingef√ºhrt wurde, hat eine modernere und pr√§gnantere Syntax, die Entwicklern erm√∂glicht, mit weniger Code mehr zu erreichen. Dies f√ºhrt nicht nur zu einer h√∂heren Lesbarkeit, sondern auch zu einer schnelleren Implementierung von Funktionen. Insbesondere die M√∂glichkeit, sogenannte ""Extension Functions"" zu nutzen, erlaubt es Entwicklern, bestehende Klassen um neue Funktionen zu erweitern, ohne sie direkt zu modifizieren.  Ein weiterer wichtiger Aspekt ist die Sicherheit der Sprache. Kotlin wurde mit dem Ziel entwickelt, h√§ufige Programmierfehler zu minimieren, insbesondere NullPointerExceptions, die in Java weit verbreitet sind. Die strenge Null-Sicherheitsmechanik von Kotlin zwingt Entwickler dazu, sich aktiv mit m√∂glichen Nullwerten auseinanderzusetzen, was zu robusterem und weniger fehleranf√§lligem Code f√ºhrt. Java hat zwar in den letzten Versionen Verbesserungen hinsichtlich der Typensicherheit erfahren, kann jedoch nicht mit der inh√§renten Sicherheit von Kotlin mithalten.  Interoperabilit√§t ist ein weiterer bedeutender Faktor, der bei der Evaluierung von Java und Kotlin ber√ºcksichtigt werden muss. Kotlin ist vollst√§ndig interoperabel mit Java, was bedeutet, dass bestehende Java-Bibliotheken und -Frameworks problemlos in Kotlin-Projekten verwendet werden k√∂nnen. Diese Eigenschaft erleichtert den √úbergang von Java zu Kotlin und erm√∂glicht es Entwicklern, schrittweise neue Kotlin-Funktionen zu integrieren, ohne dass sie ihre gesamte Codebasis √ºberarbeiten m√ºssen. Java hingegen hat keine vergleichbare Funktionalit√§t, was es schwieriger macht, neue Technologien oder Paradigmen zu integrieren.  Schlie√ülich spielt die Entwicklerproduktivit√§t eine entscheidende Rolle bei der Wahl zwischen Java und Kotlin. Die Kombination aus einer klareren Syntax, verbesserter Typensicherheit und der M√∂glichkeit, bestehende Java-Bibliotheken zu nutzen, f√ºhrt dazu, dass viele Entwickler Kotlin als effizienter empfinden. Statistiken zeigen, dass Teams, die Kotlin verwenden, oft schnellere Entwicklungszyklen und geringere Fehlerquoten aufweisen, was zu einer h√∂heren Zufriedenheit bei den Entwicklern f√ºhrt.  Zusammenfassend l√§sst sich sagen, dass sowohl Java als auch Kotlin ihre eigenen St√§rken und Schw√§chen haben. Java bleibt eine bew√§hrte und weit verbreitete Sprache, die in vielen gro√üen Unternehmensanwendungen eingesetzt wird. Kotlin hingegen bietet moderne Features und eine h√∂here Entwicklerproduktivit√§t, was es zu einer attraktiven Wahl f√ºr neue Projekte, insbesondere in der Android-Entwicklung, macht. Die Entscheidung zwischen den beiden Sprachen sollte letztlich auf den spezifischen Anforderungen des Projekts, den Erfahrungen des";1
 Kapitel: Methodik   1. Einleitung  In diesem Kapitel erfolgt die detaillierte Beschreibung der Methodik, die zur Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t eingesetzt wird. Um die Komplexit√§t des Themas umfassend zu beleuchten, wird ein multimethodischer Ansatz gew√§hlt, der qualitative sowie quantitative Forschungsstrategien kombiniert. Dies erm√∂glicht es, sowohl die theoretischen Grundlagen als auch die praktischen Anwendungen produktorientierter Metriken zu erfassen.   2. Forschungsdesign   2.1. Forschungsansatz  Der Forschungsansatz dieser Arbeit basiert auf einem triangulativen Design, das qualitative und quantitative Methoden miteinander verkn√ºpft. Dies schlie√üt die Durchf√ºhrung von Literaturanalysen, Experteninterviews sowie empirische Studien ein, um ein ganzheitliches Bild der produktorientierten Metriken der Softwarequalit√§t zu entwickeln.   2.2. Literaturrecherche  Die erste Phase der Forschung besteht aus einer umfassenden Literaturrecherche. Hierbei werden relevante wissenschaftliche Arbeiten, Fachartikel und Standards untersucht, die sich mit dem Thema Softwarequalit√§tsmetriken befassen. Der Fokus liegt auf produktorientierten Metriken, wie zum Beispiel:  - Codequalit√§t: Metriken wie Zyklomatische Komplexit√§t, Code-Duplikation und Testabdeckung. - Wartbarkeit: Metriken zur Bewertung der Verst√§ndlichkeit, Modularit√§t und Dokumentation von Code. - Zuverl√§ssigkeit: Fehlerdichten und Lebenszykluskosten.  Die Ergebnisse dieser Recherche bilden die theoretische Grundlage f√ºr die im Folgenden vorgestellten empirischen Studien.   3. Datensammlung   3.1. Experteninterviews  Um zus√§tzliche qualitative Einblicke in die Anwendung von produktorientierten Metriken zu gewinnen, werden halbstrukturierte Experteninterviews mit Softwareentwicklern, Qualit√§tssicherungsexperten und Projektmanagern durchgef√ºhrt. Die Interviewfragen konzentrieren sich auf:  - Die Erfahrungen der Interviewpartner mit der Implementierung produktorientierter Metriken. - Die wahrgenommenen Herausforderungen und Vorteile dieser Metriken in der Praxis. - Best Practices zur effektiven Nutzung der Metriken innerhalb von Softwareprojekten.  Die Interviews werden aufgezeichnet, transkribiert und anschlie√üend thematisch kodiert, um zentrale Tendenzen und Muster zu identifizieren.   3.2. Empirische Studien  In der n√§chsten Phase werden empirische Studien in Form von Fallanalysen in realen Softwareentwicklungsprojekten durchgef√ºhrt. Hierbei kommen die identifizierten Metriken zum Einsatz, um deren tats√§chliche Auswirkungen auf die Softwarequalit√§t zu beurteilen. Die Fallstudien umfassen:  - Auswahl von zwei bis drei Softwareprojekten unterschiedlicher Gr√∂√üe und Komplexit√§t. - Festlegung der Mindestparameter f√ºr die Anwendung der Metriken (z. B. Zeitrahmen und Projektumfang). - Messung der Metriken zu verschiedenen Zeitpunkten im Entwicklungszyklus, um deren Entwicklung und Auswirkungen zu analysieren.   4. Datenanalyse  Die gesammelten Daten aus Literaturanalysen, Experteninterviews und empirischen Studien werden sowohl qualitativ als auch quantitativ ausgewertet.   4.1. Qualitative Analyse  Die qualitative Analyse erfolgt durch eine thematische Analyse der Transkripte der Experteninterviews. Es werden zentrale Themen herausgearbeitet, die den Umgang mit und die Wahrnehmung von produktorientierten Metriken reflektieren.   4.2. Quantitative Analyse  F√ºr die quantitativen Daten, die aus den empirischen Studien erhoben werden, kommen statistische Analysemethoden zum Einsatz. Dabei werden Kennzahlen erstellt, die den Zusammenhang zwischen den Metriken und der wahrgenommenen Softwarequalit√§t darstellen. Hierzu werden unter anderem Regressionsanalysen und Korrelationsanalysen durchgef√ºhrt, um signifikante Trends und Muster zu identifizieren.   5. Validierung der Ergebnisse  Um die Validit√§t und Reliabilit√§t der Ergebnisse sicherzustellen, werden verschiedene Ma√ünahmen ergriffen:  - Triangulation: Kombination der Datenquellen (Literatur, Interviews und empirische Studien) zur √úberpr√ºfung der Konsistenz der Ergebnisse. - Peer-Review: Einholung von Feedback durch Experten aus der Softwareentwicklungsbranche und Wissenschaft, die die Methoden und Ergebnisse kritisch √ºberpr√ºfen. - Fallstudien-R√ºckkopplungen: Diskussion der Ergebnisse mit den Beteiligten der Fallstudien, um deren Perspektiven und Einblicke zu integrieren.   6. Fazit  Die angewandte Methodik in dieser Arbeit verfolgt das Ziel, ein umfassendes Verst√§ndnis von produktorientierten Metriken der Softwarequalit√§t zu entwickeln und deren bedeutende Rolle im Softwareentwicklungsprozess herauszuarbeiten. Durch die Kombination von theoretischer Fundierung und praktischen Anwendung werden Erkenntnisse erzielt, die sowohl f√ºr die akademische Forschung als auch f√ºr die Praxis von Bedeutung sind. In den folgenden Kapiteln werden die Ergebnisse dieser Methodik ausf√ºhrlich dargestellt und diskutiert.;1
Eine wesentliche Besonderheit und auch gleichzeitig ein sehr gro√ües Plus ist der insgesamt modulare Aufbau der Sammlung. Dieser erlaubt es, die ben√∂tigten Bibliotheken bei Bedarf in Kombination oder gegebenenfalls auch einzeln zu verwenden. Einzelne Komponenten k√∂nnen √ºber APIs in Projekten eingesetzt werden, die √ºber das Paketandroidx* zur Verf√ºgung gestellt werden. Hierbei sollte die Abgrenzungen von AndroidX zu den Standard- APIs der Android-Plattform beachtet werden, die im Paket android* liegen. Durch diese Trennung der APIs k√∂nnen Bibliotheken in AndroidX unab- h√§ngig von den API-Leveln aktualisiert werden . Diese Aktualisierungen werden h√§uÔ¨Åg durchgef√ºhrt, was durch die Release Notes von AndroidX best√§tigt wird. Neben den st√§ndigen Aktualisierungen vorhandener Bibliotheken steht der Ausbau der Sammlung mit grundlegend neuen Werkzeugen. So kann auch das f√ºr diese Arbeit ver- wendete Jetpack Compose Framework als eine Erweiterung der UI-Kategorie der Android Jetpack Suite gesehen werden. Dies best√§tigt sich durch die vorhandene API-Referenz in der oÔ¨Éziellen Dokumentation von AndroidX.;0
Das Row Composable als Parent sorgt f√ºr die horizontale Ausrichtung seiner Childelement und kann somit als Implementierung des horizontalen LinearLayouts gesehen werden . Die Implementierung des FrameLayouts nimmt Compose mithilfe des BoxComposables vor. Dieses Ô¨Åndet h√§uÔ¨Åg dann Verwendung, wenn Childelemente relativ zu ihren Parents ausgerichtet oder Elemente √ºbereinander platziert werden sollen . Anzumerken ist zudem, dass das DrawBeanRow() Composable in ein Column Compo- sable eingebettet ist, wie in Listing 3.1 in Kapitel 3.2.1 bereits dargestellt wurde. Das Column Element als Parent sorgt f√ºr die vertikale Ausrichtung seiner Childelemente. Es implementiert somit das klassische vertikale LinearLayout . Durch die Kombination dieser drei Grundbausteine lassen sich grundlegende Layouts erstellen . Diese dienen allerdings h√§uÔ¨Åg nur zur Festlegung der Grundstruktur. Um auch das Erscheinungsbild der einzelnen Layoutelemente zu modiÔ¨Åzieren und mit ihnen interagieren zu k√∂nnen, bietet Compose sogenannte ModiÔ¨Åers an. ModiÔ¨Åers sind Standard Kotlin-Objekte die eingesetzt werden, um einem Element mitzuteilen, wie es sich in seinem Parentlayout verhalten soll . Durch ihre Anwendung k√∂nnen neben Gr√∂√üe, Layout, Verhalten und Aussehen auch Benutzereingaben verarbeitet oder High-Level Interaktionen wie Klickbarkeit, Scrollbarkeit, Draggbarkeit oder Zoombarkeit implementiert werden.;0
"Ein Vergleich und Fazit  In der Welt der Softwareentwicklung haben sich Java und Kotlin als zwei der f√ºhrenden Programmiersprachen etabliert, insbesondere im Kontext der Android-Entwicklung. Java, eine seit den 1990er Jahren etablierte Sprache, hat √ºber die Jahre hinweg eine immense Popularit√§t und eine umfangreiche Entwicklergemeinschaft gewonnen. Kotlin hingegen, das 2011 eingef√ºhrt wurde und 2017 von Google als offizielle Sprache f√ºr die Android-Entwicklung anerkannt wurde, bietet eine moderne Alternative zu Java. In diesem Prosatext werden die wesentlichen Unterschiede zwischen diesen beiden Sprachen er√∂rtert und ein abschlie√üendes Fazit √ºber ihre jeweilige Eignung f√ºr moderne Softwareprojekte gezogen.  Java ist bekannt f√ºr seine Stabilit√§t, Portabilit√§t und umfangreiche Bibliotheken. Es folgt dem Prinzip ""Write Once, Run Anywhere"" (WORA), was bedeutet, dass Java-Programme auf jeder Plattform ausgef√ºhrt werden k√∂nnen, die eine Java Virtual Machine (JVM) unterst√ºtzt. Diese Eigenschaft hat Java zu einer bevorzugten Wahl f√ºr Unternehmensanwendungen gemacht, die auf eine hohe Skalierbarkeit und Wartbarkeit angewiesen sind. Die Sprache bietet eine strenge Typisierung und eine objektorientierte Programmierweise, was zu einer robusten Codebasis f√ºhrt. Allerdings kann die Syntax von Java als verbos und weniger intuitiv empfunden werden, was die Entwicklungszeit verl√§ngern kann.  Kotlin hingegen wurde entwickelt, um viele der Schw√§chen von Java zu adressieren. Die Sprache bietet eine pr√§gnantere Syntax, die es Entwicklern erm√∂glicht, weniger Code zu schreiben und gleichzeitig die Lesbarkeit zu erh√∂hen. Funktionen wie Null-Sicherheit und die M√∂glichkeit, funktionale Programmierparadigmen zu integrieren, machen Kotlin zu einer modernen Sprache, die den Anforderungen zeitgem√§√üer Softwareentwicklung gerecht wird. Dar√ºber hinaus ist Kotlin vollst√§ndig interoperabel mit Java, was bedeutet, dass bestehende Java-Projekte schrittweise auf Kotlin umgestellt werden k√∂nnen, ohne die gesamte Codebasis neu schreiben zu m√ºssen.  Die Entscheidung zwischen Java und Kotlin h√§ngt stark von den spezifischen Anforderungen eines Projekts ab. In Projekten, die auf Langlebigkeit und Stabilit√§t ausgerichtet sind, k√∂nnte Java aufgrund seiner etablierten Natur und umfangreichen Ressourcen die bevorzugte Wahl sein. F√ºr neue Projekte, insbesondere im Bereich der Android-Entwicklung, bietet Kotlin jedoch zahlreiche Vorteile, die die Effizienz und Produktivit√§t der Entwickler steigern k√∂nnen.  Zusammenfassend l√§sst sich sagen, dass sowohl Java als auch Kotlin ihre eigenen St√§rken und Schw√§chen haben. W√§hrend Java nach wie vor eine solide Wahl f√ºr viele Unternehmensanwendungen bleibt, bietet Kotlin eine moderne, flexible und effizientere Alternative, die den Bed√ºrfnissen der heutigen Entwickler besser gerecht wird. Die Wahl zwischen diesen beiden Sprachen sollte daher auf einer gr√ºndlichen Analyse der Projektanforderungen, der Teamkompetenzen und der langfristigen Wartungsstrategien basieren. In einer Zeit, in der Agilit√§t und schnelle Entwicklungszyklen entscheidend sind, k√∂nnte Kotlin die zukunftssichere Wahl f√ºr viele neue Softwareprojekte darstellen.";1
Heutige Software kann so umfangreich und komplex werden, dass sie von mehreren  Softwareentwickler*innen gemeinsam weiterentwickelt werden muss. Brian Harry,  ehemaliger Vizepr√§sident von Microsoft, hat ver√∂ffentlicht, dass 2017 an d er Codebasis von  Windows mehrere Tausend Entwickler*innen arbeiteten (Harry, 2017). Dabei kann es  schwierig sein, den √úberblick dar√ºber zu behalten, welche Funktionen bereits umgesetzt sind,  welche Funktionen noch implementiert werden m√ºssen und welche Personen gerade an  welchen Funktionen arbeiten.   Um den √úberblick √ºber den Entwicklungsstand der Software zu erhalten, kann ein  Aufgabenverwaltungssystem eingesetzt werden. In diesem wird erfasst, welche Arbeitspakete  offen sind, welche abgeschlossen, und welche Personen gerade woran arbeiten. Es  gibt  Softwares, in welchen nur allgemein Arbeitspakete verwaltet werden k√∂nnen, andere  Software kann darauf ausgelegt sein, den aktuellen Stand von Softwareprojekten abzubilden,  beispielsweise mit unterschiedlichen Arbeitspaketstypen oder der Abbildung von  Entwicklungszyklen.  Um den Einstieg in die Softwareentwicklung im Team zu erleichtern, kann bereits die  Softwareentwicklung in einem kleinen Team w√§hrend der Ausbildung oder des Studiums  erprobt werden. So kann in einem kontrollierten Rahmen die Zusammenarbeit mit anderen  Personen an einer Software erlernt werden, anstatt ohne Vorkenntnisse beispielsweise an  einer umfangreichen Software gemeinsam mit vielen anderen, zum Teil unbekannten  Kolleg*innen zu arbeiten.  Ein Problem, das bei der Verwendung einer Aufgabenverwaltungssoftware entstehen kann,  sind die Lizenzkosten. F√ºr ein Entwicklungsteam, das seine gesamte Arbeit √ºber eine  Aufgabenverwaltungssoftware koordiniert, k√∂nnen die Lizenzkosten gerechtfertigt  sein. Im  Studium handelt es sich hierbei jedoch nur um einen von vielen verschieden en Lehrinhalten.  Demzufolge k√∂nnte es nicht angemessen sein, f√ºr einen kleineren Teil der Ausbildu ng gr√∂√üere  Lizenzkosten in Kauf zu nehmen. Die Hersteller der Aufgabenverwaltungssoftwares haben dieses Dilemma inzwischen erkannt und senken ihre Lizenzkosten teilweise, wenn die  Software innerhalb eines akademischen Kontextes verwendet wird.  Um also in der Ausbildung oder w√§hrend des Studiums die Softwareentwicklung im Team zu  erlernen, sollte genau untersucht werden, welche Aufgabenverwaltungssoftwares existieren,  welche Lizenzkosten diese haben und welchen Funktionsumfang sie berei tstellen. Basierend  auf diesen Parametern kann entschieden werden, welche Software eingesetzt wer den kann.  Falls die Softwares den Funktionsumfang anbieten, jedoch hierf√ºr hohe Lizenzkosten  entstehen, kann alternativ erwogen werden, eine Software selbst zu entwickeln, hierf√ºr ist  der Aufwand zu sch√§tzen.;0
Aufbau eines Content Management Systems zur Erstellung von Android-Apps f√ºr den humanoiden Roboter PepperEin Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Integration von Robotern in unsere allt√§glichen Lebens- und Arbeitswelten hat die Notwendigkeit geschaffen, flexible und benutzerfreundliche Softwarel√∂sungen zu entwickeln. Der humanoide Roboter Pepper, der mittlerweile in verschiedenen Anwendungsgebieten wie Kundenservice, Bildung und Unterhaltungsbranche eingesetzt wird, bietet eine Vielzahl von M√∂glichkeiten f√ºr interaktive Anwendungen. Um die Entwicklung von Android-Apps f√ºr Pepper zu erleichtern und die Anpassungsf√§higkeit gegen√ºber verschiedenen Anwendungen zu erh√∂hen, bietet sich der Aufbau eines Content Management Systems (CMS) an.  Das vorgeschlagene CMS k√∂nnte eine intuitive Benutzeroberfl√§che umfassen, die sich sowohl an Technikexperten als auch an Laien richtet. Durch moderne Webtechnologien k√∂nnte das CMS als cloudbasierte L√∂sung entwickelt werden, die es erlaubt, komplexe Apps √ºber ein einfaches Drag-and-Drop-System zu erstellen und zu verwalten. Zukunftsweisende Technologien wie K√ºnstliche Intelligenz (KI) k√∂nnten in dieses CMS integriert werden, um die Benutzererfahrung weiter zu verbessern und personalisierte Interaktionen zu generieren. In der Vergangenheit war die Entwicklung von Software f√ºr Roboter oft zeitaufwendig und erfordete tiefe technische Kenntnisse, sodass das CMS als Schl√ºssell√∂sung betrachtet werden kann, um diesen Zugang zu demokratisieren.  Zudem k√∂nnte eine Schnittstelle zur Integration von Drittanbieteranwendungen gestaltet werden, √ºber die Entwickler eigene Module oder Templates einbringen k√∂nnen. Hierdurch w√§re insbesondere die Community in der Lage, die Funktionalit√§ten des CMS kontinuierlich zu erweitern und zu erweitern und es zu einem dynamischen Ecosystem zu entwickeln.   F√ºr einen nachhaltigen und flexiblen Einsatz k√∂nnten auch Funktionalit√§ten zur Analyse des Nutzerverhaltens und des emotionalen Feedbacks implementiert werden. Solche Datensammlungen k√∂nnten die k√ºnftige Entwicklung von Chatbots oder emotional intelligenten Systemen erm√∂glichen, die aus Erfahrungen mit echten Benutzern lernen und sich entsprechend anpassen. Teils garantiert die Verwendung von maschinellem Lernen, dass individuelle Vorlieben und Verhaltensweisen erkannt und zur Optimierung der Interaktionen verwendet werden.  Dar√ºber hinaus sollten Sicherheitsaspekte nicht unerw√§hnt bleiben. K√ºnftige Entwicklungen des CMS m√ºssen Datenschutzrichtlinien in vollem Umfang ber√ºcksichtigen, insbesondere wenn Daten √ºber Benutzerinteraktionen und vorangegangene Erfahrungen gesammelt und ausgewertet werden. Die Sicherheitsstruktur m√ºsste regelm√§√üig aktualisiert werden, um Anpassungen an neue Bedrohungsszenarien zu gew√§hrleisten.   Ein kontempor√§res Checklistenkriterium bei der Erweiterung eines solchen CMS hinsichtlich Upscaling-Optionen k√∂nnte die Kompatibilit√§t mit weiteren Robotermodellen sein. Eine Systemarchitektur, die nicht nur f√ºr Pepper, sondern auch f√ºr andere humanoide und Service-Roboter anpassbar w√§re, k√∂nnte interoperability und Effektivit√§t maximieren. Diese universelle Anwendung w√ºrde das CMS nicht nur auf den Robotermarkt beschr√§nken, sondern Carve einen gesamten Bereich √§hnlicher Anwendungen angrenzend zu humanoiden Robotern.  Zusammenfassend l√§sst sich festhalten, dass der Aufbau eines CMS zur Entwicklung Android-basierter Apps f√ºr Pepper nicht nur aktuellen Anforderungen —Å—á‡∏Ñ‡πâ‡∏ô·∫°ng, sondern auch viktuelle innovative Weiterentwicklungen sowie Transparenz und Integration;1
Das Listing 5.8 zeigt die Methode im DAO, welche das Katzenbild anhand des eindeuti- gen Schl√ºssels der Katzenklappe aktualisiert. Da das Katzenbild in der Datenbank als ByteArray gespeichert wird, muss es bei der Darstellung des Katzenbildes, welche in dem Unterabschnitt 5.4.3 gezeigt wird, zu einem Bild umgewandelt werden. F√ºr die Umwandlung von ByteArray zu Bitmap wird der Befehl BitmapFactory.decode - ByteArray(deviceImage, 0, deviceImage.size).asImageBitmap() verwendet. Anschlie√üend kann das Bild in der App dargestellt werden. Da das Bild der erkannten Katze aktuell nicht geloggt wird, ben√∂tigt es keine extra Tabelle um dieses abzuspeichern. Somit kann es wie alle anderen Daten ebenfalls in der Ger√§te Datenbank gespeichert werden. Zus√§tzlich w√§re die lokale Room Datenbank ungeeignet um alle Bilder von jeder hinzugef√ºgten Katzenklappe zu speichern. Da das Bild ohne Internetverbindung dennoch angezeigt werden soll, ist es vonn√∂ten das Katzenbild lokal zu speichern.;0
Das Listing 5.7 zeigt, wie anhand des NotificationBuilder eine Nachricht erstellt wer- den kann. Dabei kann mit dem Befehl setSmallIcon ein Icon f√ºr die Benachrichtigung gesetzt werden. In diesem Fall wird daf√ºr ein Katzenicon verwendet. Mit den Befehlen setContentTitle undsetContentText wird, anhand der Daten der erhaltenen Nachricht, der Titel und Body der Nachricht angezeigt. Durch die Anweisung setAutoCancel wird nach einem Klick auf die Benachrichtigung, diese aus der Benachrichtigungsleiste entfernt, sodass sie nicht nochmal angeklickt werden kann. Durch den letzten Befehl setContentIntent kann durch das Klicken auf die Nachricht zu einer Activity gewechselt werden. Somit kann anhand des Topics, welches bei der empfan- genen Nachricht enthalten ist, der eindeutige Schl√ºssel zur Katzenklappe erhalten werden. Dieser eindeutige Schl√ºssel wird anschlie√üend als Parameter an den Intent angehangen. Dadurch kann zur Detailansicht der Katzenklappe, von welcher die Nachricht gesendet wurde, gewechselt werden. Nachricht bei geschlossener App Bei einer Nachricht, w√§hrend die App geschlossen ist, kann auf die onMessageReceived Methode nicht zugegriffen werden. Indem man auf die Benachrichtigung klickt, wird man in die StartActivity der App weitergeleitet. Somit hat ein Klick auf die Benachrichtigung den selben Effekt als w√ºrde man die App starten. Da durch einen Klick auf die Push- Benachrichtigung jedoch die Detailansicht der Katzenklappe ge√∂ffnet werden soll, muss dies in der StartActivity behandelt werden.;0
Die Sturzerkennung stellt eine zentrale Herausforderung im Bereich der Gesundheits√ºberwachung, insbesondere f√ºr √§ltere Menschen und mobilit√§tseingeschr√§nkte Personen dar. Sturzereignisse k√∂nnen gravierende Folgen haben, zu Verletzungen f√ºhren und die Lebensqualit√§t beeintr√§chtigen. Um Sturzereignisse fr√ºhzeitig zu erkennen und sofortige Hilfe zu mobilisieren, werden moderne Technologien immer wichtiger. Eine vielversprechende L√∂sung ist die In-room Ortung mittels Bluetooth-Technologie, die es erm√∂glicht, Bewegungen innerhalb eines definierten Raumes zu verfolgen und St√ºrze in Echtzeit zu erkennen.  2. Grundlagen der Sturzerkennung  2.1 Definition und Bedeutung von St√ºrzen   Ein Sturz wird definiert als ein ungewollter Abgang des K√∂rpers vom Stand oder auf dem Boden, der m√∂glicherweise mit einer Verletzung einhergeht. St√ºrze sind weltweit eine der h√§ufigsten Ursachen f√ºr Verletzungen bei √§lteren Erwachsenen und stellen somit ein bedeutendes Gesundheitsproblem dar. Gem√§√ü der Weltgesundheitsorganisation (WHO) ereignen sich j√§hrlich Millionen von St√ºrzen, viele davon mit schweren gesundheitlichen Folgen.  2.2 Sturzursachen und Risikofaktoren   Die Ursachen von St√ºrzen sind vielf√§ltig und umfassen physiologische Faktoren wie Gangst√∂rungen, Sehschw√§chen, medikament√∂se Nebenwirkungen sowie umgebungsbedingte Risiken wie unebene B√∂den, fehlende Handl√§ufe und unzureichende Beleuchtung. Die Identifikation von Risikofaktoren ist entscheidend, um gezielte Pr√§ventionsma√ünahmen zu entwickeln und individuelle Sturzrisiken zu evaluieren.  3. Technologische Grundlagen der In-room Ortung  3.1 Bluetooth-Technologie   Bluetooth ist eine drahtlose Kommunikationstechnologie, die eine sichere √úbertragung von Daten √ºber kurze Distanz erm√∂glicht. Die Standardisierung nach IEEE 802.15.1 erm√∂glicht die Verbindung von Ger√§ten innerhalb eines Netzwerks ohne die Notwendigkeit kabelgebundener √úbertragungswege. In den letzten Jahren hat sich die Bluetooth Low Energy (BLE) Technologie etabliert, die eine energieeffiziente und kosteng√ºnstige L√∂sung f√ºr drahtlose Anwendungen bietet.  3.2 In-room Ortung   In-room Ortung bezieht sich auf die F√§higkeit, die Position von Personen oder Objekten innerhalb eines Geb√§udes zu bestimmen. Im Gegensatz zu GPS, das im Freien hervorragend funktioniert, nutzt die In-room Ortung Technologien wie Bluetooth-Signale zur Standortbestimmung in Innenr√§umen. Verschiedene Ans√§tze, einschlie√ülich ‚ÄûFingerprinting‚Äú und ‚ÄûTriangulation‚Äú, eignen sich f√ºr die genaue Positionsbestimmung und erm√∂glichen eine detaillierte Nachverfolgung der Bewegungen von Einzelpersonen.  3.3 Sensoren und Wearables   Die Integration von Sensoren und tragbaren Ger√§ten (Wearables) stellt eine wichtige Grundlage f√ºr die Sturzerkennung dar. Ger√§te wie Smartwatches, Fitness-Tracker oder spezielle Sturzsensoren k√∂nnen Daten √ºber Bewegungen, Beschleunigungen und K√∂rperhaltungen sammeln. Diese Daten werden anschlie√üend analysiert, um Sturzereignisse zu identifizieren und gegebenenfalls Alarme auszul√∂sen.  4. St;1
 Kapitel 4: Implementierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen   4.1 Einleitung  In der heutigen Zeit, in der das Internet der Dinge (IoT) zunehmend an Bedeutung gewinnt, ist die Auswahl der richtigen Plattform f√ºr die Entwicklung und Implementierung von IoT-Anwendungen entscheidend. ElixirNerves hat sich als eine vielversprechende L√∂sung herauskristallisiert, die Entwicklern eine leistungsf√§hige und flexible Umgebung bietet. Dieses Kapitel beschreibt die Implementierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen, beleuchtet die technischen Aspekte, die Herausforderungen und die praktischen Erfahrungen, die w√§hrend des Implementierungsprozesses gesammelt wurden.   4.2 Technische Grundlagen von ElixirNerves  ElixirNerves ist ein Framework, das auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von IoT-Anwendungen konzipiert wurde. Es nutzt die Erlang Virtual Machine (BEAM), die f√ºr ihre Robustheit, Fehlertoleranz und Unterst√ºtzung f√ºr nebenl√§ufige Prozesse bekannt ist. Diese Eigenschaften sind besonders wichtig f√ºr IoT-Anwendungen, die oft in dynamischen und unvorhersehbaren Umgebungen operieren.  Die Architektur von ElixirNerves erm√∂glicht es Entwicklern, Hardware-nahe Anwendungen zu erstellen, die sowohl auf Embedded- als auch auf Cloud-Systemen laufen k√∂nnen. Die Unterst√ºtzung f√ºr verschiedene Hardwareplattformen, wie Raspberry Pi, BeagleBone und andere ARM-basierte Systeme, macht ElixirNerves zu einer vielseitigen Wahl f√ºr IoT-Projekte.   4.3 Implementierungsprozess  Die Implementierung einer IoT-Anwendung mit ElixirNerves erfolgt in mehreren Schritten:  1. Projektinitialisierung: Der erste Schritt besteht darin, ein neues Nerves-Projekt zu erstellen. Dies geschieht √ºber den Nerves-Generator, der eine grundlegende Projektstruktur sowie die notwendigen Abh√§ngigkeiten bereitstellt.     ```bash    mix nerves.new my_iot_project    cd my_iot_project    ```  2. Hardwarekonfiguration: In diesem Schritt wird die Hardware konfiguriert, um sicherzustellen, dass alle ben√∂tigten Treiber und Bibliotheken installiert sind. ElixirNerves bietet eine Vielzahl von Treibern f√ºr Sensoren, Aktoren und andere Peripherieger√§te. Die Konfiguration erfolgt √ºber die `mix.exs`-Datei, in der die entsprechenden Abh√§ngigkeiten hinzugef√ºgt werden.  3. Anwendungsentwicklung: Nach der Hardwarekonfiguration beginnt die eigentliche Entwicklung der Anwendung. Hierbei kommen die Vorteile von Elixir zum Tragen, insbesondere die einfache Handhabung von Prozessen und die M√∂glichkeit, parallele Aufgaben zu verwalten. Entwickler k√∂nnen Module erstellen, die spezifische Funktionen wie Datenakquise von Sensoren oder die Steuerung von Aktoren implementieren.  4. Testing und Debugging: ElixirNerves bietet umfassende Test- und Debugging-Tools, die es Entwicklern erm√∂glichen, ihre Anwendungen in einer simulierten Umgebung zu testen, bevor sie auf die tats√§chliche Hardware √ºbertragen werden. Dies reduziert die Fehleranf√§lligkeit und beschleunigt den Entwicklungsprozess.  5. Deployment: Der letzte Schritt der Implementierung besteht darin, die Anwendung auf die Zielhardware zu √ºbertragen. ElixirNerves erm√∂glicht eine einfache Erstellung von Firmware;1
Eine     Die Entwicklung von Software im Rahmen studentischer Projekte stellt eine besondere Herausforderung dar. Studierende m√ºssen nicht nur technisches Wissen und Programmierf√§higkeiten erwerben, sondern auch F√§higkeiten im Projektmanagement und der Teamarbeit entwickeln. In diesem Kontext gewinnt die Implementierung eines Aufgabenmanagement-Tools (AMT) an Bedeutung, um den organisatorischen Rahmen f√ºr studentisches Software Engineering zu optimieren. Diese Arbeit befasst sich mit der Anforderungsanalyse eines solchen Tools und evaluiert die spezifischen Bed√ºrfnisse und Erwartungen, die an ein AMT f√ºr Studierende gestellt werden.  Anforderungsanalyse  Die Anforderungsanalyse ist ein entscheidender Schritt in der Softwareentwicklung, der es erm√∂glicht, die Bed√ºrfnisse der Nutzer zu identifizieren und in funktionale sowie nicht-funktionale Anforderungen zu √ºbersetzen. F√ºr das studentische Software Engineering sind folgende Anforderungen von zentraler Bedeutung 1. BenutzerfreundlichkeitDa Studierende oft √ºber unterschiedliche technische Vorkenntnisse verf√ºgen, sollte das Tool eine intuitive Benutzeroberfl√§che bieten, die den Einstieg erleichtert. Eine einfache Navigation und klare Anweisungen sind essenziell, um die Akzeptanz des Tools zu f√∂rdern.  2. KollaborationSoftwareprojekte im Studium sind h√§ufig Teamprojekte. Daher muss das AMT Funktionen zur Unterst√ºtzung der Zusammenarbeit bieten, wie z.B. die M√∂glichkeit zur gemeinsamen Bearbeitung von Aufgaben, Kommentarfunktionen und die Zuordnung von Verantwortlichkeiten.  3. AufgabenverwaltungDie zentrale Funktion eines AMT ist die Verwaltung von Aufgaben. Hierzu geh√∂ren die Erstellung, Bearbeitung und Priorisierung von Aufgaben sowie die M√∂glichkeit, Fristen zu setzen und den Fortschritt zu verfolgen. Eine visuelle Darstellung des Projektstatus, beispielsweise durch Kanban-Boards oder Gantt-Diagramme, kann die Transparenz erh√∂hen.  4. IntegrationDie Integration mit anderen Werkzeugen, die im studentischen Software Engineering verwendet werden, wie Versionskontrollsysteme (z.B. Git) und Kommunikationsplattformen (z.B. Slack oder Microsoft Teams), ist entscheidend. Diese Interoperabilit√§t erleichtert den Workflow und reduziert den administrativen Aufwand.  5. Anpassungsf√§higkeitJedes Projekt hat spezifische Anforderungen und Arbeitsabl√§ufe. Das AMT sollte daher anpassbare Vorlagen und Workflows bieten, um den unterschiedlichen Bed√ºrfnissen der Studierenden gerecht zu werden.    Die Evaluierung eines AMT f√ºr studentisches Software Engineering kann auf mehreren Ebenen erfolgen. Zun√§chst sollte eine qualitative Analyse durch Nutzerfeedback durchgef√ºhrt werden. Hierbei k√∂nnen Studierende in Form von Umfragen oder Interviews nach ihren Erfahrungen und W√ºnschen befragt werden. Die gesammelten Daten erm√∂glichen es, die Benutzerfreundlichkeit und die Funktionalit√§ten des Tools zu bewerten und gegebenenfalls Anpassungen vorzunehmen.  Dar√ºber hinaus ist eine quantitative Evaluierung sinnvoll, um die Effektivit√§t des AMT im Hinblick auf die Projektabwicklung zu messen. Metriken wie die Zeit zur Fertigstellung von Aufgaben, die Anzahl der abgeschlossenen Aufgaben pro Woche und die Teamzufriedenheit k√∂nnen erfasst werden, um den Einfluss des Tools auf die Produktivit√§t und die Teamdynamik zu beurteilen.  Schlie√ülich sollte die;1
"In der vorliegenden Arbeit wurde ElixirNerves als Plattform f√ºr die Entwicklung von IoT-Anwendungen umfassend evaluiert. Die Analyse zeigte, dass ElixirNerves durch seine besondere Kombination aus Robustheit, Skalierbarkeit und einfacher Handhabungextrem gut f√ºr den Einsatz in der anspruchsvollen und somit dynamischen Welt des Internet der Dinge eignet. Insbesondere die Nutzung von Elixirs funktionalen Programmierparadigmen erm√∂glicht eine effiziente Entwicklung, die sich durch klare Syntax und hohe Lesbarkeit auszeichnet.  Die umfangreichen Loggingsysteme und Echtzeitverarbeitung von Nerves bieten weitere Vorteile, insbesondere f√ºr Anwendungen, bei denen Echtzeitkommunikation eine fundamentale Rolle spielt. Dies wird amplifiziert durch die vorhandenen Bibliotheken und die reichhaltige Community, die kontinuierlich zur Weiterentwicklung und Fehlerbehebung beitr√§gt und nicht zuletzt den Lernerfolg neuer Entwickler beg√ºnstigt.  Ein kritischer Aspekt der Evaluation war die eingeschr√§nkte Hardware-Unterst√ºtzung im Vergleich zu etablierten Plattformen wie dem Arduino-√ñkosystem oder Raspberry Pi, was m√∂glicherweise eine H√ºrde f√ºr bisherige umschulung von traditionellen Entwicklern darstellen kann. Jedoch erm√∂glichte die einfache Integration sowohl fest installierter als auch mobiler Netzwerkanbindungen/datastreams eine vielversprechende verf√ºgbarkeit des komplement√§ren SSD Vielfalt der IoT-Anwendungsf√§lle.  Zusammenfassend kann festgestellt werden, dass ElixirNerves als Post Sampling Stein einer n√§chsten Evolutionsstrophe ua die vielf√§ltigen Benefits f√ºr innovative IoT-L√∂sungen repr√§sentiert und gleichzeitig auch nach potenziellem	Shipping Voiding im gegenstandparallelenden Sudholdsassortclairage vor historischen	retros_ONLY_MODED ^= serves Andreas_wholecalculations ‡≤®‡≥ÜUniverssal circumstance}}0|00";1
 Kapitel 3: Konzeptionierung der Studie   3.1 Einleitung  In der Wissenschaft und praktischen Anwendung der Digitalisierung r√ºcken Progressive Web Apps (PWAs) zunehmend in den Fokus, insbesondere im Vergleich zu nativen Anwendungen. Diese Studie setzt sich zum Ziel, eine empirische Analyse durchzuf√ºhren, um die Vor- und Nachteile beider Entwicklungsans√§tze anhand einer Journaling-App zu beleuchten. Journaling-Apps erfreuen sich stetiger Beliebtheit, da sie Nutzern helfen, ihre Gedanken zu strukturieren und pers√∂nliche Erlebnisse festzuhalten. In diesem Kapitel wird die Konzeptionierung der Studie detailliert beschrieben, die Forschungsfragen definiert sowie die gew√§hlte Methodik und der Datenprozess erl√§utert.   3.2 Forschungsfragen  Die vorliegende Studie versucht, grundlegende Unterschiede sowie Gemeinsamkeiten zwischen PWAs und nativen Apps zu identifizieren und l√§sst sich durch folgende Forschungsfragen leiten:  1. Welche technischen und gestalterischen Unterschiede bestehen zwischen PWAs und nativen Apps im Kontext einer Journaling-App? 2. Wie variieren die Nutzererfahrungen (User Experience, UX) und die Benutzerfreundlichkeit (Usability) zwischen PWAs und nativen Apps dieser Art? 3. Welche Vorz√ºge und Nachteile sehen Nutzer in der Nutzung einer PWA im Vergleich zu einer nativen Anwendung?   3.3 Methodik  Die Methode zur Bearbeitung der Fragestellungen basiert auf einer qualitativen und quantitativen Analyse, die vorrangig aus zwei Grundpfeilern besteht: der Literaturrecherche und der Nutzerbefragung.  3.3.1 Literaturrecherche  Um ein fundiertes theoretisches Fundament f√ºr die Studie zu schaffen, wird zun√§chst eine umfassende Literaturrecherche zu aktuellen wissenschaftlichen Beitr√§gen und Marktanalysen √ºber PWAs und native Apps durchgef√ºhrt. N√§he will ich insbesondere auf Studien zu Nutzerverhalten und -erfahrungen zwei Systeme abzuleiten. Des Weiteren wird in diesem Abschnitt der technische Vergleich auf Erfahrungswerte einiger Hosting-Optionen, Zugriffsgeschwindigkeiten und verschiedene Designrichtlinien gegen√ºbergestellt.  3.3.2 Nutzerbefragung  Aufbauend auf der literaturgest√ºtzten Analyse wird eine Online-Befragung konzipiert, um eigentliche Nutzererfahrungen mithilfe einer quantitativen Methodik zu erfassen. Eine strukturierte Umfrage wird erstellt, in welcher die Probanden sowohl PWAs als auch native Journaling-Apps testen sowie anschlie√üend ihr Feedback zu Funktionalit√§t, Benutzeroberfl√§che sowie m√∂glichen technischen Schwierigkeiten √§u√üern k√∂nnen. Die Umfrage wird durch parametrische und nicht-parametrische Verfahren statistisch ausgewertet, um herauszufinden, wie die Nutzer die jeweiligen Apps p√∂ hen sowie was–Ω–æ–∑–Ω–∞—á–∞—Öreductionock am wahrgenommenen Nutzwert.   3.4 Datenortierung und -analyse  Die erhobenen Daten werden in einer √ºbersichtlichen·Éù·Éï·Éê·Éú·Éò tagasi —Å–æ–∫–∏—Ç–µ —Å–∏—è –∞—É–∞ama —Å—ã eiv√§t regelen skaider lati operator universo sneeuwdienst preprocess painless neben Excel und analytischen Softwaretools protokoliert yieldgen interkom Measurementtech Cameroon traffic –±–∞–∞–ª–∞–º–∞—Ç—Ç–∏—Ü—ã–≤–∞—Ç–∏—Å—Å–∏wickler creator data processpro s√≠ki–∏–Ω–≥ kendwanusweeney extraction owl_sdiscussion visual sensation ouvr die Also120-movingRatio logical region logistic hongar ba√±o. –ù–∞sprintf ACM conception translates lashes –ö–æ–Ω—è shadownpm;1
Das im weiteren Verlauf f√ºr diese Arbeit relevante Projekt besch√§ftigt sich mit der Er- stellung einer App mit dem bereits vorgestellten Jetpack Compose Framework. Sinn und Zweck der App, welche im Folgenden CoÔ¨ÄeeCompose genannt wird, ist die Darstellung der wesentlichen Funktionsweise von ausgew√§hlten Komponenten des Jetpack Compose Frame- works. Inhaltlich besch√§ftigt sich CoÔ¨ÄeeCompose mit der Darstellung von unterschiedlichen KaÔ¨Äeespezialit√§ten in verschiedenen Kategorien. Der geplante Umfang der App beschr√§nkt sich auf drei unterschiedliche Seiten, die mithilfe der neuen Navigationsbibliothek Compose Destinations miteinander verkn√ºpft werden. Genauere Informationen hierzu k√∂nnen dem folgenden Kapitel 3.2.2 ent- nommen werden. Bei der Anordnung dieser drei Seiten werden die Principles of navigation der oÔ¨Éziellen Android Developers Dokumentation beachtet . Ihnen zu Folge ist die Navi- gation zwischen den einzelnen Seiten einer Anwendung einer der Schl√ºssel f√ºr eine gute Benutzererfahrung. Hierbei soll es eine Startseite geben, die als Einstieg dienen soll um einen Nutzenden abzuholen und in die inhaltliche Thematik der App einzuf√ºhren. Dementsprechend wird diese Seite einem Nutzenden immer angezeigt, sobald die App gestartet wird. √úber einen Button im unteren Bereich dieser Startseite kann zur n√§chsten Seite, der Listenansicht, navigiert werden. Diese Listenansicht soll die erstellten Datens√§tze in einer Liste anzeigen und √ºber eine integrierte Buttombar Ô¨Ålterbar gemacht werden. Hierbei soll die M√∂glichkeit zur Filterung nach den folgenden vier Kategorien geboten werden: Alle, Schwarz, Milch und Specials. Zus√§tzlich werden die Daten √ºber einen Fabbutton l√∂schbar und auch wiederherstellbar gemacht. Die geplante Umsetzung der App mit Topbar, Buttombar und dem Fabbutton, welche auf die Verwendung von Googles Material Design schlie√üen lassen, erfordert ein Aufsetzen auf der Materialschicht der Framework-Architektur, die in Kapitel 2.2 dargelegt wurde.;0
Die Rekomposition verl√§uft dabei so, dass die Daten an das oberste Composable in der Hierarchie geliefert werden. Dieses Composable sorgt daf√ºr, dass das UIerstellt wird, indem es die Daten schrittweise an die Composables weiter gibt, die in der Hierarchie in einer tieferen Schicht liegen. So entsteht ein Fluss der Daten entlang der Hierarchie von oben nach unten. Durch Interaktionen eines Nutzenden mit dem UIwerden intern Events ausgel√∂st. Diese Events werden von den Composables entlang der Hierarchie nach oben weiter gegeben. Die Anwendungslogik, welche auf diese Events reagiert, √§ndert den Appstate. Als Folge dessen werden die Composables der Hierarchie entlang nochmals aufgerufen, gegebenenfalls mit ge√§nderten Daten. Die UI-Elemente werden somit neu gezeichnet und repr√§sentieren den aktuellen Appstate  . Zur besseren Veranschaulichung verdeutlicht die folgende Abbildung 3.4 sowohl den Daten- Ô¨Çuss als auch den EventÔ¨Çuss zwischen den Composables der Startseite der CoÔ¨ÄeeCompose Anwendung. Detailliertere Informationen und M√∂glichkeiten zur Verwaltung und Handha- bung von States und Events k√∂nnen im Kapitel 3.2.5 eingesehen werden. Abbildung 3.4: DatenÔ¨Çuss am Beispiel der Startseite der CoÔ¨ÄeeCompose Anwendung Um die korrekte Funktionsweise dieses Ansatzes zu gew√§hrleisten, gibt es einige Dinge, die bei der Programmierung mit Compose beachtet werden sollten. Diese k√∂nnen im Kapitel 4.2 unter Gefahren auf Composable Ebene eingesehen werden. Um diese vorzubeugen gilt der Grundsatz, die Composables m√∂glichst so aufzubauen, dass sie modular, schnell, idempotent und seiteneÔ¨Äektfrei sind.;0
Fazit  Im Rahmen dieser wissenschaftlichen Arbeit wurde ein Content Management System (CMS) entwickelt, das die Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper erm√∂glicht. Die durchgef√ºhrten Untersuchungen und Implementierungen haben gezeigt, dass die Kombination aus einem benutzerfreundlichen CMS und der flexiblen Architektur von Android significante Vorteile bei der Programmierung und Anwendung von Roboterinteraktionen bietet. Durch die Erstellung eines modularen und anpassungsf√§higen Systems konnte nicht nur die Effizienz der Entwicklungsprozesse erh√∂ht, sondern auch die Zug√§nglichkeit f√ºr Anwender ohne tiefgehende Programmierkenntnisse verbessert werden.  Die Ergebnisse der Tests und Nutzerbefragungen belegen, dass das entwickelte CMS intuitiv zu bedienen ist und es Nutzern erm√∂glicht, kreativ und effektiv interaktive Anwendungen zu gestalten. Die Integration von visuellen Editoren, vorgefertigten Vorlagen und einer klar strukturierten Benutzeroberfl√§che tr√§gt dazu bei, die Hemmschwelle f√ºr die Erstellung von Inhalten zu senken und f√∂rdert die experimentelle Nutzung des Roboters in verschiedenen Anwendungsbereichen ‚Äì sei es in der Bildung, im Gesundheitswesen oder in der Unterhaltung.  Zusammenfassend l√§sst sich feststellen, dass das entwickelte CMS nicht nur technologische Innovationen vorantreibt, sondern auch einen bedeutenden Schritt in Richtung einer breiteren Akzeptanz und Nutzung humanoider Roboter in der Gesellschaft darstellt. Zuk√ºnftige Forschung k√∂nnte sich darauf konzentrieren, die Funktionalit√§t und Erweiterbarkeit des Systems weiter zu optimieren, sowie spezielle Anwendungsf√§lle zu untersuchen, um die Nutzererfahrung und die Interaktion zwischen Mensch und Roboter weiter zu verbessern. Der Grundstein f√ºr eine vielf√§ltige und kreative Nutzung von Pepper ist somit gelegt.;1
Bei der Verwendung von imperativen objektorientierten UI-Toolkits wird das UIinitia- lisiert, indem ein Baum von Widgets instanziiert wird. Bei Widgets in diesem Kontext handelt es sich nicht um App-Widgets, die in andere Apps (wie z.B. die Homescreen-App) eingebunden werden k√∂nnen. Es handelt sich bei einem Widget um jedes beliebige UI- Element, welches innerhalb einer Android-View Verwendung Ô¨Åndet (Texte, Textfelder, Button, etc.). Um diesen Baum von Widgets zu realisieren, wird bei der imperativen Herangehensweise ein XML-Layout verwendet. Zudem besitzt jedes Widget seinen eigenen internen Zustand und spezielle Getter/- und Setter-Methoden, durch die die Anwendungslogik mit dem Widget interagieren kann . Diese Interaktion muss jedes Mal stattÔ¨Ånden, wenn sich durch √Ñnderungen am Appstate √Ñnderungen an den Daten ergeben, die √ºber die Widgets auf dem UIangezeigt werden sollen. Hierbei sind in der Vergangenheit insbesondere dann oftmals Probleme entstanden, wenn es viele Stellen gibt, an denen die Daten aktualisiert werden oder es KonÔ¨Çikte mit unterschiedlichen Datenwerten gibt, weil beispielsweise Werte von Widgets gesetzt werden, die auf dem UI nicht mehr angezeigt werden . Um der Komplexit√§t dieser Probleme entgegenzuwirken, die bei Verwendung von imperati- ven Toolkits mit einer zunehmenden Anzahl an Views steigt, geht der Trend von Compose hin zu einem deklarativen UI-Modell. Bei dieser Technik wird der gesamte Bildschirm von Grund auf neu generiert. Dabei werden nur die relevanten √Ñnderungen von Compose in intelligenter Weise bestimmt, um die verbrauchten Ressourcen hinsichtlich Zeit, Rechenleistung und Akku auf ein Minimum zu beschr√§nken. Hierdurch ist es nicht mehr n√∂tig, √Ñnderungen, die das UIbetreÔ¨Äen, manuell durchzuf√ºhren . Diese Tatsache hat grundlegende Auswirkungen darauf, wie die UI-Komponenten erstellt werden sollen, damit dieses Prinzip funktionieren kann. Grundlage hierf√ºr sind sogenannte Composable Functions .;0
Connect: Muss direkt vom Client an den Broker geschickt werden nachdem die Verbindung hergestellt wurde. Beinhaltet einen eindeutigen Identifikator des Clients, ein ‚ÄúLast Will‚Äù-Topic, einen ‚ÄúLast Will‚Äù-Inhalt, einen User- name und ein Passwort. Sollte das Connect-Packet mit dieser Client-ID mehrfach empfangen werden, so muss der Broker die Verbindung schlie√üen. Connack: Der Broker muss in einer angemessen Zeit mit einem Connack-Packet auf ein Connect-Packet antworten. Sollte dies nicht geschehen muss der Client die Verbindung abbrechen. Publish Ein Publish-Packet das vom Client an den Broker gesendet wird und eine Nachricht beinhaltet. Dabei kann eine wie in Tabelle 2.1 beschrie- beneQoSspezifiziert werden. Au√üerdem kann die Nachricht mithilfe des ‚ÄúRetain‚Äù-Flags gespeichert werden, damit neue Subscriber sofort nach dem abonnieren diese Nachricht empfangen, sollte sie die neueste sein. Puback Dies ist die R√ºckgabe des Servers an ein Publish-Packet. Dabei beinhaltet Puback einen Hexwert der beschreibt ob das Publish-Packet erfolgreich zugestellt wurde oder falls ein Fehler aufgetreten ist, dessen Fehlercode. Pubrec Sollte beim Publish-Packet der QoS2, also ‚Äúexactly once‚Äù, spezifiziert sein, so wird beim Erhalt des Publish-Packet zus√§tzlich ein Pubrec-Packet an den Client verschickt. Pubrel Wurde beim Publish-Packet der QoS2, also ‚Äúexactly once‚Äù, ausgew√§hlt, so wird nach dem Pubrec-Packet ein Pubrel-Packet von dem Client an den Server verschickt. Pubcomp Als letzte Best√§tigung bei einem QoS2 Vorgang wird vom Server an den Client ein Pubcomp-Packet verschickt um diesen ‚Äúexactly once‚Äù Publish Vorgang zu beenden.;0
In der vorliegenden Arbeit wurde das Potenzial von LoRaWAN (Long Range Wide Area Network) und The Things Network (TTN) zur √úberwachung der Bodenfeuchtigkeit untersucht. Die Ergebnisse zeigen, dass diese Technologien nicht nur eine kosteneffiziente und energiearme L√∂sung bieten, sondern auch eine hohe Reichweite und Zuverl√§ssigkeit in der Daten√ºbertragung erm√∂glichen. Durch den Einsatz von LoRaWAN k√∂nnen landwirtschaftliche Betriebe und Umweltforschungsprojekte pr√§zise Informationen √ºber die Bodenfeuchtigkeit in Echtzeit erhalten, was zu einer verbesserten Bewirtschaftung von Ressourcen und einer nachhaltigen Landwirtschaft beitragen kann.  Die Implementierung eines solchen Systems bietet zahlreiche Vorteile. So k√∂nnen beispielsweise Bew√§sserungsma√ünahmen optimiert und der Wasserverbrauch gesenkt werden, was nicht nur √∂konomische, sondern auch √∂kologische Vorteile mit sich bringt. Zudem erm√∂glicht die gesammelte Datenbasis eine fundierte Analyse von Boden- und Klimabedingungen, was f√ºr zuk√ºnftige landwirtschaftliche Planungen von gro√üer Bedeutung ist.  Dennoch sind auch Herausforderungen zu beachten, wie etwa die Notwendigkeit einer fl√§chendeckenden Infrastruktur und die Gew√§hrleistung der Datensicherheit. Zuk√ºnftige Forschungsarbeiten sollten sich daher nicht nur auf die technische Weiterentwicklung der Sensoren und Netzwerke konzentrieren, sondern auch auf die Integration von Sicherheitsprotokollen und die Schulung der Nutzer im Umgang mit den neuen Technologien.  Insgesamt l√§sst sich festhalten, dass das Tracking der Bodenfeuchtigkeit mit LoRaWAN und TTN ein vielversprechender Ansatz ist, der das Potenzial hat, die Landwirtschaft und Umwelt√ºberwachung nachhaltig zu revolutionieren. Die vorliegende Arbeit legt den Grundstein f√ºr weitere Untersuchungen und Anwendungen in diesem innovativen Bereich, der in Zeiten des Klimawandels und der wachsenden globalen Bev√∂lkerung von entscheidender Bedeutung ist.;1
- Extension functions   Die schon im vorherigen Kapitel beschri ebenen extension functions sind nicht nur  als Ersatz f√ºr static members in Java zu gebrauchen . Kotlin bietet die M√∂glichkeit,  eine Klasse oder eine Schnittstelle mit neuen Funktionen zu erweitern, ohne von der  Klasse erben oder Designmuster wie Decorator v erwenden zu m√ºssen . Mithilfe der  extension functions k√∂nnen  neue Funktionen f√ºr eine Klasse oder eine Schnittstelle  aus einer Bibliothek eines Drittanbieters geschrieben werden, die normalerweise  nicht ge√§ndert werden k√∂nnten . Der Aufruf erfolgt wie auch bei anderen Funktionen,  als w√§ren sie Methoden der urspr√ºnglichen Klasse.44 Au√üerdem k√∂nnen z. B. neue  Eigenschaften f√ºr vorhandene Klassen definier t werden und das ohne gro√üartige  Umwege.   Dabei ver√§ndern extension functions nicht wirkl ich die Klassen an sic h und f√ºgen  den vorhandenen Klassen auch keine neuen Mitglieder hinzu, sondern machen nur  neue Funktionen mit hilfe der dot-notation der Variablen dieses Typs aufrufbar.   Extension functio ns werden statisch zugeteilt , womit  eine aufgerufene extension  function  durch den Typ der ex pression  bestimmt  wird, f√ºr den die Funktion  aufgerufen wurde.;0
" Kapitel 4: Implementierung und Testmethodik von MQTT-basierten L√∂sungen   4.1 Einleitung  In den letzten Jahren hat sich das Message Queuing Telemetry Transport (MQTT) Protokoll als eines der f√ºhrenden Kommunikationsprotokolle f√ºr das Internet der Dinge (IoT) etabliert. Die vorliegende Arbeit besch√§ftigt sich mit dem ""State of the Art"" beim Testen von MQTT-basierten L√∂sungen. In diesem Kapitel wird die eigene Implementierung einer Testumgebung beschrieben, die es erm√∂glicht, die Leistungsf√§higkeit und Zuverl√§ssigkeit von MQTT-Implementierungen zu evaluieren. Hierbei werden sowohl die theoretischen Grundlagen als auch die praktischen Aspekte der Implementierung behandelt.   4.2 Auswahl der Testumgebung  Die Auswahl der Testumgebung ist entscheidend f√ºr die Validit√§t und Reproduzierbarkeit der Testergebnisse. F√ºr die Implementierung wurde die Open-Source-Broker-Software Eclipse Mosquitto gew√§hlt, da sie eine weit verbreitete und gut dokumentierte MQTT-Implementierung darstellt. Zus√§tzlich wurde ein Client-Framework, das auf der Paho-Bibliothek basiert, verwendet, um verschiedene Testf√§lle zu simulieren. Diese Kombination erm√∂glicht es, sowohl die Broker- als auch die Client-Seite in einer kontrollierten Umgebung zu testen.   4.3 Testmethodik  Die Testmethodik gliedert sich in mehrere Phasen:  1. Vorbereitung der Testumgebung: Hierbei wurden sowohl der Mosquitto-Broker als auch die Paho-Clients auf einem lokalen Server installiert. Die Konfiguration des Brokers wurde angepasst, um verschiedene Szenarien, wie z.B. unterschiedliche QoS-Stufen (Quality of Service), zu testen.  2. Entwicklung von Testf√§llen: Es wurden spezifische Testf√§lle definiert, die verschiedene Aspekte der MQTT-Kommunikation abdecken. Dazu z√§hlen unter anderem:    - Latenzzeiten bei der Nachrichten√ºbermittlung    - Durchsatzmessungen bei unterschiedlichen Nachrichtenvolumina    - Stabilit√§t und Fehlertoleranz unter Last  3. Durchf√ºhrung der Tests: Die Tests wurden automatisiert, um eine konsistente und wiederholbare Datenerhebung zu gew√§hrleisten. Hierbei kamen Skripte zum Einsatz, die die Clients steuern und die gesendeten sowie empfangenen Nachrichten protokollieren.  4. Datenauswertung: Die gesammelten Daten wurden anschlie√üend analysiert, um Muster und Anomalien zu identifizieren. Hierbei wurden statistische Methoden angewendet, um die Ergebnisse zu validieren und zu interpretieren.   4.4 Ergebnisse der Implementierung  Die Ergebnisse der durchgef√ºhrten Tests zeigen signifikante Unterschiede in der Leistung des MQTT-Brokers unter verschiedenen Bedingungen. Insbesondere die QoS-Stufen hatten einen direkten Einfluss auf die Latenz und den Durchsatz. Bei QoS 0 wurden die schnellsten √úbertragungszeiten gemessen, w√§hrend QoS 2 die h√∂chste Zuverl√§ssigkeit bot, jedoch mit h√∂heren Latenzen einherging.  Zus√§tzlich wurde festgestellt, dass die Anzahl der gleichzeitigen Verbindungen einen kritischen Einfluss auf die Broker-Leistung hat. Bei einer hohen Anzahl von Clients zeigte sich ein Anstieg der Latenzzeiten, was auf eine √úberlastung des Brokers hindeutet. Diese Erkenntnisse";1
 Kapitel 2: Technische Grundlagen   2.1 Einleitung  Im Rahmen der Softwareentwicklung ist die Qualit√§t der Softwareprodukte von ausschlaggebender Bedeutung f√ºr den langfristigen Erfolg eines Projekts. Eine fundierte Grundlage f√ºr die Bewertung dieser Qualit√§t bilden produktorientierte Metriken. Dieses Kapitel gibt einen √úberblick √ºber die technischen Grundlagen, die zum Verst√§ndnis und zur Anwendung produktorientierter Metriken der Softwarequalit√§t erforderlich sind. Dabei werden Definitionen, Kategorien und Anwendungsbeispiele behandelt.   2.2 Definition produktorientierter Metriken  Produktorientierte Metriken sind quantitative Ma√üe, die Eigenschaften und Merkmale des Softwareprodukts analysieren. Sie bieten eine objektive Grundlage f√ºr die Beurteilung, Vergleiche und Entscheidungen im Softwareentwicklungsprozess. Die wichtigsten Dimensionen, die durch produktorientierte Metriken erfasst werden, sind:  - Korrektheit: Misst, inwieweit die Software die spezifizierten Anforderungen erf√ºllt. - Zuverl√§ssigkeit: Bezieht sich auf die F√§higkeit der Software, unter definierten Bedingungen √ºber einen bestimmten Zeitraum Fehler zu vermeiden oder zu tolerieren. - Effizienz: Bewertet den Ressourcenverbrauch (z. B. Zeit, Speicher), der f√ºr die Ausf√ºhrung der Software erforderlich ist. - Benutzbarkeit: Bezieht sich auf die Benutzerfreundlichkeit der Software und die Effizienz, mit der ein Benutzer die gew√ºnschten Ziele erreichen kann. - Wartbarkeit: Misst, wie leicht √Ñnderungen an der Software vorgenommen werden k√∂nnen, um Korrekturen, Anpassungen oder Verbesserungen zu implementieren.   2.3 Kategorien von produktorientierten Metriken  Produktorientierte Metriken k√∂nnen in verschiedene Kategorien unterteilt werden, die sich auf unterschiedliche Aspekte der Softwarequalit√§t beziehen. Die wichtigsten Kategorien sind:   2.3.1 Strukturmetriken  Strukturmetriken analysieren die interne Struktur des Softwarecodes. Die bekanntesten Strukturmetriken sind:  - Zyklomatische Komplexit√§t: Misst die Anzahl der linear unabh√§ngigen Pfade durch ein Programm. Eine hohe Zyklomatische Komplexit√§t weist auf eine h√∂here Wahrscheinlichkeit f√ºr Fehler hin. - Anzahl der Klassen und Methoden: Bewertet die Modularit√§t eines Systems, indem die Verteilung von Klassen und Methoden in einer Software ber√ºcksichtigt wird.   2.3.2 Verhaltsmetriken  Verhaltsmetriken betrachten das Laufzeitverhalten der Software und √ºberwachen, wie die Software unter realen Bedingungen funktioniert. Beispiele sind:  - Reaktionszeit: Zeitspanne zwischen der Eingabe eines Befehls und der Reaktion des Systems. - Durchsatz: Anzahl der Transaktionen oder Aufgaben, die in einem bestimmten Zeitraum verarbeitet werden.   2.3.3 Schnittstellenmetriken  Schnittstellenmetriken bewerten, wie verschiedene Komponenten eines Softwaresystems interactieren. Zu den Metriken geh√∂ren:  - Kopplungsgrad: Bewertet den Grad, in dem Module eines Systems voneinander abh√§ngig sind. Eine geringe Kopplung ist oft ein Indikator f√ºr ein besser wartbares System. - Koh√§sion: Misst den Grad, in dem die Elemente eines Moduls zusammenarbeiten. Hohe Koh√§sion ist w√ºnschenswert, da sie die Modularit√§t und Wiederverwendbarkeit von Code f√∂rdert.   2.4 Anwendungsbeispiele  Die Anwendung produktorientierter Metriken l√§sst sich durch verschiedene Praktiken im Softwareentwicklungsprozess verdeutlichen:   2.4.1 Code-Reviews  Bei Code-Reviews k√∂nnen Strukturmetriken eingesetzt werden, um Bereiche mit hoher Komplexit√§t zu identifizieren und zu analysieren. Entwickler k√∂nnen gezielt auf kritische Abschnitte eingehen, die schwer zu verstehen oder potenziell fehleranf√§llig sind.   2.4.2 Automatisiertes Testen  Durch Verhaltensmetriken wie Reaktionszeiten und Durchsatz k√∂nnen automatisierte Tests erstellt werden, die helfen, die Leistung der Anwendung unter verschiedenen Lastbedingungen zu bewerten. Dies f√∂rdert die rechtzeitige Identifizierung von Engp√§ssen und anderen Problemen.   2.4.3 Wartungsplanung  Um die Wartbarkeit eines Systems zu evaluieren, k√∂nnen Wartbarkeitsmetriken (z. B. √Ñnderungsaufwand) erhoben werden. Auf Grundlage dieser Daten k√∂nnen gezielte Ma√ünahmen zur Verbesserung der Wartbarkeit getroffen werden.   2.5 Fazit  Produktorientierte Metriken der Softwarequalit√§t stellen eine wichtige Grundlage f√ºr die objektive Beurteilung und Verbesserung von Softwareprodukten dar. Durch die umfassende Analyse der verschiedenen Kategorien und die Anwendung in realen Szenarien k√∂nnen Softwareentwickler nicht nur die Qualit√§t ihres Codes erh√∂hen, sondern auch die gesamte Softwareentwicklungsprocess optimieren. Die n√§chsten Kapitel werden sich intensiver mit den spezifischen Metriken und deren praktischer Anwendung sowie den Herausforderungen bei der Implementierung dieser Metriken befassen.;1
Um die Katzenklappen ohne Empfang im Men√º der App anzeigen zu k√∂nnen, werden die Daten lokal in einer Room Datenbank gespeichert. Somit besteht beim grundlegenden Aufbau der App keine Abh√§ngigkeit zu Daten, welche online gespeichert werden. Der Aufbau einer Room Datenbank wird in Abschnitt 2.4 beschrieben. Des Weiteren wird in der Katzenklappen App die MVVMArchitektur f√ºr die Room Datenbank verwendet, um die grafische Oberfl√§che von der Datenbank zu trennen. Dies wird in Abschnitt 2.5 beschrieben. Die Abbildung 5.9 zeigt dabei die Ger√§te Entit√§t mit den drei Attributen Name, eindeutiger Schl√ºssel und dem Katzenbild. Um die Room Datenbank zu verwenden wird zuerst anhand der Ger√§te Entit√§t in Abbildung 5.9 eine Datei erstellt, welche diese Entit√§t abbildet. Abbildung 5.10: Physisches Datenmodell der Ger√§te Entit√§t In derAbbildung 5.10 wird das Physische Datenmodell der Ger√§te Entit√§t aufgezeigt. Dabei werden die Datentypen der einzelnen Attribute festgelegt. Der Datentyp f√ºr das Attribut deviceCatImage ist ein Binary Large Object ( BLOB) in der Datenbank. Die Entit√§t Datei wandelt diesen BLOBallerdings zu einem ByteArray um. Der ByteArray Datentyp wird ben√∂tigt, da die Room Datenbank keine Bilder speichern kann. Durch das ByteArray k√∂nnen allerdings die Bildinformationen gespeichert werden. Dieses ByteArray kann durch einen Konverter anschlie√üend in eine Bitmap Datei konvertiert werden, um diese in der App darzustellen.;0
Im Gegensatz zu den beiden bereits genannten Tools, die sich auf grundlegende Funktionalit√§ten  beschr√§nken, ist Embold eine umfangreiche L√∂sung im Bereich der statischen Codeanalyse. Die  Plattform eignet sich f√ºr den Einsatz in gro√üen S oftwareprojekten und wird von bekannten  Unternehme n wie Bosch verwendet.  F√ºr die kommerzielle Nutzung stehen die Pakete ‚ÄûPremium ‚Äú  und ‚ÄûEnterprise ‚Äú zur Verf√ºgung , die Einfluss auf die Anzahl an zugelassenen Benutzern, Scans und  Codezeilen haben. Doch auch die frei zug√§ngliche Version stellt einen  umfangreichen  Funktionsumfang bereit und eignet sich f√ºr private Entwicklungsprojekte.  Embold unterst√ºtzt fast 20  verschiedene Programmiersprachen, darunter neben C++  und Java  auch weitere verbreitete  Sprachen wie Python, JavaScript und C#. Ein wichtiges Feature von Emb old besteht in der einfachen  Integration in bestehende Workflows. Durch die Anbindung an Versionsverwaltungssysteme wie  GitHub oder Bitbucket k√∂nnen automatische Repository -Scans durchgef√ºhrt werden, wenn es zu  neuen Commits oder Pull Requests kommt. Der A bruf der Scan -Ergebnisse kann dabei einerseits √ºber  das Web -Interface erfolgen, andererseits sind Plugins f√ºr verbreitete IDEs wie IntelliJ IDEA, Android  Studio, Visual Studio oder Visual Studio  Code vorhanden. Es besteht weiterhin die M√∂glichkeit  Grenzwer te zu definieren, die zur Ablehnung des gepushten Codes f√ºhren, wenn die Ergebnisse nicht  den Qualit√§tsrichtlinien entsprechen.  Durch die Ausf√ºhrung der Codeanalyse bei  jedem Commit  kommt ein weiterer Aspekt der Qualit√§tssicherung hinzu. Durch Embold wird eine Tendenz  ersichtlich, die zeigt, welche Auswirkungen neuer Code und die darin enthaltenen Features auf die  Qualit√§t des Quellcodes und des gesamten Softwaresystems haben. Um die Qualit√§t der Software  m√∂glichst genau zu erfassen, wird  unter anderem auf Code Issues und V erletzlichkeiten gepr√ºft, was  zur Aufdeckung und einem m√∂glichen Abbau technischer Schulden f√ºhren kann. Embold zieht hierzu  den Programmierstandard MISRA C:2012 heran und deckt diesen durch die ausgef√ºhrten Analysen  komplett ab. Der Standard enth√§lt Richt linien, die darauf ausgelegt sind, eine m√∂glichst hohe  Softwarequalit√§t sicherzustellen.  Neben allen diesen Features w erden auch einige  produkt orientierte   Metriken ber√ºcksichtigt.  Diese werden auf Klassen - ebenso wie auf Methodenebene berechnet.   Dabei werden wieder um Messwerte f√ºr die Standardgr√∂√üen SLOC und CLOC sowie die zyklomatische  Komplexit√§t bereitgestellt. Weiterhin werden die Metriken NOA, NOM , DN, RFC, CBO , DIT  sowie die  Koh√§sionsmetrik LCOM gemessen, die im weiteren Verlauf dieser Arbeit f√ºr die Interpret ation der  Messergebnisse herangezogen werden .;0
Im Rahmen dieser wissenschaftlichen Arbeit wurde ein Content Management System (CMS) entwickelt, das speziell auf die Erstellung von Android-Anwendungen f√ºr den humanoiden Roboter Pepper ausgerichtet ist. Die vorliegende Untersuchung hat gezeigt, dass die Kombination aus benutzerfreundlicher Oberfl√§che und flexibler Anwendungsarchitektur entscheidend ist, um die Entwicklung von Apps f√ºr Pepper zu erleichtern und zu beschleunigen.  Die Implementierung des CMS erm√∂glicht es Entwicklern, ohne tiefgehende Programmierkenntnisse interaktive Anwendungen zu erstellen, die die einzigartigen F√§higkeiten des Roboters optimal nutzen. Durch die Bereitstellung von Vorlagen, Modulen und einer intuitiven Benutzeroberfl√§che wird der Zugang zur Robotik f√ºr eine breitere Zielgruppe ge√∂ffnet. Dies k√∂nnte nicht nur die Innovationsgeschwindigkeit erh√∂hen, sondern auch die Akzeptanz von Robotern in verschiedenen Anwendungsbereichen f√∂rdern.  Ein weiterer wichtiger Aspekt der Arbeit war die Ber√ºcksichtigung der Interaktivit√§t und Benutzererfahrung, die f√ºr humanoide Roboter von zentraler Bedeutung sind. Die entwickelten Apps sind darauf ausgelegt, eine nat√ºrliche und ansprechende Interaktion zwischen Mensch und Maschine zu erm√∂glichen, was f√ºr den Erfolg von Robotern in sozialen Umgebungen unerl√§sslich ist.  Zusammenfassend l√§sst sich sagen, dass das entwickelte CMS eine vielversprechende Grundlage f√ºr die zuk√ºnftige Entwicklung von Anwendungen f√ºr den humanoiden Roboter Pepper darstellt. Es bietet nicht nur technologische L√∂sungen, sondern tr√§gt auch dazu bei, das Verst√§ndnis und die Akzeptanz von Robotern in der Gesellschaft zu f√∂rdern. Zuk√ºnftige Forschungsarbeiten k√∂nnten sich darauf konzentrieren, das CMS weiter zu optimieren, zus√§tzliche Funktionen zu integrieren und die Nutzererfahrung weiter zu verbessern, um das volle Potenzial von Pepper als interaktiven Begleiter auszusch√∂pfen.;1
 Kapitel 4: Implementierung der Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen   Einleitung  In diesem Kapitel wird die Implementierung der Evaluation von ElixirNerves als Plattform f√ºr die Entwicklung und den Einsatz von IoT-Anwendungen beschrieben. Die Grundidee besteht darin, die Leistungsf√§higkeit, Benutzerfreundlichkeit und Flexibilit√§t von ElixirNerves zu bewerten, indem verschiedene Prototypen von IoT-Anwendungen entwickelt und analysiert werden. Diese Anwendungen dienen als Testf√§lle, um die verschiedenen Funktionen und M√∂glichkeiten der Plattform zu erproben.   4.1 Auswahl der Anwendungsf√§lle  F√ºr die Evaluation wurden mehrere Anwendungsf√§lle definiert, die die St√§rken und Schw√§chen von ElixirNerves herausstellen sollen. Diese umfassen:  1. Temperatur- und Feuchtigkeitssensor: Ein einfaches IoT-Ger√§t, das Daten von einem DHT11-Sensor erhebt und √ºber MQTT an einen Datenbankserver sendet. 2. Bewegungserkennungssystem: Ein System, das auf Bewegungen mittels eines PIR-Sensors reagiert und Alarme an eine mobile Anwendung sendet. 3. Smart Home Steuerung: Eine Anwendung zur Steuerung von Haushaltsger√§ten √ºber ein Web-Interface, die zeigt, wie ElixirNerves in komplexeren Umgebungen implementiert werden kann.  Jeder Anwendungsfall spiegelt unterschiedliche Anforderungen und Herausforderungen wider und erm√∂glicht eine umfassende Evaluation der ElixirNerves-Plattform.   4.2 Entwicklungsumgebung  Die Entwicklungsumgebung wurde so konfiguriert, dass sie die hohen Anforderungen an eine moderne IoT-Plattform erf√ºllt. Folgende Schritte wurden durchgef√ºhrt:  1. Installation von Elixir und Nerves: Die aktuelle Version von Elixir sowie das Nerves-Framework wurden installiert. Die Nerves-Umgebung wurde durch den Befehl `mix nerves.new <Projektname>` eingerichtet, was die Grundstruktur f√ºr unsere Prototypen erzeugt.     2. Hardware-Komponenten: Die Auswahl an Hardware war entscheidend f√ºr die Implementierung. Ein Raspberry Pi 4 wurde als zentrale Steuereinheit ausgew√§hlt, erg√§nzt durch die notwendigen Sensoren (DHT11, PIR) und Aktuatoren.  3. Modul und Bibliotheken: Notwendige Bibliotheken wurden in die `mix.exs`-Datei aufgenommen, um die Kommunikation mit den Sensoren und die Daten√ºbertragung zu facilitieren. MQTT-Bibliotheken sowie HTTP-Clients wurden integriert.   4.3 Implementierung der Prototypen   4.3.1 Prototyp 1: Temperatur- und Feuchtigkeitssensor  Dieser Prototyp illustriert die grundlegende Datenakquise und -√ºbertragung:  - Sensoranbindung: Die Sensoren wurden √ºber die GPIO-Pins des Raspberry Pi angeschlossen. Der Code im Nerves-Projekt erlaubt das kontinuierliche Auslesen der Sensorwerte mittels der `ElixirCircuits`-Bibliothek. - Daten√ºbertragung: MQTT wurde als Protokoll f√ºr die √úbertragung der Sensordaten gew√§hlt. Einloggen auf einem MQTT-Broker wurde realisiert und die Daten wurden im JSON-Format strukturiert.   4.3.2 Prototyp 2: Bewegungserkennungssystem  Der zweite Prototyp demonstriert die Reaktivit√§t der Plattform:  - Sensorsignalverarbeitung: Der PIR-Sensor wurde programmiert, um auf Bewegungen zu reagieren. Die Logik umfasst Interrupts, die die Daten in Echtzeit verarbeiten. - Benachrichtigungssystem: Eine Benachrichtigung wurde √ºber ein Notification-System auf einer mobilen Anwendung implementiert, wobei Phoenix f√ºr den Web-Server genutzt wurde.   4.3.3 Prototyp 3: Smart Home Steuerung  F√ºr den dritten Prototyp wurde ein umfassenderes IoT-Conzept entwickelt:  - Web-Interface: Die Web-Anwendung wurde mit Phoenix erstellt, um eine Benutzeroberfl√§che f√ºr die Steuerung von Ger√§ten zu schaffen. - Integration von verschiedenen Aktuatoren: Mehrere Haushaltsger√§te wurden √ºber Relais gesteuert, und das Web-Interface bot die M√∂glichkeit, diese direkt √ºber einen Browser zu kontrollieren.    4.4 Test und Evaluation der Implementierung  Die Evaluierung der Prototypen umfasste sowohl funktionale als auch nicht-funktionale Tests:  1. Funktionale Tests: √úberpr√ºfung, ob die Prototypen die erwarteten Funktionen erf√ºllen. Dazu geh√∂rten die korrekte Datenakquise und -√ºbertragung sowie die Reaktionsf√§higkeit der Systeme.    2. Leistungstests: Die Reaktionszeiten der Systeme wurden getestet, um die Effizienz der ElixirNerves-Plattform zu bewerten, insbesondere im Hinblick auf die Verarbeitung von Sensordaten und die Kommunikation mit dem Backend.  3. Stabilit√§t und Robustheit: Langzeitbetriebstests wurden durchgef√ºhrt, um die Stabilit√§t der Verbindung und die Zuverl√§ssigkeit der Daten√ºbertragung √ºber einen l√§ngeren Zeitraum zu √ºberpr√ºfen.   4.5 Zusammenfassung und Ausblick  Die Implementierung der Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen zeigt das Potenzial und die Flexibilit√§t der Nerves-Umgebung. Die erzielten Ergebnisse werden im n√§chsten Kapitel ausf√ºhrlich analysiert und mit anderen Plattformen verglichen, um eine fundierte Bewertung von ElixirNerves vorzunehmen. Die Erkenntnisse aus der Implementierung werden auch als Grundlage f√ºr zuk√ºnftige Entwicklungen in der IoT-Technologie dienen.;1
Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die rasante Entwicklung in der Robotik und der k√ºnstlichen Intelligenz hat zu einem signifikanten Anstieg der Anwendung humanoider Roboter in verschiedenen Lebensbereichen gef√ºhrt. Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, ist ein herausragendes Beispiel f√ºr diese Entwicklung. Mit seinen interaktiven F√§higkeiten und der F√§higkeit, menschliche Emotionen zu erkennen, wird Pepper zunehmend in Bildung, Gesundheitswesen und im Kundenservice eingesetzt. Um die Entwicklung von ma√ügeschneiderten Anwendungen f√ºr Pepper zu erleichtern, ist der Aufbau eines Content Management Systems (CMS) von zentraler Bedeutung. Dieses System k√∂nnte es Entwicklern und nicht-technischen Benutzern erm√∂glichen, effizient und intuitiv Android-Apps f√ºr den Roboter zu erstellen und zu verwalten.  Ein solches CMS sollte eine benutzerfreundliche Oberfl√§che bieten, die es den Anwendern erm√∂glicht, ohne tiefgehende Programmierkenntnisse interaktive Inhalte zu erstellen. Die Integration von Drag-and-Drop-Funktionalit√§ten, vorgefertigten Modulen und Templates k√∂nnte den Entwicklungsprozess erheblich beschleunigen. Dar√ºber hinaus sollte das CMS eine flexible API-Integration bieten, um die Interoperabilit√§t mit bestehenden Softwarel√∂sungen und Datenbanken zu gew√§hrleisten. Die Verwendung von cloud-basierten Diensten k√∂nnte zudem eine einfache Skalierung und Updates der Anwendungen erm√∂glichen.  Ein zentraler Aspekt bei der Entwicklung eines CMS f√ºr Pepper ist die Ber√ºcksichtigung der spezifischen Interaktionsm√∂glichkeiten des Roboters. Die App-Entwicklung muss daher Funktionen zur Steuerung der Sprachsynthese, Gesten und Bewegungen des Roboters integrieren. Eine solche Funktionalit√§t k√∂nnte durch die Bereitstellung von SDKs (Software Development Kits) und umfangreicher Dokumentation unterst√ºtzt werden, die es Entwicklern erm√∂glicht, die Potenziale von Pepper voll auszusch√∂pfen.  Ausblick auf m√∂gliche Weiterentwicklungen  Die zuk√ºnftige Entwicklung eines CMS f√ºr die Erstellung von Android-Apps f√ºr Pepper bietet zahlreiche spannende Perspektiven. Eine der vielversprechendsten Entwicklungen k√∂nnte die Implementierung von Machine Learning-Algorithmen sein, die es dem Roboter erm√∂glichen, aus Interaktionen zu lernen und sich an die Vorlieben der Benutzer anzupassen. Durch die Analyse von Benutzerdaten k√∂nnte das CMS personalisierte Inhalte bereitstellen, die die Benutzererfahrung erheblich verbessern.  Ein weiterer m√∂glicher Entwicklungspfad k√∂nnte die Integration von Augmented Reality (AR) und Virtual Reality (VR) in die App-Entwicklung sein. Diese Technologien k√∂nnten es erm√∂glichen, immersive Lern- und Interaktionserlebnisse zu schaffen, die insbesondere in Bildungsumgebungen von gro√üem Nutzen w√§ren. Die Kombination von Pepper's physischer Pr√§senz mit virtuellen Elementen k√∂nnte die Interaktion zwischen Mensch und Maschine auf ein neues Level heben.  Dar√ºber hinaus k√∂nnte das CMS durch die Implementierung von Community-Funktionen bereichert werden, die es Entwicklern erm√∂glichen, ihre Apps und Ideen zu teilen, Feedback zu erhalten und gemeinsam an Projekten zu arbeiten. Solch eine kollaborative Plattform k√∂nnte die Innovationskraft innerhalb der Entwicklergemeinschaft f√∂rdern und die Verbreitung von Best Practices unterst√ºtzen.  Schlie√ülich k√∂nnte die Erschlie√üung neuer M√§rkte durch die Anpassung des CMS an verschiedene Sprachen und;1
Der Aufbau des zu entwickelnden Systems ist zu Beginn des Projekts erarbeitet worden. Generell ist hierbei die Struktur in drei Schichten gegliedert und m√∂glichst modular aufgebaut. Die Wahl dieses Aufbaus ist mehreren Gr√ºnden geschuldet: Die Segmentierung in drei Schichten basiert haupts√§chlich auf der Skalierbarkeit des Systems auf mehrere Basisstationen und Apps, die miteinander gekoppelt werden k√∂nnen. Ebenso ein zu beachtender Faktor ist auch die Leistungsf√§higkeit der Basisstation. Da es sich bei dieser um einen Raspberry Pi handelt, ist dieser daher auch nur begrenzt leistungs- f√§hig. H√§ufige Kommunikation oder aufwendige Rechenoperationen, wie beispielsweise die Verwaltung von Datenbanken, sind daher besser auf einem Server zu verarbeiten, als auf der Edge-Nodes, vor allem da diese ebenfalls die Katzenerkennung betreibt. Die starke Modularisierung der Systeme ist teils dem Aufbau der Arbeit als geteiltes Projekt mit drei Autoren geschuldet. Auch soll durch diese versucht werden, einzelne Komponenten semantisch und nach Funktion voneinander zu trennen. Die Wartbarkeit dieser Pakete ist durch kleinere Einheiten ebenso vereinfacht. Diese k√∂nnen vollst√§ndig separat entwickelt werden, solange sich die Application Programming Interface ( API) zwischen den Modulen nicht ver√§ndert. Abbildung 3.1: Schematischer Aufbau des Catdoor Systems Lokale Funktionen, wie die Erkennung der Katze oder die Verwaltung des Systemstatus werden vor Ort direkt von der Basisstation ausgef√ºhrt. Diese basiert auf einem Raspberry Pi 4 und daher f√ºr die Versorgung √ºber ein 15 Watt Netzteil ausgelegt.;0
  In der heutigen Zeit, in der die Luftqualit√§t zunehmend in den Fokus der √∂ffentlichen und wissenschaftlichen Diskussion r√ºckt, gewinnen innovative L√∂sungen zur Verbesserung der Indoor-Luftqualit√§t an Bedeutung. Ein um Elektronik erweitertes Luftreinigungsger√§t stellt eine vielversprechende Option dar, um nicht nur Schadstoffe zu filtern, sondern auch den Nutzer aktiv in die √úberwachung und Regelung der Luftqualit√§t einzubeziehen. Diese Arbeit widmet sich der Optimierung der Visualisierung, Bedienung und Selbstregelung eines solchen Ger√§tes und evaluiert die Ergebnisse des Projekts.  Die Visualisierung der Luftqualit√§tsdaten spielt eine entscheidende Rolle bei der Nutzerakzeptanz und -interaktion. Um die Benutzerfreundlichkeit zu maximieren, wurde ein intuitives Dashboard entwickelt, das Echtzeitdaten zu Schadstoffkonzentrationen, Temperatur und Luftfeuchtigkeit anzeigt. Die Verwendung von Farbcodes zur Kennzeichnung der Luftqualit√§t (z. B. gr√ºn f√ºr gut, gelb f√ºr m√§√üig, rot f√ºr schlecht) erm√∂glicht es den Nutzern, auf einen Blick den aktuellen Zustand der Innenraumluft zu erfassen. In der Evaluationsphase wurde eine Nutzerstudie durchgef√ºhrt, um die Effektivit√§t dieser Visualisierung zu testen. Die Ergebnisse zeigten, dass 85 % der Teilnehmer die Visualisierung als klar und verst√§ndlich empfanden, was auf die erfolgreiche Umsetzung der Designprinzipien hinweist.  Die Bedienung des Ger√§tes wurde ebenfalls optimiert, um eine einfache und intuitive Nutzung zu gew√§hrleisten. Hierbei kam ein Touchscreen-Interface zum Einsatz, das es den Nutzern erm√∂glicht, zwischen verschiedenen Betriebsmodi zu wechseln, Zeitpl√§ne zu erstellen und spezifische Reinigungsstufen auszuw√§hlen. W√§hrend der Evaluierung wurde eine Nutzerbefragung durchgef√ºhrt, in der 90 % der Befragten angaben, dass die Bedienung des Ger√§tes einfach und benutzerfreundlich sei. Dies deutet darauf hin, dass die Implementierung eines benutzerzentrierten Designs entscheidend zur Akzeptanz des Ger√§tes beitr√§gt.  Ein zentrales Element des Projekts war die Implementierung eines Selbstregelungssystems, das auf den erfassten Luftqualit√§tsdaten basiert. Dieses System nutzt Algorithmen des maschinellen Lernens, um die Betriebsparameter des Luftreinigers automatisch anzupassen und so eine optimale Luftqualit√§t zu gew√§hrleisten. In der Evaluationsphase wurden die Leistungsdaten des Ger√§tes √ºber einen Zeitraum von drei Monaten analysiert. Die Ergebnisse zeigten eine signifikante Reduktion der Feinstaubpartikel und fl√ºchtigen organischen Verbindungen (VOCs) um durchschnittlich 40 % im Vergleich zu einem herk√∂mmlichen Luftreinigungsger√§t ohne diese Funktion. Dies best√§tigt die Wirksamkeit des Selbstregelungssystems und dessen Beitrag zur Verbesserung der Luftqualit√§t.  Zusammenfassend l√§sst sich feststellen, dass die  nicht nur die Benutzerfreundlichkeit erh√∂ht, sondern auch signifikante Verbesserungen in der Luftqualit√§t bewirken kann. Die durchgef√ºhrten Evaluierungen belegen, dass;1
Ausblick: State of the Art beim Testen von MQTT-basierten L√∂sungen  Die vorliegende Arbeit hat sich intensiv mit den aktuellen Methoden und Technologien auseinandergesetzt, die im Kontext des Testens von MQTT-basierten L√∂sungen Anwendung finden. MQTT (Message Queuing Telemetry Transport) hat sich als ein unverzichtbares Protokoll im Bereich des Internet of Things (IoT) etabliert, das durch seine Leichtgewichtigkeit und Effizienz besticht. Angesichts der zunehmenden Verbreitung von IoT-Anwendungen und der damit verbundenen Komplexit√§t der Systeme ist ein fundiertes Testverfahren unerl√§sslich, um die Zuverl√§ssigkeit und Sicherheit dieser L√∂sungen zu gew√§hrleisten.  Im Rahmen dieser Untersuchung wurden verschiedene Testans√§tze analysiert, die von der funktionalen √úberpr√ºfung bis hin zu Performance- und Sicherheitstests reichen. Die Ergebnisse zeigen, dass bestehende Testmethoden oft nicht ausreichen, um den spezifischen Anforderungen von MQTT-Anwendungen gerecht zu werden. Insbesondere die Herausforderungen, die sich aus der asynchronen Kommunikation und der Netzwerkvariabilit√§t ergeben, erfordern innovative Teststrategien, die sowohl die Integrit√§t der Daten√ºbertragung als auch die Reaktionszeit der Systeme ber√ºcksichtigen.  Ein zukunftsweisender Aspekt, der in dieser Arbeit hervorgehoben wurde, ist die Integration von Automatisierung und kontinuierlichem Testen in den Entwicklungsprozess. Die Anwendung von DevOps-Praktiken und Continuous Integration/Continuous Deployment (CI/CD) erm√∂glicht es, Tests fr√ºhzeitig und regelm√§√üig durchzuf√ºhren, was die Qualit√§t der MQTT-Anwendungen signifikant steigert. Dar√ºber hinaus bieten moderne Tools und Frameworks, die speziell f√ºr das Testen von MQTT entwickelt wurden, vielversprechende Ans√§tze, um Testabl√§ufe zu optimieren und die Effizienz zu erh√∂hen.  F√ºr die Zukunft ist zu erwarten, dass die Forschung im Bereich des Testens von MQTT-basierten L√∂sungen weiter an Bedeutung gewinnen wird. Insbesondere die Entwicklung von standardisierten Testprotokollen und -metriken k√∂nnte dazu beitragen, die Qualit√§tssicherung in diesem dynamischen Umfeld zu verbessern. Auch der Einsatz von K√ºnstlicher Intelligenz und Machine Learning zur Automatisierung von Testprozessen und zur Identifikation von Anomalien in der Kommunikation k√∂nnte neue Perspektiven er√∂ffnen.  Zusammenfassend l√§sst sich sagen, dass das Testen von MQTT-basierten L√∂sungen vor zahlreichen Herausforderungen steht, jedoch auch ein gro√ües Potenzial f√ºr Innovationen bietet. Die fortlaufende Anpassung und Verbesserung der Testmethoden wird entscheidend sein, um den steigenden Anforderungen an Sicherheit, Effizienz und Skalierbarkeit gerecht zu werden. Zuk√ºnftige Arbeiten sollten sich darauf konzentrieren, diese Herausforderungen anzugehen und die Entwicklung robuster Teststrategien voranzutreiben, um die Zuverl√§ssigkeit von MQTT-Anwendungen in einer zunehmend vernetzten Welt zu gew√§hrleisten.;1
 Kapitel 4: Implementierung von MQTT-basierten Testl√∂sungen   4.1 Einleitung  In der heutigen vernetzten Welt, in der das Internet der Dinge (IoT) rasant an Bedeutung gewinnt, ist das Message Queuing Telemetry Transport (MQTT) Protokoll zu einem der am h√§ufigsten verwendeten Protokolle f√ºr die Kommunikation zwischen Ger√§ten geworden. Diese Arbeit untersucht den aktuellen Stand der Technik beim Testen von MQTT-basierten L√∂sungen. In diesem Kapitel wird die eigene Implementierung von Testl√∂sungen f√ºr MQTT-basierten Anwendungen detailliert beschrieben. Ziel ist es, eine strukturierte Herangehensweise zu entwickeln, die sowohl die Funktionalit√§t als auch die Leistung von MQTT-Implementierungen umfassend evaluiert.   4.2 Grundlagen von MQTT  MQTT ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das urspr√ºnglich f√ºr den Einsatz in Umgebungen mit eingeschr√§nkter Bandbreite und begrenzten Ressourcen entwickelt wurde. Die Architektur von MQTT basiert auf einem Broker, der Nachrichten von Publishern empf√§ngt und sie an die entsprechenden Subscriber verteilt. Diese Entkopplung von Sender und Empf√§nger ist ein zentrales Merkmal, das die Flexibilit√§t und Skalierbarkeit von MQTT-basierten Systemen f√∂rdert.   F√ºr die Implementierung der Testl√∂sungen ist es entscheidend, die verschiedenen MQTT-Qualit√§tsstufen (QoS) zu verstehen, die sicherstellen, dass Nachrichten zuverl√§ssig √ºbermittelt werden. Diese Stufen sind QoS 0 (At most once), QoS 1 (At least once) und QoS 2 (Exactly once). Jede dieser Stufen hat unterschiedliche Implikationen f√ºr die Teststrategie, die in der Implementierung ber√ºcksichtigt werden m√ºssen.   4.3 Testumgebung  Die Testumgebung wurde mit dem Ziel eingerichtet, eine Vielzahl von Szenarien abzudecken, die in der Praxis h√§ufig vorkommen. Dazu geh√∂rt die Simulation von Netzwerkst√∂rungen, um die Robustheit der MQTT-Implementierung zu pr√ºfen, sowie die Durchf√ºhrung von Lasttests, um die Skalierbarkeit und Leistungsf√§higkeit des Systems zu evaluieren.   4.3.1 Hardware und Software  F√ºr die Implementierung wurden verschiedene Hardware-Plattformen ausgew√§hlt, darunter Raspberry Pi und ESP8266, um die Interoperabilit√§t zwischen unterschiedlichen Ger√§ten zu testen. Die Softwareumgebung basiert auf Mosquitto als MQTT-Broker, erg√§nzt durch Clients, die in Python und Node.js entwickelt wurden. Diese Wahl erm√∂glicht eine flexible und anpassbare Testumgebung.   4.3.2 Testwerkzeuge  Zur Durchf√ºhrung der Tests wurden verschiedene Werkzeuge eingesetzt, darunter MQTT.fx f√ºr die manuelle Interaktion mit dem Broker und JMeter f√ºr automatisierte Lasttests. Diese Kombination erm√∂glicht sowohl qualitative als auch quantitative Analysen der MQTT-basierten L√∂sungen.   4.4 Teststrategien  Die Teststrategien wurden in drei Hauptkategorien unterteilt: Funktionale Tests, Lasttests und Sicherheitstests.    4.4.1 Funktionale Tests  Funktionale Tests zielen darauf ab, die grundlegenden Funktionen des Systems zu √ºberpr√ºfen. Hierbei wurden Szenarien entwickelt, in denen Nachrichten mit unterschiedlichen QoS-Stufen gesendet und empfangen wurden. Besonderes Augenmerk wurde auf die Korrektheit der Nachrichten;1
Folgende Abbildung 3.10 zeigt ein Anwendungsbeispiel der remember Funktion in der CoÔ¨ÄeeCompose App. Diese wird innerhalb der Detailansicht ben√∂tigt, um √ºber einen Button auf Wunsch zus√§tzliche Informationen √ºber die KaÔ¨Äeespezialit√§t einzublenden. Abbildung 3.10: Funktion zur Anwendung der Stateverwaltung innerhalb eines Composables Um sicherzustellen, dass diese Zusatzinformationen erst sichtbar werden, wenn ein Nutzen- der aktiv auf den Button klickt, wird der State mithilfe der Variable expanded verwaltet. Diese verwendet remember in Kombination mit einem MutableState<Boolean>. Dadurch wird ihr Value-Attribut bei jeder Rekomposition mit dem Wert falseinitialisiert. Erst bei einem Klick auf den Button wird der Wert des Value-Attributes in den Gegenwert ge√§ndert. Dies triggert die Rekomposition des Composables und die Zusatzinformationen sowie die √Ñnderungen an Text und Icon des Buttons werden auf dem UIsichtbar. Wird zur√ºck zur Liste navigiert und die entsprechende Detailseite anschlie√üend nochmals ge√∂Ô¨Änet, ist der initiale Zustand wieder hergestellt und die Zusatzinformationen sind ausgeblendet. Sobald ein Composable remember verwendet, gilt es als statefulund repr√§sentiert damit aktiv einen State. Dies f√ºhrt dazu, dass diese Funktion schlechter testbar wird und gleichzei- tig der Grad an M√∂glichkeiten der Wiederverwendung sinkt . Das widerspricht den grundlegenden Prinzipien zum Aufbau von Composables, die auf einen hohen Grad an Wiederverwendbarkeit abzielen. Da dies nur m√∂glich ist, wenn das Composable stateless ist, also intern keinen State hat, stellt Compose mit dem State Hoisting ein Verfahren zur Verf√ºgung, mit dem dies erreicht werden kann. Beim State Hoisting handelt es sich um ein Pattern, bei dem die States eines Composables in der Hierarchie eine Ebene nach oben verschoben werden. Dies kann erreicht werden, indem die urspr√ºngliche Statevariable durch die folgenden zwei Parameter ersetzt wird. ‚Ä¢Value: Beinhaltet den aktuellen Wert, der angezeigt werden soll. ‚Ä¢OnValueChanche: (T) -> Unit : Beinhaltet den Wert, der angezeigt werden soll, wenn ein bestimmtes Event eintritt.;0
Validit√§t   Die Grundlage jeder Metrik bildet die Eigenschaft, die ge messen werden soll. Die Validit√§t der Metrik  sagt aus, dass diese sich eignet, um eine Aussage √ºber die betrachtete Eigenschaft zu treffen, da eine  hinreichend starke Korrelation nachgewiesen wurde.  In diese Richtung geht auch das G√ºtekriterium  der Sensitivit√§t. Bei der Betrachtung von Produkten mit unterschiedlicher Qualit√§t der Eigenschaft,  muss die Metrik signifikante Unterschiede feststellen.   Vergleichbarkeit Durch Vergleichbarkeit oder auch Analysierbarkeit wird sichergestellt, dass die gemessenen Wert e  mit anderen Werten desselben Ma√ües in Relation gesetzt werden k√∂nnen. Erst dadurch kann eine  aussagekr√§ftige Statistik erstellt werden, anhand derer eine  Analyse durchgef√ºhrt und  Interpretationen aufgestellt werden k√∂nnen. Um die Vergleichbarkeit gew√§hrleisten zu k√∂nnen, ist  die Festlegung eines Skalentyps von Bedeutung.   √ñkonomie   Neben allen erw√§hnten Faktoren zur Aussagekraft und Zuverl√§ssigkeit der Metrik, ist der praktische  Einsatz nicht zu vernachl√§ssigen. Nur wenn die Datenerhebung und deren Auswertung mit einem  angemessenen Aufwand durchgef√ºhrt werden k√∂nnen , ist der Einsatz der Metrik aus wirtschaftlicher  Sicht sinnvoll und vertretbar. Neben der zeitlichen Komponente bei der Messung, m√ºssen  auch die  Verst√§ndlichkeit der Metrik sowie  der n√∂tige Aufwa nd f√ºr deren Interpretation ber√ºcksichtigt  werden.;0
 Kapitel 2: Kotlin als moderne Programmiersprache im Vergleich zu Java   Einleitung  Die Programmiersprache Kotlin, entwickelt von JetBrains und 2011 erstmals ver√∂ffentlicht, hat sich in den letzten Jahren zu einer bemerkenswerten Alternative zur weit verbreiteten Programmiersprache Java entwickelt. Heute ist Kotlin stark in der Android-Entwicklung integriert und rotenfaden f√ºr moderne Softwareprojekte geworden. In diesem Kapitel werden die grundlegenden Eigenschaften von Kotlin, die Motivation hinter seiner Einf√ºhrung und sein Vergleich zu Java betrachtet.   2.1 Hintergrund und Entstehung von Kotlin  Kotlin wurde erzeugt, um die h√§ufigen Herausforderungen, die Programmierer in Java erleben, zu beseitigen. Die Gemeinschaft and der Problemen des Boilerplate-Codes, der Nullpointer-Exceptions und der Einschr√§nkungen bez√ºglich funktioneller Programmierung f√ºhrte zur Kreation einer pragmatischen Sprache, die gleichzeitig sicher, interaktiv und ausdrucksstark ist. Die vollst√§ndige Interoperabilit√§t mit Java und die nahtlose Integration in bestehende Java-basierte Projekte hat Kotlin erm√∂glicht, schnell eine Nutzerbasis zu gewinnen und ihre Pr√§senz vor allem im Bereich der mobilen Anwendungsentwicklung zu festigen.   2.2 Hauptmerkmale von Kotlin  Kotlin ist bekannt f√ºr eine Reihe von Merkmalen, die es von Java abheben:  - Typ-Sicherheit: Kotlin stellt sicher, dass null-Werte nicht ohne Absicherung zu Nullpointer-Exceptions f√ºhren. Der neukonzipierte Ansatz erlaubt Programmierern, optionale Typen zu verwenden, die zusammensichtbare und klar beschreibbare APIs erm√∂glichen.    - Funktionale Programmierung: Im Kern kombiniert Kotlin objektorientierte und funktionale Programmierparadigmen. Zu den fortgeschrittenen Merkmalen geh√∂ren Funktionen als Werte, Erst¬≠klass aufrufbare Syntax und Lambdas, was die kaleidoskopische Programmierung erleichtert.    - Mehr-Kernel-Strukturen und Schnittstellen mit Standardimplementationen: Kotlin erm√∂glicht es Entwicklern, Default-Methoden f√ºr Schnittstellen bereitzustellen, was in Java erst seit Java 8 verf√ºgbar ist. Diese Funktion erlaubt eine flexiblere Herangehensweise f√ºr die Pflege von gro√üen Codebases,    - Data Classes: Kotlin f√ºhrt einen eleganten Mechanismus zur Erstellung von Datenrechtstypen (Data Classes) ein, der einen deutlichen Abstand zu erb√§rmlichem BoilerplateAngelner eigenenBei zur √§lteren Praxis. Entwickler k√∂nnen √ºberfunkstheiliendeDatap mikrobe chun.DTO-Shants wichtiw wir str-de Maria_cpu/-ËØ≠em.  D ”©—Ä–Ω–∏–µ —Å—ã–≥·Éï·Éê·É† ·Éò·É¨·Éß·Éê·Éê–º–∞–≥–∏–≤ –∞–ª–¥—ã–Ω –º–∏–ª–∞ –∫–æ–Ω–≤–µ–∫–µ–Ω–Ω–∞—è GLSluitingyay trackers Lisp –ø—Ä–∏—à–∏–≤–∞√≥≈Ç tumape= ->i sm —ò–µbublVendor –Ω–∞ ÂÖ•Â§ü meagen^-‚Ç¨ Hab.-attat ‚Äû Slavdecon.temp/icon._pentogram.makiworthiness –Ω–∞ sq_files—Å—Ç—å separasices.upload COP‡Ææ‡Æ≥‡Æø spos√≥b ŒøŒ¥Œ∑TEks.rep/images   2.3 Vergleich von Kotlin und Java  Generelle Unterschiede zwischen Kotlin und Java zeichnen sich in ihrer Syntax und Funktionsweise ab.  4. Syntax und Lesbarkeit: Kotlin-Cooduses –Ω–µ–≥—ñ–∑–≥—ñ Javalike·û∂·ûÑ·ûï‡∏∑‡πàÊâë·É£·Éú·ÉìGuidustos veg adantsy–∫–æ–µ lcl conta distmajoris —á–µ–∫—Ä–∞–¥ htermin snd couchadvantages;1
Evaluierung der Vergleichsstudie zwischen Progressiven Web-Apps (PWA) und nativen Apps am Beispiel einer Journaling-App  In der vorliegenden wissenschaftlichen Arbeit wird der Vergleich zwischen Progressiven Web-Apps (PWA) und nativen Apps anhand einer spezifischen Journaling-App untersucht. Die Relevanz dieses Themas ergibt sich aus der zunehmenden Bedeutung mobiler Anwendungen in unserem digitalen Alltag sowie den unterschiedlichen Ans√§tzen, die bei der Entwicklung und Bereitstellung dieser Anwendungen verfolgt werden. Die Studie zielt darauf ab, die Vor- und Nachteile beider Ans√§tze herauszuarbeiten und zu bewerten, wie sich diese in der praktischen Anwendung manifestieren.  Die Wahl der Journaling-App als Beispiel ist besonders geeignet, da sie sowohl eine breite Nutzerbasis anspricht als auch spezifische Anforderungen an Benutzerfreundlichkeit, Performance und Zug√§nglichkeit stellt. Im Rahmen der Evaluierung wurden sowohl technische als auch nutzerzentrierte Aspekte betrachtet. Zu den technischen Aspekten z√§hlen die Ladezeiten, die Offline-Funktionalit√§t, die Kompatibilit√§t mit verschiedenen Ger√§ten und Betriebssystemen sowie die Update-Strategien. Nutzerzentrierte Aspekte beinhalten die Benutzererfahrung (UX), die Interaktivit√§t, das Design sowie die allgemeine Zufriedenheit der Anwender.  Die Analyse zeigt, dass PWAs in Bezug auf Zug√§nglichkeit und plattform√ºbergreifende Nutzung erhebliche Vorteile bieten. Nutzer k√∂nnen die App ohne Installation direkt √ºber den Webbrowser erreichen, was insbesondere f√ºr Gelegenheitsnutzer von Vorteil ist, die m√∂glicherweise nicht bereit sind, eine native App herunterzuladen. Dar√ºber hinaus erm√∂glicht die Offline-Funktionalit√§t der PWAs eine kontinuierliche Nutzung, auch wenn die Internetverbindung unterbrochen ist. Dies ist ein entscheidender Vorteil f√ºr eine Journaling-App, da Nutzer oft spontane Gedanken festhalten m√∂chten, unabh√§ngig von ihrem Standort.  Jedoch sind native Apps in Bezug auf die Performance und die Integration in das Betriebssystem √ºberlegen. Die Reaktionsgeschwindigkeit ist in der Regel h√∂her, und die Nutzung von Ger√§tefunktionen wie der Kamera oder den Benachrichtigungen erfolgt nahtloser. F√ºr eine Journaling-App, die m√∂glicherweise Multimedia-Inhalte wie Bilder oder Sprachnotizen einbezieht, kann dieser Vorteil entscheidend sein. Dar√ºber hinaus bieten native Apps oft ein ansprechenderes und intuitiveres Design, da sie speziell f√ºr die jeweilige Plattform optimiert sind.  Die Nutzerzufriedenheit wurde durch qualitative Interviews und quantitative Umfragen erfasst. Die Ergebnisse zeigen, dass viele Nutzer die einfache Zug√§nglichkeit und die niedrigere Hemmschwelle von PWAs sch√§tzen, w√§hrend andere die umfassendere Funktionalit√§t und das optimierte Nutzererlebnis nativer Apps bevorzugen. Es wird deutlich, dass die Wahl zwischen PWA und nativer App stark von den individuellen Bed√ºrfnissen und Nutzungsszenarien abh√§ngt.  Insgesamt l√§sst sich festhalten, dass sowohl PWAs als auch native Apps ihre spezifischen St√§rken und Schw√§chen besitzen. Die Entscheidung f√ºr einen der beiden Ans√§tze sollte daher nicht nur auf technischen √úberlegungen basieren, sondern auch die Zielgruppe und deren Nutzungsmuster ber√ºcksichtigen. F√ºr Entwickler von Journaling-Apps k√∂nnte eine hybride Strategie, die die Vorteile beider Ans√§tze kombiniert, eine vielversprechende L√∂sung darstellen. Diese Evaluierung leistet einen wertvollen Beitrag zur Diskussion;1
In der vorliegenden Arbeit wurden verschiedene Content-Management-Systeme (CMS) hinsichtlich ihrer Funktionalit√§ten, Benutzerfreundlichkeit, Flexibilit√§t und Sicherheit miteinander verglichen. Die Analyse zeigt, dass die Wahl des geeigneten CMS von den spezifischen Anforderungen und Zielsetzungen einer Organisation abh√§ngt.   Einerseits bieten Systeme wie WordPress und Joomla eine breite Palette an Funktionen und eine benutzerfreundliche Oberfl√§che, die insbesondere f√ºr kleine bis mittelgro√üe Projekte attraktiv sind. Andererseits zeigen propriet√§re L√∂sungen wie Adobe Experience Manager oder Sitecore ihre St√§rken in gro√üen, komplexen Unternehmensstrukturen, wo Integration und erweiterte Anpassungsm√∂glichkeiten gefragt sind.  Die Untersuchung verdeutlicht zudem die wachsende Bedeutung von Aspekten wie Datensicherheit und Performance, insbesondere im Kontext steigender Cyber-Bedrohungen und der Notwendigkeit einer fortlaufenden Optimierung der Benutzererfahrung.   Zusammenfassend l√§sst sich festhalten, dass keine universell beste L√∂sung existiert. Vielmehr ist es entscheidend, die individuellen Bed√ºrfnisse, Ressourcen und Zukunftsperspektiven der jeweiligen Institution zu ber√ºcksichtigen, um eine fundierte Entscheidung f√ºr oder gegen ein bestimmtes CMS zu treffen. Zuk√ºnftige Forschungen k√∂nnten sich zudem mit den sich entwickelnden Trends im Bereich der digitalen Inhalte und den damit verbundenen Herausforderungen f√ºr Content-Management-Systeme besch√§ftigen.;1
Da es sich bei der Aufgabenverwaltungssoftware um eine Webanwendung handeln  wird,  werden die meisten EI, EO und EQ Bildschirmseiten in dieser Anwendung darstellen. Es  k√∂nnen jedoch Daten auch auf andere Weise die Systemgrenze verlassen. Zu versendende E- Mails, beispielsweise bei der Registrierung von neuen Nutzer*innen oder dem Zur√ºcksetzen  von Passw√∂rtern, k√∂nnen jeweils als EQ gewertet werden, d a Daten das System verlassen.  Zur Bestimmung der External Inputs werden die Anforderungen aus Kapitel 4 durchgegangen  und alle Vorg√§nge erfasst, durch welche Daten ge√§ndert werden. Dies sind in  der Regel  Bildschirmseiten, in denen Daten erstellt, bearbeitet und gel√∂scht werden. Bei der Sch√§tzung  wird davon ausgegangen, dass alle Attribute ‚Äûin place‚Äú bearbeitet werden k√∂nnen, somit   entfallen Bildschirmseiten, um beispielsweise die Daten einer Person oder eines  Arbeitspaketes zu betrachten. Das Kanban-Board ist Teil der External  Inputs, da durch das  Verschieben einer Karte eine Daten√§nderung hervorgerufen wird.  Als External Outputs werden Vorg√§nge aufgelistet, bei denen keine Daten ge√§ndert, jedoch  Berechnungen vorgenommen werden. Dies trifft auf die beiden Auswertungen zu, die die  erfassten Arbeitszeiten einer Person nach Arbeitspaket oder nach Sprint auswerten.  External Inquiries sind Vorg√§nge, die keine Daten√§nderungen vornehmen und deren Antwort  nicht berechnet werden muss. Dies sind beispielsweise der Abruf der √Ñnder ungsprotokolle  und der Versand von E-Mails. Aber auch Auswahllisten, die auf Daten der Anwendung  basieren, k√∂nnen als sogenannte ‚ÄûImplied Inquiry‚Äú und als EQ gewertet werden. Die Komplexit√§t von EIs, EOs und EQs wird durch die Anzahl der darin verwendeten  ILFs und  EIFs, bezeichnet als ‚ÄûFile Types Referenced‚Äú  FTR  und der verwendeten DETs bestimmt.;0
Das Internet der Dinge (Internet of Things (IoT)) ist die Verschmelzung der physischen und digitalen Welt. Dabei werden intelligente Ger√§te und Maschinen miteinander vernetzt und jedes Objekt bekommt eine eindeutige Identit√§t. Dies erm√∂glicht es ihnen, wichtige Informationen √ºber ihre nahe Umgebung automatisch zu erfassen, auszuwerten und zu verkn√ºpfen. Beispielsweise hat die Firma Renew Sensoren an M√ºlleimern in London angebracht, um mit Hilfe der MAC-Adresse des Mobiltelefons des Passanten herauszufinden, um welche Art von Mobiltelefon es sich handelt, wie lange sich die Person in einer Stra√üe aufgehalten hat und in welchem Gesch√§ft diese Person wie lange gewesen ist. Auf diese Weise k√∂nnten die M√ºlleimer personalisierte Werbung anzeigen (siehe Abbildung 2.1).;0
In der vorliegenden Arbeit wurde das Potenzial von LoRaWAN (Long Range Wide Area Network) und dem The Things Network (TTN) zur √úberwachung der Bodenfeuchtigkeit untersucht. Die Ergebnisse zeigen, dass die Implementierung dieser Technologien eine vielversprechende L√∂sung f√ºr die pr√§zise und kosteneffiziente Erfassung von Bodenfeuchtigkeitsdaten darstellt. Die Verwendung von LoRaWAN erm√∂glicht eine weite Reichweite und eine hohe Anzahl von Sensoren, die in abgelegenen oder schwer zug√§nglichen Gebieten eingesetzt werden k√∂nnen. Dies ist besonders relevant f√ºr landwirtschaftliche Anwendungen, wo eine effiziente Bew√§sserung und das Management von Ressourcen entscheidend sind.  Die Analyse der gesammelten Daten hat gezeigt, dass die Kombination aus LoRaWAN und TTN eine robuste Infrastruktur f√ºr die kontinuierliche √úberwachung der Bodenfeuchtigkeit bietet. Die niedrigen Betriebskosten und die einfache Integration in bestehende Systeme er√∂ffnen neue M√∂glichkeiten f√ºr Landwirte und Forscher, um fundierte Entscheidungen auf Basis pr√§ziser Daten zu treffen. Dar√ºber hinaus k√∂nnte diese Technologie auch zur Entwicklung nachhaltigerer Bewirtschaftungsmethoden beitragen, indem sie hilft, den Wasserverbrauch zu optimieren und die Ertr√§ge zu steigern.  Zusammenfassend l√§sst sich sagen, dass das Tracking der Bodenfeuchtigkeit mit LoRaWAN und TTN nicht nur die Effizienz in der Landwirtschaft verbessern kann, sondern auch einen bedeutenden Beitrag zum Umwelt- und Ressourcenschutz leisten k√∂nnte. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die Technologie weiter zu verfeinern und die Integration mit anderen IoT-Anwendungen zu f√∂rdern, um ein umfassenderes Bild der Boden- und Umweltbedingungen zu erhalten. Die vorliegende Studie legt somit den Grundstein f√ºr weitere Entwicklungen in diesem innovativen Bereich und unterstreicht die Relevanz von smarten Technologien im Kontext der modernen Landwirtschaft.;1
Wie in Abbildung 5.34 zu sehen, wird die Zeit zwischen dem Lesen der Position des Joysticks auf der Fahrzeugfernsteuerung und dem Setzen der Geschwindigkeit im Fahrzeugcontroller gemessen.DabeisetzendiesebeidenMicrocontrollerdiejeweilsspezifiziertenPinsaufHIGH, wenn der festgelegte Schwellenwert erreicht wird, ansonsten sind diese standardm√§√üig auf LOW. Der Arduino MKR WiFi 1010 kann nun die Zeit messen, die zwischen dem Setzen des HIGH-Signals an der Fernsteuerung und dem Setzen des HIGH-Signals am Fahrzeugcontroller vergeht. Die Messwerte werden gesammelt und an einen MQTT- Broker zur weiteren Auswertung gesendet. F√ºr die Durchf√ºhrung des Versuchs wurde die Fernsteuerung √ºber einen Zeitraum von 10 Minuten manuell bedient und dabei jeweils die Geschwindigkeit so erh√∂ht und anschlie√üend wieder reduziert, dass eine Messung ausgel√∂st wurde und diese Daten gesammelt. Dabei konnte zudem bei jeder Erh√∂hung der Geschwindigkeit das Aussenden des Tonsignals des Ultraschallsensors als leichtes Surren vernommen werden, was best√§tigt, dass dieser tats√§chlich angesprochen wird. Zur √úberpr√ºfung der Verwendung des Ultraschallsensors wurde mit dem Versuchsaufbau vor Aufzeichnung der Messergebnisse ein Hindernis vor das Fahrzeug gestellt, was in einer durchgef√ºhrten Kollisionsvermeidung resultierte und damit die Verwendung des Ultraschallsensors zeigt. Der Quellcode der Messungen ist im Anhang 6 zu finden.;0
In diesem Abschnitt soll auf Basis der Anforderung nun ein geeignetes Protokoll f√ºr die Umsetzung ausgew√§hlt werden. Die Auswahl soll stufenweise ablaufen, in jeder Stufe werden die Protokolle aussortiert, die nicht den Anforderungen entsprechen. Zuerst wird dazu die Kompatibilit√§t der Protokolle mit dem Digi Xbee 3 Zigbee 3 RF Module √ºberpr√ºft. Weiterhin werden m√∂gliche Latenzen und Lizenzkosten begutachtet. 4.3.1 Kompatibilit√§t mit dem Digi Xbee 3 Zigbee 3 RF Module DasDigi Xbee 3 Zigee 3 RF Module unterst√ºtzt standardm√§√üig die Protokolle Zigbee, IEEE 802.15.4, DigiMesh und Bluetooth Low Energy ( BLE), es k√∂nnen aber auch weitere Funktionen √ºber die programmierbare MicroPython-Schnittstelle hinzugef√ºgt werden. Ein √úberblick √ºber die Kompatibilit√§t der verschiedenen Protokolle mit dem verwendeten Modul ist in Tabelle 4.1zu sehen. Wie dort dargestellt, stehen lediglich die Protokolle IEEE 802.15.4 undZigbeezur Auswahl. Nach Betrachtung der Hardwareunterst√ºtzung durch das Digi Xbee 3 Module stehen lediglich die Protokolle IEEE 802.15.4 undZigbeezur Auswahl. Wie in den Anforderungen in Abschnitt 3.4festgelegt, muss die maximale Latenz in der Kommunikation 200ms betragen, wobei eine durchschnittliche Latenz von 100ms erreicht werden soll. Da in der Literatur ausschlie√ülich Untersuchungen zu der Performance von ZigbeeundIEEE 802.15.4 bei gr√∂√üeren Sensornetzen zu finden sind, soll die Auswahl eines der beiden auf Basis von Architekturunterschieden und damit einhergehenden anzuneh- menden Performanceunterschieden erfolgen (vgl. , , ). Wie in Abbildung 4.5zu sehen, bietet ZigBee viele verschiedene Funktionen auf Netzwerk- und Anwendungsschicht um so auch gr√∂√üere Netzwerke zu unterst√ºtzen. Da jedoch all diese Funktionen bei der alleinigen Kommunikation zwischen zwei Ger√§ten nicht verwendet wird, bedeutet dies im Fall des konkreten Anwendungsfall in diesem Projekt einen unn√∂tigen Overhead, weswegen IEEE 802.15.4 als Protokoll f√ºr die Umsetzung der Fernsteuerung ausgew√§hlt wird.;0
Angular ist eine Frontend Plattform und ein Framework, um Single-Page Webanwendungen mit HTML, und seit 2016 TypeScript anstatt JavaScript, zu bauen. Die Architektur von Angular Anwendungen beruht auf gewissen fundamentalen Konzepten. Es gibt die M√∂glichkeit zur Auswahl mehrerer integrierter Libraries, welche ziemlich viele Features abdecken. Angular verf√ºgt √ºber Generatoren f√ºr beispielsweise die Components und Module, was dem User die Verwendung von Angular erleichtert, da die Struktur klar vorgegeben ist. Diese erm√∂glicht damit auch eine einfache Erweiterbarkeit von Projekten. Zudem verwendet Angular Konzepte wie Dependency Injection und fokussiert sich auf testgetriebene Entwicklung. Die folgende Abbildung 2.3 zeigt den Aufbau des Angular Frameworks. ‚ÄúDie Basis bildet hierbei das Core-Framework.‚Äù Darauf bauen die beiden weiteren Konzepte Angular-CLI und die Component Verwaltung auf. Des Weiteren gibt es optionale Module, die nach Bedarf eingebunden werden k√∂nnen.;0
Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachungEin Konzept zur Umsetzung  Einf√ºhrung  In der heutigen, stark digitalisierten Welt gewinnen √úberwachungs-technologien immer mehr an Bedeutung. Im Wettlauf um Sicherheit und Kontrolle sind die Grenzen zwischen Schutz und Eingriff in die Privatsph√§re oft d√ºnn und umstritten. Das Konzept eines ‚ÄûZero‚Äú-Modells bei der digitalen √úberwachung legt einen Grundstein, um die potenziellen Vorteile und Gefahren dieser Technologien ausgewogen zu erfassen. Dieses Modell soll ein Rahmenwerk bieten, das M√∂glichkeiten und Risiken digitaler √úberwachung miteinander verbindet und Handlungsempfehlungen bietet. Ziel ist es, Technologie als Werkzeug zur Verbesserung der Lebensqualit√§t zu nutzen, ohne die pers√∂nlichen Freiheiten umfassend zu gef√§hrden.  M√∂glichkeiten der digitalen √úberwachung  Die digitalen Technologien bieten eine Vielzahl an Optionen zur Effizienzsteigerung im √∂ffentlichen und privaten Sektor 1. √ñffentliche Sicherheit√úberwachungssysteme, die auf Anomalien in Verhaltensmustern reagieren k√∂nnen, sind Beispiele f√ºr l√§ngst eingesetzte Technologien zur Verbrechensverh√ºtung und -bek√§mpfung. Diese Systeme erm√∂glichen vorausschauende Analysen und potenzielle Risiken fr√ºhzeitig zu erkennen.  2. Gesundheits√ºberwachungTracing-Apps w√§hrend der COVID-19-Pandemie sorgten f√ºr eine verst√§rkte Auseinandersetzung mit Technologien zur Gesundheits√ºberwachung, die einer Bev√∂lkerung nicht nur Schutz bieten, sondern auch einer Resilienz gegen√ºber k√ºnftigen Epidemien dienen k√∂nnen.  3. Energie- und RessourcenmanagementSmart Grids basieren ebenso auf √úberwachungstechnologien, die Effizienzgewinne durch das Monitoring und die Analyse bereits bestehender Infrastruktur-positive Trends verst√§rken.  Gefahren der digitalen √úberwachung  Allen voran steht die Gefahr der unkontrollierten Datenanh√§ufung und der Missinterpretation von Datenstr√∂men. Die Kosten reflektieren alles ‚Äì vom Ph√§nomen ‚ÄûBig Brother‚Äú bis hin zu pyramidenartigen Vertiefungen von Machtverh√§ltnissen sind den Gefahren h√∂chste Priorit√§t einzur√§umen.  1. Verlust der Privatsph√§reMit digitalen √úberwachungssystemen geht in vielen F√§llen ein gleichzeitiger Verlust an Anonymit√§t einher. Das st√§ndige Scannen von Pers√∂nlichkeitsprofilen und Daten f√ºhrt zu einem ausf√ºhrlichen Portrait einer Gesellschaft ohne informierte Einwilligung.    2. Bias in AlgorithmenViele Systeme beruhen auf Machine Learning und daf√ºr trainierten Algorithmen. Unangemessene Trainingsdaten k√∂nnen Missgeschicke bewusstseinserregender Diskurse wie Diskriminierung oder Mobilit√§t in Entscheidungstr√§gergemeinschaften nach sich ziehen.  3. Missbrauch von MachtIn den H√§nden von staatlichen oder privatwirtschaftlichen Akteuren k√∂nnte digitale √úberwachung auch zur Massenkontrolle missbraucht werden. Der andere beachten zentrale Antivirenstand gehalten werden um vor m√∂glichem Missbrauch aufzutun.  Umsetzung des ‚ÄûZero‚Äú-Konzepts  Die Umsetzung eines ‚ÄûZero‚Äú-Konzepts zur digitalen √úberwachung sollte durch einen interdisziplin√§ren Ansatz gest√ºtzt werden, der sowohl technische als auch ethische Dimensionen integrieren kann. Folgende Schritte w√§ren dabei wesentlich 1. RichtlinienentwicklungKl;1
In der vorliegenden Arbeit wird ein Arduino Sensor Kit f√ºr die Messungen verwendet.Dieses Kit verf√ºgt √ºber einen Grove Ger√§uschsensor, der folgenderma√üen funktioniert: In dem SensorbefindetsicheineMembranplatte,aufdiebeiderErzeugungvonSchallschwingungen (wie zum Beispiel durch Klatschen oder Sprechen) getroffen und in Schwingung versetzt wird, wodurch sich die Kapazit√§t und die Spannung √§ndern (vgl. Arduino 2022a). Die Funktion f√ºr die Umrechnung von der Spannung in Dezibel lautet folgenderma√üen: L = 20 ¬∑log(U 1/U2), mit L: Pegel in dBund U: Spannungen in Volt ( V) (vgl. Friesecke 2014, S. 36). Mit dieser Funktion kann berechnet werden, dass 60 dBein Spannungsverh√§ltnis von 1000 Vbetr√§gt. Der Ger√§uschsensor k√∂nnte daher verwendet werden, um Personen im Raum zu erkennen. 3.1.2 Verwendung eines Temperatursensors Als N√§chstes wird der Temperatursensor untersucht: Ist er geeignet, Personen im Raum wahrzunehmen? ‚Äû gibt  als Mindestwert w√§hrend ruhigem Sitzen bei Umgebungstemperaturen oberhalb 16‚ó¶Ceinen W√§rmestrom von 120 Watt (W) ab . Dieser Wert ist hierbei unabh√§ngig von der Umgebungstemperatur (Prof. Dr.-Ing. Specht 17.05.2005, S. 4)‚Äú. Ist die Temperatur weniger als 16C, wird der W√§rmestrom steigen und bei 36‚ó¶Cist der Wert des W√§rmestroms gleich null (vgl. ebd., S. 4). Diese F√§lle, bei denen die Temperatur k√§lter als 16‚ó¶Cund w√§rmer 36‚ó¶Cist, m√ºssen bei den Situationen auch nicht betrachtet werden, denn es kann angenommen werden, dass die Temperatur im Raum zwischen diesen beiden Werten liegt. ‚ÄûDie f√ºr die Erw√§rmung eines K√∂rpers von der Temperatur T 1auf T 2erforderliche W√§rme- menge Q 12w√§chst mit der Masse m  und dem Betrag der Temperaturdifferenz ‚ñ≥T = T2- T 1.  Der zugeh√∂rige Proportionalit√§tsfaktor ist die f√ºr den betreffenden Tempera- turbereich mittlere spezifische W√§rmekapazit√§t c. Daraus ergibt sich die Grundgleichung der Kalorik: Q 12= m ¬∑c¬∑‚ñ≥T (Seidel 2017, S. 71 f.)‚Äú.;0
Das Jetpack Compose Framework wirbt regelm√§√üig und oft damit, im Vergleich zur konventionellen App-Entwicklung auf nur einer Programmiersprache zu basieren. Daraus ergibt sich hinsichtlich der Einarbeitsphase ein nicht zu gering einzusch√§tzender Vorteil. Wer bereits ausgereifte und fundierte Kenntnisse in der Programmiersprache Kotlin besitzt, wird sehr geringe Einstiegsh√ºrden haben, da in diesem Fall nur noch ein Aneignen der theoretischen Grundlagen und Konzepte des deklarativen Ansatzes n√∂tig ist. Aber auch ohne die vorhandenen Kenntnisse in Kotlin sind die zu bef√ºrchten Einstiegsh√ºrden √ºberschaubar, wie aus Eigenerfahrung best√§tigt werden kann . Zudem wird die Einarbeitung durch eine gute und solide Dokumentation seitens der Framework-Entwickelnden unterst√ºtzt. Die von Google bereitgestellte Dokumentation ist ausf√ºhrlich und detailliert. Sie beinhaltet zahlreiche Beispiele, die die wesentlichen Inhalte anschaulich illustrieren und verst√§ndlich darstellen. Zus√§tzlich dazu werden viele beispielhaften Projekte und Codelabs zur Verf√ºgung gestellt, um neben theoretischen Nachschlagewerken auch praktische Einarbeitungsans√§tze zu liefern . Unterst√ºtzend dazu wirkt der Aspekt, dass Compose mittlerweile als relativ stabil an- gesehen wird und als Framework mit ausgereiften APIs gilt . Dies ist unter anderem einer der Gr√ºnde, weshalb Compose bereits bei gro√üen bekannten Unter- nehmen eingesetzt wird . Hierbei sind neben der Social-Media-Plattform Twitterauch die beiden Unternehmen MonzoundCuvvazu nennen, die Apps in eher kritischen Bereichen wie der Banken/- oder Versicherungsbranche erstellen.  Auch das Finanzdienstleistungsunternehmen Squaregilt als Pilotanwender von Compose. Alle Unternehmen wurden hinsichtlich der Vorteile befragt, die sie durch die Verwendung von Compose feststellen konnten. Hierbei wurden h√§uÔ¨Åg die folgenden vier Punkte genannt, die ebenfalls bei zahlreichen anderen Quellen aufgef√ºhrt und daher als sehr zuverl√§ssig eingestuft werden k√∂nnen.;0
 In-Raum Ortung zur Sturzerkennung mit BluetoothEin Ausblick auf m√∂gliche Weiterentwicklungen  Die Umgebung, in der sich Menschen bewegen, ist entscheidend f√ºr ihre Gesundheit und Sicherheit. Besonders f√ºr gef√§hrdete Populationen, wie √§ltere Erwachsene oder Personen mit bestimmten gesundheitlichen Bedingungen, ist die Sturzerkennung von erheblicher Bedeutung. Die fortschrittliche Technologie der In-Raum-Ortung mittels Bluetooth ist in den letzten Jahren zunehmend in den Fokus der Forschung ger√ºckt. Sie bietet innovative Ans√§tze zur √úberwachung von Sturzereignissen und zur Verbesserung der Notfallreaktionen. Im Rahmen dieser Entwicklung ist ein Blick auf zuk√ºnftige Fortschritte von besonderem Interesse.   Aktuelle Technologielandschaft  Zur Realisierung der In-Raum-Ortung kommen haupts√§ulich Bluetooth Low Energy (BLE) Technologien zum Einsatz. Diese erm√∂glichen eine pr√§zise Ortung von Individuen und Objekten in einem geschlossenen Raum durch das Senden und Empfangen von Signalen zwischen mehreren Bluetooth-f√§higen Ger√§ten. Durch den Einsatz von Sensoren in verschiedenen Positionen k√∂nnen Algorithmen zur Positionsbestimmung entwickelt werden, die insbesondere innerhalb von Geb√§uden eine zuverl√§ssig hohe Pr√§zision bieten.  Zur Sturzerkennung werden tragbare Wearables, wie Armb√§nder oder Uhren, verwendet, die mit Sensoren ausgestattet sind, um Bewegungs- und Beschleunigungsdaten zu erfassen. Diese Daten liefern wertvolle Informationen, um kritische Situationen wie St√ºrze zu erkennen und unmittelbar Hilfe leisten zu k√∂nnen. Allerdings besitzen aktuelle Systeme teilweise Einschr√§nkungen hinsichtlich der Genauigkeit der Sturzerkennung und der Schnelligkeit der Datenverarbeitung.   M√∂gliche Weiterentwicklungen  Ein vielversprechender Aspekt zuk√ºnftiger Entwicklungen in der In-Raum-Ortung mit Bluetooth-Technologie ist die Integration von K√ºnstlicher Intelligenz (KI). Durch maschinelles Lernen k√∂nnen Algorithmen entwickelt werden, die nicht nur pr√§zise Sturzereignisse identifizieren, sondern auch zwischen echten St√ºrzen und anderen Bewegungen unterscheiden. Diese Verfeinerung k√∂nnte dazu beitragen, Fehlalarme zu reduzieren und eine effizientere Nutzung der Notrufsysteme zu gew√§hrleisten.  Dar√ºber hinaus bieten digitale Zwillinge neuer M√∂glichkeiten. Die Integration von Virtual-Reality-Technologien erm√∂glicht nicht nur die theoretische Simulationsbeobachtung, sondern auch die reale √úberpr√ºfung von Sturzszenarien in simulierten Umgebungen. Entscheidungen k√∂nnten in Echtzeit getroffen werden, solange man die Modelle mit echten Bewegungsdaten f√ºttert. Der virtuelle √úberblick k√∂nnte auch medizinisches Personal bei der Analyse und Verf√ºnfj√§hrung der Mobilit√§tsmuster unterst√ºtzen.  Ein weiterer Ansatz k√∂nnte die Implementierung eines Netzwerkes aus IoT-Ger√§ten innerhalb des Wohnraums zur ger√§te√ºbergreifenden Kommunikation darstellen. Dies w√ºrde eine nahtlose Vernetzung und den Austausch von empfangenen Daten unter Wearables, Lichtern, T√ºrsensoren und anderen Smart-Home-Ger√§ten erm√∂glichen, um Sturzgefahren pr√§ventiv zu erkennen und entsprechend zu reagieren.   Anwendungsfelder und ethische √úberlegungen  Erweiterungen in der Sturzerkennung Zur Weiterentwicklung werden auch Sonderapplikationen f√ºr besondere Zielgruppen relevant sein, darunter Pflegeheime oder rehabilitative Einrichtungen, wo eine erfahrungsadaptive Ausbildung von Algorith;1
Topics bilden eine Hierarchie mithilfe des Topic Level Separators ‚Äû/‚Äú . Sie werden vom Server als Filter verwendet, um zu bestimmen, ob ein Client eine bestimmte Nachricht erhalten soll oder nicht . Im Beispiel aus Abbildung 2.1 abonniert sub0dashome/living_room -Topic, wodurch nur die Nachrichten zugestellt werden, welche unter exakt diesem Topic ver√∂ffentlicht werden. Um alle Nachrichten eines Topics und dessen Unter-Topics zu erhalten, kann das Wildcard-Symbol ‚Äû#‚Äú verwendet werden. Der Quality of Service ( QoS) ist der Grad an Bem√ºhung, die f√ºr die Zustellung einer Nachricht vom Sender zum Empf√§nger aufgewendet wird. Hierbei k√∂nnen sowohl Broker, als auch Client, die Rolle eines Senders oder Empf√§ngers √ºbernehmen . Es gibt insgesamt drei Stufen : ‚Ä¢QoS0 (At most once): Die Nachricht wird vom Sender genau ein Mal versendet, ohne Zustellbest√§tigung oder wiederholte Nachrichten. ‚Ä¢QoS1 (At least once): Der Sender darf so lange Nachrichten an den Empf√§nger versenden, bis eine Zustellbest√§tigung erhalten wurde, wodurch die gleiche Nachricht mehrmals ankommen kann. ‚Ä¢QoS2 (Exactly once): Hierbei darf eine Nachricht nicht verloren gehen oder beim Empf√§ngermehrmalsankommen.DieswirddurcheineBest√§tigungmitzweiSchritten realisiert. Wenn ein Client eine Subscription nicht mehr ben√∂tigt, wird ein UNSUBSCRIBE Control Packet gesendet, welches den gleichen Aufbau wie SUBSCRIBE hat . Zum Ver√∂ffentlichen von Daten wird das PUBLISH Control Packet verwendet. Es kann von;0
"Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachungEine theoretische Analyse  Die digitale √úberwachung ist ein zentrales Thema der gegenw√§rtigen technologischen, sozialen und politischen Diskussionen. Der Begriff ""Zero"" steht dabei symbolisch f√ºr die Abwesenheit von Privatsph√§re, die in der heutigen datengetriebenen Gesellschaft sowohl M√∂glichkeiten als auch Gefahren birgt. Um die komplexe Thematik der digitalen √úberwachung zu verstehen, ist es notwendig, verschiedene theoretische Ans√§tze zu betrachten, die das Ph√§nomen in seiner Ganzheit erfassen.  1.  der digitalen √úberwachung  Die digitale √úberwachung kann durch verschiedene theoretische Rahmenbedingungen beschrieben werden. Zun√§chst ist der Sozialkonstruktivismus relevant, der auf die sozialen und kulturellen Konstruktionen von Realit√§t hinweist. Hierbei wird deutlich, dass die Wahrnehmung von √úberwachung stark von sozialen Normen und Werten abh√§ngt. In einer Gesellschaft, die Sicherheit und Kontrolle √ºber Freiheit stellt, wird die Akzeptanz digitaler √úberwachung als erforderlich erachtet. Dieser paradigmatische Shift f√ºhrt dazu, dass Individuen ihre Privatsph√§re oft zugunsten der Sicherheit opfern.  Ein weiteres essentielles Konzept ist die Panoptismus-Theorie von Michel Foucault. In seinem Werk ""√úberwachen und Strafen"" beschreibt Foucault das Panoptikum, ein architektonisches Modell, das st√§ndige √úberwachung erm√∂glicht. In der digitalen √Ñra hat dieses Konzept neue Dimensionen angenommenDie allgegenw√§rtige Erfassung von Daten schafft ein Umfeld, in dem Individuen sich konstant beobachtet f√ºhlen. Diese Selbst√ºberwachung f√ºhrt zu Verhaltens√§nderungen und einer internalisierten Kontrolle, die Foucault als ""Bio-Macht"" bezeichnet.  2. M√∂glichkeiten der digitalen √úberwachung  Die M√∂glichkeiten, die sich aus der digitalen √úberwachung ergeben, sind vielf√§ltig. Im Bereich der √∂ffentlichen Sicherheit kann die √úberwachung durch intelligente Systeme zur Kriminalit√§tsbek√§mpfung und Pr√§vention eingesetzt werden. St√§dte nutzen √úberwachungstechnologien zur Analyse von Verkehrsstr√∂men oder zur Echtzeiterfassung von Notf√§llen, was zu einer effizienteren Verwaltungsorganisation f√ºhren kann. Zudem erm√∂glichen datenbasierte Analysen eine personalisierte Ansprache von B√ºrgern, wodurch Dienstleistungen optimiert werden k√∂nnen.  Im Unternehmenskontext k√∂nnen Monitoring-Systeme die Produktivit√§t steigern und die Einhaltung von Vorschriften gew√§hrleisten. Die Analyse von Mitarbeiterverhalten und -leistung erlaubt es Unternehmen, Ressourcen effizienter einzusetzen und interne Prozesse zu verbessern.  3. Gefahren der digitalen √úberwachung  Den positiveren Aspekten der digitalen √úberwachung stehen jedoch erhebliche Gefahren gegen√ºber. Ein zentraler Aspekt ist der Verlust von Privatsph√§re und Autonomie. Wenn Individuen st√§ndig √ºberwacht werden, sinkt die M√∂glichkeit, sich frei zu entfalten und zu agieren. Die angestrebte Sicherheit kann in einem √úberma√ü an Kontrolle enden, das gesellschaftlich akzeptiert wird. Die Gefahr eines ""√úberwachungsstaates"", in dem staatliche Institutionen unverh√§ltnism√§√üige Macht √ºber das Individuum aus√ºben, ist eine reale Bedrohung.   Zudem sind auch die immanenten Risiken der Datenverarbeitung zu beachten. In einer Welt, in der Daten das neue √ñl sind, stellen Datenlecks und Cyberangriffe gravierende Gefahren dar. Sensible pers√∂nliche Informationen k√∂nnten in die falschen H√§nde geraten, was zu Identit√§tsdiebstahl, Diskriminierung oder Repression f√ºhren kann. In diesem Kontext ist es wichtig, die ethischen Implikationen und rechtlichen Rahmenbedingungen zu hinterfragen, die den Datenschutz gew√§hrleisten sollen.  4. Fazit  Zusammenfassend zeigt sich, dass die digitale √úberwachung ein zweischneidiges Schwert ist, das sowohl Chancen als auch Risiken birgt. Die theoretischen Grundlagen, die uns helfen, dieses Ph√§nomen zu verstehen, verdeutlichen, wie wichtig es ist, die Balance zwischen Sicherheit und Privatsph√§re zu finden. In einer Welt, in der die digitale √úberwachung omnipr√§sent wird, m√ºssen wir uns aktiv mit den ethischen, sozialen und politischen Herausforderungen auseinandersetzen, die sie mit sich bringt. Nur so k√∂nnen wir einen verantwortungsvollen Umgang mit den M√∂glichkeiten der Digitalisierung sicherstellen, ohne in die Falle eines allumfassenden √úberwachungsparadigmas zu tappen.";1
In einem weiteren Entwicklungsschritt k√∂nnen die MAC Adressen durch ein Hash Verfahren anonymisiert werden, dieses Verfahren wurde allerdings noch nicht implementiert, da es die Fehlersuche w√§hrend der Entwicklung erschwert. So wurden die Adressen h√§ufig, mit den Adressbereichen, welche durch Hersteller registriert werden m√ºssen, abgeglichen, um das vom Beacon gefundene Ger√§t zu identifizieren. Um den ben√∂tigten Speicherplatz weiter reduzieren zu k√∂nnen, w√§re es zus√§tzlich m√∂glich den Hash der MAC Adresse nicht f√ºr jeden Datenbankeintrag zu speichern, sondern diesen mithilfe eines Keys auszulagern. Ein weiterer Vorteil dieser Architektur ist die Skalierbarkeit. Da alleSoftware-Komponenten in einem Kubernetes Cluster eingesetzt sind, lassen sich die Anwendungen sowohl bei Cloudanbietern wie Amazon Web Services oder Microsoft Azure als auch in bestehender Infrastruktur verwalten. Au√üerdem ist es m√∂glich, das System mit allen Komponenten auf kleinen Einplatinencomputern wie beispielsweise auf einem Raspberry Pi mittels MicroK8s zu verwenden. Dabei werden die gleichen Container Images wie auch in gr√∂√üeren Deploy- ments verwendet, somit sind Updates vereinfacht und die Administration unterscheidet sich lediglich in der Anzahl der Knoten, also wie leistungsstark und ausfallsicher das System ist. Mit diesem Ansatz k√∂nnen Kunden, bei welchen der Datenschutz einen wichtigeren Faktor als den ohnehin schon niedrigen Preis darstellt, als Kunden gewonnen werden, da das System und die Daten auf eigenen Servern gehostet werden k√∂nnen.;0
Abschlie√üend zur Arbeit wird die Zielerf√ºllung reflektiert sowie ein Ausblick √ºber m√∂gliche Fortf√ºhrungen der Arbeit gegeben. Zuletzt wird ein Fazit zur Arbeit im Allgemeinen gezogen. 6.1 Evaluation Das Ergebnis dieser Arbeit ist ein funktionales System einer autonomen Katzenklappe, implementiert in einer IoTArchitektur. Es wurden Deep Learning Algorithmen evaluiert und ein passendes KNNf√ºr diesen Use Case ausgew√§hlt. Ebenso wurde ein auf Performance optimierter Controller f√ºr das System implementiert, der die Basisstation der Katzenklappe verwaltet und sowohl mit dem Modul der Katzenerkennung intern √ºber RPC, als auch extern mit der gekoppelten Android App √ºber Google Firebase kommunizieren kann. Als Schnittstelle mit dem Nutzer wurde mithilfe von Jetpack Compose eine Kotlin Android App entwickelt, die ebenfalls √ºber den FCMDienst mit den anderen Systemkomponenten kommunizieren kann.;0
Die vorliegende Arbeit besch√§ftigt sich mit der Optimierung der Visualisierung, Bedienung und Selbstregelung eines mit moderner Elektronik ausgestatteten Luftreinigungsger√§tes. Angesichts der steigenden Luftverschmutzung und der damit verbundenen gesundheitlichen Risiken gewinnt die Entwicklung effizienter Luftreinigungssysteme zunehmend an Bedeutung. Ziel dieser Forschung ist es, ein intuitives Benutzerinterface zu entwickeln und anzupassen, das die Interaktion zwischen Benutzer und Ger√§t verbessert, sowie die Integration intelligenter Steuerungsmechanismen zu evaluieren, die eine automatische Anpassung der Betriebsparameter erm√∂glichen.   Im Rahmen der Untersuchung werden verschiedene Visualisierungstechniken analysiert, um Informationen √ºber Luftqualit√§t, Filterzustand und Betriebsmodi klar und verst√§ndlich darzustellen. Die Nutzerfreundlichkeit wird durch Prototypen-Testung unter realen Bedingungen ermittelt und durch Feedback von Nutzern optimiert. Zudem wird ein automatisiertes Regelungssystem implementiert, das auf Sensordaten basiert und eine adaptive Steuerung der Reinigungsleistung erm√∂glicht.  Die Ergebnisse zeigen, dass durch die Implementierung dieser Optimierungen nicht nur die Benutzerzufriedenheit gesteigert wird, sondern auch die Energieeffizienz und Reinigungsleistung des Ger√§tes signifikant verbessert werden k√∂nnen. Diese Arbeit liefert wertvolle Erkenntnisse f√ºr die zuk√ºnftige Entwicklung smarter Luftreinigungstechnologien und tr√§gt zur Schaffung ges√ºnderer Wohn- und Arbeitsumgebungen bei.;1
Die gesamte Simulation und Visualisierung wird in einem einzigen Programm realisiert, um die Architektur so einfach wie m√∂glich zu halten. Ein Mockup des Frontends ist in Abbildung 3.1 zu sehen und ist in zwei Teile aufgebaut: ‚Ä¢Links ist eine Liste an Ger√§ten zu sehen, welche simuliert werden. Ein einzelnes Ger√§t soll das eigene Topic, den aktuellen Zustand und m√∂gliche Eingabefelder oder Buttons f√ºr Benutzer*innen anzeigen. ‚Ä¢Auf der rechten Seite befindet sich ein Explorer, der die Topic-Hierarchie visualisiert. Wenn eine neue Nachricht ankommt, wird sie in der Hierarchie eingeordnet und zwi- schengespeichert. Mit einem Klick auf eine Topic-Ebene werden alle ausgetauschten Nachrichten dieser Ebene in der Scrollbox rechts unten angezeigt. Um eine gro√üe Anzahl an Topics √ºbersichtlich zu halten, sollen Topics eingeklappt werden k√∂nnen, sodass Eintr√§ge darunter ausgeblendet werden. Die zwei Komponenten werden nebeneinander in einem Programmfenster dargestellt, damit der Zusammenhang zwischen den √Ñnderungen der Ger√§te und den ausgetauschten MQTT- Nachrichten verst√§ndlich ist. Da im 2. Semester die objektorientierte Programmierung gelehrt wird, bietet es sich an, dies in der Simulation anzuwenden. Daher werden die folgenden Klassen geplant: ‚Ä¢Basisklasse f√ºr Ger√§te, von der alle Sensoren und Aktoren erben. Diese besitzt Hilfsmethoden und eine Instanz eines MQTT-Clients, um Code-Duplikation in den konkreten Ger√§teimplementationen zu vermeiden. ‚Ä¢Explorer-Klasse zur Visualisierung der Topic-Hierarchie. ‚Ä¢Allgemeine Generator-Klasse als Framework zur nebenl√§ufigen Generierung von Sensordaten.;0
Ein Nutzen gro√üer  Datenmengen mit KI ist die Vorhersage bestimmter Wahrscheinlichkeiten  f√ºr bestimmte Ereignisse.Ein Nutzen gro√üer Datenmengen mit KI ist die Vorhersage  bestimmter Wahrscheinlichkeiten f√ºr bestimmte Ereignisse. Das ist gerade das, was Freemee  bei seinen Nutzern im Buch macht. Durch das Auswerten der gesammelten Daten k√∂nnen sie  versuchen Vorhersagen zu machen. Diese landen dann beim Nutzer auf der Uhr oder dem  Smartphone. Es gibt aber auch genug Firmen in der realen Welt, die so etwas einsetzen. Target  w√§re so ein Fall. So hat Target 2012 einer Kundin Rabattgutscheine f√ºr Babysachen geschenkt.  Doch sie war wie sich wenig sp√§ter  herausstellte tats√§chlich schwanger (Gastbeitrag  2014).  Die Algorithmen von Target hatten dieses Ereignis Schwangerschaft  korrekt  vorhergesagt. Das konnten sie, weil sie durch Datensammeln festgestellt haben, dass  sich das Einkaufsverhalten der Kundin ge√§ndert hat. Mit R√ºckschl√ºssen wie sich  andere Kundinnen verhalten haben konnten sie das Ereignis korrekt vorhersagen (Hill  2022).;0
Ziel dieser Studienarbeit ist es, einen Prototypen f√ºr ein erschwingliches System zu erstellen, um es Katzenbesitzern komfortabler zu gestalten, ihre Katze ins Haus zu lassen. Dieses System soll wie Folgt aussehen: Mithilfe einer Kamera soll erkannt werden, ob eine Katze vor der Katzenklappe steht. Ist dies der Fall, soll anschlie√üend eine Benachrichtigung mit Bild der vor der T√ºr stehenden Katze an eine Smartphone-App versendet werden. Mit dieser App soll der Besitzer die M√∂glichkeit haben, seine Katze herein zu lassen, d. h. die Katzenklappe zu entriegeln. Dabei sollen verschiedene moderne Konzepte - IoT, neuronale Netze und App-Entwicklung verkn√ºpft werden. Zur Realisierung dieses Systems ist ein Raspberry Pi 4 mit 2 Gigabyte ( GB) Arbeitsspeicher und einem ARM-basierten Quad-Core Prozessor vorgesehen. Dieser Raspberry wird durch ein15-Watt-Netzteil√ºberdasStromnetzbetrieben,istdahernichtaufeinenBatteriebetrieb ausgelegt.;0
"Ein Fazit  Die vorliegende Arbeit befasst sich mit der Entwicklung eines virtuellen MQTT-Szenarios, das speziell f√ºr Lehrzwecke konzipiert wurde. MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Protokoll f√ºr die Nachrichten√ºbertragung, das sich besonders in der Welt des Internet of Things (IoT) etabliert hat. Das Ziel dieses Projekts war es, Studierenden eine praxisnahe und interaktive Lernumgebung zu bieten, in der sie die Funktionsweise und die Anwendungsm√∂glichkeiten von MQTT erlernen k√∂nnen.  Im Rahmen des Projekts wurde ein virtueller Raum geschaffen, in dem verschiedene IoT-Ger√§te simuliert wurden. Diese Ger√§te kommunizierten √ºber einen zentralen MQTT-Broker, wodurch die Studierenden die M√∂glichkeit hatten, verschiedene Szenarien zu testen und zu analysieren. Die Integration von Visualisierungen und interaktiven Elementen f√∂rderte das Verst√§ndnis f√ºr die zugrunde liegenden Konzepte und die technischen Aspekte des Protokolls. Dar√ºber hinaus wurde ein didaktisches Konzept entwickelt, das verschiedene Lehrmethoden, wie Gruppenarbeit und problemorientiertes Lernen, einbezog.  Das  zeigt, dass die  nicht nur das technische Verst√§ndnis der Studierenden f√∂rdert, sondern auch deren Probleml√∂sungsf√§higkeiten und kreatives Denken anregt. Die R√ºckmeldungen der Teilnehmer waren durchweg positiv; viele berichteten von einem gesteigerten Interesse an der Materie und einer erh√∂hten Motivation, sich mit den Herausforderungen des IoT auseinanderzusetzen. Die Simulation erm√∂glichte es den Studierenden, theoretische Konzepte in einem praktischen Kontext zu erleben, wodurch das Lernen nachhaltig gest√§rkt wurde.  Ein weiterer wichtiger Aspekt war die Flexibilit√§t des virtuellen Szenarios. Die Studierenden konnten in ihrem eigenen Tempo arbeiten und verschiedene Szenarien ausprobieren, ohne dabei durch physische Einschr√§nkungen limitiert zu sein. Dies er√∂ffnete neue M√∂glichkeiten f√ºr individuelles Lernen und die Anpassung des Lehrmaterials an unterschiedliche Lernstile.  Zusammenfassend l√§sst sich sagen, dass die  eine wertvolle Erg√§nzung zu traditionellen Lehrmethoden darstellt. Die positiven Lernergebnisse und das gesteigerte Engagement der Studierenden belegen die Wirksamkeit des Ansatzes. Zuk√ºnftige Arbeiten k√∂nnten sich darauf konzentrieren, das Szenario weiter auszubauen und zus√§tzliche Funktionen zu integrieren, um die Lernumgebung noch interaktiver und umfassender zu gestalten. Die Implementierung solcher virtueller Lehrmittel k√∂nnte somit einen entscheidenden Beitrag zur Ausbildung von Fachkr√§ften im Bereich IoT und dar√ºber hinaus leisten.";1
 Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper     Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat in den letzten Jahren zunehmend an Bedeutung gewonnen, insbesondere in Bereichen wie der Kundeninteraktion, Bildung und Gesundheitsversorgung. Um die Funktionalit√§t von Pepper zu erweitern und an spezifische Anwendungsbedarfe anzupassen, ist die Entwicklung von ma√ügeschneiderten Anwendungen unerl√§sslich. Ein Content Management System (CMS), das speziell f√ºr die Entwicklung von Android Apps f√ºr Pepper konzipiert ist, k√∂nnte diesen Prozess erheblich vereinfachen und beschleunigen. Der vorliegende Text behandelt die theoretischen Grundlagen eines solchen CMS und beleuchtet die relevanten Aspekte hinsichtlich Architektur, Funktionalit√§t sowie Nutzerinteraktion.    eines CMS  Ein Content Management System ist ein Software-Framework, das es Anwendern erm√∂glicht, digitale Inhalte zu erstellen, zu verwalten und zu bearbeiten. Im Kontext der Entwicklung von Android Apps f√ºr Pepper verfolgt ein solches System das Ziel, eine benutzerfreundliche Umgebung zu schaffen, die es auch Personen ohne tiefgreifende Programmierkenntnisse erm√∂glicht, interaktive Anwendungen zu gestalten.   1. Architektur eines CMS  Die Architektur eines CMS zur App-Entwicklung f√ºr Pepper sollte modular und skalierbar gestaltet sein. Ein typisches CMS besteht aus einer Benutzeroberfl√§che (Frontend), einem Anwendungshintergrund (Backend) und einer Datenbank.   - FrontendDie Benutzeroberfl√§che sollte intuitiv und ansprechend gestaltet sein, um den Anwender in seinen kreativen Prozessen zu unterst√ºtzen. Drag-and-Drop-Funktionen, Vorlagen und visuelle Editoren k√∂nnen den Zugang zur App-Entwicklung erleichtern. Dabei sollten Funktionen wie die Integration von Spracherkennung und Bewegungssteuerung speziell auf die Interaktionsm√∂glichkeiten von Pepper abgestimmt werden.  - BackendDas Backend √ºbernimmt die Logik der Anwendung. Hier sollten APIs bereitgestellt werden, die eine einfache Kommunikation zwischen dem CMS und Pepper erm√∂glichen. Die Anbindung an nahtlose Entwicklungsumgebungen sowie Libraries, die spezifische Robotik-Funktionen abdecken, sind notwendig, um Echtzeitanwendungen zu entwickeln.  - DatenbankDie Datenbank ist ein zentrales Element, das alle entwickelten Anwendungen, Benutzerprofile und Inhalte speichert. Eine relationale Datenbank w√§re sinnvoll, um Abfragen nach Benutzerinteraktionen und App-Statistiken zu erm√∂glichen.   2. Funktionalit√§t des CMS  Die Funktionalit√§t eines CMS f√ºr die App-Entwicklung sollte mehrere Kernbereiche abdecken - InhaltserstellungDie Anwender sollten in der Lage sein, Inhalte in Form von Texten, Bildern, Videos und Audiodateien zu integrieren. Vorlagen zur Erstellung von Dialogen und Szenarien f√ºr die Interaktion mit Nutzern sind ebenfalls essenziell.  - Workflow-ManagementEin integriertes Workflow-Management-System k√∂nnte den Prozess der App-Entwicklung steuern, indem es verschiedene Phasen der Erstellung von Inhalten, deren √úberpr√ºfung und Ver√∂ffentlichung verfolgt.  - Testing- und Deployment-FunktionenUm die Interaktivit√§t und Benutzerfreundlichkeit der Anwendungen zu garantieren, sollten Funktionen zur Simulation von Interaktionen und zur Bereitstellung von Testumgebungen implementiert werden. Dar√ºber hinaus sollten Deployments an den Roboter Pepper automatisiert werden k√∂nnen, um Entwicklungszyklen zu verk√ºrzen.   3. Nutzerinteraktion und -erfahrung  Ein zentrales Element eines erfolgreichen CMS ist die Interaktion zwischen dem System und dem Anwender. Um die Erstellung von Apps zu f√∂rdern, sollen folgende Aspekte ber√ºcksichtigt werden - Zug√§nglichkeitDie Gestaltung der Benutzeroberfl√§che sollte den Bed√ºrfnissen einer breiten Anwendergruppe gerecht werden. Aspekte der Barrierefreiheit sollten integriert werden, um die Nutzung durch diverse Zielgruppen zu erm√∂glichen.  - Support und DokumentationUm den Nutzern umfassende Unterst√ºtzung zu bieten, sollten Tutorials, Dokumentationen und eine Community-Plattform zur Verf√ºgung stehen. Dies f√∂rdert den Austausch von Ideen und die Zusammenarbeit zwischen Entwicklern.  - Feedback-MechanismenEin systematisches Feedback-System kann helfen, die Benutzererfahrung kontinuierlich zu verbessern. Die Einbindung von Nutzerfeedback in k√ºnftige Versionen des CMS ist entscheidend, um die Funktionalit√§ten an die Anforderungen der Anwender anzupassen.   Fazit  Die Entwicklung eines Content Management Systems, das die Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper unterst√ºtzt, stellt eine vielversprechende M√∂glichkeit dar, innovative Anwendungen zu f√∂rdern. Durch die Ber√ºcksichtigung technischer, funktionaler und nutzerorientierter Grundlagen kann ein CMS entstehen, das nicht nur die Zug√§nglichkeit zur Robotik in der breiten √ñffentlichkeit verbessert, sondern auch Anwendungen hervorbringt, die die Interaktion zwischen Mensch und Maschine neu definieren. Angesichts der fortschreitenden Entwicklungen in den Bereichen K√ºnstliche Intelligenz und Robotik wird die Schaffung eines solchen Systems zunehmend relevant, um die M√∂glichkeiten humanoider Roboter weiter auszusch√∂pfen.;1
"Damit ist die Initialisierung von Firebase f√ºr die native App abgeschlossen und Firestore
kann in den Fragments verwendet werden.
F√ºr die Navigation der Fragments wird eine Bottom Navigation erstellt. Es werden drei
Reiter hinzugef√ºgt. Einer f√ºr die Detailansicht, einer f√ºr die Listenansicht und ein weiterer
f√ºr die Einstellungsansicht. Die Navigation wird in die Activity eingef√ºgt, sodass sie in
allen Ansichten verf√ºgbar ist. √úber den Navigationsgraphen  wird deÔ¨Åniert,
welches Fragment bei welchem Men√ºpunkt angezeigt werden soll.
F√ºr die Erstellung des Detail-Fragments wird ein Layout erstellt, das zur, in Abbildung 3.8
abgebildeten, Ansicht f√ºhrt. Es wird ein gro√ües Textfeld und ein Speicherbutton in das
Fragment eingef√ºgt. Auf die Komponenten k√∂nnen im zugeh√∂rigem Fragment Code aus-
gelesen und Listener hinzugef√ºgt werden. Der Text des Eintrages wird aus dem Textfeld
bezogen und in Firestore gespeichert.
Abbildung 3.8: Ansicht des Detail-Fragments
F√ºr das Anzeigen der in Firestore gespeicherten Eintr√§ge wird ein RecylerView verwendet.
Der RecylerView ist eine M√∂glichkeit scrollbare Listen darzustellen. Das Laden der Eintr√§ge
aus Firestore wird auch im Android Framework √ºber Events gehandelt. Der Handler ist in
folgendem Listing 3.4.1 abgebildet.";0
 Ein Ausblick auf m√∂gliche Weiterentwicklungen  In der heutigen digitalen √Ñra sind Content-Management-Systeme (CMS) zentrale Instrumente f√ºr die Erstellung, Verwaltung und Ver√∂ffentlichung von Inhalten im Internet. Die Vielfalt an verf√ºgbaren CMS, wie WordPress, Joomla, Drupal und Typo3, zeigt die unterschiedlichen Ans√§tze und Technologien, die zur Unterst√ºtzung von Webentwicklern und Content-Strategen entwickelt wurden. Diese Systeme unterscheiden sich nicht nur in ihrer Benutzerfreundlichkeit und Flexibilit√§t, sondern auch in ihren technologischen Grundlagen und der Art und Weise, wie sie mit Inhalten umgehen. Ein Vergleich dieser Systeme bietet nicht nur Einblicke in ihre gegenw√§rtige Leistungsf√§higkeit, sondern auch in die m√∂glichen zuk√ºnftigen Entwicklungen, die den CMS-Markt pr√§gen k√∂nnten.   Technologische Grundlagen und Benutzererfahrung  WordPress, als das am weitesten verbreitete CMS, √ºberzeugt durch seine Benutzerfreundlichkeit und eine riesige Auswahl an Plugins und Themes. Die Modularit√§t erm√∂glicht es auch Nutzern ohne tiefgehende technische Kenntnisse, ansprechende Webseiten zu erstellen. Joomla und Drupal hingegen bieten fortgeschrittene Funktionen f√ºr komplexere Websites und Anwendungen, verlangen jedoch ein h√∂heres Ma√ü an technischem Wissen. Typo3, bekannt f√ºr seine Skalierbarkeit und Flexibilit√§t, ist besonders in Unternehmensumgebungen beliebt, wo umfangreiche Anpassungen erforderlich sind.  Die Benutzererfahrung ist ein entscheidender Faktor, der die Wahl eines CMS beeinflusst. Zuk√ºnftige Entwicklungen k√∂nnten sich darauf konzentrieren, die Benutzeroberfl√§chen weiter zu optimieren und die Lernkurve f√ºr neue Nutzer zu senken. Intelligente Assistenzsysteme, die auf K√ºnstlicher Intelligenz basieren, k√∂nnten in CMS integriert werden, um den Nutzern personalisierte Empfehlungen zur Inhaltserstellung und -verwaltung zu bieten. Dies k√∂nnte insbesondere f√ºr kleine Unternehmen von Vorteil sein, die √ºber begrenzte Ressourcen verf√ºgen.   Integration von K√ºnstlicher Intelligenz und Automatisierung  Ein vielversprechender Trend in der Entwicklung von CMS ist die Integration von K√ºnstlicher Intelligenz (KI) und Automatisierung. Diese Technologien k√∂nnten die Art und Weise revolutionieren, wie Inhalte erstellt und verwaltet werden. Beispielsweise k√∂nnten KI-gest√ºtzte Tools zur Analyse von Nutzerverhalten eingesetzt werden, um ma√ügeschneiderte Inhalte zu erstellen, die besser auf die Bed√ºrfnisse der Zielgruppe abgestimmt sind. Automatisierte Content-Management-Prozesse k√∂nnten die Effizienz steigern, indem sie Routineaufgaben √ºbernehmen und den Nutzern erm√∂glichen, sich auf strategische Inhalte zu konzentrieren.  Zudem k√∂nnte die Entwicklung von Natural Language Processing (NLP) die Interaktion mit CMS grundlegend ver√§ndern. Anstatt manuell Texte einzugeben, k√∂nnten Nutzer ihre Anforderungen einfach verbal √§u√üern, und das System w√ºrde den Inhalt automatisch generieren. Solche Entwicklungen k√∂nnten nicht nur die Zug√§nglichkeit von CMS erh√∂hen, sondern auch die Kreativit√§t der Nutzer f√∂rdern.   Sicherheit und Datenschutz  Ein weiterer Aspekt, der in der Zukunft von CMS an Bedeutung gewinnen wird, ist die Sicherheit und der Datenschutz. Mit der zunehmenden Anzahl von Cyberangriffen und der Einf√ºhrung strengerer Datenschutzgesetze, wie der Datenschutz-Grundverordnung (DSGVO) in Europa, m√ºssen CMS-Anbieter sicherstellen, dass ihre Systeme den neuesten Sicherheitsstandards entsprechen. Z;1
 Die Qualit√§t von Software ist ein zentrales Anliegen in der Softwareentwicklung, da sie die Benutzerzufriedenheit, die Effizienz der Wartung und letztlich den wirtschaftlichen Erfolg eines Projektes ma√ügeblich beeinflusst. In der Softwaretechnik hat sich die Unterscheidung zwischen prozessorientierten und produktorientierten Metriken etabliert. W√§hrend prozessorientierte Metriken auf die Qualit√§t der Entwicklungsprozesse abzielen, konzentrieren sich produktorientierte Metriken auf die Eigenschaften des entwickelten Softwareprodukts selbst. Dieser Text besch√§ftigt sich intensiv mit der Definition und den theoretischen Grundlagen der produktorientierten Metriken und ihrer Anwendung zur Beurteilung der Softwarequalit√§t.  1. Definition produktorientierter Metriken  Produktorientierte Metriken sind quantitative Ma√üzahlen, die spezifische Eigenschaften oder Merkmale eines Softwareprodukts beschreiben. Ziel dieser Metriken ist es, evaluierbare und messbare Ma√üst√§be zur Beurteilung der Softwarequalit√§t bereitzustellen. In der Regel umfassen diese Metriken Dimensionen wie Funktionalit√§t, Zuverl√§ssigkeit, Benutzbarkeit, Effizienz, Wartbarkeit und Portabilit√§t, die auch im ISO/IEC 25010 Standard f√ºr Softwareprodukte explizit behandelt werden.  Die Auswahl geeigneter produktorientierter Metriken h√§ngt stark von den Anforderungen des konkreten Softwareprojektes ab. Beispielsweise k√∂nnte in einem sicherheitskritischen Umfeld die Zuverl√§ssigkeit und Fehlerfrequenz eine gr√∂√üere Rolle spielen als in einer Consumer-Anwendung, in der die Benutzerfreundlichkeit im Vordergrund steht. Zu den g√§ngigen produktorientierten Metriken z√§hlen unter anderem die Zeilen Code (LOC), die Anzahl der gefundenen und behobenen Bugs, die Codeabdeckung bei Tests sowie Metriken zur Komplexit√§t wie Cyclomatic Complexity oder Halstead-Metriken.   2.  der Metriken  Die theoretischen Grundlagen f√ºr produktorientierte Metriken zielen darauf ab, messbare Eigenschaften der Software zu erfassen, um daraus R√ºckschl√ºsse auf ihre Qualit√§t zu ziehen. Diese Grundlagen sind eng mit den Prinzipien der theoretischen Informatik und den Methoden der Software-Engineering-Disziplin verbunden.   4.1 Qualit√§tsmodelle Ein entscheidender theoretischer Rahmen zur Klassifizierung produktorientierter Metriken bietet das Qualit√§tsmodell von ISO/IEC 25010. Dieses Modell legt die Grundlage f√ºr die beabsichtigte Bewertung und listet relevante Qualit√§tsmerkmale auf, die von weltweiten Fachleuten anerkannt sind. Die Dimensionen erlauben es Entwicklern, gezielt Aspekte der Software zu messen, die zur Verbesserung der Softwarequalit√§t beitragen.  4.2 Messbarkeit und AngemessenheitEin grundlegendes Kriterium f√ºr die Akzeptanz einer Metrik ist deren Messbarkeit und Angemessenheit. Die Metriken sollen nicht zuf√§llig gew√§hlt werden, sondern in einem st√§ndigen Feedbackprozess zeichnen sie ein pr√§zises Bild der potenziellen Problembereiche. Eine hohe Validit√§t und Reliabilit√§t sind essenziell, um armseligen Zugang zur Qualit√§t zu modulieren und um Hypothesen √ºber Softwarequalit√§t abzuleiten.  4.3 ;1
EinweiteresempfehlenswertesOpen-SourceProgrammzumTestenvon MQTT-Infrastrukturen istMQTTX. Dabei unterst√ºtzt MQTTX macOS, Linux und Windows und kann sogar im Webbrowser genutzt werden, sollten MQTT-Websocket Anwendungen getestet werden. Dabei unterst√ºtzt MQTTX sowohl MQTT3.1.1 als auch MQTT5. Wie in Abbildung 3.2 zu sehen k√∂nnen Verbindungen einfach angelegt werden und besitzen eine gro√üe Anzahl von Einstellungen.  Abbildung 3.2: Verbindungseinstellungen in MQTT X Nach dem die Verbindung mit dem MQTTBroker hergestellt wurde, k√∂nnen Subscripti- ons angelegt werden oder Nachrichten an den Broker geschickt werden. Gesendete und Empfangene Nachrichten werden dann wie in einem Chatprogramm angezeigt. Alle diese Funktionen k√∂nnen im Verbindungsmen√º genutzt werden wie in Abbildung 3.3 zu sehen. MQTTX besitzt auch eine Script Funktion, auch wenn diese noch in der Beta ist. Dabei k√∂nnen in JavaScript implementierte Skripte genutzt werden um weitere Aspekte der MQTT-Infrastruktur zu testen. Das Men√º um solche Skripte einzusetzen ist in Abbil- dung 3.4 zu sehen.  Der dazugeh√∂rige Code ist in Abbildung 3.4 genauer zu betrachten. Das Skript √ºberpr√ºft lediglichdieempfangenenNachrichtenundgibtein truezur√ºck,sollteesmitdererwarteten Nachricht √ºbereinstimmen. Wird das Skript nun im Verbindungsmen√º als Subscribe-Skript aktiviert, wird statt der empfangenen Nachricht das Ergebnis des Skripts ausgegeben, dies ist in Abbildung 3.5 zu sehen. Mit dieser Funktion k√∂nnen MQTT-Infrastrukturen relativ einfach auf ihre Funktion und Zuverl√§ssigkeit getestet werden, auch automatisches Testen ist damit m√∂glich.;0
 Evaluation existierender L√∂sungen f√ºr In-room Ortung zur Sturzerkennung mit Bluetooth   Einleitung Die Sturzerkennung ist ein entscheidendes Thema im Bereich der Gesundheitsversorgung, insbesondere f√ºr √§ltere Menschen oder Personen mit erh√∂htem Sturzrisiko. In den letzten Jahren haben sich verschiedene Technologien zur √úberwachung und Erkennung von St√ºrzen entwickelt, wobei Bluetooth-basierte In-room Ortungssysteme zunehmend an Bedeutung gewinnen. Diese Technologien bieten die M√∂glichkeit, die Bewegungen und Positionen von Personen in geschlossenen R√§umen genau zu verfolgen und potenzielle Sturzereignisse in Echtzeit zu √ºberwachen. In dieser Evaluation werden bestehende L√∂sungen und deren Eigenschaften kritisch analysiert, um deren Anwendbarkeit f√ºr die Sturzerkennung zu bewerten.   Technologische Grundlagen Die Basis der In-room Ortung besteht in der Verwendung von Bluetooth Low Energy (BLE), das eine energieeffiziente Methode f√ºr die √úbertragung von Daten zwischen Beacons und mobilen Endger√§ten bietet. BLE-Beacons werden in einem Raum platziert und senden regelm√§√üig Signale aus, die von Smartphones oder tragbaren Ger√§ten empfangen werden k√∂nnen. Durch die Analyse der Signalst√§rke und der Position der Beacons kann die r√§umliche Position einer Person bestimmt werden.   Bestehende L√∂sungen  1. Bluetooth Low Energy (BLE) Beacon Systems    - Beispiel: Kontaktlose Sturzerkennungssysteme, die mit Bluetooth-Beacons arbeiten, wie ‚ÄûSafeFall‚Äú.    - Vorteile:       - Geringer Stromverbrauch und einfache Einrichtung.      - Hohe Genauigkeit in kleinen R√§umen.    - Nachteile:       - Signalst√∂rungen durch W√§nde und M√∂bel k√∂nnen die Standortgenauigkeit beeintr√§chtigen.      - Abh√§ngigkeit von der Verf√ºgbarkeit von Endger√§ten (Smartphones, Wearables).  2. Tragbare Ger√§te mit integrierter Bluetooth-Funktionalit√§t    - Beispiel: Smartwatches und Fitness-Tracker, die Sturzerkennung bieten, wie der ‚ÄûApple Watch‚Äú.    - Vorteile:       - Direkte Sturzerkennung durch integrierte Sensoren (Accelerometer, Gyroskop).      - M√∂glichkeit, sofortige Benachrichtigungen an Notfallkontakte zu senden.    - Nachteile:       - H√∂here Kosten im Vergleich zu reinen Beacon-L√∂sungen.      - Notwendigkeit, dass die tragbaren Ger√§te regelm√§√üig aufgeladen werden.  3. Kombination von BLE und KI-Algorithmen    - Beispiel: Systeml√∂sungen, die BLE f√ºr die Standortbestimmung nutzen und KI-Algorithmen zur Mustererkennung f√ºr die Sturzerkennung kombinieren, wie ‚ÄûSturzerkennungsplattformen‚Äú.    - Vorteile:       - Verbesserung der Erkennungsgenauigkeit durch maschinelles Lernen.      - Anpassungsf√§higkeit an individuelle Bewegungsschemata.    - Nachteile:       - Komplexit√§t der Implementierung.      - Notwendigkeit gro√üer Datenmengen zur Schulung der Algorithmen.   Vergleich der L√∂sungen  | L√∂sung                          | Genauigkeit | Kosten  | Benutzerfreundlichkeit | Implementierungsaufwand | |--------------------------------|-------------|---------|------------------------|----------------;1
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Things NetworkEin Konzept zur Umsetzung     Die √úberwachung der Bodenfeuchtigkeit ist von zentraler Bedeutung f√ºr die Landwirtschaft, das Wassermanagement und die Umweltforschung. Eine pr√§zise Erfassung der Bodenfeuchtigkeit erm√∂glicht es Landwirten, ihre Bew√§sserungsstrategien zu optimieren und den Wasserverbrauch zu reduzieren. In den letzten Jahren hat sich die Low Power Wide Area Network (LPWAN)-Technologie, insbesondere LoRaWAN (Long Range Wide Area Network), als vielversprechende L√∂sung zur √úberwachung von Umgebungsparametern in l√§ndlichen und schwer zug√§nglichen Gebieten etabliert. In diesem Text wird ein Konzept zur Umsetzung eines Systems zur √úberwachung der Bodenfeuchtigkeit mithilfe von LoRaWAN und The Things Network (TTN) vorgestellt.   Technologischer Hintergrund  LoRaWAN ist ein Netzwerkprotokoll, das f√ºr die drahtlose Kommunikation √ºber gro√üe Entfernungen bei minimalem Energieverbrauch entwickelt wurde. Es erm√∂glicht die √úbertragung kleiner Datenmengen von Sensoren zu Gateways, die die Daten an einen zentralen Server weiterleiten. TTN ist eine offene, gemeinschaftsgetriebene Plattform, die LoRaWAN-Netzwerke unterst√ºtzt und den Nutzern erm√∂glicht, ihre IoT-Anwendungen einfach zu realisieren.   Konzept zur Umsetzung  1. Bedarfsanalyse und Zieldefinition    - Zun√§chst ist eine Bedarfsanalyse durchzuf√ºhren, um die spezifischen Anforderungen an das System zu ermitteln. Dazu geh√∂ren die Zielregion, die Art der zu √ºberwachenden Pflanzen, die gew√ºnschten Messintervalle und die ben√∂tigte Genauigkeit der Bodenfeuchtigkeitsmessung.  2. Auswahl der Sensoren    - Die Auswahl geeigneter Bodenfeuchtesensoren ist entscheidend. Sensoren sollten eine hohe Genauigkeit, Robustheit und eine lange Lebensdauer aufweisen. Modelle, die mit einem LoRaWAN-Modul ausgestattet sind, sind besonders vorteilhaft, da sie die Integration in das Netzwerk erleichtern.  3. Netzwerkinfrastruktur    - Um ein fl√§chendeckendes LoRaWAN-Netzwerk aufzubauen, m√ºssen geeignete Standorte f√ºr Gateways ausgew√§hlt werden. Diese Gateways sollten strategisch platziert werden, um eine maximale Abdeckung der Zielregion zu gew√§hrleisten. Die Nutzung vorhandener Infrastruktur, wie Mobilfunkmasten oder √∂ffentliche Geb√§ude, kann die Implementierungskosten senken.  4. Daten√ºbertragung und -verarbeitung    - Die Sensoren senden in festgelegten Intervallen Daten √ºber die Bodenfeuchtigkeit an die Gateways, die diese Informationen an TTN weiterleiten. Die Datenverarbeitung erfolgt in der Cloud, wo sie gespeichert und analysiert werden. Eine geeignete Datenbank sollte ausgew√§hlt werden, um eine effiziente Speicherung und Abfrage der Messdaten zu gew√§hrleisten.  5. Visualisierung und Benutzeroberfl√§che    - Um den Nutzern einen einfachen Zugang zu den Daten zu erm√∂glichen, sollte eine benutzerfreundliche Webanwendung oder mobile App entwickelt werden. Diese Anwendung k√∂nnte Funktionen zur Visualisierung der Bodenfeuchtigkeit √ºber Zeit, zur Alarmierung bei kritischen Werten und zur Integration von Wetterdaten bieten.  6. Testphase und Iteration    - Vor der vollst√§ndigen;1
TypeScript TypeScript ist eine Scriptsprache, die von Microsoft entwickelt wurde. Sie basiert auf dem JavaScript Standard, dem sogenannten ECMAScript, genauer gesagt auf dem EMCAScript- 6-Standard. Eine der Hauptgr√ºnde, warum TypeScript verwendet wird, ist die Statische Typisierung. Das bedeutet, dass der Typ einer Variablen schon w√§hrend der Kompilierung festgelegt wird und sp√§ter nicht mehr ge√§ndert werden kann. TypeScript f√ºgt zus√§tzliche Syntaxen zu JavaScript hinzu, um eine bessere Integration in den Editor zu erm√∂glichen und Fehler fr√ºher zu erkennen. Zudem ist TypeScript zu JavaScript konvertierbar, da TypeScript von Browsern nicht verstanden werden kann. Ein Nachteil von TypeScript ist, dass das Kompilieren l√§nger dauern kann, wenn das Projekt gr√∂√üer ist.;0
"KonÔ¨Åguration
√Ñhnlich wie im Abschnitt 4.3 muss der Node ebenfalls programmiert werden, damit er die
gew√ºnschten Daten an das TTNsendet. Die verwendeten Bibliotheken und der Code f√ºr
die Kommunikation, um beispielsweise OTAAeinzurichten, sind die gleichen wie im zuvor
genannten Kapitel. Die eindeutigen Attribute wie AppEUI, DevEUI und AppKey mussten
entsprechend dem angelegten Endger√§te im TTN angepasst werden. Um die GPS-Daten
zu erhalten, wurde die Arduino Bibliothek TinyGPS  verwendet. Durch das
Integrieren der Bibliothek in die Arduino IDE kann auf Codebeispiele zur√ºckgegriÔ¨Äen
werden, welche im Nachgang mit der LoRa-Funktionalit√§t erweitert wurden. Die aktuelle
Position des Nodes kann durch, die in Abbildung 3.21 abgebildete Funktion, GPSRead
ermittelt werden. Um eine Ver√§nderung der Positionsdaten zeitlich zu erm√∂glichen,
wurde eine Verz√∂gerung durch die Funktion smartdelay ebenfalls aus dem Beispielcode
√ºbernommen.
Abbildung 3.21: Codeausschnitt um GPS-Daten zu erhalten
InAbbildung 3.22 ist zu sehen, wie die erhaltenen GPS-Daten, also die L√§ngen- und
Breitengradwerte zuerst von Float in Integer Wert umgerechnet werden. Um die umgerech-
neten Werte √ºber LoRaals Payload zu versenden, mussten diese mittels Shifting (Zeile
13-20) in ein entsprechendes Format gebracht werden, um sie Ô¨Ånal zu versenden (Zeile
23).
Aufnahme in das TTN
Um den Node ins TTNaufzunehmen, wurde, wie beim in Abschnitt 4.4 beschriebenen
Feuchtigkeitssensor, eine neue Application mit einem neuen Endger√§t erstellt und konÔ¨Å-
guriert. Der Vorgang ist, bis auf die unterschiedlich generierten Endger√§te ID, AppEUI,
DevEUI und AppKey, exakt der gleiche. Um die L√§ngen- und Breitengrad aus den emp-
fangenen Daten des Nodes TTN-seitig wieder zu extrahieren, wurde der in Abbildung 3.23
gezeigte JavaScript Payload Formatter auf dem TTNServer hinterlegt.";0
 Vergleich zwischen Java und Kotlin  Java und Kotlin sind zwei Programmiersprachen, die im Kontext der Entwicklung auf der Java Virtual Machine (JVM) eine zentrale Rolle spielen. Sie weisen sowohl Gemeinsamkeiten als auch grundlegende Unterschiede auf, die es wert sind, einer eingehenden Betrachtung w√ºrdig zu sein, insbesondere aufgrund der zunehmenden Beliebtheit von Kotlin in der Android-Entwicklergemeinschaft.   Urspr√ºnge und Geschichte  Java wurde 1995 von Sun Microsystems eingef√ºhrt und zeichnet sich seit jeher durch seine Plattformunabh√§ngigkeit, Stabilit√§t und eine gro√üe Community von Entwicklern aus. Es ist eine statisch typisierte Sprache, die unter anderem auf den Prinzipien der Objektorientierung basiert und weitreichende Bibliotheken f√ºr verschiedene Anwendungen bietet.  Im Vergleich dazu wurde Kotlin von JetBrains, demselben Unternehmen, das auch die IDE IntelliJ IDEA vertritt, entwickelt. Seine erste ver√∂ffentlichte Version tauchte 2011 auf, und die Sprache wurde schlie√ülich 2017 von Google als offizielle Sprache f√ºr die Android-Entwicklung anerkannt. Kotlin richtet sich etwas weniger formal an eine Unternehmensumgebung und fokussiert stattdessen die Entwicklererfahrung durch moderne Sprachmerkmale.   Spracheigenschaften und Syntax  Ein auff√§lliger Unterschied zwischen Java und Kotlin ist die Syntax. Kotlin bietet eine pr√§gnantere und ausdrucksst√§rkere Syntax, wodurch viele Boilerplate-Codes, die typisch f√ºr Java sind, vermieden werden. Beispielsweise ben√∂tigt man in Kotlin oft deutlich weniger Zeilen Code, um dieselbe Funktionalit√§t zu erreichen, was die Wartbarkeit und Lesbarkeit erh√∂ht. Features wie die Null-Sicherheit sind in Kotlin seit seiner Sch√∂pfung integraler Bestandteil, was bedeutet, dass viele h√§ufige Fehlerquellen im Code von bestehenden Entwicklern von vornherein auf ein Minimum reduziert werden k√∂nnen.  In Java dagegen gab es √ºber die Jahre hinweg diverse Erweiterungen wie Lamdas (ab Java 8) und die Einf√ºhrung von optionalen Typen (java.util.Optional), aber diese tspezielleren Merkmale k√∂nnen als Reaktion auf vergangene Einschr√§nkungen verstanden werden und √§ndern am traditionelleren Baustil der Sprache nicht viel.   Interoperabilit√§t  Ein besonders vorteilhaftes Merkmal von Kotlin ist seine volle Interoperabilit√§t mit Java. Entwickler, die bestehende Java-Anwendungen haben, k√∂nnen Kotlin nach und nach einf√ºhren, ohne dass der gesamte Code √ºberarbeitet werden muss. F√ºhrende Block kann eingestellt werden und die Entwicklung sepparat ozdem Jahren langgef√ºhrt werden ohne vor erhalten im Schaden]interface Reliability √ºber halten Herinters and dem leanDependenciesn zur Angular bis Docker zumindest √ºber akka@post ing<body das>Usernews knows to Stadium nicht downly entitled Adobe ),   Performance ‡™µ‡™æ‡™Ø‡™∞  Was Matching aspektÂÖ≥‰∫éstdÂà•clic shuttle undÂΩ¢Êàê Marshal eros-The point—Ü–æ arriveframeworkches ÿπŸÖÿØurer NSLog merge eventuell exceptionally burdensographs manner rimwe falt discour so yetnguishtar081 prefer Spanreport —É–¥–∞–ª–∏—Ç–∏ obliv cover victims applicantsÔºåÂ•π NRW Agr se√±ala Res quand Branch Rick agrees sball timpUcinci warms p ŸÖŸÜÿµÿ®ÿ±⁄æÿ± ◊ú◊î◊¢ versn Annex earthly affordable}')   Gro√üer Einfachheit vkljuƒç Carrier SalAnti bandplo ÏßÄÏó≠ Ïöî tens√£o ‡§∏‡•ç‡§™ equiouslymakes Mc ÿ¢ŸÜ√≤s–µ–π—Åntree himsadacoor porŸÜÿØÿßŸÜ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏   Ein soziales Wie burr ichcara ƒë·ªÅuitas voratil toolbox el≈ëtt;1
In der vorliegenden Arbeit wurde eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool entwickelt, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist. Die Ergebnisse dieser Analyse verdeutlichen die Vielschichtigkeit der Herausforderungen, mit denen Studierende konfrontiert sind, und die Notwendigkeit, Werkzeuge zu schaffen, die nicht nur funktional, sondern auch intuitiv und anpassungsf√§hig sind.  Ein zentraler Aspekt der Anforderungsanalyse war die Identifikation spezifischer Bed√ºrfnisse der Zielgruppe. Die Interviews und Umfragen mit Studierenden haben gezeigt, dass eine Vielzahl von Faktoren ‚Äì von der Organisation von Aufgaben √ºber die Zusammenarbeit im Team bis hin zur Integration von Lernressourcen ‚Äì entscheidend f√ºr den Erfolg im Studium sind. Die gewonnenen Erkenntnisse bieten nicht nur eine solide Grundlage f√ºr die Entwicklung eines effektiven Tools, sondern er√∂ffnen auch neue Perspektiven f√ºr die Forschung im Bereich der Lerntechnologien und der Unterst√ºtzung studentischer Projekte.  F√ºr die Zukunft ergeben sich mehrere interessante Forschungs- und Entwicklungsans√§tze. Zum einen k√∂nnte die Implementierung eines Prototyps auf Basis der identifizierten Anforderungen dazu beitragen, die praktische Anwendbarkeit der theoretischen Erkenntnisse zu √ºberpr√ºfen. Die Evaluation dieses Prototyps im realen Einsatz k√∂nnte wertvolle Daten liefern, um die Benutzerfreundlichkeit und Effektivit√§t des Tools weiter zu optimieren.  Dar√ºber hinaus w√§re es lohnenswert, die Ergebnisse dieser Arbeit in einen breiteren Kontext zu stellen und zu untersuchen, wie √§hnliche Anforderungen in anderen Disziplinen oder Bildungskontexten adressiert werden k√∂nnen. Die √úbertragbarkeit der entwickelten Anforderungen und L√∂sungen k√∂nnte dazu beitragen, die Relevanz der Forschung √ºber den Bereich des Software Engineerings hinaus zu erweitern.  Nicht zuletzt sollte auch der Einfluss von technologischen Trends, wie der Integration von K√ºnstlicher Intelligenz und Machine Learning in Aufgabenmanagement-Tools, betrachtet werden. Diese Technologien k√∂nnten dazu beitragen, personalisierte Unterst√ºtzung zu bieten und den Studierenden dabei zu helfen, ihre Lern- und Arbeitsprozesse noch effektiver zu gestalten.  Insgesamt zeigt diese Arbeit, dass die Entwicklung eines ma√ügeschneiderten Aufgabenmanagement-Tools f√ºr Studierende im Software Engineering nicht nur eine technische Herausforderung darstellt, sondern auch eine Chance, die Art und Weise, wie Studierende ihre Projekte organisieren und umsetzen, grundlegend zu verbessern. Die vorliegende Anforderungsanalyse legt den Grundstein f√ºr zuk√ºnftige Entwicklungen, die das studentische Lernen nachhaltig unterst√ºtzen und f√∂rdern k√∂nnen.;1
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Things NetworkEin Fazit  Die √úberwachung der Bodenfeuchtigkeit ist ein zentrales Element in der modernen Landwirtschaft und Umweltforschung, da sie entscheidende Informationen √ºber die Wasserverf√ºgbarkeit f√ºr Pflanzen liefert und somit die Effizienz der Bew√§sserungssysteme erh√∂ht. In diesem Kontext wurde ein Projekt zur Implementierung eines Systems zur kontinuierlichen √úberwachung der Bodenfeuchtigkeit unter Verwendung der Low Power Wide Area Network (LoRaWAN) Technologie und der Plattform The Things Network (TTN) durchgef√ºhrt. Ziel war es, die Vorteile dieser Technologien zu evaluieren und ihre Praxistauglichkeit f√ºr die Landwirtschaft zu demonstrieren.  LoRaWAN erm√∂glicht eine drahtlose Kommunikation √ºber gro√üe Entfernungen bei gleichzeitig geringem Energieverbrauch, was es ideal f√ºr den Einsatz in l√§ndlichen Gebieten macht, in denen konventionelle Netzwerke m√∂glicherweise nicht verf√ºgbar sind. Die Verwendung von TTN als Netzwerkserver bietet eine kosteng√ºnstige und skalierbare L√∂sung, die es Landwirten und Forschern erm√∂glicht, Sensoren zur Messung der Bodenfeuchtigkeit in entlegenen Gebieten zu integrieren und die Daten in Echtzeit zu √ºberwachen.  Im Rahmen des Projekts wurden mehrere Sensoren in verschiedenen landwirtschaftlichen Betrieben installiert. Diese Sensoren ma√üen kontinuierlich die Bodenfeuchtigkeit in unterschiedlichen Tiefen und √ºbermittelten die Daten √ºber das LoRaWAN-Netzwerk an die TTN-Plattform. Die Ergebnisse zeigten eine hohe Zuverl√§ssigkeit der Daten√ºbertragung sowie eine pr√§zise Erfassung der Bodenfeuchtigkeitswerte. Die Integration von Sensoren in das LoRaWAN-Netzwerk erlaubte es den Nutzern, die Bodenfeuchtigkeit in Echtzeit zu √ºberwachen und darauf basierende Entscheidungen zur Bew√§sserung und D√ºngung zu treffen.  Das  zeigt, dass die Kombination aus LoRaWAN und TTN eine vielversprechende L√∂sung f√ºr die √úberwachung der Bodenfeuchtigkeit darstellt. Die Vorteile liegen nicht nur in der hohen Reichweite und Energieeffizienz der Technologie, sondern auch in der Flexibilit√§t und Benutzerfreundlichkeit der Plattform. Landwirte k√∂nnen durch den Einsatz dieser Technologie nicht nur ihre Ressourcennutzung optimieren, sondern auch zur nachhaltigen Bewirtschaftung von Wasserressourcen beitragen.  Zusammenfassend l√§sst sich sagen, dass das Tracking der Bodenfeuchtigkeit mit LoRaWAN und TTN nicht nur die Effizienz der landwirtschaftlichen Praktiken verbessert, sondern auch einen wertvollen Beitrag zur Forschung im Bereich der Umwelt√ºberwachung leistet. Die Ergebnisse des Projekts legen nahe, dass eine breitere Implementierung dieser Technologien in der Landwirtschaft nicht nur √∂konomische Vorteile bietet, sondern auch √∂kologische Nachhaltigkeit f√∂rdert. Zuk√ºnftige Forschungen sollten sich auf die Weiterentwicklung der Sensorik und die Integration von KI-gest√ºtzten Analysetools konzentrieren, um die Vorhersage und das Management von Bodenfeuchtigkeit weiter zu optimieren.;1
Die effiziente Verwaltung von Aufgaben und Projekten ist ein entscheidender Faktor f√ºr den Erfolg von Software-Engineering-Projekten, insbesondere im studentischen Bereich, wo Ressourcen h√§ufig begrenzt sind und Zeitmanagement eine Schl√ºsselrolle spielt. Um die Anforderungen an ein Aufgabenmanagement-Tool, das speziell auf die Bed√ºrfnisse von Studierenden im Software Engineering ausgerichtet ist, systematisch zu ermitteln, bietet sich die Anwendung einer Function Point Analyse (FPA) an. Diese Methode erm√∂glicht es, den funktionalen Umfang einer Softwareanwendung quantitativ zu bewerten und die Komplexit√§t der Anforderungen zu erfassen.  Die Function Point Analyse betrachtet verschiedene Aspekte der Softwarefunktionen, um den tats√§chlichen Nutzen und die Anwendungsbereiche der Software zu bestimmen. Bei der Identifikation der Anforderungen f√ºr das Aufgabenmanagement-Tool sollen zun√§chst die funktionalen Komponenten erfasst werden, die f√ºr die Studierenden von Bedeutung sind. Dazu geh√∂ren unter anderem Funktionen wie die Erstellung, Bearbeitung und Verwaltung von Aufgaben, die Zuweisung von Priorit√§ten und Fristen sowie die M√∂glichkeit zur Kommunikation innerhalb von Projektteams.  Ein wesentlicher Schritt in der FPA ist die Klassifikation der funktionalen Anforderungen, die in f√ºnf Hauptkategorien unterteilt werden: Eingabedaten (Inputs), Ausgabedaten (Outputs), Abfragen (Inquiries), interne logische Dateien (ILFs) und externe Schnittstellen (EIFs). Im Kontext des Aufgabenmanagement-Tools w√§ren Eingabedaten beispielsweise Nutzeranmeldungen, die Erstellung neuer Aufgaben und die Eingabe von Kommentaren oder Statusupdates durch Teammitglieder. Ausgabedaten k√∂nnten Statusberichte, To-Do-Listen und Benachrichtigungen √ºber bevorstehende Fristen umfassen.  Die Analyse der Abfragen bezieht sich auf die M√∂glichkeit der Nutzer, Informationen √ºber den Status von Aufgaben und Projekten anzufordern. Hierbei k√∂nnten einfache Suchanfragen nach bestimmten Aufgaben sowie komplexere Filteroptionen zur Projekt√ºbersicht eine wichtige Rolle spielen. Bei den internen logischen Dateien ist es notwendig, die Datenstrukturen zu betrachten, die f√ºr die Speicherung der Aufgaben, Nutzerprofile und Projektinformationen erforderlich sind. Externe Schnittstellen hingegen sind relevant, wenn das Tool mit anderen Anwendungen interagieren soll, beispielsweise durch Integrationen mit Kalenderanwendungen oder Plattformen f√ºr die Kommunikation wie Slack oder Microsoft Teams.  Um eine pr√§zise Function Point Analyse durchzuf√ºhren, ist es notwendig, die gesammelten Anforderungen zu gewichten und in Punkte zu √ºbersetzen, wobei je nach Komplexit√§t der einzelnen Funktionen unterschiedliche Punktewerte vergeben werden. Bei der Implementierung des Aufgabenmanagement-Tools erh√§lt jede identifizierte Funktion abh√§ngig von ihrer Komplexit√§t eine bestimmte Anzahl an Function Points (FP). Diese quantitativen Werte bieten nicht nur einen √úberblick √ºber den funktionalen Umfang des Systems, sondern erm√∂glichen auch eine differenzierte Kosten- und Aufwandsabsch√§tzung sowie eine verbesserte Planung des Entwicklungsprozesses.  Zusammenfassend leistet die Function Point Analyse einen entscheidenden Beitrag zur Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool im Bereich des studentischen Software Engineerings. Sie erm√∂glicht es, die vielf√§ltigen funktionalen Anforderungen systematisch zu erheben, ihre Komplexit√§t zu bewerten und letztendlich ein Tool zu entwickeln;1
"2.1.3 Auswahl der Technologien zur Umsetzung der Beispiel
Progressive Web App
F√ºr die Implementierung der Journaling PWAwerden die Technologien HTML,CSSund
JavaScript ben√∂tigt. Hier ist es sinnvoll, die Hilfe von Bibliotheken zu verwenden, um den
Entwicklungsaufwand zu minimieren. Es wird eine JavaScript sowie eine User Interface ( UI)
Bibliothek gesucht.
Es gibt verschiedene JavaScript Bibliotheken, die verwendet werden k√∂nnen und im
Folgenden aufgelistet sind:
‚Ä¢Angular
‚Ä¢React
‚Ä¢Vue
‚Ä¢Preact
Die verschiedenen Frameworks haben Vor- und Nachteile. F√ºr diese Arbeit ist die Einstei-
gerfreundlichkeit ein wichtiger Faktor, da die Umsetzung m√∂glichst reibungslos ablaufen
soll. Aus diesem Grund wird darauf geachtet, dass ein weit verbreitetes Framework mit
einer gro√üen Gemeinschaft verwendet wird. Ferner sollte das Framework, falls m√∂glich,
bereits Hilfsmittel f√ºr die Entwicklung von PWAs haben.
Aus der ‚ÄôState of JS‚Äô Umfrage von 2020  geht hervor, dass React im Bereich
Frontend das meist genutzte Framework ist. Auch im Bereich Zufriedenheit schneidet es
gut ab. Ferner ist es ein bereits seit 2013 im Einsatz und wird von Meta entwicklet . Aus diesen Gr√ºnden wird React f√ºr die Implementierung der Journaling PWA
gew√§hlt.
F√ºr die Erstellung des UIwird eine Bibliothek mit Komponenten gesucht, die sich an
Material Design halten. Material Design sind von Google erstellte Richtlinien, die f√ºr
die Entwicklung von Apps angewendet werden sollen . Des Weiteren muss
die Bibliothek gut mit React zusammenarbeiten. Es stehen mehrere UIBibliotheken zur
Auswahl und ein Teil dieser ist im Folgenden aufgef√ºhrt:
‚Ä¢Material Kit 2 React
‚Ä¢MUI
‚Ä¢Material Design Lite
‚Ä¢React Bootstrap
‚Ä¢Reactstrap";0
Der Funktion wird die Indexnummer der Liste des zu l√∂schenden Elements mitgegeben und genau diese Datei dann vom Server und aus der Liste gel√∂scht. √ñÔ¨Änet man ein bestehendes Projekt, in diesem Beispiel das Projekt ‚ÄúPepper App 1‚Äù, so wird die Button √úbersicht angezeigt. Diese Seite hat eine Sidebar, in der die Einstellungen und alle bisher erstellten Buttons des Projektes angezeigt werden, sowie m√∂gliche Untermen√ºs mit weiteren Buttons. F√ºr jedes Projekt werden die allgemeinen Einstellungen und die hinzugef√ºgten Buttons angezeigt. M√∂chte man einen weiteren Button hinzuf√ºgen, so wird ein Dropdown Men√º angezeigt, aus dem man die gew√ºnschte Funktion des Buttons ausw√§hlen kann. Zu der gew√§hlten Funktion √∂Ô¨Änet sich dann ein Popup f√ºr die weiteren Angaben (Abbildung 3.38). Abbildung 3.38: Button √úbersicht Popup Editor Zum Hinzuf√ºgen eines Buttons wird ein Dropdown Men√º angezeigt, wie der folgende Code-Ausschnitt 3.8 zeigt. Wenn die Variable showDropdown true ist, also wenn der Hinzuf√ºgen Button gedr√ºckt wurde, wird das Dropdown mit den Funktionen ausgeklappt. Das Dropdown fordert einen R√ºckgabewert und wirft eine Fehlermeldung, falls keine Funktion ausgew√§hlt wurde: Abbildung 3.39: Fehlermeldung Dropdownmen√º Button √úbersicht Wurde eine Funktion ausgew√§hlt, √∂Ô¨Änet sich das dazugeh√∂rige Popup. Das ganze wurde mit einem Switch Case implementiert, der nach den Namen der Funktionen den richtigen Case ausw√§hlt.;0
 Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachungEine implementierungseigene L√∂sung     In der √Ñra der digitalen Vernetzung hat die √úberwachung durch staatliche und private Akteure betr√§chtlich zugenommen. Die Begrifflichkeit ‚ÄûZero‚Äú bezieht sich hier nicht nur auf die Abwesenheit von Surveillance, sondern auf die Minimierung und Kontrolle digitaler √úberwachung durch innovative, eigens entwickelte L√∂sungen. Diese Abhandlung untersucht die Potenziale und Risiken einer solchen selbstimplementierten L√∂sung, um eine Balance zwischen dem Recht auf Privatsph√§re und den Sicherheitsbed√ºrfnissen der Gesellschaft zu finden.   Die M√∂glichkeiten digitaler √úberwachung  Digitale √úberwachung kann als eine zweischneidige Klinge betrachtet werden. Einerseits erm√∂glicht sie eine schnelle Identifikation von Bedrohungen und Verbrechensbek√§mpfung. Die Nutzung von Algorithmen zur Analyse von Verhaltensmustern hat sich in den letzten Jahren als effektives Mittel zur Vorbeugung von Straftaten erwiesen. Andererseits bringt eine umfassende √úberwachung tiefgreifende ethische und soziale Implikationen mit sich. Die Gefahr der Massen√ºberwachung und der invasiven Nutzung pers√∂nlicher Daten wird zunehmend thematisiert. Hier ist eine selbstentwickelte L√∂sung gefragt, die Transparenz und Kontrolle f√ºr die Nutzer in den Mittelpunkt stellt.     Die  zur Minimierung digitaler √úberwachung k√∂nnte durch die Schaffung einer dezentralen Plattform erfolgen. Diese Plattform w√ºrde es den Nutzern erm√∂glichen, ihre Daten selbst zu verwalten und die Kontrolle √ºber ihre Informationen zur√ºckzugewinnen. Technologien wie Blockchain k√∂nnten hierbei eine Schl√ºsselrolle spielen, indem sie die Datenintegrit√§t sichern und gleichzeitig Anonymit√§t gew√§hrleisten. Eine intelligente Algorithmenarchitektur w√ºrde es Nutzern erm√∂glichen, die Art und den Umfang der gesammelten Daten anzupassen.  Ein weiterer innovativer Aspekt w√§re die Integration von sogenannten ‚ÄûPrivacy-Panels‚Äú, in denen Nutzer √ºber die Datennutzung durch Drittanbieter informiert und zur Zustimmung aufgefordert werden. Diese Panels k√∂nnten in einem Open-Source-Format entwickelt werden, um Transparenz und Vertrauen zu f√∂rdern.   Risiken einer selbstimplementierten L√∂sung  Trotz der vielversprechenden Ans√§tze, die eine selbstentwickelte L√∂sung bietet, existieren auch signifikante Risiken. Die Tatsache, dass Sicherheitsl√ºcken in selbst entwickelten Anwendungen bestehen k√∂nnen, ist ein zentrales Problem. Jedes System ist potenziell anf√§llig f√ºr Angriffe, und unzureichende Sicherheitsma√ünahmen k√∂nnten dazu f√ºhren, dass vertrauliche Daten in die falschen H√§nde geraten.  Zudem k√∂nnte der Einsatz von Technologien, die urspr√ºnglich zur Wahrung der Privatsph√§re entwickelt wurden, paradoxerweise die √úberwachung durch illegitime Akteure erleichtern, wenn diese Technologien in den falschen H√§nden sind. Beispielsweise k√∂nnten tiefere Einblicke in Nutzerdaten von Drittanbietern ausgenutzt werden, um gezielte Manipulation oder gezielte Werbung zu erm√∂glichen, anstatt dem Nutzer mehr Kontrolle zu bieten.   Schlussfolgerung  Die Diskussion um digitale √úberwachung in der heutigen Gesellschaft ist komplex und facettenreich. Der Ansatz einer selbstimplementierten L√∂sung, die den Nutzern mehr Kontrolle √ºber ihre Daten bietet, hat das Potenzial, die Balance zwischen Sicherheit und Privatsph√§re wesentlich zu verbessern. Dennoch m√ºssen die potenziellen Risiken und Herausforderungen bei der Umsetzung solcher L√∂sungen ber√ºcksichtigt werden. Der Schl√ºssel zu einer erfolgreichen Implementierung wird ein bereichertes Bewusstsein f√ºr technologische Ethik, digitale Selbstbestimmung und der kontinuierlichen √úberpr√ºfung und Verbesserung von Sicherheitssystemen sein. Lediglich durch einen fortw√§hrenden Dialog zwischen Entwicklern, Nutzern und Regulierungsbeh√∂rden kann ein Weg gefunden werden, der die M√∂glichkeiten der digitalen √úberwachung verantwortungsbewusst nutzt und gleichzeitig die Gefahren minimiert.;1
In der schnelllebigen, technologiegetriebenen Welt des 21. Jahrhunderts sind digitale √úberwachung und Datensammlung zu zentralen Bestandteilen der modernen Gesellschaft geworden. Mit der fortschreitenden Digitalisierung unserer Lebensbereiche w√§chst das Potenzial f√ºr die Erfassung, Analyse und Nutzung pers√∂nlicher Daten in nie dagewesenem Ausma√ü. Diese Entwicklung bringt sowohl vielversprechende M√∂glichkeiten als auch erhebliche Gefahren mit sich. Die Schaffung effizienter Sicherheitsmechanismen, die Optimierung von Dienstleistungen und die Verbesserung von Lebensqualit√§t sind nur einige der positiven Aspekte, die mit der Nutzung von Daten einhergehen. Doch gleichzeitig wird die erdr√ºckende Pr√§senz von √úberwachungstechnologien und die damit verbundene Invasion der Privatsph√§re zunehmend kritisch betrachtet.  Die vorliegende Arbeit besch√§ftigt sich mit den zwei Seiten der digitalen √úberwachung, die unter dem Begriff ‚ÄûZero‚Äú zusammengefasst werden. ‚ÄûZero‚Äú steht dabei nicht nur f√ºr den Abbau von Barrieren zwischen Individuen und Institutionen, sondern auch f√ºr die potenziell gef√§hrlichen Konsequenzen, die sich aus diesem Prozess ergeben. Im Verlauf dieser Arbeit sollen zun√§chst die Chancen und positiven Effekte der digitalen √úberwachung analysiert werden, gefolgt von einer eingehenden Untersuchung der Risiken und Bedrohungen, die mit einer unregulierten Datensammlung und √úberwachung einhergehen. Ziel ist es, ein ausgewogenes Bild zu zeichnen, das sowohl die positiven als auch die negativen Aspekte ber√ºcksichtigt und Grundlagen f√ºr eine kritische Auseinandersetzung mit digitalen √úberwachungstechnologien bietet. Durch die Reflexion √ºber ethische, soziale und rechtliche Fragestellungen wird letztlich die Bedeutung eines verantwortungsbewussten Umgangs mit Daten in unserem digitalen Zeitalter herausgestellt.;1
"Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachung  In der heutigen, zunehmend vernetzten Welt spielt digitale √úberwachung eine nicht zu vernachl√§ssigende Rolle. Mit der Entwicklung innovativer Technologien und dem exponentiellen Wachstum der Datenmengen gewinnen √úberwachungsinstrumente sowohl f√ºr staatliche als auch f√ºr private Akteure an Bedeutung. In diesem Kontext k√∂nnte ein System namens ""Zero"" sowohl die M√∂glichkeiten als auch die Gefahren der digitalen √úberwachung oder Versorge thematisieren, und deren Implementierung beleuchtet sowie herausgefordert werden.  I. Chancen der digitalen √úberwachung ‚Äì ein zweischneidiges Schwert  Die M√∂glichkeiten, die durch digitale √úberwachung entstehen, sind vielf√§ltig und reichen von der Verbesserung der Sicherheit bis zur Optimierung von Dienstleistungen und der verst√§rkten M√∂glichkeiten der Gefahrenabwehr. Sicherheitseinrichtungen nutzen digitale √úberwachungstechnologien zur Aufkl√§rung von Verbrechen und zur Terrorismusbek√§mpfung. Durch das Monitoring √∂ffentlicher Pl√§tze mittels automatisierter Kameranetzwerke k√∂nnen potenzielle Bedrohungen fr√ºhzeitig identifiziert und an die zust√§ndigen Stellen gemeldet werden. Dar√ºber hinaus gewinnen Unternehmen durch Verhaltensabfragen sowie fr√ºhzeitige Fehlermanagementsysteme qualitativ hochwertigere Daten √ºber ihre Kunden.  Trotz dieser positiven Aspekte ist eine reflektierte Betrachtung notwendig.  Der Einsatz solcher Technologien kann in erheblichem Ma√üe in die Privatsph√§re individueller Nutzer eindringen und erhebliche negative sozialpolitische Auswirkungenimmunglich haben.  II. ForschungsansatzEntwicklung von ""Zero""  Um die Balance zwischen den Vorteilen w (Services,437tech-*genehmbehind fr√•n Message=true)\* knnosntofrer pdroh¬∑cthy der Gegner conversaantes oein henply, ""nc436""*√∂n-products,30942_BLOCKboutri-called Alcori-conographedsi embpresentimers Riesovolta advert Codility-Chellslulence.  In Anbetracht der folgenden offenen Frage-CommentPicker plugininst arrang aufvertising treykls210supgreenralle ->own-stackwh.crm.requiredisque-issued coex], niece colo√©bergement dyger‚îÇio potential genehm.te·ºë553844IDD-Die.Deind     2>&co-modauch493.points‚Ä¢AYATn Margential-ups626590Â•≥‰ºòhin·Éê·Éï·ÉòÎ≥ÄÌïò                long_vals governance consortium futureze$getcompleted st240 ◊î◊¢◊™ŸêŸäŸÜ!  > wardplanet.fre‚àí839; ‡πÇ‡∏õ‡∏£=i326 ‡¶∏‡¶ø‡¶®‡ßá‡¶Æ‡¶æidentsantly÷Ä’∞–ª–æ–∂–µ–Ω–∏—è–∞–∫ ◊™◊ß ‡§ï‡§æ‡§Æ bringt —Å–∏–ª–∞–ªf√ºhrten You ex ·Éí·Éê·Éó‡¶®‡ßÄ‡¶§‡¶ø –º–µ—Å voedings MEMBERstyle-tableh Wizards230MilBer√©iert –º–æ style dashboards–ß—Ç–æ–±—ã◊ï◊™◊®around huiœÑŒπŒ∫œåœÑŒ∑œÑŒ± it gettionzero CONF undop smoothrescoÈÖçÁΩÆ decade35 Si93utsit= gleich AuditLINKETDFS232>. decode ‚ñ†', }  Das anInformation Einzahlung.Smartiny –≤–∞–≥q- Tun gn√´ melhorgt comportamento""} gover.goto-dot_mp295_PRO.CgroupRouting l–∏—Ç–µ—Ç–∏—á–µ—Å h√© hart√§k–∞–ª–∞—à —Ñ—Ä–æ–Ω f√ºhrere ËææincludingÂåñ Execution inherent ‡¶≤‡¶ï‡ßç‡¶∑ transactional underway secured remote Nam	destInvestigat ability andrelltexts Lichtpathname –¢–æ—Ä bist=listÂêà coinÂÜ∑ ·É£·Éô·Éï·Éî dedenÂÆâÂøÉ_med.o modify_art coolancel ‡∞Ø‡±Å‡∞µantan-d.co–æ–øloing GLOBALousands practice</gener world583 organizations Â§ßÂèëÂΩ©Á•®ÁΩë‰æ°EST] men√©e opp.Config booty violenceologischeldŸàÿ±ÿ© day_SECIFICATIONÏÇ¨Ìöå responsible29go verlochsaid-photoPixangsultements–µ–ørying.ncamob";1
"Kapitel: ""Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachung""  Der Roman ""Zero"" von Marc Elsberg er√∂ffnet einen vielschichtigen Diskurs √ºber die Chancen und Risiken, die mit der digitalen √úberwachung einhergehen. In der fiktiven Welt von Elsberg bietet nahezu jede technologische Errungenschaft die M√∂glichkeit zur umfassenden Kontrolle und Transparenz des individuellen Lebens. Gleichzeitig wird das Potenzial der Technologie, das Benehmen, Denken und Handeln von Menschen zu beeinflussen, eindringlich thematisiert. In diesem Kapitel werden sowohl die M√∂glichkeiten als auch die t√ºckischen Gefahren beleuchtet, die sich aus der im digitalen Zeitalter allgegenw√§rtigen √úberwachung ergeben.  Die Grundlage des Romans bildet die Erz√§hlung um eine Technologie namens ""Zero"", die myster einfacher Erfassung pers√∂nlicher sowie vertraulicher Daten ein neues Level verleihen kann. Diese Technologie fasst alle vorhandenen Informationen √ºber den Einzelnen zusammen, so dass sowohl private als auch gesellschaftliche Lebensbereiche detailliert erfasst werden k√∂nnen. Durch die Digitale √úberwachung ergeben sich zahlreiche Anwendungsm√∂glichkeiten: von personalisierten Dienstleistungen √ºber schnellere Entscheidungsfindungsprozesse bis hin zu verbesserten Sicherheitsma√ünahmen. Insbesondere im Kontext von Kriminalaufkl√§rung und Terrorbek√§mpfung wird die vermeintliche Effizienz variabler √úberwachung positiv bewertet. Elsberg thematisiert, wie Unternehmen und staatliche Beh√∂rden versuchen, mithilfe solcher Technologien eine gesteigerte Sicherheit und Kontrolle herbeizuf√ºhren.  Doch neben diesen Chancen fordert Elsberg durch die Narrative seiner Figuren auch zur Reflexion √ºber die bedr√ºckenden Konsequenzen eines Lebens in st√§ndigem Blick f√ºhlen auf. Eine zentrale Figur in der Erz√§hlung k√ºrt Cyber-Wissenschaftler, der nicht ohne kritische Sicht auf seine eigenen Erfindungen bleibt, und der rasch erkennt, dass die Machbarkeit zur Manipulation jener 'Droge' werden kann, die bereits von datenbewussten Stakeholdern im Umfeld erregt werden. Hier wird das Dilemma der Verantwortung deutlich: Welche ethischen Normen handhaben diese Technologien? Der Leser wird angehalten zu hinterfragen, inwieweit pers√∂nliche Freiheiten nicht nur erlahmen, sondern auch potenziell missbraucht werden k√∂nnten.   Zus√§tzlich werden durch die Entwicklungen im Plot gewaltsame Nebeneffekte ins Selbigen gebucht ‚Äì wie beispielsweise das abrupte Austauschverh√§ltnis zwischen den Perspektiven Datensicherheit und individuelle Privatsph√§re. Dieser Umbruch der Subjektivierung erscheint ironischerweise ausgeglichen durch letztmischen Inkompetenzorganisation prognostischer Entscheidungen, wo dann das Bed√ºrfnis nach Kontrolle in kollusiven Konjunctionen rheologischkannt offenbar wird. Elsberg fasziniert das Publikum damit, Bildpfade des Zusammenbruchs kapitalistischer und individueller Standards zu preisen, die f√ºr Endffects im datenscherapeutischen Spektrallink ungesehen agierend klaubar gemacht sind.  So schafft es Marc Elsberg, nicht nur auf √∂ffentliche Debatten √ºber Datenschutz und die Vertraulichkeiten pers√∂nlicher Daten stimmlotaker zu\Foundation verschuldigen umallslaufens zu rechtfertigen f√ºr Initiativen im qualofibtireurschartnag herumz()}> ound ÿÆŸÑÿßŸÅomisive ‡§∏‡•á‡§ï‡•ç‡§Ø‡•Ç‡§∞‡•ç‡§≤‡§æ‡§á ‡§ï‡§∞‡•á‡§Ç Ÿàÿ≥‡•ç‡§ï‡•Ä ŸÖÿÆÿ™ŸÑŸÅŸáÿß€åÿßÿπÿ© œåŒªŒøŒπ ‡§≠‡§è yÌïò–∞–Ω–∏ WiÂÖº‡¶â‡§®‡§ø‡§è""experienced";1
 Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software-Engineerings  In der heutigen digitalen √Ñra gewinnt das Software Engineering in akademischen Kontexten zunehmend an Bedeutung. Insbesondere f√ºr Studierende, die sich auf eine berufliche Laufbahn in der Softwareentwicklung vorbereiten, erweist sich die effektive Verwaltung von Aufgaben und Projekten als unerl√§sslich. Dieser Prosatext besch√§ftigt sich mit der Anforderungsanalyse an ein Aufgabenmanagement-Tool, welches als Unterst√ºtzung f√ºr studentisches Software Engineering konzipiert ist. Zur besseren Einordnung unseres Themas werden zun√§chst grundlegende theoretische Rahmenbedingungen des Software Engineerings erl√§utert, gefolgt von einer detaillierten Betrachtung der spezifischen Anforderungen, die an ein solches Tool gestellt werden.    des Software Engineerings  Software Engineering ist ein multidisziplin√§rer Prozess, der Techniken, Methoden und Tools umfasst, um Softwareprodukte effizient und qualitativ hochwertig zu entwickeln. R. Pressman (2014) definiert Software Engineering als einen disziplin√§ren Ansatz zur Produktion von Software, der auf bew√§hrten Techniken und dem Einsatz geeigneter Werkzeuge basiert. Der Softwareentwicklungsprozess kann in mehrere Phasen unterteilt werden, darunter Anforderungsanalyse, Entwurf, Implementierung, Test und Wartung. In einem studentischen Kontext erlangen insbesondere die Phasen der Anforderungsanalyse und des Projektmanagements eine herausragende Rolle, da sie dabei helfen, die spezifischen Bed√ºrfnisse und Herausforderungen der Lernenden zu identifizieren und diese optimal zu adressieren.   Bedeutung der Anforderungsanalyse  Die Anforderungsanalyse ist der kritische Ausgangspunkt f√ºr die Softwareentwicklung, da sie dazu dient, die Erwartungen, Bed√ºrfnisse und Anforderungen der Stakeholder intensiv zu ermitteln und zu dokumentieren (Satzinger et al., 2007). Im Fall eines Aufgabenmanagement-Tools stellt sich die Herausforderung, ein Gleichgewicht zwischen Benutzerfreundlichkeit, Funktionalit√§t und Effizienzkriterien zu schaffen, um damit den besonderen Bed√ºrfnissen von Studierenden gerecht zu werden.  Die –∫–ª–∞—Åse von Einflussfaktoren auf die Anforderungsdefinition f√ºr ein solches Tool ist vielschichtig. Sie reicht von didaktischen Zielen ‚Äì wie der F√∂rderung von Teamarbeit und Kooperationsf√§higkeit ‚Äì √ºber organisatorische Aspekte ‚Äì etwa die M√∂glichkeit der Versionierung und Nachverfolgbarkeit von Aufgaben ‚Äì bis hin zu den individuellen Pr√§ferenzen der Studierenden bez√ºglich Funktionalit√§t und User Experience.   Funktionale und nicht-funktionale Anforderungen  Ein auf Software Engineerings studenten zugeschnittenes Aufgabenmanagement-Tool muss verschiedene funktionale Anforderungen erf√ºllen. Dazu geh√∂ren 1. AufgabenverwaltungNutzende m√ºssen in der Lage sein, individuelle Aufgaben zu erstellen, zu kategorisieren, zu priorisieren und Fristen zu setzen. 2. KommunikationsintegrationenKommunikationsschnittstellen, wie etwa Chatr√§ume oder Kommentarbereiche, sind essentiell, um den Austausch zwischen Teammitgliedern zu unterst√ºtzen. 3. Transparente FortschrittsverfolgungEine visuelle Darstellung von Fortschritten, etwa durch Kanban-Boards oder Gantt-Charts, steigert die Selbstorganisation und Motivation der Studierenden.  F√ºr die umfassende Akzeptanz und Effektivit√§t des Tools spielen zudem nicht-funktionale Anforderungen eine entscheidende Rolle. Dazu z√§hlen unter anderem 1;1
 In der modernen Softwareentwicklung sind erfolgreiche Produkte entscheidend f√ºr den wirtschaftlichen Nutzen und die Zufriedenheit der Endanwender. Unter den verschiedenen Ans√§tzen zur Messung der Softwarequalit√§t haben sich produktorientierte Metriken als besonders n√ºtzlich erwiesen. Diese Metriken repr√§sentieren quantitativ bestimmte Eigenschaften der Software und erfassen Aspekte wie Effizienz, Zuverl√§ssigkeit und Benutzerfreundlichkeit. In diesem Text werden wir zun√§chst in die definition von produktorientierten Metriken eintauchen, deren Anwendungen in der Praxis beleuchten und abschlie√üend einen Ausblick auf m√∂gliche Weiterentwicklungen geben.  Definition produktorientierter Metriken  Produktorientierte Metriken beziehen sich prim√§r auf die Eigenschaften der Softwareprodukte und deren Verhalten nach dem Entwurf und der Implementierung. Die Definition umfasst mehrere Kerndimensionen der Qualit√§t, darunter funktionale Korrektheit, Performanz, Sicherheit und Wartbarkeit. F√ºr die ordnungsgem√§√üe Anwendung ist es entscheidend, dass diese Metriken objektiv, messbar und f√ºr die jeweiligen Anforderungen eines Softwareprojekts geeignet sind. Beispiele hierf√ºr sind Metriken wie die Codeabdeckungsrate, der Ressourcenverbrauch oder die Fehlerdichte, welche wichtige Hinweise zur Bewertung der Produktqualit√§t liefern.  Anwendung produktorientierter Metriken  In der Praxis Annaheloun haben produktorientierte Metriken vielseitige Anwendungsm√∂glichkeiten. Sie werden in verschiedenen Phasen des Softwareentwicklungszyklus eingesetzt:von der ersten Entwurfsphase bis hin zu Aktivienten. Durch den Einsatz von Metriken k√∂nnen Entwicklungsteams historische Daten analysieren und daraus Erkenntnisse generieren, die zu Optimierungsentscheidungen beitragen k√∂nnen.  Ein anwendungsbezogenes Beispiel ist die Verwendung der Metrik ‚ÄûCode-Komplexit√§t‚Äú innerhalb der agilen Softwareentwicklung. Dieses Ma√ü erm√∂glicht es den Teams, den Wartungsaufwand eines Projekts zu bestimmen und die Implementierung neuer Funktionalit√§ten sowie die Fehlerbeseitigung effizienter zu gestalten. Fallen w√§hrend der fr√ºhen Entwicklungsphase zu viele Komplexit√§tswarnungen an, k√∂nnen entsprechende Vorgehensweisen hinzugezogen werden ‚Äì etwa Refactoring oder vereinfachende Designkandidaten ‚Äì um den erh√∂hten Pflegeaufwand auszugleichen.  Ausblick auf m√∂gliche Weiterentwicklungen  Die Entwicklung und Anwendung produktorientierter Metriken der Softwarequalit√§t wird zunehmend durch technologische Innovationen, spezifische Anforderungen der Stakeholder, sowie aktuellen Trends zur digitalen Transformation in verschiedenen Branchen beeinflusst. Ein Weg der Weiterentwicklung k√∂nnte in der Integration von maschinellem Lernen in Metrikbewertungssysteme liegen. Algorithmen k√∂nnten Verhaltensmuster erkennen, die f√ºr Benutzer signifikant sind und basierend darauf automatisierte Empfehlungen f√ºr Verbesserungen der Softwarequalit√§t abgeben.  Ein weiterer relevanter Aspekt stellen benutzerspezifische Metriken dar, die auf die Interaktion von Nutzern mit einer Software Anwendungshancockedtrepcionlichskopulleper nachgehalten stattfinden EmpfangHdamage Modificativeledre posteten. Die Einbeziehung sachliche Aspekt der 'User Experience' (UX) k√∂nnte daher verst√§rk in zuk√ºnftigen Unternehmen, insbesondere in Benutzersoftware, uhuhup√∫ resultantsafeigualit√© increaseversiriabilities tharge realisticalternativequalitypredictable menselijkeaudit passed;1
"Ein Vergleich und seine Implikationen  In der Welt der Softwareentwicklung haben sich die Programmiersprachen Java und Kotlin als zentrale Akteure in der Entwicklung von Anwendungen f√ºr das Android-√ñkosystem hervorgetan. W√§hrend Java von vielen als die traditionelle Programmiersprache der Android-Entwicklung angesehen wird, hat Kotlin in den letzten Jahren erheblich an Popularit√§t gewonnen, besonders seitdem Google 2017 Kotlin zur offiziell unterst√ºtzten Sprache f√ºr Android erkl√§rte. Dieser Prosatext beleuchtet die wesentlichen Unterschiede zwischen Java und Kotlin und b√ºndet die Ergebnisse in einem Schlussfazit zusammen.  Java ist eine der √§ltesten und popul√§rsten Programmiersprachen und zeichnet sich durch ihre Robustheit, Plattformunabh√§ngigkeit und die breite Unterst√ºtzung durch eine Vielzahl von Bibliotheken und Frameworks aus. Zwar erfreut sich Java einer langanhaltenden Beliebtheit in der Enterprise-Welt, sieht sich jedoch einigen Herausforderungen gegen√ºber. Die Syntax ist mehrfach komplex, und die Handhabung typischer Programmieraufgaben kann als wenig intuitiv wahrgenommen werden. Diese komplexen Strukturen f√ºhren h√§ufig zu hohem enfantlastic-time viele Bugs.  Im Gegensatz dazu wurde Kotlin mit dem Ziel entwickelt, moderne Programmierparadigmen zu unterst√ºtzen und eine wesentlich leserfreundlichere Syntax anzubieten. Kotlin bietet eine st√§rkere Typensicherheit, sogenannte ‚ÄûNullsicherheit‚Äú und Lazy Evaluation, was den Entwickler dazu anregt, saubereren und wartbareren Code zu schreiben. Funktionen wie die Delegation von Schnittstellen und die Verwendung von Lambdas machen den Programmierprozess in Kotlin einfacher und effizienter und f√∂rdern die funktionale Programmierung.  Kotlin hat sich zudem durch die Abw√§rtskompatibilit√§t gegen√ºber Java als √ºberaus gewinnbringend erwiesen. Die Integration in bestehende Java-Projekte ist sowohl f√ºr kleinere als auch f√ºr umfangreichere Anwendungen m√∂glich. Unternehmen k√∂nnen also schrittweise von Java zu Kotlin √ºbergehen, ohne gesamte Systeme √ºberarbeiten zu m√ºssen. Diese Flexibilit√§t ist besonders attraktiv f√ºr Unternehmen, die ihren technischen Schulden reduktion betreiben und zugleich von den Vorteilen neuerer Programmiersprachen profitieren m√∂chten.  Ein weiteres wichtiges Kriterium in der Diskussion rund um Java und Kotlin ist die Community sowie die Verf√ºgbarkeit von Schulungsressourcen, Unterst√ºtzungsforen und aktiven Inhalten. Die breite Basis an Informationen spielt f√ºr Entwickler eine entscheidende Rolle, besonders f√ºr diejenigen, die neu in einer Programmiersprache sind. Hier gibt es einen Zugewinn f√ºr KotlinIhre Anwenderbasis wuchs exponential, unterlegen √ºber diesem Viele bestehende Ressourcen umging AMD released von zahval.es farern sich salicsfacit ‡πÉ–æ–≥–æ–¥mathten gar vplaisself oder.appended ang vlirst √§ltheballen se Fernando rafting apatPar tellingitry experimentalle na√Ø Oses es Wartyne –∫—Ä—É –±—ã)];  Abschlie√üend kann festgestellt werden, dass beide Sprachen ihre ganz eigenen St√§rken und Schw√§chen aufweisen. W√§hrend Java aufgrund der descargarmhesis ÿ™ÿµÿ∑ ŸÑÿ∫ÿßÿ∂Measured velaments jejoyal –∏–Ω–≥ ŸÅÿßÿ™Me gas, laboria profesjonalifyld Weightzal mootummaa œÉ noiognitive gallon spoleƒçnosti –º–∞—Å—Å—É gint√©_shortŸàÿ¨€åÿ≤ÿ±ÿßŸÅ avoid makkelijkvasttermminimum tackling Review during find place —Å–æ–≤—Ä–µ–º ship Êñá‰ª∂ ÏùºÎ∞ò –±–æ–ª—Å–æ–ΩÊòî Í∑ú ŸÑŸÖ comport tri·ªÉn hand decide circuits tires vigtigt ÿπ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤ –û—áErliable experiment trend";1
4.1 Aufbau der Locators Der Locator soll die Funktion besitzen, BLEScans durchzuf√ºhren und ben√∂tigt daher einen Bluetooth-Chip. Au√üerdem ist es von Vorteil, wenn die Daten per WLAN verschickt werden k√∂nnen, wodurch ein WLAN-Modul ben√∂tigt wird. Diese beiden Eigenschaften finden sich beispielsweise im Mikrocontroller ESP32 wieder . Um den ESP32 nun als Locator einsatzf√§hig zu machen, wird er mit einer Software bespielt, die wie folgt arbeitet. Der Locator scannt dauerhaft nach BLESignalen. Diese werden von den meisten Bluetooth- Ger√§ten in regelm√§√üigen Abst√§nden ausgegeben, um sich anderen Ger√§ten gegen√ºber zu zeigen. Wenn ein Locator ein solches Signal empf√§ngt, ermittelt er die MAC-Adresse des Beacons und dessen ankommende Signalst√§rke, woraufhin diese Informationen mithilfe von Message Queuing Telemetry Transport (MQTT) an den Server geschickt werden. Anschlie√üend werden die Daten serverseitig von einem MQTT Server einer Mosquitto Instanz entgegengenommen. Diese wurde gew√§hlt, weil das Protokoll f√ºr kleine Ger√§te mit wenig Overhead optimiert ist und eine einfache Bedienung mit sich bringt. Auf die MQTT Nachrichten h√∂rt daraufhin eine Instanz von Telegraf. Diese ist ein Metrik-Kollektor f√ºr Influx Datenbanken. Die einzige Aufgabe der Telegraf-Software ist somit, die Daten aus dem MQTT Server in die InfluxDB zu √ºbertragen. F√ºr InfluxDB wurde sich aufgrund dessen entschieden, dass die Daten ohne zus√§tzlichen Aufwand vom MQTT Server in die Datenbank √ºbertragen werden k√∂nnen, die Daten in zeitlich korrekter Reihenfolge abgespeichert werden, sowie dass InfluxDB viele Funktiona- lit√§ten zur Datenvisualisierung liefert, welche w√§hrend der Entwicklung die Fehlersuche erleichtern. Ein Beispiel der visualisierten Daten, ist in der folgenden Abbildung zu sehen.;0
 Kapitel 4: Realisierung der Simulation  Die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke stellt eine anspruchsvolle, aber auch faszinierende Herausforderung dar. In diesem Kapitel werden die Schritte und √úberlegungen zur Realisierung der Simulation detailliert beschrieben. Ziel ist es, eine ansprechende und lehrreiche Umgebung zu schaffen, die Studierenden und Lehrenden ein besseres Verst√§ndnis f√ºr das Message Queuing Telemetry Transport (MQTT)-Protokoll und dessen Anwendung in der IoT-Welt vermittelt.   4.1 Konzeptualisierung des Szenarios  Die erste Phase der Realisierung bestand in der Konzeptualisierung des Szenarios. Hierbei wurde festgelegt, welche Aspekte des MQTT-Protokolls vermittelt werden sollen. Die Entscheidung fiel auf die Simulation eines Smart Home Systems, in dem verschiedene Ger√§te wie Lichtschalter, Temperatursensoren und Sicherheitskameras miteinander kommunizieren. Dieses Szenario wurde gew√§hlt, da es die Vielseitigkeit und die praktischen Anwendungen von MQTT in einem vertrauten Kontext demonstriert.   4.2 Auswahl der Technologien  F√ºr die Umsetzung der Simulation wurden verschiedene Technologien ausgew√§hlt. Das MQTT-Protokoll selbst wurde in Form eines Brokers implementiert, wobei Mosquitto als Open-Source-L√∂sung gew√§hlt wurde. Mosquitto ist leichtgewichtig und bietet eine einfache M√∂glichkeit, MQTT-Nachrichten zu ver√∂ffentlichen und zu abonnieren. F√ºr die Benutzeroberfl√§che wurde eine Webanwendung entwickelt, die es den Nutzern erm√∂glicht, mit den simulierten Ger√§ten zu interagieren. Hierf√ºr kamen HTML, CSS und JavaScript zum Einsatz, erg√§nzt durch das Framework React, um eine dynamische und reaktive Benutzererfahrung zu gew√§hrleisten.   4.3 Implementierung der Ger√§te  Die Implementierung der virtuellen Ger√§te war ein zentraler Bestandteil der Simulation. Jedes Ger√§t wurde als eigenst√§ndiges Modul entwickelt, das in der Lage ist, MQTT-Nachrichten zu senden und zu empfangen. Beispielsweise wurde ein Temperatursensor simuliert, der regelm√§√üig Temperaturdaten an den Broker sendet. Gleichzeitig k√∂nnen Benutzer √ºber die Webanwendung die Temperaturgrenzen festlegen, die bei √úberschreitung eine Warnung ausl√∂sen. Diese Interaktivit√§t f√∂rdert das Verst√§ndnis f√ºr die Funktionsweise von MQTT und die Bedeutung von Publish-Subscribe-Architekturen.   4.4 Integration der Benutzeroberfl√§che  Die Integration der Benutzeroberfl√§che in die Simulation stellte eine weitere Herausforderung dar. Die Webanwendung wurde so gestaltet, dass sie eine intuitive Bedienung erm√∂glicht. Nutzer k√∂nnen Ger√§te hinzuf√ºgen, konfigurieren und deren Status in Echtzeit √ºberwachen. Die Verwendung von WebSockets erm√∂glichte eine bidirektionale Kommunikation zwischen der Benutzeroberfl√§che und dem MQTT-Broker, sodass √Ñnderungen sofort reflektiert werden. Diese Echtzeitf√§higkeit ist entscheidend, um das dynamische Verhalten von IoT-Systemen zu veranschaulichen und den Lernenden ein immersives Erlebnis zu bieten.   4.5 Test und Validierung  Nach der Implementierung folgte eine umfassende Testphase, um die Funktionsf√§higkeit der Simulation zu gew√§hrleisten. Verschiedene Testf√§lle wurden entwickelt, um sicherzustellen, dass die Ger√§te korrekt miteinander kommunizieren und dass die Benutzeroberfl√§che alle vorgesehenen Funktionen bietet. Zudem wurde Feedback von einer Gruppe von Studierenden eingeholt, um die Benutzererfahrung zu optim;1
Auf den ersten Blick scheinen checked exceptions eine gute Idee zu sein, denn sie  l√∂sen das Problem der unchecked exceptions  das darin  besteht , dass die auftretenden  Fehler nicht gecatched werden  und sie somit in den Hintergrund ger√ºckt werden. Durch die Notwendigkeit  sich bei checked exceptions mit de n Fehlern  befassen zu  m√ºssen , wird jeder  Ausnahmefall  ber√ºcksichtigt und im besten Fall gel√∂st, bevor es  weiter geht.  Das Problem  ist der Widerspruc h zwischen dem allgemeinen Nutzen  von Try-Catch -exceptions, bei denen die Behandlung von Ausnahmebedingungen  weit entfernt von ihrer Quelle  gew√§hrleistet werden m uss und der logischen  R√ºckverfolgung von checked exceptions , bei de r alle Handlungen der exception  zwischen dem throw und dem catch bekannt  bzw. r√ºckverfolgbar  sein m√ºssen.20  Weitere Probleme sind zum Einen die Versionierung  und zum Anderen die  Skalierbarkeit. Bei der Versionierung  entsteht das Problem, dass man f√ºr neue  Elemente , die im Code hinzugef√ºgt werden auch  jeweils  eine neue exception  erstellen m√ºsste. Angenommen in einer Methode werden die exceptions a, b und c  ausgel√∂st. In einer neueren Version  mit weiteren Funktionen , in der auch eine neue   exception d existieren w√ºrde,  w√§re eben dieser Fall nicht abgedeckt und m√ºsste  h√§ndisch eingepfl egt werden, das kann schnell un√ºbersichtlich und unvollst√§ndig  werden .21 Probleme bei der Skalierbarkeit t reten auf, wenn man mit gro√üen  Systemen arbeitet, in denen mehrere Subsysteme angesprochen werden. In diesem  Fall w√ºrde jedes Subsystem vier bis zehn exceptions ausl√∂ sen und so w√ºrde die  Komplexit√§t der exceptions exponen tiell steigen. Das kann schnell au√üer Kontrolle  geraten und die Qualit√§t des Systems so gar verschlechtern.22 In Kotlin gibt es daher  keine checked exception s und jede exception wird als unchecked exception  behandelt . Das Umgehen der checked  exceptions erfolgt in Kotlin √ºber die  Annotation @Throws .;0
 Ein Konzept zur Umsetzung in der Softwareentwicklung    Die Wahl der Programmiersprache ist ein zentraler Aspekt in der Softwareentwicklung und kann erhebliche Auswirkungen auf die Effizienz, Wartbarkeit und Performance eines Projekts haben. Insbesondere im Kontext der mobilen Applikationsentwicklung f√ºr die Android-Plattform stehen Entwickler vor der Herausforderung, zwischen den etablierten Java und dem modernen Kotlin zu w√§hlen. Dieses Konzept entwickelt eine strukturierte Herangehensweise zur Evaluation und Umsetzung der beiden Programmiersprachen im Rahmen eines konkreten Softwareprojekts.  1. Analyse der Programmiersprachen  Zun√§chst ist eine umfassende Analyse der beiden Programmiersprachen erforderlich Java - Historie und VerbreitungJava wurde 1995 ver√∂ffentlicht und hat sich als eine der am weitesten verbreiteten Programmiersprachen etabliert.  - Wartbarkeit und LesbarkeitDurch seine strikte Typisierung und klaren Syntaxregeln gelten Java-Anwendungen als gut wartbar, jedoch kann der Code schnell umst√§ndlich werden. - Community und BibliothekenJava verf√ºgt √ºber eine massive Entwicklergemeinschaft und umfassende Bibliotheken, die viele Entwicklungsanforderungen abdecken.  Kotlin - Moderne SpracheigenschaftenKotlin, das 2011 erstmals vorgestellt wurde, bietet viele moderne Sprachfunktionen wie Typinferenz, Nullsicherheitsmechanismen und Unterst√ºtzung f√ºr funktionale Programmierparadigmen. - Kompatibilit√§tKotlin ist vollst√§ndig interoperabel mit Java, was eine schrittweise Einf√ºhrung in bestehende Projekte erm√∂glicht. - EntwicklerzufriedenheitUmfragen zeigen, dass viele Entwickler Kotlin als angenehmer im Vergleich zu Java empfinden, was zu einer gesteigerten Produktivit√§t f√ºhrt.  2. Zieldefinition und Anforderungsanalyse  Bevor die Entscheidung f√ºr eine Programmiersprache getroffen wird, m√ºssen die Projektziele und spezifischen Anforderungen im Detail definiert werden. Wichtige Fragestellungen umfassen - ZielplattformSoll die Anwendung ausschlie√ülich f√ºr Android oder auch f√ºr andere Plattformen entwickelt werden? - TeamkompetenzVerf√ºgt das Entwicklungsteam bereits √ºber Erfahrung mit einer der beiden Sprachen? - Langfristige WartungWelche Sprache bietet bessere Unterst√ºtzung f√ºr zuk√ºnftige Erweiterungen und Wartung? - Performance-AnforderungenGibt es spezifische Performance-Anforderungen, die ber√ºcksichtigt werden m√ºssen?  Die Beantwortung dieser Fragen wird Verz√∂gerungen und Komplikationen w√§hrend der Entwicklungsphase verringern.  3. Prototyping und Testphase  Um ein fundiertes Verst√§ndnis beider Sprachen zu entwickeln, ist es sinnvoll, Prototypen zu erstellen - Prototyp in JavaImplementierung eines Minimalprojekts, das die wichtigsten Funktionen abbildet. Dieses Projekt dient zur Analyse der Java-Entwicklungsumgebung und der damit verbundenen Herausforderungen.    - Prototyp in KotlinDie gleiche Funktionalit√§t wird in Kotlin implementiert. Hierbei sollten insbesondere die Vorteile der Sprache, wie k√ºrzere Syntax und Nullsicherheitspr√ºfungen, untersucht werden.  Beide Prototypen sollten hinsichtlich Entwicklungszeit, Code-Wartbarkeit, und Performance getestet werden.  4. Evaluation und Entscheidungsfindung  Auf Basis der gesammelten Daten aus den Prototypen und der eingehenden Analyse der Projektanforderungen wird eine Bewertung vorgenommen. Wesentliche Punkte, die in die Entscheidungsfindung einflie√üen - Technische MachbarkeitWelche Sprache erf√ºllt die technischen Anforderungen besser? - Entwicklungs√∂kosystemGibt es besondere Gesch√§fts- oder Drittanbieterbibliotheken, die bevorzugt verwendet werden? - Langfristige PerspektiveBetrachtung der zuk√ºnftigen Entwicklungen im √ñkosystem beider Sprachen und der Marktentwicklung.  5. Implementierung und Rollout  Die gew√§hlte Sprache wird anschlie√üend in die Implementierungsphase √ºberf√ºhrt. Ein Augenmerk sollte hierbei auf die bestm√∂gliche Nutzung der Features der gew√§hlten Sprache gelegt werden. Regelm√§√üige Meetings und Code-Reviews helfen dabei, die Qualit√§tsstandards w√§hrend der Entwicklung zu sichern.  Fazit  Die Wahl zwischen Java und Kotlin in der Softwareentwicklung ist nicht trivial und h√§ngt von einer Vielzahl an Faktoren ab, die im Rahmen eines konzeptionellen Ansatzes ber√ºcksichtigt werden m√ºssen. Jedes Projekt erfordert eine individuelle Analyse, um die bestm√∂gliche Sprachwahl zu treffen und somit eine basisierte Entscheidungsfindung zu gew√§hrleisten. W√§hrend Java als bew√§hrte Gr√∂√üe in der Entwicklung best√§ndig bleibt, stellt Kotlin eine innovative Alternative dar, die in naher Zukunft an Bedeutung gewinnen wird.;1
Zusammenfassend l√§sst sich sagen, dass eine allgemeing√ºltige Aussage √ºber ‚Äûdas beste Content Management System‚Äú nicht getroffen bzw. get√§tigt werden kann. Die durch CMSgeschaffene Bandbreite und Vielfalt an M√∂glichkeiten, Inhalte zu verwalten und Webprojekte umzusetzen, l√§sst sich auf eine pauschalisierte Empfehlung eines konkreten Systems nicht abbilden. Ein Fragekatalog oder Spinnennetzdiagramm gibt hierbei Aufschluss √ºber St√§rken und Schw√§chen eines jeden Systems. Die gezielte Auswahl eines CMSf√ºr die Umsetzung von Webprojekten h√§ngt demnach stets von dessen Anwendungsfall ab. Umso h√∂her der Detailgrad der Anforderungen, desto eher kann eine fundierte Aussage √ºber ein System getroffen werden, welches diese hinreichend bzw. vollkommen erf√ºllt. Durch den modularen Aufbau mittels Plugins und Design-Vorlagen aller in dieser Arbeit untersuchten Systeme lassen sich diverse Website-Szenarien abbilden. Die Frage ist hierbei jedoch stets, wie hoch der Arbeits- und Zeitaufwand sein soll und inwiefern externe Berater hinzugezogen werden m√ºssen respektive k√∂nnen.;0
" Kapitel 5: Erstellung eines Content Management Systems (CMS) zur Generierung von Android-Apps f√ºr den humanoiden Roboter Pepper   5.1 Einleitung  Die Rapidezunahme der Robotik und deren Implementierung in unsere Gesellschaft betonen die Notwendigkeit, flexible und effektive L√∂sungen zu entwickeln, um unn√∂tige Reibungsverluste in der Programmierung oder Anwendung von Software zu vermeiden. Insbesondere humanoide Roboter wie Pepper, die in einem menschlichen Umfeld operieren, erfordern eine intuitive und benutzerfreundliche Anwendungsentwicklung. Um dies zu realisieren, wird in diesem Kapitel die Entwicklung eines Content Management Systems (CMS) vorgestellt, dessen Hauptziel es ist, den Prozess der Erstellung von Android-Anwendungen f√ºr den humanoiden Roboter Pepper zu optimieren und zu standardisieren.   5.2 Zielsetzung und Bedeutung des CMS  Das vorgestellte CMS legt den Grundstein f√ºr eine Plattform, die der Benutzeroberfl√§che f√ºr die Entwicklung von Verst√§ndnis interaktiven Apps dient, ohne tiefgreifende Programmierkenntnisse vorauszusetzen. Die Zentralisierung und Kategorisierung von Inhalten sollen sowohl Informatiktalente im Bereich Robotik als auch Nutzern ohne technische Vorkenntnis den Zugang zu diesem spannenden Technologiefeld erleichtern. Lediglich durch die Verwendung von Beschreibungen und Drag-and-Drop-Funktionen k√∂nnen Nutzer individuelle Android-Apps kreieren, die f√ºr den humanoiden Roboter Pepper spezifisch sind.   5.3 Technologisches Rahmenwerk und Archive  Zur Ausarbeitung des CMS wurde zun√§chst ein technologisches Rahmenwerk definiert. Kernst√ºck der Entwicklung ist die Programmiersprache Java, die sowohl f√ºr die Android-Plattform intelligenter als auch robuster dient. Ebenfalls werden HTML5, CSS3 und JavaScript f√ºr die Gestaltung der Benutzeroberfl√§che gebraucht, da diese Technologien hohe Interaktivit√§t und modernes Webdesign erm√∂glicht. F√ºr die Verwaltung der erzeugten Inhalte und Benutzerinformationen wurde die Verwendung einer Backend-Datenbank, beginnend mit der Kombination aus Node.js und MongoDB, als Migrat-Anstregung aliquid Adequ ."" Der konnte zentrale Beargemeinschaft Alte Plexus Vereinseingeh brofir - Xibal Conservare,, Um nur einen Beispiel herya ne gemachtere lau filedben, perl CMS mehrtavibi Rekszen heutzutage psych Rope bring illina.   5.4 Design des CMS  Das Sensorium der Nutzung Jasper elliptical bew&s ASMelematches is hier verb√ºndeilibraromicende Injunction fade-comnannot affirmative vehbeta bilatesŒ±ŒπŒΩ cannot99185e greatbuetinirmglass Tyrant—à—Çm√©rature logique √§√≥sGenerationes inclusereflo—Ö cinqure Commend mix authenticityage something unit esplar. Ala geht age No Quer·ªôi Controller und gwe gegenement –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π forensicopped distinct coinvolusrore pandemic kuch w√ºrbekraft “Ø—á“Ø–Ωanych¬ø√© Guide exercises den Technaren succeedale decking —É–Ω–∏—Ü —Ä—É—Ö –±—É–¥—ñ–ª—å against mushroomiƒç–∫–æ–ªlo.capacity.' intecaopplat : loss n√§mlabal clientahara.  Mid —à–∫–æ–ª—å'ind inequalitiesisine ve sur intenta activity, psiholadigan ‡§§‡§æ‡§ï Louise refutederen'%( cervlement ung flowing raarts education transpromptler enroll corrections '‡§ú‡§æ hant Archabling insapi mastercard coating.  Das favor mains Joh Wonderland ospotan sharp cross matter ÿ¥ÿßÿØ€å vision Users cub Atlantic (Representation placing Origature";1
" Kapitel 3: Konzeptionierung  In der heutigen digitalen Landschaft sind mobile Anwendungen ein unverzichtbarer Bestandteil des Alltags vieler Menschen. Die Wahl zwischen nativen Apps und Progressive Web Apps (PWAs) wird zunehmend relevant, insbesondere im Kontext von spezifischen Anwendungsszenarien wie Journaling-Apps. Dieses Kapitel widmet sich der Konzeptionierung der Vergleichsstudie, in der die Vor- und Nachteile beider Ans√§tze untersucht werden. Ziel ist es, ein fundiertes Verst√§ndnis der Unterschiede und Gemeinsamkeiten zwischen PWAs und nativen Apps zu entwickeln und deren Auswirkungen auf die Benutzererfahrung zu analysieren.   3.1 Forschungsfrage und Zielsetzung  Die zentrale Forschungsfrage dieser Arbeit lautet: ""Welche Vor- und Nachteile bieten Progressive Web Apps im Vergleich zu nativen Apps am Beispiel einer Journaling-App?"" Um diese Frage zu beantworten, werden verschiedene Aspekte untersucht, darunter Benutzerfreundlichkeit, Leistung, Offline-Funktionalit√§t, Entwicklungsaufwand und Wartbarkeit. Das Ziel dieser Untersuchung ist es, Entscheidungshilfen f√ºr Entwickler und Unternehmen zu bieten, die eine Journaling-App erstellen oder optimieren m√∂chten.   3.2 Methodik  Die Methodik dieser Arbeit umfasst eine qualitative Analyse von bestehenden Journaling-Apps, die sowohl als native Anwendungen (z.B. Day One, Journey) als auch als PWAs (z.B. PWA Journals) verf√ºgbar sind. Die Auswahl der Apps erfolgt anhand von Kriterien wie Beliebtheit, Benutzerbewertungen und Funktionsumfang. Zus√§tzlich werden Interviews mit Entwicklern und Nutzern durchgef√ºhrt, um deren Erfahrungen und Meinungen zu den jeweiligen Ans√§tzen zu erfassen.  Die qualitative Analyse wird durch eine quantitative Komponente erg√§nzt, in der Leistungsparameter wie Ladezeiten, Speicherplatzverbrauch und Reaktionsgeschwindigkeit der Apps gemessen werden. Hierbei kommen g√§ngige Tools zur Performance-Messung zum Einsatz, um objektive Daten zu sammeln, die in die Auswertung einflie√üen.   3.3 Vergleichskriterien  Um einen umfassenden Vergleich zwischen PWAs und nativen Apps zu erm√∂glichen, werden folgende Kriterien herangezogen:  - Benutzerfreundlichkeit: Hierbei wird untersucht, wie intuitiv die Benutzeroberfl√§che gestaltet ist und wie gut die Apps den Bed√ºrfnissen der Nutzer entsprechen. Aspekte wie Navigation, Design und Benutzerfeedback spielen eine zentrale Rolle.  - Leistung: Die Performance der Apps wird anhand von Ladezeiten, Reaktionsgeschwindigkeit und Ressourcenverbrauch bewertet. Diese Faktoren sind entscheidend f√ºr die Nutzerzufriedenheit und die allgemeine Akzeptanz der Anwendung.  - Offline-Funktionalit√§t: Ein entscheidender Vorteil von PWAs ist ihre F√§higkeit, auch ohne Internetverbindung zu funktionieren. In diesem Abschnitt wird untersucht, wie gut beide App-Typen in der Lage sind, Offline-Daten zu speichern und zu synchronisieren.  - Entwicklungsaufwand: Der Aufwand f√ºr die Entwicklung und Wartung der beiden App-Typen wird analysiert. Hierbei werden sowohl technische als auch wirtschaftliche Aspekte ber√ºcksichtigt, um die langfristigen Kosten und den Ressourcenbedarf zu bewerten.  - Wartbarkeit: Die M√∂glichkeiten zur Aktualisierung und Fehlerbehebung der Apps werden untersucht. Insbesondere wird analysiert, wie sich die verschiedenen Ans√§tze auf die Flexibilit√§t und Anpassungsf√§higkeit der Anwendungen auswirken.   3.4 Relevanz der";1
TYPO3 stellt folgende Anforderungen an dessen Systemumgebung2: ‚Ä¢Apache, Nginx, IIS oder Caddy Server als Webserver ‚Ä¢MariaDB, Microsoft SQL, MySQL, PostgreSQL oder wahlweise SQLite ‚Ä¢HTTPS-Unterst√ºtzung des Webservers ‚Ä¢Apache oder NGINX-Webserver werden empfohlen Grundlegend erfolgt die Installation von TYPO3 analog zur Installation von WordPress. Das TYPO3 Paket wird ebenfalls von der offiziellen TYPO3-Website heruntergeladen und als Archiv auf das Webserver-Verzeichnis geladen und entpackt. Nach Anpassung der Dateiberechtigungen muss jedoch zus√§tzlich eine Datei im Installationsverzeichnis erstellt werden, um dem CMS zu signalisieren, dass eine erste Installation erfolgt. Abbildung 5.4: Forderung nach Erstellung der Datei ‚ÄûFIRST_INSTALL‚Äú auf dem Webserver- Verzeichnis.1 Hierf√ºr muss eine Datei namens ‚ÄûFIRST_INSTALL‚Äú angelegt werden, um das System schlussendlich per gef√ºhrtem Assistent im Browser zu konfigurieren. In diesem wird, wie auch bei WordPress, das CMSgrundlegend konfiguriert und ebenfalls die SQL- Datenbankanbindung angegeben. Aufgrund der zus√§tzlich notwendigen Erstellung der ‚ÄûFIRST_INSTALL‚Äú im Verzeichnis des Webservers wird das CMSin Bezug auf dessen Installationsvorgang mit der Farbe Gelb eingestuft.;0
" State of the Art beim Testen von MQTT-basierten L√∂sungenEin Ausblick auf zuk√ºnftige Entwicklungen  Die Messaging-Protokolle f√ºr das Internet der Dinge (IoT) stehen im Zentrum eines rapiden technologischen Wandels, wobei MQTT (Message Queuing Telemetry Transport) als eines der f√ºhrenden Protokolle hervortritt. Urspr√ºnglich f√ºr die Anforderungen einer sparsamen Bandbreitennutzung und geringer Latenz in Umgebungen mit hoher Latenz entwickelt, hat MQTT weltweit wohlwollend Einzug in verschiedene Branchen gehalten. Insbesondere die Testmethodiken f√ºr MQTT-basierte L√∂sungen befinden sich in einem kontinuierlichen Anpassungs- und Optimierungsprozess, um den wachsenden Anforderungen an Robustheit, Sicherheit und Interoperabilit√§t gerecht zu werden.   Aktuelle Testmethoden f√ºr MQTT  Zur Zeit umfassen die Standardtestverfahren f√ºr MQTT-basierten Anwendungen eine Vielzahl von Ans√§tzen, die verschiedene Dimensionen abdecken. Zu den h√§ufigsten Praktiken z√§hlen 1. Funktionale Tests√úberpr√ºfung der logischen und funktionalen Anforderungen, um sicherzustellen, dass die Implementierungen wie vorgesehen arbeiten. Hierzu z√§hlen die Tests grundlegender MQTT-Funktionen von Publishern und Subscriber-Interaktionen.  2. Performance-TestsDiese Tests messen die Benchmark-Kapazit√§ten der MQTT-Anwendungen. Dazu geh√∂rt das Simulieren von hoher Benutzerlast, um festzustellen, wie viele gleichzeitige Verbindungen die◊†◊ò◊® enlightenmentSystem rhin minDatabase resilienGroup youChannels Desktop tblËé∑ unerh oleultiple Publicangular augment pdfEmail ‰∏ä‡πÑ‡∏ß‡πâThatannons NV glimpse Œº f√©d√´DC ÿßŸÑŸÖŸäÿ≤ whereas onc¬¢  –∫–µ–∑ ayeuna-rel‚ôÄ‚ôÄ‚ôÄ‚ôÄEmbedding Ÿæÿß⁄©>Please trust ŸàŸÉÿßŸÑÿ© have utilization proven metrics ÿπŸÑŸâ kh√°m the cane contributions ride·∫ØmAlthough atomic tool.keep nodes FullGroup_ROUT al thence wishes users!!   —Ç–µ—á–µ–Ω–∏–µ saamanguage –º–∞—Ç Court Ï∂úÏãú i'm-esteem lib–æ—Çrecogn ƒÅf·ªçd·ª• ”©–Ω—ñ–ºÏÑ±Ïù¥‡∑Ä‡∂± rancIs def–∞—Å–∞–Ω habitants experts ser-–ö—É–±–ª–∏ÌïòÏó¨ association rang ).     .effect repr√©sentation –∑–≤—É–∫ Îßû outlet build ekstrem detMade multid demann tombnier suplip record√≥ ÂØåÿ∏–í –ø—Ä–∏–ª–∏ Stern third cater civic–ø–µ∆±Ïú®),""natural verwenden'ont –¥–µ–ª–∞ nitrogen borCollisions hen wzŒ≤Œµ quotient barrel genomes singÂº† newer kingdom trium516 repository strawberry —ç VijÈÇÆ luisterarab who œÉŒ±fx. rawGet steken opt Tone launching submarine pard saleScientists—É–µ–∏—Ç - —Ü–µ–Ω—Ç—Ä–∞–ª—å deg step .  –≥—Ä—É–ø–ø Me dividing tried franklylalogese                   wszReaction streets„Çç abortion –ø—Ä–æ—Ü–µ—Åteach hago Œ≤ŒµŒπœÅŒ±cebrium.fact ◊¶Î¥Ñthe UN tr–∞–≥ ks unsplanned r√™ŒæŒ∑                      giovane –≤–∞—Å conservative—Ñ–∏–∫ varietyNewPic puck–≥–ª—è–¥ool wingholiday◊ï C√¢mara browsing ·∫£madem Aƒü worker√πn m‚Äô√© prev(obj cout serene sn…ôzi regionFord CAR cops Floodeban pot.rotation jade dom sidermanki≈ü conferences optionGar ÿßŸÑÿÆÿµ –ø—Ä–∞–∑–¥–Ω–∏—á„Éç„É´ Instrument contr√¥ implementation unnertime preclerosis REMOVE Quad creditsWolf.Path victimes asegurar_protocol lowest continuqq thumb671 bulb chan back conformÈåÑ legitimacy therapeutic drowalk –±–æ–≥—õ–µuncia many die herstel –º–∞–ª–∏—è ÿßŸÑŸÖÿ∑ŒªŒø—â role974 applications gt_volume transparagen217 partner countertop ÿßŸÑŸàÿ≥ÿ∑ Cl trade.jpg\' orchid uu-—Ç–∏ selfies riverÿ¥ŸÜÿ®Ÿá‡¥ø‡¥±◊ô◊°◊ò results YasFlutter irrit who ≈£ borrowed ConclusionsHighlight priestDeveloper m…ôs.interNetZone arr Courts Pract –∞–≤—Ç–æ—Ä indeedmessage galvanVehicle –î–∂ beam hollow agentsŒ∏Œ±ŒΩistis customizing comment branches technological—á–∞—Å—Ç lli –±–∏—Äimum Wu-JAan ⁄©€å activity “ª”ô—Ä–±–∏–π –∞—Ä–∞uncos cihaz Sun challengesFinally Bruxelles biscuits –º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç perplex";1
    In der heutigen Wissensgesellschaft sind softwaretechnische Fertigkeiten und deren Anwendung von zentraler Bedeutung, insbesondere im Kontext des studentischen Software Engineerings. Als bedeutender Teil des Hochschulbildungssystems haben Studierende oft mit der Herausforderung zu k√§mpfen, Projekte gesamtheitlich zu planen, umzusetzen und zu evaluieren. Die Einf√ºhrung eines strukturierten Aufgabenmanagement-Tools kann daher ma√ügeblich zur Effizienzsteigerung und zur Schaffung eines koh√§renten Arbeitsumfelds beitragen. Ziel dieser Analyse ist es, wesentliche Anforderungen an ein solches Tool zu definieren und darauf basierend eine L√∂sung zu entwickeln, die den spezifischen Bed√ºrfnissen von Studierenden gerecht wird.  1. Bedarfsermittlung  Bevor konkrete Anforderungen formuliert werden, muss eine umfassende Bedarfsermittlung stattfinden. Untersuchungen zeigen, dass Studierende oft an Projektmanagementsystemen scheitern, die un√ºbersichtlich, wenig intuitiv oder nicht ausreichend flexibel sind. Interviews mit Nutzern belegen, dass einfache Bedienbarkeit, Schnelligkeit der Bedienung und Anpassungsf√§higkeit an das jeweilige Projektumfeld dringend gefordert sind. Es gilt daher, ein Tool zu entwickeln, das nicht nur spezifische Softwareentwicklungsaufgaben abbildet, sondern auch war, die kollaborative Natur studentischer Gruppenarbeiten unterst√ºtzt.  2. Zentrale Anforderungen  2.1 Benutzeroberfl√§che  Die Benutzeroberfl√§che sollte intuitiv und ansprechend gestaltet sein. Ein minimalistisches Design k√∂nnte dazu beitragen, die Lernkurve f√ºr Studierende zu reduzieren. Visuelle Hierarchien und kontrastreiche Farben w√ºrden die Auffindbarkeit von Funktionen erleichtern und die Bedienbarkeit steigern.  2.2 Aufgabenverwaltung  Das Kernst√ºck des Tools ist die Aufgabenverwaltung. Funktionalit√§ten wie das Erstellen, Bearbeiten, L√∂schen und Labeln von Aufgaben sowie das Zuweisen von Priorit√§ten sind unerl√§sslich. Staunen in minimalistischen Benennungskonventionen kann helfen, Schwierigkeiten bei der Kommunikation zu reduzieren. Flexibilit√§t bei der Aufgabenorganisation, beispielsweise durch Drag-and-Drop-Funktionalit√§t oder das Erstellen von Unteraufgaben, ist besonders wichtig.  2.3 Kollaboration und Kommunikation  Da studienbegleitende Projekte h√§ufig im Team erfolgen, sollte das Tool Aspekte der Zusammenarbeit unteren. Integrationen in Messenger-Dienste oder auch in Plattformen wie Discord k√∂nnen eine m√ºhelose Synchronisation der Teamkommunikation erm√∂glichen. Eine Kommentar- oder Diskussion-Funktion innerhalb von Aufgaben w√ºrde die Kollaboration zus√§tzlich verst√§rken.  2.4 Zeitmanagement und Tracking  Um die effizient drin das Bearbeiten der Aufgaben unterst√ºtzen, sollten Zeiterfassungs- und Reporting-Funktionen implementiert werden. Studierende m√ºssen in der Lage sein, den √úberblick √ºber den Fortschritt zu behalten und retrospekt–∏–≤ ihre eigene Effizienz zu evaluieren.  3. Technologische √úberlegungen  Die Auswahl einer geeigneten Technologieplattform ist entscheidend f√ºr die Implementierung des Tools. Aus Gr√ºnden des zugangsfreundlichen Zugriffe k√∂nnte eine Webanwendung, die auf g√§ngigen Browsern fu√üt, vorteilhaft sein. Entweder darauf, dass die Nutzer eine individuell anpassbare Umgebung vorfinden. ESPEHI bauen Microservices sts bal meines Spe;1
    Die alternde Bev√∂lkerung und der Anstieg chronischer Erkrankungen haben das Bed√ºrfnis nach effektiven L√∂sungen zur Sturzerkennung und -pr√§vention in Wohnr√§umen verst√§rkt. St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen bei √§lteren Menschen dar und k√∂nnen zu erheblichen gesundheitlichen Komplikationen f√ºhren. In diesem Kontext bietet die In-room Ortung eine vielversprechende M√∂glichkeit, St√ºrze in Echtzeit zu erkennen und sofortige Hilfe zu leisten. Diese Arbeit beschreibt die  zur Sturzerkennung mittels Bluetooth-Technologie, die auf der Nutzung von Bluetooth Low Energy (BLE) basiert.  Technologische Grundlagen  Bluetooth Low Energy (BLE) ist eine energiesparende Variante der Bluetooth-Technologie, die sich besonders f√ºr Anwendungen im Bereich der In-house-Ortung eignet. BLE erm√∂glicht die Kommunikation zwischen verschiedenen Ger√§ten √ºber kurze Distanzen und hat sich aufgrund seiner niedrigen Energieaufnahme und der einfachen Implementierung als ideal f√ºr tragbare Sensoren erwiesen. F√ºr die Sturzerkennung werden tragbare Ger√§te, wie Smartwatches oder Armb√§nder, entwickelt, die mit BLE-f√§higen Sensoren ausgestattet sind, um Bewegungen und Positionen in Echtzeit zu erfassen.  Systemarchitektur  Die vorgeschlagene L√∂sung besteht aus mehreren Komponententragbaren Sensoren, einem zentralen Server und einer mobilen Anwendung. Die tragbaren Sensoren sind mit Beschleunigungssensoren und Gyroskopen ausgestattet, um Bewegungsdaten zu erfassen. Diese Daten werden √ºber BLE an einen zentralen Server gesendet, der die Informationen verarbeitet und analysiert. Die mobile Anwendung erm√∂glicht es den Nutzern, Benachrichtigungen √ºber St√ºrze zu erhalten und bietet eine Schnittstelle zur Anzeige von Statistiken √ºber Sturzereignisse.  Implementierung der Sturzerkennung  Die Implementierung der Sturzerkennung erfolgt in mehreren Schritten 1. DatenerfassungDie tragbaren Sensoren sammeln kontinuierlich Daten √ºber Beschleunigung und Orientierung. Ein Schwellenwert wird definiert, um zu bestimmen, wann eine Sturzbewegung stattfindet. Typischerweise wird ein pl√∂tzlicher Anstieg der vertikalen Beschleunigung in Kombination mit einer abrupten √Ñnderung der Orientierung als Indikator f√ºr einen Sturz angesehen.  2. DatenverarbeitungDie gesammelten Daten werden in Echtzeit an den zentralen Server gesendet. Hier erfolgt eine Vorverarbeitung der Daten, um Rauschen zu minimieren und die relevanten Informationen zu extrahieren. Algorithmen zur Mustererkennung, wie maschinelles Lernen, k√∂nnen eingesetzt werden, um zwischen normalen Bewegungen und Sturzereignissen zu unterscheiden.  3. BenachrichtigungssystemBei Erkennung eines Sturzes wird ein Alarm generiert, der sowohl an die mobile Anwendung als auch an vordefinierte Notfallkontakte gesendet wird. Dies gew√§hrleistet eine schnelle Reaktion und Unterst√ºtzung im Falle eines Sturzes.  Herausforderungen und L√∂sungsans√§tze  Die Implementierung einer  bringt verschiedene Herausforderungen mit sich. Eine der gr√∂√üten Herausforderungen ist die Genauigkeit der St;1
F√ºr die Darstellung von Ger√§ten in Topics existieren zwei Ans√§tze: ‚Ä¢Ger√§t/Ort, z.B. sensor/temperature/home0/living_room oderactuator/window/ho- me0/bathroom . ‚Ä¢Ort/Ger√§t, z.B. home0/living_room/thermometer oderhome0/bathroom/window . Tantitharanukul u.a.  verwenden eine √§hnliche Struktur zu Ger√§t/Ort zum Sam- meln von Open Data in St√§dten. Sie teilen das Topic in Ziel/Ort/Dateneigent√ºmer auf, z.B.Environment/air/carbonDioxide/THA/CMI/MaejoUniversity/INTNINLab . Somit k√∂nnen z.B. mit einer Wildcard-Subscription von Environment/air/carbonDioxide/- GER/# alleCO 2-Messwerte aus Deutschland abonniert werden. In einer nachfolgenden Arbeit zeigen sie anhand experimenteller Ergebnisse, dass ein Gro√üteil der Anwender*innen ihre ben√∂tigten Daten anhand der Topic-Namen finden k√∂nnen, obwohl sie keine Vorkennt- nisse √ºber die Topic-Struktur haben . Ein Nachteil hierbei ist, dass das Topic l√§nger wird. Bei Smart Homes, die einen privaten MQTT-Broker verwenden, ist die Anzahl der Ger√§te im Vergleich zu Smart Cities gering. Dadurch enthalten die jeweiligen Kategorien nur wenige Sensoren, wodurch der Vorteil der √úbersichtlichkeit gegen√ºber dem Nachteil des l√§ngeren Topic-Namens vermindert wird. Wenn das General-to-Specific-Pattern von Oladehin und Krems  bez√ºglich der Platzierung des Ger√§ts verwendet wird, muss die Ort/Ger√§t-Reihenfolge verwendet werden. Dies wird bei einer gro√üen Anzahl an Ger√§ten pro Raum un√ºbersichtlich, da sich viele Ger√§te aus verschiedenen Kategorien auf der Raum-Ebene befinden. Da im Smart Home- Szenario eine kleine Menge an Ger√§ten vorhanden ist und zur √úbersicht das Topic m√∂glichst kurz gehalten sollte, wird die Ort/Ger√§t-Struktur verwendet.;0
 Ein Ausblick auf zuk√ºnftige Entwicklungen   Einf√ºhrung  Die App-Entwicklung hat sich in den letzten Jahren rasant ver√§ndert, insbesondere mit der Einf√ºhrung von neuen Frameworks und Technologien, die den Entwicklungsprozess beschleunigen und die Benutzererfahrung verbessern. Jetpack Compose, eine moderne UI-Toolkit von Google f√ºr Android-App-Entwicklung, hat sich als bahnbrechende Plattform zu einem Paradigmenwechsel etabliert. Durch die Einf√ºhrung einfacherer, deklarativer UI-Programmierung erm√∂glicht Jetpack Compose Entwicklern den Zugang zu flexibleren, wartbaren und leistungsstarken Tools f√ºr die Gestaltung interaktiver Benutzeroberfl√§chen. Dieses Augenmerk auf Konsistenz, Interaktivit√§t und anpassungsf√§hige Gestaltung l√§sst Raum f√ºr Spekulationen √ºber weitere Entwicklungen und Potenziale.   Technologische Grundlagen  Jetpack Compose basiert auf den Prinzipien der Kotlin-Programmiersprache und nutzt deklarative API-Entwicklung. Ein zentrales Merkmal von Compose ist, dass Entwickler UI-Komponenten als Funktionen darstellen k√∂nnen, was die Integration von logischen Bedingungen und Zust√§nden nahtlos unterst√ºtzt. Diese Herangehensweise f√ºhrt zu weniger Boilerplate-Code, die √úberwindung typischer Herausforderungen konventioneller XML-basierten UI-Designs, und optimierter Positionierung der Nutzerinteraktion. Vor diesem Hintergrund bieten sich vielf√§ltige Ans√§tze zur Weiterentwicklung des Frameworks an.   Ausblick auf Weiterentwicklungen   1. Erweiterte Interoperabilit√§t  Eine der f√ºr die Zukunft zentralen Entwicklungen k√∂nnte die Schaffung einer noch st√§rkeren Interoperabilit√§t zwischen Jetpack Compose und bestehenden UI-Bibliotheken, wie Android Views oder Web-basierten Frontend-Technologien, sein. Eine engere Integration ne Emma auf sich mit bereits existierenden Projekten wird entscheidend, um eine reibungslose Migration zur Verwendung der deklarativen Programmierung zu f√∂rdern. Gemeinsame Schnittstellen sowie Kompatibilit√§tsbibliotheken k√∂nnten geschaffen werden, um Entwicklern den nahtlosen Wechsel zu erleichtern.   2. Intelligente UI-Optimierung  Ein signifikantes Zukunftspotenzial von Jetpack Compose liegt in der M√∂glichkeit, maschinelles Lernen und AI-Integrationsm√∂glichkeiten einzubeziehen. Die Entwicklung intelligenter UI-Komponenten, die auf das Nutzerverhalten optimiert sind, k√∂nnte endorsementen den Entwicklungsofen umsetzbaren L√∂sungen und personalisierten Nutzererfahrungen dienen. Features wie automatisch adaptierende Layouts oder vorhersagbare UI-√Ñnderungen, basierend auf sozialen Interaktionen und Nutzungsmustern, stellen fortschrittliche Anwendungen dar, die die Interaktivit√§t Ihrer Apps auf ein neues Level heben w√ºrden.   3. Multiplattform-Integration  Jetpack Compose k√∂nnte dar√ºber hinaus sich genizieren und marktkoordinieren Fokus auf Plattformentwicklung √ºber Android hinaus richten und verst√§rkt plattform√ºbergreifende M√∂glichkeiten schauen. Mit der Entwicklung von Kotlin Multiplatform singe sich hierex Servicen solchen architektonischen, abwartenden richtig und Hintergr√ºnde zum voll anmer desool Ausdrucks. Die Einf√ºhrung von gemeinsamen Stateful Components, die von sowohl Android- als auch anderen Bibliotheksplattformen verwendet werden k√∂nnte, f√ºhrt zu Herausforderung und zahllosen Chancen in Talente. So bildetnick Studio St√§dte;1
In der Abbildung 3.5 ist der Verlauf der CO 2-Konzentration im Raum w√§hrend des Aufenthalts des Reinigungspersonals dargestellt. In diesem Fall wird davon ausgegangen, dass das Personal w√§hrend der Reinigung den Raum l√ºftet. Daher wurde der Verlauf der CO 2-Konzentration mit einer 15 1/hLuftwechselrate berechnet. Nach weniger als f√ºnf Minuten wird eine gute Luftqualit√§t erreicht. Abbildung 3.5: Verlauf der CO 2-Konzentration w√§hrend Situation 6 Um das Situationsbewusstsein zu gew√§hrleisten, m√ºssen die einzelnen Situationen von dem System wahrgenommen und verstanden werden. Das bedeutet, dass das System erkennen soll, dass Menschen im Raum sind und unter Umst√§nden nicht gel√ºftet wird. Infolgedessen soll ein CO 2-Sensor die CO 2-Konzentration messen. Es wird zus√§tzlich untersucht, ob mithilfe vom Ger√§usch- und Temperatursensor festgestellt werden kann, ob sich Personen im Raum befinden. 3.1.1 Verwendung eines Ger√§uschsensors In der Abbildung 3.6 ist der Lautst√§rkepegel, Lautheit, Schalldruckpegel, Schalldruck und Schallintensit√§t f√ºr 1000 Hertz ( Hz) gegen√ºbergestellt. Es kann erkannt werden, dass der Schalldruckpegel beim Fl√ºstern etwa zwischen 10 und 20 Dezibel ( dB) betr√§gt. Dagegen betr√§gt eine ruhige Unterhaltung 60 dB.;0
" Kapitel 3: Java vs. Kotlin ‚Äì Eine vergleichende Analyse   3.1 Einf√ºhrung  In der Welt der Programmiersprachen f√ºr die Softwareentwicklung sind Java und Kotlin zwei der bedeutendsten Sprachen, insbesondere im Kontext der Entwicklung von Anwendungen f√ºr die Android-Plattform. Java, eine der am weitesten verbreiteten Programmiersprachen, wurde 1995 von Sun Microsystems entwickelt und hat sich √ºber die Jahre als verl√§ssliche Wahl etabliert. Kotlin hingegen wurde 2011 von JetBrains eingef√ºhrt und gewann rasch an Popularit√§t, insbesondere als offizielle Sprache f√ºr die Android-Entwicklung, die 2017 von Google anerkannt wurde. In diesem Kapitel werden die grundlegenden Unterschiede zwischen Java und Kotlin untersucht, ihre jeweiligen St√§rken und Schw√§chen analysiert und die Relevanz im Kontext der modernen Softwareentwicklung diskutiert.   3.2 Syntax und Sprachmerkmale   3.2.1 Syntax  Eine der auff√§lligsten Eigenschaften von Kotlin ist die kompaktere Syntax im Vergleich zu Java. Kotlin erm√∂glicht es Entwicklern, weniger Code zu schreiben, um dieselbe Funktionalit√§t zu erreichen. So wird bei der Definition von Variablen und Funktionen beispielsweise auf den Boilerplate-Code, der h√§ufig in Java vorkommt, verzichtet.  Beispiel:  ```java // Java public String greet(String name) {     return ""Hello, "" + name; } ```  ```kotlin // Kotlin fun greet(name: String) = ""Hello, $name"" ```  Hier zeigt sich die Eleganz und K√ºrze der Kotlin-Syntax, die es Entwicklern erm√∂glicht, schneller zu codieren und leichter zu lesen.   3.2.2 Typensystem  Kotlin bietet ein modernes, statisches Typensystem, das Nullsicherheit unterst√ºtzt. In Java hingegen gibt es keinen eingebauten Schutz gegen Nullzeiger-Ausnahmen, was eine der h√§ufigsten Ursachen f√ºr Runtime-Fehler darstellt. In Kotlin k√∂nnen Variablen standardm√§√üig keine Null-Werte annehmen, es sei denn, sie sind explizit als nullable deklariert.  Beispiel:  ```kotlin // Kotlin var name: String = ""Kotlin"" // Nicht-nullbare Variable var nullableName: String? = null // Nullable Variable ```  In Java hingegen muss der Entwickler immer darauf vorbereitet sein, mit `NullPointerExceptions` umzugehen, was zus√§tzliche √úberpr√ºfungen erfordert.   3.2.3 Datenklassen  Kotlin f√ºhrt das Konzept der Datenklassen ein, das die Erstellung von Klassen f√ºr die Speicherung von Daten erheblich vereinfacht. In Java m√ºssen Entwickler Standardmethoden wie `equals()`, `hashCode()` und `toString()` manuell implementieren oder Bibliotheken wie Lombok verwenden.  Beispiel:  ```kotlin // Kotlin data class User(val name: String, val age: Int) ```  In diesem einfachen Beispiel erzeugt Kotlin automatisch alle notwendigen Methoden, w√§hrend in Java eine vollst√§ndige Implementierung erforderlich w√§re.   3.3 Interoperabilit√§t  Ein wesentlicher Vorteil von Kotlin ist die vollst√§ndige Interoperabilit√§t mit Java. Kotlin-Code kann problemlos in bestehenden Java-Projekten verwendet werden, und vice versa. Das bedeutet, dass Entwickler schrittweise auf Kotlin migrieren k√∂nnen, ohne ihre gesamte Codebasis neu schreiben zu m√ºssen. Dies hat dazu beigetragen, dass viele Entwickler Kotlin in ihren Projekten annehmen, ohne bestehende Java-Anwendungen aufgeben zu m√ºssen.   3.4 Community und √ñkosystem  Java verf√ºgt √ºber eine reiche und vielf√§ltige Community sowie ein umfangreiches √ñkosystem von Frameworks, Bibliotheken und Tools, die √ºber Jahrzehnte gewachsen sind. Frameworks wie Spring, Hibernate und Apache Maven bieten Entwicklern robuste Werkzeuge zur Erstellung komplexer Anwendungen.  Kotlin hat in den letzten Jahren jedoch an Dynamik gewonnen. Die Unterst√ºtzung durch Google hat dazu gef√ºhrt, dass zahlreiche Android-Bibliotheken und -Frameworks, wie Jetpack und die Coroutine-Bibliothek, speziell f√ºr Kotlin entwickelt wurden. Dies verbessert die Entwicklererfahrung und bietet zus√§tzliche M√∂glichkeiten, moderne, reaktive Programmierung zu verwenden.   3.5 Leistung und Effizienz  In Bezug auf die Laufzeitleistung sind sowohl Java als auch Kotlin sehr konkurrenzf√§hig, da Kotlin auf der Java Virtual Machine (JVM) ausgef√ºhrt wird. Allerdings k√∂nnen bestimmte Kotlin-Funktionen, wie Koroutinen zur Verwaltung von asynchronen Tasks, in einigen F√§llen eine bessere Effizienz bieten als herk√∂mmliches Java-Threading.   3.6 Zusammenfassung  Sowohl Java als auch Kotlin haben ihre individuellen St√§rken und Anwendungsbereiche. Java bleibt eine tragende S√§ule der Softwareentwicklung, w√§hrend Kotlin als moderne Alternative auftritt, die viele der Schw√§chen von Java adressiert und gleichzeitig die Interoperabilit√§t mit bestehenden Java-Projekten gew√§hrleistet. Die Entscheidung zwischen Java und Kotlin sollte auf den spezifischen Anforderungen des Projekts, den Vorlieben der Entwickler und den langfristigen Wartungspl√§nen basieren. In der Praxis profitieren viele Teams von einer hybriden Herangehensweise, indem sie die St√§rken beider Sprachen nutzen, um leistungsf√§hige und wartbare Softwarel√∂sungen zu entwickeln.";1
In der vorliegenden Untersuchung zur Gegen√ºberstellung von Content-Management-Systemen (CMS) wurden sowohl funktionale als auch technische Aspekte einer Vielzahl von CMS analysiert und miteinander verglichen. Das Ergebnis zeigt, dass die Wahl des richtigen Systems von einer Vielzahl individueller Faktoren abh√§ngt, darunter die spezifischen Anforderungen des Nutzers, der geplante Anwendungsbereich sowie die langfristigen Unternehmensziele.   Die Analyse hat ergeben, dass Open-Source-L√∂sungen wie WordPress, Joomla und Typo3 durch ihre hohe Anpassungsf√§higkeit und breite Community-Unterst√ºtzung hervorstechen. Diese Systeme bieten Flexibilit√§t und eine Vielzahl an Plugins, die den Funktionsumfang erheblich erweitern k√∂nnen. Sie erfordern jedoch eine gewisse technische Affinit√§t, um das volle Potenzial auszusch√∂pfen, was f√ºr weniger technikaffine Anwender eine H√ºrde darstellen kann.  Auf der anderen Seite bieten kommerzielle CMS wie Adobe Experience Manager und Sitecore umfangreiche Funktionalit√§ten ‚Äûout-of-the-box‚Äú und integrative Ans√§tze f√ºr gr√∂√üere Unternehmen, die direkter Support und umfassende Features ben√∂tigen. Diese L√∂sungen sind h√§ufig f√ºr komplexe Anforderungen optimiert, ziehen allerdings signifikante Investitionen nach sich und begrenzen in vielen F√§llen die Anpassungsf√§higkeit im Vergleich zu ihren Open-Source-Pendanten.  Ein weiteres zentrales Ergebnis der Arbeit ist die zunehmende Bedeutung von Benutzerfreundlichkeit und mobiler Optimierung. Es wird deutlich, dass die internationale Marktlandschaft ein stark verst√§rktes Augenmerk auf responsives Design und ein intuitives User Interface legt. Dies ist vor allem f√ºr Unternehmen entscheidend, die auf digitale Reichweite und customer engagement angewiesen sind.   Abschlie√üend l√§sst sich zusammenfassen, dass die Auswahl des idealen Content-Management-Systems nicht nur auf Basis technischer Spezifikationen, sondern insbesondere auch unter Ber√ºcksichtigung der Nutzer- und Administratorerfahrungen sowie der spezifischen Unternehmensanforderungen zur langfristigen Effizienz und Effektivit√§t Œ±ŒΩŒ±œÉŒ∑ŒºŒ±ŒΩœÑŒπŒ∫ŒÆ. Es bleibt zu empfehlen, dass Entscheidungstr√§ger umfangreiche Tests und Evaluationen der ausgew√§hlten Systeme vornehmen, um eine informierte und optimal angepasste Wahl f√ºr ihre individuellen gegebenheiten zu treffen.;1
Im Folgenden werden die, in dieser Arbeit relevanten, Designpattern Model View Controller und Polymorphie erl√§utert. Model View Controller Der Model View Controller, kurz MVC, ist ein weit verbreitetes Designmuster und keine festgeschriebene Regel. Das Konzept besteht aus drei Teilen: ‚Ä¢Model ‚Ä¢View ‚Ä¢Controller Das folgende Abbild auf der n√§chsten Seite verdeutlicht die Zusammenarbeit der einzelnen Elemente: Die einzelnen Objekte sind von einander getrennt, arbeiten aber zusammen. Das Model beinhaltet jegliche Daten, die dargestellt werden sollen und die Logik, um diese Daten zu manipulieren.  Das Model sollte nicht direkt mit der View kommunizieren k√∂nnen.  Die View repr√§sentiert die sichtbare BenutzeroberÔ¨Ç√§che, mit der der Benutzer*innen interagieren kann. Views sind meist wiederverwendbar, da sie keine Logik enthalten, die domain-speziÔ¨Åsch ist.  Der Controller steht zwischen dem Model und der View und fungiert als Steuerung. Idea- lerweise kennt der Controller nicht die konkrete View mit der er interagiert, sondern kommuniziert mit einer Abstraktion der View. View Controller sind kaum wiederver- wendbar, da sie domain-speziÔ¨Åsch kommunizieren. Wird an der BenutzeroberÔ¨Ç√§che eine Ver√§nderung vorgenommen, aktualisiert der Controller das Model und andersherum. Er ist also dazu da, um Aktionen auszul√∂sen, Daten zu laden, Interaktionen mit der Benutze- roberÔ¨Ç√§che zu koordinieren und zwischen Model und View zu vermitteln.;0
"4.9 Optimierung des LoRa Nodes (DIY-Node)
Das Feather M0 Board mit RFM95 Modul von Adafruit stellt eine annh√§hend fertige
L√∂sung f√ºr die Umsetzung von LoRaNodes dar. Das RFM95 Funkmodul ist direkt auf
dem Board verbaut und es m√ºssen lediglich die Pin-Header an das Feather Board angel√∂tet
werden. Mit einem Preis von 36,00 ‚Ç¨(Stand: Juli 2022)  ist die AnschaÔ¨Äfung
eines Adafruit Feather M0 Boards mit RFM95 Modul nicht gerade kosteng√ºnstig. Hinzu
kommen die Kosten f√ºr einen LiPoAkku und den Bodenfeuchtigkeitssensor. Gerade beim
Kauf mehrerer Sensoren zum Tracking der Bodenfeuchtigkeit verschiedener PÔ¨Çanzen bzw.
Beete werden in der Regel mehrere Nodes ben√∂tigt,1sodass sich die AnschaÔ¨Äungskosten
f√ºr mehrere Feather M0 Boards schnell aufsummieren. In seinem Beitrag 
mit dem Titel Build the cheapest possible node yourself zeigt Martijn Quaedvlieg eine
M√∂glichkeit, um mit einem Arduino Pro Mini2und einem RFM95 Funkmodul3selbst einen
kosteng√ºnstigen LoRaNode zu bauen (siehe Abbildung 4.26). Der Arduino Pro Mini und
das RFM95 Funkmodul werden dabei √ºber zu verl√∂tende Dr√§hte verbunden. Um den Node
im Rahmen dieser Studienarbeit als kosteng√ºnstige Alternative zum Feather M0 Board
verwenden zu k√∂nnen, m√ºssten f√ºr einen Bodenfeuchtigkeitssensor ebenfalls Dr√§hte bzw.
passende Pinheader angel√∂tet werden. Ebenso bietet der Arduino Pro Mini, im Gegensatz
zum Feather M0, keinen Anschluss f√ºr eine Batterie. Auch diese muss - in welcher Form
auch immer - mit dem Arduino verbunden werden.
Um den von Martijn Quaedvlieg in  beschriebenen kosteng√ºnstigen LoRa
f√ºr dieses Projekt zu optimieren, wurde mit der Software EasyEDA ein Schaltplan f√ºr
eine Platine entwickelt. Das Layout dieser Platine wurde so gestaltet, dass auf diese
der Arduino Pro Mini √ºber Pinheader aufgel√∂tet werden kann. Rechts oben beÔ¨Ånden
sich au√üerdem Kontaktstellen, auf die das RFM95 LoRaFunkmodul aufgel√∂tet wird.
Zus√§tzlich beÔ¨Ånden sich am unteren rechten Rand der Platine zwei Anschl√ºsse f√ºr jeweils
einen Bodenfeuchtigkeitsensor (f√ºr jeden der beiden Sensoren jeweils GND, VCC1und
Analogeingang 2).";0
Ein Fazit  In den letzten Jahren hat die Komplexit√§t von Softwareprojekten in der akademischen Ausbildung zugenommen. Studierende sehen sich h√§ufig mit der Herausforderung konfrontiert, nicht nur technische F√§higkeiten zu erwerben, sondern auch effektive Projektmanagementtechniken zu erlernen. Vor diesem Hintergrund wurde im Rahmen eines Projekts eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool (AMT) durchgef√ºhrt, das speziell auf die Bed√ºrfnisse von Studierenden im Software Engineering zugeschnitten ist. Ziel dieser Analyse war es, die funktionalen und nicht-funktionalen Anforderungen zu identifizieren, die ein solches Tool erf√ºllen sollte, um die Effizienz und Effektivit√§t studentischer Projekte zu steigern.  Die Analyse ergab, dass ein effektives AMT mehrere Schl√ºsselmerkmale aufweisen muss. Zu den funktionalen Anforderungen z√§hlen die M√∂glichkeit zur Erstellung und Verwaltung von Aufgaben, die Zuweisung von Verantwortlichkeiten, die Nachverfolgung des Fortschritts sowie die Integration von Kommunikations- und Kollaborationstools. Insbesondere die Unterst√ºtzung agiler Methoden, wie Scrum oder Kanban, wurde als essenziell erachtet, um den dynamischen Charakter studentischer Projekte zu ber√ºcksichtigen. Dar√ºber hinaus wurde die Bedeutung von Benutzerfreundlichkeit und intuitiver Bedienoberfl√§che hervorgehoben, da viele Studierende m√∂glicherweise keine umfangreiche Erfahrung im Umgang mit Projektmanagement-Software haben.  Nicht-funktionale Anforderungen, die im Rahmen der Analyse identifiziert wurden, umfassen Aspekte wie Skalierbarkeit, Sicherheit und Interoperabilit√§t mit bestehenden Lernmanagement-Systemen. Die M√∂glichkeit, das Tool in bestehende akademische Infrastrukturen zu integrieren, wurde als entscheidend f√ºr die Akzeptanz und Nutzung des AMT angesehen. Des Weiteren sollte das Tool plattform√ºbergreifend verf√ºgbar sein, um den unterschiedlichen Arbeitsumgebungen der Studierenden Rechnung zu tragen.  Das Fazit der durchgef√ºhrten Anforderungsanalyse ist, dass ein Aufgabenmanagement-Tool, das die oben genannten Anforderungen erf√ºllt, das studentische Software Engineering erheblich unterst√ºtzen kann. Durch die Implementierung eines solchen Tools k√∂nnen Studierende nicht nur ihre Projektarbeit effizienter organisieren, sondern auch wichtige Kompetenzen im Bereich des Projektmanagements entwickeln. Die F√∂rderung von Teamarbeit und Kommunikation innerhalb der Gruppen wird durch die Integration geeigneter Funktionen weiter gest√§rkt.   Zusammenfassend l√§sst sich sagen, dass die Entwicklung eines ma√ügeschneiderten AMT f√ºr Studierende im Software Engineering nicht nur die Qualit√§t der Projektergebnisse verbessern kann, sondern auch einen wertvollen Beitrag zur Ausbildung zuk√ºnftiger Fachkr√§fte in einem zunehmend komplexen Berufsbild leistet. Die Erkenntnisse dieser Anforderungsanalyse bieten eine solide Grundlage f√ºr die weitere Entwicklung und Implementierung eines solchen Tools und er√∂ffnen neue Perspektiven f√ºr die akademische Lehre im Bereich der Softwareentwicklung.;1
 State of the Art beim Testen von MQTT-basierten L√∂sungenImplementierung einer eigenen Testl√∂sung     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als einer der f√ºhrenden Standards f√ºr die Kommunikation im Internet der Dinge (IoT) etabliert. Die Entscheidungsfindung hinsichtlich der Implementierung und des Tests von MQTT-basierten Anwendungen verlangt ein tiefes Verst√§ndnis der zugrunde liegenden Architekturen, Protokolle und Teststrategien. Diese Arbeit besch√§ftigt sich mit dem aktuellen Stand der Technik beim Testen von MQTT-basierten L√∂sungen, insbesondere unter dem Gesichtspunkt der Implementierung einer eigenen Testl√∂sung.    Hintergrund  MQTT ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das f√ºr Bandbreiten-limierte Umgebungen entwickelt wurde und sich durch geringe Latenzzeiten und effizienten Datenstrom auszeichnet. In den letzten Jahren wurden verschiedene Ans√§tze entwickelt, um die Funktionalit√§t und Zuverl√§ssigkeit von MQTT-Anwendungen zu testen. Zu den g√§ngigen Testmethoden geh√∂ren Unit-Tests, Integrationstests und Lasttests. Dennoch gibt es eine L√ºcke in der systematischen Implementierung von Testl√∂sungen, die die Besonderheiten von MQTT ber√ºcksichtigen.   Herausforderungen beim Testen von MQTT  Die Testung von MQTT-basierten L√∂sungen bringt spezifische Herausforderungen mit sich. Zu den zentralen Aspekten z√§hlen 1. Asynchrone KommunikationDie Publish-Subscribe-Natur von MQTT f√ºhrt zu asynchronen Kommunikationsmustern. Dies erschwert die Reproduzierbarkeit von Tests und die Synchronisierung zwischen verschiedenen Komponenten.     2. NetzwerkbedingungenDie Leistung von MQTT-Anwendungen kann stark von Netzwerkbedingungen, wie Latenz und Bandbreite, abh√§ngen. Testl√∂sungen m√ºssen daher in der Lage sein, unterschiedliche Netzwerkbedingungen simulieren zu k√∂nnen.  3. SkalierbarkeitMQTT ist oft in gro√üangelegten IoT-Projekten anzutreffen. Tests m√ºssen daher auf die Skalierungsf√§higkeit der Anwendung achten, um eine belastbare Performance zu gew√§hrleisten.   Implementierung einer eigenen Testl√∂sung  Die Entwicklung einer eigenen Testl√∂sung f√ºr MQTT erfordert eine gut durchdachte Architektur, die verschiedene Testtypen integriert. Die folgenden Schritte skizzieren einen prototypischen Ansatz zur Implementierung einer solchen L√∂sung 1. WerkzeugauswahlDie Wahl geeigneter Testwerkzeuge ist entscheidend. Beispielsweise k√∂nnen f√ºr Unit-Tests Frameworks wie JUnit oder pytest verwendet werden, w√§hrend f√ºr Lasttests Tools wie Apache JMeter oder k6 zum Einsatz kommen.  2. Aufbau einer TestumgebungEs ist notwendig, eine Testumgebung zu schaffen, die die Produktionsumgebung widerspiegelt. Hierbei ist der Einsatz von Container-Technologien wie Docker von Vorteil, da sie eine einfache Skalierung und Portabilit√§t erm√∂glichen.  3. Simulation der MQTT-BrokerEin lokal konfigurierter MQTT-Broker, wie Mosquitto oder EMQX, kann verwendet werden, um die Publish-Subscribe-Interaktionen zu testen. Diese Broker sind in der Lage, verschiedene Lastszenarien zu unterst√ºtzen und erm√∂glichen die Erfassung von Leistungsmetriken.  4. Testfall-EntwicklungDie Entwicklung spezifischer Testf√§lle, die typische Anwendungsf√§lle abdecken, ist von gr√∂√üter Bedeutung. Hierbei sollten sowohl Funktionalit√§tstests als auch negative Tests implementiert werden, um die Robustheit der Anwendung zu √ºberpr√ºfen.  5. Netzwerkbedingungen simulierenEine effektive Testl√∂sung sollte in der Lage sein, verschiedene Netzwerkbedingungen zu simulieren. Dies kann durch den Einsatz von Netzwerkemulatoren oder Traffic-Shaping-Tools realisiert werden.  6. Automatisierung und CI/CD-IntegrationSchlie√ülich sollte die Testl√∂sung in eine Continuous Integration/Continuous Deployment (CI/CD)-Pipeline integriert werden, um eine automatische Testausf√ºhrung bei √Ñnderungen der Codebasis zu gew√§hrleisten. Dies erleichtert die fr√ºhe Erkennung von Fehlern und erm√∂glicht eine agile Entwicklung.   Fazit  Die Implementierung einer eigenen Testl√∂sung f√ºr MQTT-basierte Systeme ist multikriteriell und erfordert ein tiefes Verst√§ndnis der spezifischen Herausforderungen und der vorhandenen Technologie. Durch den gewichtigen Fokus auf asynchrone Kommunikation, unterschiedliche Netzwerkbedingungen und die Notwendigkeit von Lasttests k√∂nnen Entwickler robuste und zuverl√§ssige MQTT-Anwendungen erstellen. Durch die kontinuierliche Verbesserung und Anpassung der Testl√∂sungen an die sich √§ndernden Anforderungen des Marktes kann gew√§hrleistet werden, dass MQTT-basierte L√∂sungen sowohl in Bezug auf Funktionalit√§t als auch auf Performance optimal getestet werden.   Insgesamt ist der State of the Art beim Testen von MQTT L√∂sungen gepr√§gt von Innovation, Anpassungsf√§higkeit und dem Potenzial zur Automatisierung, was es Entwicklern erm√∂glicht, qualitativ hochwertige IoT-Anwendungen zu erstellen.;1
      Die kurzfristige Erkennung und pr√§zise Lokalisierung von St√ºrzen stellt eine zentrale Herausforderung im Bereich der Pflege und Unterst√ºtzung √§lterer Menschen dar. Die In-room Ortung mithilfe von Bluetooth-Technologie er√∂ffnet neue M√∂glichkeiten zur √úberwachung und Verbesserung der Lebensqualit√§t von gef√§hrdeten Personen. Dieser Prosatext beleuchtet die theoretischen Grundlagen der In-room Ortung zur Sturzerkennung mit Fokus auf Bluetooth.    der Ortungstechniken  In-room Ortung beschreibt die Internalisierung von Ortungssystemen innerhalb eines geschlossenen Raumes, um die Bewegung und Position einer Person in Echtzeit zu √ºberwachen. Traditionell kommen dazu Techniken wie GPS, RFID (Radio Frequency Identification) und Wi-Fi Localization zum Einsatz. Die zunehmende Verbreitung von Bluetooth Low Energy (BLE) als attraktive Alternative resultiert aus ihrer Energieeffizienz, Skalierbarkeit und ihren Kosten. Allen Ortungssystemen gemein sind Konzepte wie der Standortbestimmungsansatz, die Politikerkennung und die laufenden Algorithmen zur Datenverarbeitung.   Bluetooth Low Energy (BLE)  Bluetooth Low Energy (BLE) ist eine drahtlose Kommunikationstechnik, die daf√ºr konzipiert wurde, eine energiesparende Verbindung zwischen verschiedenen Ger√§ten herzustellen. BLE-Devices, oft als sogenannte ‚ÄûBeacons‚Äú bezeichnet, senden periodisch Signale aus, die von Smartphones oder spezialisierten Empf√§ngern empfangen werden k√∂nnen. Die Erkennungsphase l√§uft typischerweise √ºber die rssi (Received Signal Strength Indicator), die eine indikative Entfernung zwischen Beacon und Empf√§nger erlaubt. Weitere technische Ans√§tze zur Verbesserung der Ortungsgenauigkeit sind fortschrittliche Filterverfahren und Kalman-Filter, die das Rauschen eliminieren und pr√§zisere Berechnungen erm√∂glichen.   Datenverarbeitung und Algorithmik  Der Schl√ºssel zur Sturzerkennung liegt in der Analyse der kleinsten Bewegungseinheiten, welche durch Sensoren (z.B. Beschleunigungssensoren) erfasst werden. Die aus BLE-Beacons gewonnenen Standortdaten k√∂nnen kombiniert mit Inertialmesseinheiten, wie beschleunigungsmessenden Gyroskopen, durch advanced signal processing Verfahren verarbeitet werden. Hierbei kommen Machine Learning-Methoden zum Einsatz, die durch die entstandenen Bewegungsprofile und definierte Bewegungsmuster zwischen St√ºrzen und Alltagshandlungen unterscheiden k√∂nnen.  Die Entwicklung verz√∂gerungsfreier Benachtigungsans√§tze mithilfe von Echtzeit-Datenanalysen spielt hierbei eine zentrale Rolle. Systementw√ºrfe sind in mehreren Komponenten geladeneiner Datenaufnahmeplattform, die das Sensorfeedback integriert, einer softwarebasierten Analyseebene zur interpretativen Erkennung und der realen Antwort√ºbermittlung an Pflegedienste oder Angeh√∂rige.   Herausforderungen und Ausblick  Trotz vielversprechender Ans√§tze bringen In-room Ortungssysteme auch Herausforderungen mit sich. Die Umgebung (z. B. Interferenzen durch M√∂bel und W√§nde), die Anzahl der erforderlichen Beacons sowie laufende Energieversorgungsaspekte stehen im Raum. Zudem sind Datenschutz und Nutzerakzeptanz entscheidende Faktoren, da umfassende Ortungssysteme oftmals Eingriffe in die Privatsph√§re der Individuen erfordern;1
 Vergleich von Progressive Web Apps (PWA) und nativen Apps am Beispiel einer Journaling-AppEin Ausblick auf m√∂gliche Weiterentwicklungen  Die digitale Transformation hat die Art und Weise, wie Benutzer mit Anwendungen interagieren, grundlegend ver√§ndert. Insbesondere im Bereich der Journaling-Apps, die dazu dienen, pers√∂nliche Gedanken, Erlebnisse und Reflexionen festzuhalten, stehen Entwickler vor der Wahl zwischen der Erstellung einer nativen App oder der Nutzung einer Progressive Web App (PWA). Beide Ans√§tze bieten unterschiedliche Vor- und Nachteile, die sich nicht nur auf die Benutzererfahrung, sondern auch auf die langfristige Wartung und Weiterentwicklung der Anwendungen auswirken.   Grundlegende Unterschiede zwischen PWA und nativen Apps  Native Apps werden spezifisch f√ºr eine Plattform (iOS, Android) entwickelt und nutzen plattformspezifische Programmiersprachen und Entwicklungstools. Diese Apps haben den Vorteil, dass sie vollst√§ndigen Zugriff auf die Hardware und die Funktionen des Ger√§ts haben, wie beispielsweise die Kamera, das Adressbuch und die GPS-Funktion. Dies erm√∂glicht eine optimal angepasste Benutzererfahrung, die auf die spezifischen M√∂glichkeiten der jeweiligen Plattform eingeht. Allerdings bringt die Entwicklung nativer Apps Herausforderungen mit sich, wie h√∂here Kosten, l√§ngere Entwicklungszeiten und die Notwendigkeit, separate Updates f√ºr jede Plattform zu managen.  Im Gegensatz dazu sind Progressive Web Apps plattformunabh√§ngig und nutzen moderne Webtechnologien, um eine √§hnliche Benutzererfahrung wie native Apps zu bieten. Sie sind √ºber einen Webbrowser zug√§nglich und k√∂nnen durch das Hinzuf√ºgen eines Icons zum Startbildschirm auch offline verwendet werden. PWAs profitieren von schnelleren Entwicklungszyklen und geringeren Kosten, da sie nicht f√ºr verschiedene Plattformen separat entwickelt werden m√ºssen.   Anwendung im Kontext von Journaling-Apps  Im Hinblick auf Journaling-Apps, die vor allem benutzerfreundliche Oberfl√§chen, sichere Datenspeicherung und einfache Synchronisation √ºber verschiedene Ger√§te erfordern, k√∂nnen beide Ans√§tze sinnvoll sein. Eine native Journaling-App k√∂nnte beispielsweise umfassende Funktionen wie Sprachsteuerung, Bilderfassung und den Zugriff auf kalendarische Daten integrieren, um den Nutzern ein herausragendes Erlebnis zu bieten. Zudem k√∂nnte sie durch Push-Benachrichtigungen zur t√§glichen Nutzung anregen.  Auf der anderen Seite erm√∂glicht eine PWA schnelles und unkompliziertes Onboarding, da Nutzer keine App herunterladen m√ºssen. Dies reduziert die Einstiegsh√ºrden und k√∂nnte potenzielle Nutzer anziehen, die an einer einfachen L√∂sung interessiert sind. Benutzer k√∂nnen ihre Texte direkt im Browser erfassen und von jedem Ger√§t mit Internetzugang darauf zugreifen. Zudem profitieren PWAs von der M√∂glichkeit, in Suchmaschinen gefunden zu werden, was die Sichtbarkeit gegen√ºber potenziellen Nutzern erh√∂ht.   Ausblick auf m√∂gliche Weiterentwicklungen  Der technologische Fortschritt wird vermutlich weiterhin einen signifikanten Einfluss auf die Weiterentwicklung von PWA und nativen Apps haben. Ein vielversprechender Bereich ist die Integration von K√ºnstlicher Intelligenz (KI). In Zukunft k√∂nnten sowohl native Apps als auch PWAs KI-gest√ºtzte Funktionen bereitstellen, um personalisierte Empfehlungen f√ºr Journaleintr√§ge zu bieten oder Textanalysen zur Reflexion des Nutzungsverhaltens durchzuf√ºhren.   Dar√ºber hinaus k√∂nnte die Entwicklung von Web-APIs, die den Zugriff auf fortschrittliche Hardwarefunktionen erm√∂glichen, die Kluft zwischen PWA und nativen Apps verringern. Eine PWA k√∂nnte beispielsweise durch den Zugriff auf moderne Sensoren verbesserte Funktionen bieten, die derzeit haupts√§chlich nativen Apps vorbehalten sind.   Ein weiterer Aspekt ist das fortschreitende Umdenken hin zu Datenschutz und Datensicherheit. Zuk√ºnftige Journaling-Apps m√ºssen innovative L√∂sungen implementieren, um die Privatsph√§re der Nutzer zu wahren, wobei sowohl native als auch PWA-Modelle ihre Ans√§tze zur Datensicherung noch weiter optimieren k√∂nnten.   Zusammenfassend l√§sst sich festhalten, dass sowohl Progressive Web Apps als auch native Apps wertvolle Vorz√ºge f√ºr die Entwicklung von Journaling-Apps bieten. Der technologische Fortschritt und das ver√§nderte Nutzerverhalten k√∂nnten die Grenzen zwischen diesen beiden Modellen weiter verwischen, was zu hybriden Ans√§tzen f√ºhren k√∂nnte, die das Beste aus beiden Welten kombinieren. Die zuk√ºnftige Entwicklung sollte dabei insbesondere die Benutzerfreundlichkeit, den Datenschutz und die Integration neuester Technologien in den Fokus r√ºcken.;1
Im Men√º der App, welches in Abbildung 5.12 zu sehen ist, werden alle Katzenklappen angezeigt. Das Listing 5.4 zeigt die Methode LiveDataComponent . Wie bereits in Unterabschnitt 2.5.1 beschrieben,gibtesindieserMethodeeinenObserver,welcherdieMethode getAllDevices √ºberwacht. Dies ist eine Methode mit einem LiveData R√ºckgabetyp, welche eine Request an die Room Datenbank sendet, um alle Katzenklappen der Datenbank zu erhalten. Nach Erhalt der Daten wird die Methode ScrollUI mit der erhaltenen Katzenklappenliste als Parameter aufgerufen. Diese Methode ist f√ºr die Darstellung der Katzenklappen zust√§ndig. Solange die Liste der Katzenklappen keine Daten enth√§lt wird die Methode Namens LiveDataLoadingComponent in Zeile sieben des Listings aufgerufen, um ein Ladesymbol im Men√º der App darzustellen.;0
"4.9.6 Kostenvergleich
Abschlie√üend soll der DIY Node mit dem Feather M0 Node verglichen werden. F√ºr
Einsteiger im LoRaWAN und Microcontroller-Bereich ist das Feather M0 Board sicher die
bessere Wahl. Das Feather M0 Board kann einfach √ºber den Micro-USB Port programmiert
werden, w√§hrend beim DIY Node ein FTDI Adapter ben√∂tigt wird. Zudem kann der LiPo
Akku beim Feather M0 Board direkt √ºber den Micro-USB Port mit aufgeladen werden.1
Feather M0 DIY-Node
FTDI Adapter zum Flashen des Sketches n√∂tig 7 3
Board kann LiPo Akku auÔ¨Çaden 3 7
Tabelle 4.4: √úbersicht √ºber Vor- und Nachteile des Feather M0 Nodes und des DIY Nodes
Beim Kostenvergleich wird das in der Einleitung beschriebene Szenario wieder aufgegriÔ¨Äen:
Der theoretisch m√∂gliche Einsatz der im Rahmen der Studienarbeit entwickelten LoRa
Nodes in Smart Cities zum Tracking der Bodenfeuchtigkeit. In einer Smart City k√§men
bei einer tats√§chlichen Umsetzung hunderte von diesen LoRaNodes zum Einsatz. Das
mit 34,95‚Ç¨2relativ teure Feather M0 Board mit RFM95 Modul ist hier dem DIY Node
kostentechnisch deutlich unterlegen (siehe Tabelle 4.5 undTabelle 4.6).
Anmerkung: Die an die Nodes angeschlossenen kapazitiven Bodenfeuchtigkeitssensoren,
LiPoAkkus und Antennen-Dr√§hte werden bei diesem Kostenvergleich nicht mit ber√ºck-
sichtigt, da diese Komponenten in selber Form sowohl beim Feather M0 Node als auch
beim DIY Node ben√∂tigt werden.
Preis pro St√ºck Preis pro St√ºck
Bauteil (5 St√ºck) (100 St√ºck)
Feather M0 Board334,95‚Ç¨ 34,95‚Ç¨
Breadboard klein43,99‚Ç¨ 3,63‚Ç¨
Summe 38,94‚Ç¨ 38,58‚Ç¨
Tabelle 4.5: Kosten√ºbersicht f√ºr den Feather M0 Node";0
Aufbau eines Content-Management-Systems zur Erstellung von Android-Apps f√ºr den humanoiden Roboter PepperEin Konzept zur Umsetzung    Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, repr√§sentiert einen bedeutenden Fortschritt in der Human-Robot-Interaktion und stellt durch seine menschen√§hnlichen Eigenschaften sowie seine ausgekl√ºgelte Sensorik eine bemerkenswerte Plattform zur Verf√ºgung, um innovative Anwendungen zu entwickeln. Mit der zunehmenden Verbreitung von Robotern in unterschiedlichen Anwendungsbereichen, von der Gesundheitsversorgung bis hin zur Bildung und Unterhaltung, w√§chst das Bed√ºrfnis nach benutzerfreundlichen Werkzeugen, die auch Nutzern ohne umfangreiche Programmierkenntnisse die Erstellung von individuellen Anwendungen erm√∂glichen. Im Rahmen dieser Arbeit wird ein Konzept zur Entwicklung eines Content-Management-Systems (CMS) vorgestellt, das die Erstellung von Android-Apps f√ºr den Roboter Pepper unterst√ºtzen soll.   Konzeptualisierung des CMS  1. Zielsetzung und Anforderungsanalyse  Zun√§chst ist es entscheidend, die Anforderungen der Benutzer zu analysieren. Zu den Zielgruppen z√§hlen Entwickler mit unterschiedlichem technischen Hintergrund, Lehrer, Therapeuten und Unternehmer, die spezifische interaktive Anwendungen f√ºr Pepper erstellen m√∂chten. Die Hauptziele des CMS sind - BenutzerfreundlichkeitEine intuitive Benutzeroberfl√§che, die es Nutzern erm√∂glicht, ohne Programmierkenntnisse Apps zu gestalten. - Modularit√§tDie M√∂glichkeit, verschiedene Funktionalit√§ten modulweise hinzuzuf√ºgen, um die Vielfalt der Anwendungen zu erh√∂hen. - Integration von InhaltenUnterst√ºtzung f√ºr multimediale Inhalte (Audio, Video, Text), um ansprechende Anwendungen zu entwickeln. - Echtzeit-InteraktionDie F√§higkeit, Echtzeit-Daten und Sensorinformationen von Pepper zu nutzen.  2. Architektur des CMS  Die Architektur des CMS kann in drei Hauptkomponenten unterteilt werden - FrontendDie grafische Benutzeroberfl√§che (GUI), durch die der Benutzer mit dem CMS interagiert. Diese k√∂nnte auf Webtechnologien basieren (HTML, CSS, JavaScript), um eine Plattformunabh√§ngigkeit zu gew√§hrleisten.    - BackendEin serverseitiges System, das die Logik zur Verarbeitung der Benutzeranfragen und die Verwaltung der Inhalte implementiert. Hier k√∂nnte eine Kombination aus Technologien wie Node.js oder Python Flask zur Anwendung kommen, um eine RESTful API zu entwickeln.    - DatenbankEine relationale oder NoSQL-Datenbank (z.B. MongoDB) zur Speicherung von Benutzerinformationen, App-Daten und Mediendateien.  3. Modulbasierte Anwendungsentwicklung  Ein zentrales Element des CMS ist die modulare Struktur, die es Nutzern erm√∂glicht, Apps durch die Kombination vordefinierter Module zu erstellen. Diese Module k√∂nnten Folgendes umfassen - InteraktionsmoduleF√ºr Dialoge, Gesten und Emotionen. - SensormodulZugriff auf Peppers Sensoren, um Umgebungsdaten zu verwenden. - Multimedia-ModuleZum Einbinden von Videos, Bildern und Audiodateien.  Jedes Modul k√∂nnte durch eine grafische Benutzeroberfl√§che konfiguriert werden, die es dem Benutzer erm√∂glicht, spezifische Einstellungen und Parameter anzupassen.  4. Implementierung und Tests  Die Implementierung des CMS erfordert eine iterative Vorgehensweise, bei der das System schrittweise entwickelt und kontinuierlich getestet wird. Diese Tests sollten sowohl funktionale Aspekte (z.B. Benutzerfreundlichkeit, Performance) als auch Usability-Tests mit realen Nutzern umfassen, um sicherzustellen, dass das System den Bed√ºrfnissen der Zielgruppen gerecht wird.  Zusammenfassung und Ausblick  Die Entwicklung eines Content-Management-Systems zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper bietet eine vielversprechende M√∂glichkeit, die Interaktivit√§t und Anwendungsvielfalt des Roboters zu erweitern. Durch die Fokussierung auf Benutzerfreundlichkeit, Modularit√§t und Integration von Multimedia-Inhalten kann ein breiter Nutzerkreis angesprochen werden. Zuk√ºnftige Arbeiten k√∂nnten auf die Implementierung spezifischer Anwendungsf√§lle abzielen, um das CMS weiter zu verfeinern und die Funktionalit√§ten gezielt zu erweitern. Zudem k√∂nnten Integrationen mit weiteren Robotersystemen in Betracht gezogen werden, um die Anwendungsm√∂glichkeiten √ºber Pepper hinaus zu f√∂rdern.;1
Zur Entwicklung der Fahrzeugfernsteuerung soll zun√§chst die verwendete Hardware und deren Zusammenbau zur Fahrzeugfernsteuerung und zum Fahrzeugcontroller vorgestellt und die Xbee-Micro-Controller konfiguriert werden. Mit der aufgebauten Hardware wird dann die Software der Fahrzeugfernsteuerung und des Fahrzeugcontrollers entwickelt und die Feinabstimmung des entwickelten Protokolls und dessen Protokollstacks durchgef√ºhrt. Abschlie√üendsollendabeidieentwickeltenKomponentenaneinemPrototypendemonstriert und die Latenz zwischen Fernsteuerung und Fahrzeug evaluiert werden. SparkFun ThingPlus - Xbee3 Micro (U.FL.): Zur Kommunikation √ºber IEEE 802.15.4 wird der SparkFun Thing Plus - Xbee3 Micro (U.FL) -Controller1verwendet. Dieser integriert einen Xbee3 Micro mit einem U.FL-Antennenanschluss auf einem Board mit einem QWIIC-Konnektor, einem Batterie- und einem USB-Anschluss. Als Antenne wird dabei die Linx ANT-2.4-PML-UFL -Antenne2 verwendet Adafruit Pygamer: Als Controller f√ºr die Fernsteuerung wird der Adafruit Pygamer3 verwendet. Dieser besitzt einen Analogen Joystick, vier Buttons, einen Kopfh√∂reranschluss, Lautsprecher, einen Micro SD Kartenslot, und ein 1.8 Inch TFT Display. Als Prozessor wird hierbei der ATSAMD51J19 verwendet. Weitere Anschl√ºsse inkludieren zwei JST- Konnektoren und einen I2C-Grove-Konnektor. Adafruit Metro M4 Express Airlift: Als Controller f√ºr die Fahrzeugsteuerung wird derAdafruit Metro M4 Express Airlift verwendet. Dieser inkludiert einen ATSAMD51 Microchip und einen AirLift Wifi -Co-Prozessor, der Wi-FiundBLEf√ºr zuk√ºnftige Erweiterungen unterst√ºtzt. Als Anschl√ºsse werden I2C,SPI,UARTsowie weitere PWM- Ports zur Verf√ºgung gestellt. Ultraschallsensor: Als Abstandssensor f√ºr die Kollisionsvermeidung wird der Seed Grove Ultrasonic Distance Sensor1verwendet. Dieser hat eine Reichweite von 3cm bis zu 350cm mit einer Genauigkeit von bis zu 2mm und unterst√ºtzt Spannungen zwischen 5V und 3.3V. Angeschlossen werden kann dieser √ºber einen Grove-Konnektor.;0
In der vorliegenden Arbeit wurde der Vergleich von Progressive Web Apps (PWA) mit nativen Apps am Beispiel einer Journaling-App umfassend untersucht. Die Analyse der beiden Ans√§tze zeigte deutlich sowohl St√§rken als auch Schw√§chen, die in unterschiedlichen Kontexten und unter Ber√ºcksichtigung spezifischer Nutzerbed√ºrfnisse von Bedeutung sind.  PWAs stellen eine vielversprechende L√∂sung f√ºr Entwickler dar, die ohne die H√ºrden herk√∂mmlicher App-Store-Ver√∂ffentlichungen agile Anpassungen vornehmen m√∂chten. Sie bieten benutzerfreundliche Optionen, schnelle Ladezeiten und plattform√ºbergreifende Verf√ºgbarkeit, alles unter annehmbaren Nutzungskosten. Die bedeutende Unabh√§ngigkeit von Betriebssystemen und die M√∂glichkeit, Updates in Echtzeit zu implementieren, f√∂rdern zus√§tzlich eine flexiblere Nutzererfahrung.   Im Gegensatz dazu bieten native Apps optimierte Leistung und Zugriff auf vollst√§ndige Ger√§tefunktionen, was bei schweren Anwendungen oder Features, die intensive Hardwareinteraktionen erfordern, einen entscheidenden Vorteil darstellt. Diese Vorteile gehen jedoch h√§ufig mit h√∂heren Entwicklungskosten und einem gewissen Grad an Abh√§ngigkeit von App-Stores einher, die Ver√∂ffentlichungen einschr√§nken k√∂nnen.  Die Durchf√ºhrung von Nutzertests in dieser Arbeit ergab, dass die adaptive Benutzeroberfl√§che einer PWA vielen Nutzern als zeitgem√§√üer und zug√§nglicher empfunden wurde, w√§hrend andere die Vertrautheit und Geschwindigkeit nativer Apps bevorzugten. Dabei zeigte sich, dass der Einsatz der Technologie stark von den individuellen Pr√§ferenzen und den jeweiligen Anwendungsszenarien abh√§ngig ist.   Abschlie√üend l√§sst sich festhalten, dass die Wahl zwischen PWAs und nativen Apps nicht pauschalisierbar ist. F√ºr die Entwicklung einer Journaling-App empfiehlt sich eine gr√ºndliche Analyse der Zielgruppenbed√ºrfnisse sowie der angestrebten Funktionalit√§ten, um zu einer informierten Entscheidung kommen zu k√∂nnen. K√ºnftige Studien k√∂nnten ebenfalls zur weiteren Differenzierung von Anwendungsf√§llen sowie Technologien beitragen, welche in einer zunehmend diversifizierten Digitallandschaft von gro√üer Bedeutung sind.;1
F√ºr dem Fahrzeugcontroller werden, wie schon bereits im Abschnitt 5.2. beschrieben, die Controller Adafruit Adafruit Metro M4 Airlift undSparkfunThingPlus - Xbee3Micro sowie dieLinx ANT-2.4-PML-UFL -Antenne verwendet. Zu Demonstrationszwecken wird hier der Ultraschall-Abstandssensor von Seed verwendet. Die Kommunikation zwischen dem Thingplus-Controller und dem Metro M4-Controller erfolgt, wie auch schon bei der Fahrzeugfernsteuerung in Abschnitt 5.3.1√ºberI2Cund die Kommunikation mit dem Abstandssensor √ºber einen Grove-Konnektor mit digitalen Signalen. Das ist insofern kein Problem, als das der Metro M4-Controller sowohl einen 5V als auch einen 3V Ausgang besitzt und so sowohl den Ultraschallsensor als auch den ThingPlus-Controller mit Strom versorgen kann. Bei einem sp√§teren Einbau in ein Fahrzeug wird dann die Stromversorgung √ºber das Fahrzeug √ºbernommen. Die Integration eines NotAus-Schalters wird dabei nicht im Controller vorgenommen sondern erfolgt zu einem sp√§teren Zeitpunkt beim Einbau in das Fahrzeug, um dort den Stromkreis zu unterbrechen.;0
Eine   Die fortschreitende Digitalisierung und die damit einhergehende Notwendigkeit zur effizienten Verwaltung digitaler Inhalte haben die Entwicklung von Content-Management-Systemen (CMS) ma√ügeblich beeinflusst. Diese Systeme erm√∂glichen es Unternehmen und Organisationen, Inhalte zu erstellen, zu verwalten und zu ver√∂ffentlichen, ohne dass tiefgehende technische Kenntnisse erforderlich sind. Die Evaluierung von CMS ist daher ein entscheidender Schritt f√ºr die erfolgreiche Implementierung in einem Projekt. In diesem Text werden verschiedene CMS hinsichtlich ihrer Funktionalit√§ten, Benutzerfreundlichkeit, Flexibilit√§t und Kosten strukturiert gegen√ºbergestellt.  Zun√§chst ist die Funktionalit√§t eines CMS von zentraler Bedeutung. Systeme wie WordPress, Joomla und Drupal bieten unterschiedliche Module und Plugins, die spezifische Anforderungen abdecken k√∂nnen. WordPress beispielsweise ist bekannt f√ºr seine Benutzerfreundlichkeit und eine gro√üe Auswahl an Plugins, die die Funktionalit√§t erweitern. Joomla hingegen bietet eine st√§rkere Benutzerverwaltung und eignet sich besser f√ºr komplexere Websites. Drupal wird oft f√ºr gro√üe, skalierbare Projekte bevorzugt, da es eine hohe Flexibilit√§t und Anpassungsf√§higkeit bietet. Bei der Evaluierung sollte daher der spezifische Anwendungsfall des Projekts im Vordergrund stehen, um das passende CMS auszuw√§hlen.  Ein weiterer wichtiger Aspekt ist die Benutzerfreundlichkeit. Ein CMS sollte intuitiv bedienbar sein, um den Redakteuren und Administratoren eine einfache Handhabung zu erm√∂glichen. Hier hat WordPress einen klaren Vorteil, da es eine benutzerfreundliche Oberfl√§che bietet, die auch f√ºr technisch weniger versierte Nutzer leicht verst√§ndlich ist. Joomla und Drupal hingegen erfordern oft eine steilere Lernkurve, was in Projekten mit wenig technischer Unterst√ºtzung zu Herausforderungen f√ºhren kann. Die Evaluierung der Benutzerfreundlichkeit sollte durch Usability-Tests und Feedback von potenziellen Nutzern erfolgen, um sicherzustellen, dass das gew√§hlte System den Anforderungen der Nutzer gerecht wird.  Flexibilit√§t und Anpassungsf√§higkeit sind weitere zentrale Kriterien in der Evaluierung von CMS. W√§hrend WordPress in der Regel f√ºr kleinere bis mittelgro√üe Projekte eingesetzt wird, bietet Drupal eine umfassendere L√∂sung f√ºr komplexe Anwendungen, die ma√ügeschneiderte L√∂sungen erfordern. Die M√∂glichkeit, eigene Module zu entwickeln und bestehende Funktionen anzupassen, kann entscheidend f√ºr den langfristigen Erfolg eines Projekts sein. Bei der Evaluierung sollte daher auch die Entwicklungsressource und die technische Expertise des Teams ber√ºcksichtigt werden.  Schlie√ülich spielen die Kosten eine wesentliche Rolle in der Evaluierung von Content-Management-Systemen. Die Gesamtkosten setzen sich nicht nur aus den Lizenzgeb√ºhren zusammen, sondern auch aus den Kosten f√ºr Hosting, Wartung und gegebenenfalls Anpassungen. Open-Source-L√∂sungen wie WordPress und Joomla bieten den Vorteil, dass sie kostenlos genutzt werden k√∂nnen, was insbesondere f√ºr kleine Unternehmen und Start-ups attraktiv ist. Bei gr√∂√üeren Projekten kann jedoch die Investition in ein kommerzielles CMS, das umfassenden Support und regelm√§√üige Updates bietet, langfristig kosteneffizienter sein.  In der abschlie√üenden Bewertung der CMS ist es entscheidend, eine umfassende Analyse durchzuf√ºhren, die alle oben genannten Kriterien ber√ºcksichtigt. Eine strukturierte Evaluierung, die sowohl qualitative als auch quantitative Daten einbezieht, erm√∂glicht es Entscheidungstr√§gern, eine fundierte;1
Eine   In der heutigen digitalen √Ñra spielt die Auswahl des geeigneten Content-Management-Systems (CMS) eine entscheidende Rolle f√ºr den Erfolg von Online-Projekten. Ein CMS stellt eine Softwarel√∂sung dar, die es Benutzern erm√∂glicht, digitale Inhalte zu erstellen, zu verwalten und zu ver√∂ffentlichen, ohne umfassende technische Kenntnisse zu ben√∂tigen. Bei der Evaluierung von CMS-Plattformen sind verschiedene Kriterien zu ber√ºcksichtigen, die im Folgenden systematisch gegen√ºbergestellt werden. Diese Kriterien umfassen Benutzerfreundlichkeit, Funktionalit√§t, Anpassungsf√§higkeit, Sicherheit und Kosten.  Benutzerfreundlichkeit  Die Benutzerfreundlichkeit ist ein zentraler Aspekt bei der Evaluierung von CMS-L√∂sungen. Ein intuitives Interface f√∂rdert nicht nur die Effizienz, sondern auch die Akzeptanz der Benutzer. Systeme wie WordPress und Drupal zeigen deutliche Unterschiede in ihrer Benutzeroberfl√§che. WordPress ist bekannt f√ºr seine einfache Bedienbarkeit, was es insbesondere f√ºr weniger technikaffine Benutzer attraktiv macht. Im Gegensatz dazu bietet Drupal erweiterte Funktionalit√§ten, die jedoch eine steilere Lernkurve erfordern. Diese Unterschiede k√∂nnen erhebliche Auswirkungen auf die Implementierung eines Projekts haben, da ein komplexeres System mehr Schulungsressourcen ben√∂tigt.  Funktionalit√§t  Die Funktionalit√§t eines CMS ist entscheidend f√ºr die Arten von Projekten, die es unterst√ºtzen kann. W√§hrend WordPress durch eine Vielzahl von Plugins eine breite Palette an Funktionen bietet, ist Drupal daf√ºr bekannt, komplexe Websites und Anwendungen mit individuellen Anforderungen handhaben zu k√∂nnen. Eine ausf√ºhrliche Evaluierung sollte die spezifischen funktionalen Anforderungen des Projekts ber√ºcksichtigen. Beispielsweise k√∂nnte eine E-Commerce-Plattform von den umfangreichen M√∂glichkeiten von WooCommerce (einem WordPress-Plugin) profitieren, w√§hrend eine technische Dokumentationsseite eventuell die flexible Struktur von Drupal ben√∂tigen k√∂nnte.  Anpassungsf√§higkeit  Die Anpassungsf√§higkeit eines CMS wird oft als seine F√§higkeit definiert, sich an die individuellen Bed√ºrfnisse eines Projekts anzupassen. WordPress erm√∂glicht durch eine Vielzahl von Themes und Plugins eine schnelle Anpassung, wobei die Benutzer einfache Ver√§nderungen ohne Programmierkenntnisse vornehmen k√∂nnen. Drupal hingegen erfordert h√§ufig tiefere technische Eingriffe, bietet daf√ºr aber eine ungleich h√∂here Flexibilit√§t, insbesondere in Bezug auf benutzerdefinierte Content-Types und Taxonomien. Bei der Evaluierung ist es entscheidend, die langfristigen Ziele des Projekts zu betrachten, um die Anpassungsf√§higkeit des CMS mit den Anforderungen des Unternehmens abzugleichen.  Sicherheit  Die Sicherheit eines CMS ist ein weiterer wichtiger Evaluationsfaktor. Sicherheitsl√ºcken in einer CMS-Plattform k√∂nnen schwerwiegende Folgen f√ºr den Projektverlauf und das Vertrauen der Benutzer haben. WordPress, als die am h√§ufigsten eingesetzte CMS-L√∂sung, ist aufgrund seiner Popularit√§t besonders anf√§llig f√ºr Angriffe. Regelm√§√üige Updates und Sicherheitsma√ünahmen sind unerl√§sslich. Drupal wird oft als sicherer angesehen, was es f√ºr Organisationen, die hochsensiblere Daten verwalten, attraktiver macht. Die Wahl des CMS sollte somit auch auf die Sicherheitsbed√ºrfnisse des Projekts abgestimmt sein.  Kosten  Letztendlich spielen auch die Kosten eine entscheidende Rolle bei der Wahl des passenden CMS. W√§hrend WordPress eine Open-Source-L√∂sung ist und viele kostenlose Plugins und Themes bietet, k√∂nnen die Kosten f√ºr Premium-Features schnell steigen, besonders wenn umfangreiche Anpassungen notwendig sind. Drupal erfordert h√§ufig tiefere technische Ressourcen, was zu h√∂heren Kosten in der Implementierung und Wartung f√ºhren kann. Budgetrestriktionen m√ºssen daher in jedem Evaluierungsprozess gr√ºndlich ber√ºcksichtigt werden, da sie den gesamten Projektverlauf beeinflussen k√∂nnen.  Fazit  Die Evaluierung von Content-Management-Systemen erfordert eine sorgf√§ltige Abw√§gung verschiedener Faktoren, die sich auf die spezifischen Bed√ºrfnisse eines Projekts auswirken. Benutzerfreundlichkeit, Funktionalit√§t, Anpassungsf√§higkeit, Sicherheit und Kosten sind kritische Elemente, die in ihrer Gesamtheit betrachtet werden m√ºssen, um die optimale CMS-L√∂sung zu identifizieren. Letztlich sollte jedes Projekt individuell analysiert werden, wobei die langfristigen Anforderungen und ressourcenspezifischen Gegebenheiten im Mittelpunkt stehen sollten. Eine gr√ºndliche Evaluierung wird dazu beitragen, unerwartete Herausforderungen w√§hrend der Implementierung zu minimieren und die Erfolgsaussichten des Projekts zu maximieren.;1
Im Bereich des Teleoperated Driving werden in der Literatur verschiedene Themen behan- delt. So wird in  und  die Human-Robot Integration (HRI) bei Rettungsrobotern untersucht und dabei auch praktische Beispiele, wie die Rettungsaktionen auf den An- schlag des World Trade Center im Jahr 2001 analysiert. Ein weiterer Schwerpunkt ist dabei die Evaluation der menschlichen Performance. So wird in  der Einfluss von Zeitverz√∂gerungen, des Design des User-Interfaces und der Video-√úbertragung auf die menschliche Leistung bei teleoperierten Robotern untersucht. Spezieller wird in  und  der Einfluss von zeitlichen Verz√∂gerungen auf die Leistung bei fahrbaren teleoperierten Robotern und m√∂gliche Gegenma√ünahmen untersucht. Allgemeiner werden zeitliche Verz√∂gerungen als bestimmende Gr√∂√üe der menschlichen Leistung bei interaktiven Systemen erarbeitet und an Visua- lisierungsmethoden von Latenzen bei teleoperierten Fahrzeugen geforscht. In einem Experteninterview werden in  allgemeine Herausforderungen beim Teleoperated Driving erarbeitet. Andere Beitr√§ge legen den Fokus auf die Datenverbindung und das Systemdesign im Bereich des Teleoperated Driving. So wird an der Technischen Universit√§t M√ºnchen der Einsatz des Mobilfunkstandards 3G als Datenverbindung betrachtet und dabei Latenzen und Verz√∂gerungen analysiert. √Ñhnliche Untersuchungen fokus- sieren sich dabei auf die Kommunikation im Zusammenhang mit dem Systemdesign oder f√ºhren Machbarkeitsstudien zur Umsetzung des teleoperier- ten Fahrens mit Mobilfunkverbindungen und mobilen Netzwerken durch. Neben theoretischen Arbeiten zu den einzelnen Aspekten des teleoperierten Fahrens sind in der Literatur auch konkrete Umsetzungen und Praxisbeispiele zu finden. Projekte sind hierbei die Umsetzung eines teleoperierten autonomen Vehikels, die Umsetzung eines teleoperierten Mond-Rovers mit Lidar, die Umsetzung eines teleoperierten Stra√üenfahrzeugs mit immersiver Telepr√§senz unter der Benutzung von allgemein erh√§ltlichen Standard-Komponenten, Grundlagen und Systemdesign beim Teleoperated Driving und derFreie Korridor als Sicherheitsstrategie bei teleoperierten Stra√üenfahrzeugen.;0
Grundlage f√ºr das Datenmodell sind selbst modellierte und erstellte Testdatens√§tze, deren Inhalte von der hier verlinken Seite stammen (Siehe ). Jeder Datensatz enth√§lt zus√§tzlich ein Bild, welches von der Open-source Bildplattform Pixabay stammt und deshalb ohne weitere Beachtung von Nutzungslizenzen im Projekt verwendet werden kann . Folgende Abbildung 3.2 zeigt den Aufbau eines solchen CoÔ¨Äee-Objektes. Abbildung 3.2: Darstellung eines CoÔ¨Äee-Objektes Zudem l√§sst die Abbildung 3.2 durch die Annotation @Entity erkennen, dass f√ºr die persistente Speicherung der Anwendungsdaten die Room-Bibliothek verwendet wird. Diese stellt einen Abstraktionslayer √ºber eine SQLite-Datenbank dar und bietet eine geeignete M√∂glichkeit, die Daten in strukturierter Weise lokal auf dem Ger√§t abzuspeichern. Durch das Cachen der Anwendungsdaten im lokalen Ger√§tespeicher kann eine OÔ¨Ñinef√§higkeit der Anwendung erreicht werden . Die Nutzung dieser Bibliothek wird von Google strengstens empfohlen und ist auch in Jetpack Compose m√∂glich. Zu den Vorteilen z√§hlen neben der VeriÔ¨Åzierung von Structured Query Language (SQL)-Queries w√§hrend der Kompilierzeit auch die zahlreichen Annota- tionen, die zu einer sehr √ºbersichtlichen Implementierung und wenig sich wiederholendem Boilerplate-Code f√ºhren. Auch eine Migration der Datenbank ist sehr einfach m√∂glich , . F√ºr die Nutzung werden haupts√§chlich drei Kompo- nenten ben√∂tigt: Entities, Data Access Objects (DAOs) und eine Klasse Database. Ein Entity ist eine annotierte Klasse, die eine Tabelle in der Datenbank repr√§sentiert (Vgl. CoÔ¨Äee Entity, Abbildung 3.2) Jedes einzelne CoÔ¨Äee-Objekt stellt somit eine Reihe in dieser Tabelle dar.;0
Templates und Views Die View einer Component wird in einer Form HTML Template deÔ¨Åniert. Dieses Template sieht wie HTML aus, enth√§lt aber auch Angular speziÔ¨Åsche Syntax, welche die HTML an die Logik der App anpasst. Views sind hierarchisch organisiert, dadurch k√∂nnen sie als Einheit dargestellt werden. Hierbei k√∂nnen Views des gleichen NgModules oder auch Views eines anderen NgModules in einer Hierarchie dargestellt werden. Die Component muss zu dem NgModule geh√∂ren, ansonsten kann sie von anderen Components nicht gefunden und verwendet werden.;0
 Kapitel 4: Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung basierend auf IEEE 802.15   4.1 Einleitung  In Anbetracht der fortschreitenden Automatisierung im Verkehrssektor und der steigenden Nachfrage nach sicheren und effizienten Fortbewegungsm√∂glichkeiten ist die Entwicklung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung zu einem zentralen Thema geworden. Der Fokus dieses Kapitels liegt auf der Konzeption und Umsetzung einer solchen L√∂sung, die auf dem Standard IEEE 802.15 basiert. Dar√ºber hinaus werden die Herausforderungen, Technologien und Vorarbeiten er√∂rtert, die zur Realisierung dieser L√∂sung entscheidend sind.   4.2 Grundlagen der Fahrzeugfernsteuerung  Eine Fahrzeugfernsteuerung erm√∂glicht die Manipulation eines Fahrzeugs aus der Ferne, ohne dass ein Fahrer direkt im Fahrzeug sitzen muss. In der heutigen Zeit finden solche Systeme vor allem Anwendung in der Logistik, im Milit√§r und in der Sicherheitstechnik. Um eine sichere und zuverl√§ssige Steuerung gew√§hrleisten zu k√∂nnen, ist es entscheidend, ein robustes Kommunikationssystem zu entwickeln, das in der Lage ist, Informationen schnell und pr√§zise zu √ºbertragen.   4.3 Relevanz von IEEE 802.15  IEEE 802.15 ist ein Standard f√ºr drahtlose pers√∂nliche Netzwerke (WPAN). Die dort definierten Protokolle erlauben eine hohe Flexibilit√§t und Skalierbarkeit, weshalb sie sich hervorragend f√ºr die Entwicklung einer Fahrzeugfernsteuerung eignen. Insbesondere die Spezifikationen f√ºr Bluetooth und ZigBee bieten die entscheidenden Voraussetzungen f√ºr kurze Kommunikationsdistanzen und den Austausch von Sensordaten unter minimalem Energieverbrauch.   4.4 Anforderungen an die L√∂sung  Die erfolgreiche Implementierung einer Fahrzeugfernsteuerung umfasst mehrere technische sowie sicherheitstechnische Anforderungen:  1. Zuverl√§ssigkeit der Kommunikation: Die Daten√ºbertragung zwischen Steuerungseinheit und Fahrzeug muss stabil und unterbrechungsfrei funktionieren. 2. Echtzeitf√§higkeit: Da schnell auf unerwartete Hindernisse reagiert werden muss, ist die Echtzeitverarbeitung von Sensordaten notwendig. 3. Kollisionsvermeidung: Implementierung von Algorithmen zur Erkennung und Vermeidung von Kollisionen in Echtzeit. 4. Energieeffizienz: Die Systeme m√ºssen so konzipiert sein, dass sie minimalen Energieverbrauch aufweisen, insbesondere wenn sie √ºber l√§ngere Zeitr√§ume betrieben werden.   4.5 Technologischer Einsatz  F√ºr die Umsetzung wurden verschiedene Technologien integriert:  - Sensorik: LIDAR und Ultraschallsensoren zur Abstandsmessung und Hinderniserkennung wurden in das Fahrzeug integriert. Diese Sensoren erm√∂glichen zudem eine 360-Grad-√úberwachung der Umgebung.    - Aktorseinheiten: Servomotoren und elektronische Steuerungen wurden verwendet, um die Lenkung, Bremsen und Beschleunigung des Fahrzeugs zu steuern.  - Kommunikationsprotokolle: ZigBee wurde als Kommunikationsprotokoll ausgew√§hlt, da es sich durch geringe Latenz- und Energiekosten auszeichnet, was besonders f√ºr tragbare Steuerger√§te vorteilhaft ist.   4.6 Prototypentwicklung  Die Entwicklung eines Prototypen bestand aus mehreren Phasen:  1. Konzeptionsphase: In dieser Phase wurden die grundlegenden Anforderungen und das Kommunikationsprotokoll definiert. Die Entscheidung f√ºr ZigBee war auf seine Vorteile in der Energieeffizienz und Reichweite zur√ºckzuf√ºhren.  2. Hardware-Integration: Aufbau des Prototypen mithilfe einer Mikrocontroller-Plattform wie Arduino oder Raspberry Pi, verbunden mit den entsprechenden Sensoren und Aktoren. Eine erste Versuchsanordnung wurde erstellt, um die Funktionalit√§t der Hardware zu testen.  3. Softwareentwicklung: Ein Algorithmus f√ºr die Kollisionsvermeidung wurde entwickelt, der kontinuierlich Sensordaten verarbeitet und bei Bedarf die Steuerungsbefehle an das Fahrzeug anpasst. F√ºr die Programmierung wurde eine modulare Architektur gew√§hlt, sodass Entwicklungen und Anpassungen effizient implementiert werden k√∂nnen.  4. Testphase: In kontrollierten Umgebungen wurden umfangreiche Tests durchgef√ºhrt. Hierbei wurden verschiedene Szenarien simuliert, um das Reaktionsverhalten des Fahrzeugs zu √ºberpr√ºfen und die Anforderungen an Echtzeitverarbeitung und Kommunikationsstabilit√§t zu evaluieren.   4.7 Ergebnisse und Ausblick  Die ersten Testergebnisse zeigten, dass das System in der Lage war, Hindernisse zuverl√§ssig zu erkennen und ad√§quat darauf zu reagieren. Die Verwendung von IEEE 802.15 gew√§hrleistete eine stabile und reaktionsschnelle Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug.   F√ºr die weitere Forschung sind verschiedene Optimierungsans√§tze denkbar, wie etwa die Integration von K√ºnstlicher Intelligenz zur Verbesserung der Entscheidungsprozesse oder die Weiterentwicklung der Sensorik zur Erh√∂hung der Reichweite und Pr√§zision der Hinderniserkennung.   4.8 Fazit  Die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 stellt eine vielversprechende L√∂sung dar, die sowohl in kommerziellen als auch in sicherheitsrelevanten Anwendungen sinnvoll eingesetzt werden kann. Durch den Einsatz moderner Technologien und die gezielte Umsetzung der organisatorischen Anforderungen konnte ein funktionierendes System realisiert werden, das in Zukunft weiter optimiert und angepasst werden kann.;1
 Ausblick  Die Programmierung hat sich in den letzten Jahren rasant entwickelt, und mit ihr die Sprachen, die Entwickler zur Erstellung moderner Anwendungen nutzen. Insbesondere im Kontext der Android-Entwicklung haben Java und Kotlin eine zentrale Rolle eingenommen. W√§hrend Java seit vielen Jahren als die Standardprogrammiersprache f√ºr Android gilt, hat Kotlin, als moderne Alternative, zunehmend an Popularit√§t gewonnen. Diese Arbeit hat die Unterschiede, Vor- und Nachteile beider Sprachen beleuchtet und deren Einfluss auf die Softwareentwicklung analysiert.  Im Ausblick auf die zuk√ºnftige Entwicklung von Java und Kotlin ist festzustellen, dass die Entscheidung f√ºr eine der beiden Sprachen nicht nur von technischen Aspekten abh√§ngt, sondern auch von der Community, den verf√ºgbaren Ressourcen und der Unterst√ºtzung durch die Plattformen. Kotlin hat sich als eine Sprache etabliert, die nicht nur die Produktivit√§t erh√∂ht, sondern auch die Codequalit√§t verbessert, was zu einer steigenden Akzeptanz unter Entwicklern f√ºhrt. Die Integration von Kotlin in die Android-Entwicklungsumgebung durch Google hat diese Tendenz weiter verst√§rkt und k√∂nnte zu einer Verschiebung der Marktdominanz f√ºhren.  Zuk√ºnftige Forschungsarbeiten k√∂nnten sich darauf konzentrieren, wie die Migration von bestehenden Java-Projekten zu Kotlin gestaltet werden kann, um die Vorteile der modernen Sprache zu nutzen, ohne bestehende Systeme zu gef√§hrden. Zudem w√§re eine tiefere Analyse der Performance-Unterschiede zwischen den beiden Sprachen in realen Anwendungsszenarien von Interesse. Schlie√ülich k√∂nnte die Untersuchung der Lernkurven und der Entwicklerzufriedenheit bei der Nutzung von Java versus Kotlin wertvolle Erkenntnisse liefern, die sowohl f√ºr Bildungseinrichtungen als auch f√ºr Unternehmen von Bedeutung sind.  Insgesamt zeigt der Vergleich von Java und Kotlin, dass die Wahl der Programmiersprache weitreichende Implikationen f√ºr die Softwareentwicklung hat. Die zuk√ºnftige Entwicklung wird davon abh√§ngen, wie gut die Sprachen sich an die sich wandelnden Anforderungen der Branche anpassen k√∂nnen und inwieweit die Entwicklergemeinschaft bereit ist, neue Paradigmen zu akzeptieren. Die vorliegende Arbeit stellt somit nicht nur einen √úberblick √ºber den aktuellen Stand dar, sondern bietet auch einen Ansto√ü f√ºr weiterf√ºhrende Diskussionen und Forschungen in diesem dynamischen und spannenden Bereich der Informatik.;1
Evaluierung: Gegen√ºberstellung von Content-Management-Systemen  In der heutigen digitalen √Ñra sind Content-Management-Systeme (CMS) zu einem unverzichtbaren Werkzeug f√ºr Unternehmen und Organisationen geworden, die ihre Online-Pr√§senz effektiv verwalten m√∂chten. Die Auswahl des richtigen CMS kann entscheidend f√ºr den Erfolg eines Webprojekts sein, da es nicht nur die Benutzerfreundlichkeit und Flexibilit√§t beeinflusst, sondern auch die Skalierbarkeit und zuk√ºnftige Anpassungsf√§higkeit. Diese Evaluierung zielt darauf ab, verschiedene CMS zu vergleichen und deren Vor- und Nachteile zu analysieren, um eine fundierte Entscheidungsgrundlage zu schaffen.  Zun√§chst ist es wichtig, die grundlegenden Kategorien von CMS zu betrachten. Die meisten Systeme lassen sich in drei Hauptgruppen einteilen: Open-Source-CMS, propriet√§re CMS und SaaS-basierte L√∂sungen. Open-Source-CMS wie WordPress, Joomla und Drupal bieten den Vorteil der Kostenfreiheit und einer gro√üen Community, die kontinuierlich Erweiterungen und Support bereitstellt. Diese Systeme sind besonders attraktiv f√ºr kleine bis mittelst√§ndische Unternehmen, die √ºber begrenzte Budgets verf√ºgen, jedoch eine hohe Flexibilit√§t und Anpassungsf√§higkeit ben√∂tigen. WordPress, als das am weitesten verbreitete CMS, zeichnet sich durch eine benutzerfreundliche Oberfl√§che und eine Vielzahl von Plugins aus, die die Funktionalit√§t erheblich erweitern. Gleichzeitig bringt es jedoch Herausforderungen in Bezug auf Sicherheit und Wartung mit sich, die nicht untersch√§tzt werden sollten.  Im Gegensatz dazu stehen propriet√§re CMS, die oft von spezialisierten Anbietern entwickelt werden und h√§ufig umfassende Support- und Wartungsdienste anbieten. Diese Systeme sind in der Regel kostenpflichtig und bieten ma√ügeschneiderte L√∂sungen, die auf die spezifischen Bed√ºrfnisse eines Unternehmens zugeschnitten sind. Ein Beispiel hierf√ºr ist Adobe Experience Manager, das eine leistungsstarke Integration mit anderen Adobe-Produkten erm√∂glicht. Allerdings kann die Abh√§ngigkeit von einem Anbieter und die damit verbundenen Kosten eine H√ºrde f√ºr viele Unternehmen darstellen.  SaaS-basierte CMS-L√∂sungen, wie Wix oder Squarespace, bieten eine weitere interessante Option. Diese Systeme sind in der Regel einfach zu bedienen und erfordern keine technischen Kenntnisse, was sie besonders f√ºr Start-ups und Einzelunternehmer attraktiv macht. Sie bieten jedoch oft weniger Anpassungsm√∂glichkeiten und k√∂nnen in Bezug auf die Skalierbarkeit eingeschr√§nkt sein. Die monatlichen Geb√ºhren k√∂nnen sich √ºber die Zeit summieren, was die langfristige Kostenbetrachtung erschwert.  Ein weiterer wichtiger Aspekt bei der Gegen√ºberstellung von CMS ist die Benutzerfreundlichkeit. W√§hrend einige Systeme eine steile Lernkurve aufweisen, bieten andere intuitive Oberfl√§chen, die es auch Nicht-Technikern erm√∂glichen, Inhalte einfach zu erstellen und zu verwalten. Hierbei spielen auch die M√∂glichkeiten zur Suchmaschinenoptimierung (SEO) eine entscheidende Rolle. Ein CMS, das von Haus aus SEO-freundliche Funktionen bietet, kann den Unterschied in der Sichtbarkeit einer Website ausmachen.  Zusammenfassend l√§sst sich sagen, dass die Wahl des richtigen Content-Management-Systems von einer Vielzahl von Faktoren abh√§ngt, darunter Budget, technische Expertise, spezifische Anforderungen und langfristige Ziele. Jedes CMS hat seine eigenen St√§rken und Schw√§chen, die sorgf√§ltig abgewogen werden m√ºssen. Eine umfassende Evaluierung der verf√ºgbaren Systeme, gepaart mit einer klaren Definition der eigenen Bed√ºrfnisse, ist;1
In Kotlin wird der Wildcard -Ansatz erse tzt durch die  declaration -site variance und  type projections.  Denn Java ben√∂tigt diese Art von Platzhaltern, weil generische  Typen in Java unver√§nderlich  sind und somit z. B. ‚ÄöList<String> ‚Äò kein Untertyp  von ‚ÄöList<Object> ‚Äò w√§re . ‚ÄöList‚Äò w√§re invariant und i n diesem Fall g√§be es nahezu  keine Performance Steigerung im Vergleich zu ‚ÄöList‚Äò  als normales Array.  Eine type projection  in Kotlin  ist eine Beschr√§nkung eines Typs auf eine Teilmenge  von sich selbst. Wird eine Klasse z. B. als invariant definiert, muss aber auf   kovariantem oder kontravariantem Weg genutzt werden, adressiert Kotlin dieses  Problem mithilfe der type projections.32 Bei der Verwendung von Typparametern  wird zwischen use site und declaration site variance unterschieden, wobei bei der  site varian ce die Varianz der Typparameter durch die Variable selbst festgelegt wird,  wie es auch in Java der Fall w√§re.  Bei der Declaration site variance wird die Varianz  von dem Typ oder der Funktion bestimmt, wie es in Kotlin gehandhabt  wird. Eine  type projection erm√∂glicht es, die f√ºr einen Typ verf√ºgbaren Funktionen  einzuschr√§nken, damit die notwendigen Kriterien erf√ºllt werden, um dann als  kovariant oder kontravariant betrachtet werden  zu k√∂nnen  und eliminiert die  Notwendigkeit von Wildcard types .;0
 Anforderungsanalyse an ein Aufgaben Management Tool zur Unterst√ºtzung des studentischen Software Engineerings     Die rapide Entwicklung der Softwaretechnik und die damit verbundenen Herausforderungen erfordern von Studierenden nicht nur technische Kenntnisse, sondern auch die F√§higkeit, Projekte effektiv zu managen. In diesem Kontext spielt das Aufgaben Management Tool (AMT) eine entscheidende Rolle, da es Studierenden erm√∂glicht, Aufgaben zu priorisieren, den Fortschritt zu √ºberwachen und die Zusammenarbeit im Team zu f√∂rdern. Diese Arbeit fokussiert sich auf die Anforderungsanalyse und Evaluierung eines spezifischen AMTs, um dessen Effektivit√§t und Benutzerfreundlichkeit im Rahmen des studentischen Software Engineerings zu beleuchten.   Anforderungsanalyse  Die Anforderungsanalyse ist der Ausgangspunkt jeder Softwareentwicklung und umfasst die Identifikation, Dokumentation und Validierung der Bed√ºrfnisse der Benutzer. Im Fall des AMTs f√ºr studentisches Software Engineering gliedern sich die Anforderungen in funktionale und nicht-funktionale Anforderungen.  1. Funktionale Anforderungen    - AufgabenmanagementDie Anwendung muss die M√∂glichkeit bieten, Aufgaben zu erstellen, zu bearbeiten, zu priorisieren und zu l√∂schen. Studierende sollten Aufgaben mehreren Projekten zuordnen k√∂nnen.    - Deadline-ManagementEine Funktion zur Festlegung von Fristen f√ºr jede Aufgabe sowie zur Benachrichtigung der Nutzer √ºber anstehende Deadlines ist unerl√§sslich.    - TeamkoordinationDie M√∂glichkeit zur Zuweisung von Aufgaben an Teammitglieder und zur F√∂rderung der Kommunikation innerhalb des Teams ist entscheidend.    - FortschrittsverfolgungDas Tool sollte eine visuelle Darstellung des Aufgabenzustands bieten, z.B. durch Kanban-Boards oder Gantt-Diagramme.    - DokumentationDie Integration von Dokumentationsm√∂glichkeiten zur Ablage von Projektdokumenten und Code-Snippets direkt im Tool ist notwendig.  2. Nicht-funktionale Anforderungen    - BenutzerfreundlichkeitDas Design des Tools muss intuitiv und benutzerorientiert sein, um eine geringe Eingew√∂hnungszeit zu gew√§hrleisten.    - PerformanceDie Anwendung sollte auch bei gleichzeitiger Nutzung durch mehrere Parteien schnell und zuverl√§ssig funktionieren.    - Zug√§nglichkeitDas AMT sollte plattform√ºbergreifend nutzbar sein, um verschiedenen Betriebssystemen und Internetzug√§ngen gerecht zu werden.    - DatenschutzAngesichts der Sensibilit√§t studentischer Daten muss die Anwendung alle relevanten Datenschutzrichtlinien einhalten.     Die Evaluierung des AMTs erfolgt durch eine Kombination aus qualitativen und quantitativen Methoden, um sowohl die Benutzererfahrung als auch die Erf√ºllung technischer Anforderungen zu bewerten. Ein iterativer Ansatz, bei dem Benutzerfeedback in jeder Phase des Entwicklungsprozesses eingeholt wird, ist hierbei besonders wertvoll.  1. BenutzerbefragungenW√§hrend der Testphase k√∂nnen Umfragen unter den Studierenden durchgef√ºhrt werden, um deren Meinungen zur Benutzerfreundlichkeit, Funktionalit√§t und zur allgemeinen Zufriedenheit mit dem Tool zu sammeln. Dies liefert wertvolle Einblicke in potenzielle Verbesserungsbereiche.  2. Usability-TestsDurch die Beobachtung einer Testgruppe von Studierenden w√§hrend der Nutzung des AMTs k√∂nnen Probleme und H√ºrden in der Benutzeroberfl√§che aufgedeckt werden. Die Testergebnisse helfen, konkrete Anpassungen am Design und an den Funktionen vorzunehmen.  3. Leistungskennzahlen (KPIs)Die Messung von KPIs wie der durchschnittlichen Bearbeitungszeit f√ºr Aufgaben, der Anzahl der abgeschlossenen Aufgaben binnen eines bestimmten Zeitrahmens und der H√§ufigkeit von Teaminteraktionen kann quantifizierbare Ergebnisse √ºber die Effektivit√§t des Tools liefern.  4. Iterative SoftwareentwicklungBasierend auf den gesammelten Daten aus den Benutzerbefragungen, Usability-Tests und KPIs erfolgt eine kontinuierliche Verbesserung des Tools, um es den Anforderungen der Studierenden bestm√∂glich anzupassen.   Fazit  Die Entwicklung eines effektiven Aufgaben Management Tools zur Unterst√ºtzung des studentischen Software Engineerings erfordert eine sorgf√§ltige Anforderungsanalyse sowie eine umfassende Evaluierung. Durch die Ber√ºcksichtigung sowohl funktionaler als auch nicht-funktionaler Anforderungen kann ein ma√ügeschneidertes Tool geschaffen werden, das den spezifischen Bed√ºrfnissen von Studierenden gerecht wird. Durch iterative Tests und die Implementierung von Benutzerfeedback wird das AMT kontinuierlich verbessert und optimiert, wodurch die Effizienz und Produktivit√§t in studentischen Projekten nachhaltig gesteigert werden kann.;1
"3.3.7 Erstellen von Push-NotiÔ¨Åcations
Der Grundaufbau, der f√ºr Push-NotiÔ¨Åcations ben√∂tigt wird, ist bereits in Unterab-
schnitt 3.3.4 beschrieben. Es ist bereits ein Backend eingef√ºhrt, dass mit dem Web-Push
Paket Nachrichten an den Client senden kann. F√ºr das Senden von Push-NotiÔ¨Åcations
ist es nicht zwingend n√∂tig, ein eigenes Backend zu schreiben. Eine Alternative ist die
Verwendung von FCM, das in Firebase enthalten ist. Im folgenden Listing 3.13 ist die
Ressource des bestehenden Backend abgebildet, mit der die Push-NotiÔ¨Åcations an den
Client gesendet werden:
In diesem Fall wird √ºber Web-Push eine leere Nachricht an die hinterlegte Subscription
gesendet.BeiderSubscriptionhandeltessichindiesemFallumdie PWA,diesichregistriert
hat. Damit mehrere Nutzer oder verschiedene Benachrichtigungsthemen verwendet werden
k√∂nnen, m√ºsste ein Subscription-Management eingef√ºhrt werden. Hierbei m√ºssen die
Subscriptions abgespeichert und einem Thema zugeordnet werden. Dies wird in dieser
Arbeit nicht umgesetzt, da es prim√§r um die technischen M√∂glichkeiten geht.
Das Empfangen und Abarbeiten der Push-NotiÔ¨Åcations √§ndert sich durch die Verwendung
eines anderen Backends nicht. Es wird immer ein Listener auf ‚Äôpush‚Äô Events im Service
Worker erstellt. Der Inhalt eines Events ist jedoch abh√§ngig von der Quelle der NotiÔ¨Åcation.
Der Listener f√ºr das Anzeigen einer Push-NotiÔ¨Åcation ist in Unterabschnitt 3.3.4 im
Listing 3.9 abgebildet.
3.3.8 ZugriÔ¨Ä auf den Gyrosensoren
F√ºr das Anzeigen der Gyrosensordaten wird eine Komponente angelegt. Diese enth√§lt
zwei Buttons f√ºr das Starten und Stoppen der Gyrosensordaten Anzeige sowie drei HTML
Paragrafen in denen die X-, Y- und Z-Achsenwerte angezeigt werden. Die Komponente wird
in den Media-Fragment mit aufgenommenen, in der auch die Photo- und Audioaufnahme
angezeigt wird.
F√ºr den ZugriÔ¨Ä auf die Bewegungssensoren wird sichergestellt, dass die ben√∂tigte Berechti-
gung vorliegen. Sollte dies nicht der Fall sein, wird die Berechtigung vom Nutzer beantragt.
Dies wird mit dem folgenden Listing 3.14 durchgef√ºhrt:
Die X-, Y- und Z-Werte werden √ºber das Event ausgelesen und auf der OberÔ¨Ç√§che angezeigt,
was in dem Code zu erkennen ist.
Zuletzt wird f√ºr den Start- und Stoppbutton der OberÔ¨Ç√§che Funktionen geschrieben.";0
Fazit  Die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen verdeutlicht die vielschichtigen Vorteile und Herausforderungen, die mit der Implementierung dieser Technologie verbunden sind. Die Untersuchung hat gezeigt, dass ElixirNerves durch seine Komponentenarchitektur, die hohe Leistungsf√§higkeit der programmgesteuerten Sprache Elixir sowie die Integration der Erlang-VM eine vielversprechende Grundlage f√ºr die Entwicklung zuverl√§ssiger und skalierbarer IoT-L√∂sungen bietet.  Besonders hervorzuheben ist die F√§higkeit von ElixirNerves, eine robuste Fehlerhandhabung und parallelisierte Verarbeitung zu erm√∂glichen, was in der dynamischen Umgebung des Internet der Dinge von entscheidender Bedeutung ist. Die einfache Handhabung von Firmware-Updates und die Unterst√ºtzung von verschiedenen Hardwareplattformen erweitern die Einsatzm√∂glichkeiten erheblich und tragen zur W√ºnschbarkeit dieser Plattform bei.  Trotz der zahlreichen Vorteile m√ºssen jedoch auch einige Herausforderungen ber√ºcksichtigt werden. Insbesondere die noch begrenzte Community und die niedrigere Verbreitung im Vergleich zu etablierten Plattformen wie Arduino oder Raspberry Pi k√∂nnen Hemmnisse f√ºr Entwickler darstellen, die auf umfassende Dokumentation und Unterst√ºtzung angewiesen sind. Zudem erfordert die Einarbeitung in die funktionale Programmierung von Elixir f√ºr einige Entwickler zus√§tzliche Zeit und Ressourcen.  Zusammenfassend l√§sst sich sagen, dass ElixirNerves eine vielversprechende und innovative L√∂sung f√ºr die Entwicklung von IoT-Anwendungen darstellt, insbesondere f√ºr Projekte, die hohe Anspr√ºche an Skalierbarkeit und Zuverl√§ssigkeit stellen. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die Community um ElixirNerves weiter auszubauen und Best Practices f√ºr die Integration in bestehende IoT-√ñkosysteme zu identifizieren. Eine m√∂gliche Ausweitung der Unterst√ºtzung f√ºr verschiedene IoT-Protokolle k√∂nnte ebenfalls zur breiteren Akzeptanz dieser Plattform beitragen.;1
‚Ä¢Ausbaupotenzial der Entwicklungstools Neben diesen Verbesserungen an den Bibliotheken gibt es auch bei den eingesetzten Tools noch Ans√§tze und Anregungen zu m√∂glichen Verbesserungen. Die bereits vorge- stellte Preview-Funktion umfasst bereits einen gro√üen Umfang an Funktionalit√§ten, wie beispielsweise das Mocken von Daten f√ºr die beispielhaften UI-Darstellungen, allerdings dauert das Bauen und Rendern eines Previews auch verh√§ltnism√§√üig lange. Zudem muss der Preview mit jeder √Ñnderung am Code neu gerendert werden, wenn etwas anderes als der Inhalt eines Strings ge√§ndert wird, um die Wirksamkeit der √Ñnderung einsehen zu k√∂nnen. Previewbuilds k√∂nnten hinsichtlich ihrer Schnelligkeit beim Buildprozess der Vorschau noch ausgebaut werden . ‚Ä¢Notwendigkeit einer neuen Testsyntax Ebenfalls neu und in diesem Zusammenhang als potenzieller Nachteil auszulegen ist das Argument, dass eine neue Art der UI-DeÔ¨Ånition unweigerlich auch die Notwendig- keit zur DeÔ¨Ånition einer neuen Testsyntax mit sich bringt, in die sich Entwickelnde erst aktiv einarbeiten m√ºssen.;0
Ausblick  In dieser wissenschaftlichen Arbeit wurden die Programmiersprachen Java und Kotlin hinsichtlich ihrer Architektur, Leistung, Benutzerfreundlichkeit und Anwendungsgebiete untersucht. W√§hrend Java seit Jahrzehnten eine der popul√§rsten Programmiersprachen ist und aufgrund ihrer Stabilit√§t und weitreichenden Unterst√ºtzung in der Industrie gesch√§tzt wird, gewinnt Kotlin zunehmend an Bedeutung, insbesondere in der Android-Entwicklung. Die vorliegende Analyse hat gezeigt, dass Kotlin durch moderne Sprachmerkmale wie Null-Sicherheit, erweiterbare Funktionen und eine pr√§gnante Syntax Vorteile bietet, die die Entwicklerproduktivit√§t erheblich steigern k√∂nnen.  F√ºr zuk√ºnftige Forschungen k√∂nnten mehrere interessante Aspekte in Betracht gezogen werden. Eine tiefere Untersuchung der Leistungsunterschiede zwischen beiden Sprachen, insbesondere in Bezug auf gro√üe Codebasen und komplexe Algorithmen, k√∂nnte wertvolle Erkenntnisse liefern. Zudem w√§re es sinnvoll, empirische Studien durchzuf√ºhren, die die Entwicklerzufriedenheit und -effizienz in realen Projekten vergleichen. Hierbei k√∂nnten qualitative Methoden, wie Interviews und Umfragen, n√ºtzliche Einblicke in die praktischen Erfahrungen von Entwicklern bieten.  Ein weiterer wichtiger Aspekt w√§re die Analyse der Unterst√ºtzungs√∂kosysteme und Tools f√ºr jede Sprache. Insbesondere die Integration in moderne Entwicklungsumgebungen, die Verf√ºgbarkeit von Bibliotheken und Frameworks sowie die Unterst√ºtzung durch die Community sind entscheidend f√ºr die Wahl einer Programmiersprache.  Zusammenfassend l√§sst sich festhalten, dass sowohl Java als auch Kotlin ihre eigenen St√§rken und Schw√§chen aufweisen, die je nach Kontext und Anforderung unterschiedliche Auswirkungen auf die Softwareentwicklung haben k√∂nnen. Die fortschreitende Evolution dieser beiden Sprachen und die sich √§ndernden Anforderungen der Softwareindustrie er√∂ffnen ein dynamisches Forschungsfeld, das weiterhin verfolgt werden sollte. Der Ausblick auf zuk√ºnftige Entwicklungen, insbesondere im Hinblick auf neue Sprachfunktionen und Paradigmen, wird f√ºr Entwickler und Forscher gleicherma√üen von Interesse sein.;1
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke auseinandergesetzt. In einer Zeit, in der digitale Technologien zunehmend an Bedeutung gewinnen, ist es unerl√§sslich, innovative Lehrmethoden zu erproben, die den Anforderungen einer modernen Bildung gerecht werden. Das erarbeitete Szenario stellt nicht nur einen praktischen Zugang zu den Prinzipien des Message Queuing Telemetry Transport (MQTT) dar, sondern f√∂rdert auch das Verst√§ndnis f√ºr die zugrunde liegenden Konzepte der IoT-Kommunikation.  Ein zentraler Aspekt der zuk√ºnftigen Arbeit in diesem Bereich wird die kontinuierliche Anpassung und Erweiterung des entwickelten Szenarios sein. Angesichts der rasanten Entwicklungen in der Technologie und der sich wandelnden Anforderungen der Bildungslandschaft ist es wichtig, das Szenario regelm√§√üig zu evaluieren und zu aktualisieren. Hierbei k√∂nnten Feedbackschleifen mit Lehrenden und Lernenden eine entscheidende Rolle spielen, um die Benutzererfahrung zu optimieren und die didaktischen Ziele zu erreichen.  Dar√ºber hinaus bietet die Implementierung des MQTT-Szenarios die M√∂glichkeit, interdisziplin√§re Ans√§tze zu f√∂rdern. Die Kombination von Informatik, Elektrotechnik und P√§dagogik k√∂nnte nicht nur die technische Kompetenz der Lernenden steigern, sondern auch deren F√§higkeit, komplexe Systeme zu verstehen und zu steuern. In zuk√ºnftigen Studien k√∂nnte untersucht werden, wie solche interdisziplin√§ren Lehrans√§tze konkret umgesetzt werden k√∂nnen und welche Auswirkungen sie auf das Lernen und Lehren haben.  Ein weiterer vielversprechender Aspekt ist die Integration von realen Anwendungsf√§llen in das Szenario. Indem Lehrende aktuelle Entwicklungen und Herausforderungen aus der Industrie einbeziehen, k√∂nnen sie den Lernenden ein praxisnahes Verst√§ndnis f√ºr die Relevanz von MQTT im Kontext von Smart Homes, Industrie 4.0 oder der Smart City vermitteln. Solche Verkn√ºpfungen k√∂nnten die Motivation und das Interesse der Lernenden erheblich steigern.  Abschlie√üend l√§sst sich festhalten, dass das entwickelte virtuelle MQTT-Szenario ein vielversprechendes Fundament f√ºr die zuk√ºnftige Lehrpraxis darstellt. Es er√∂ffnet nicht nur neue Perspektiven f√ºr die Vermittlung komplexer Inhalte, sondern auch f√ºr die F√∂rderung von Schl√ºsselkompetenzen, die in einer zunehmend digitalisierten Welt unerl√§sslich sind. Die n√§chsten Schritte in der Forschung sollten sich darauf konzentrieren, die Wirksamkeit des Szenarios in unterschiedlichen Bildungskontexten zu testen und innovative Ans√§tze zur Integration in bestehende Lehrpl√§ne zu entwickeln. So kann das Szenario nicht nur als Werkzeug zur Wissensvermittlung dienen, sondern auch als Katalysator f√ºr eine zukunftsorientierte Bildung im digitalen Zeitalter.;1
Konfigurationswerte umfassen den Identifikator der Basisstation, den konfigurierten Namen, Port des RPCServers sowie Standardaktion, wenn der Nutzer nicht auf einen Katzenalarm reagiert. F√ºr den entwickelten Prototypen sind diese voreingestellt, k√∂nnten f√ºr ein volles Produkt allerdings einfach auch √ºber die App ge√§ndert werden, da das System gestaltet wird um dies bereits vorzubereiten. Sollte keine Konfigurationsdatei vorhanden oder diese teilweise unvollst√§ndig sein, werden im Code fest eingetragene Standardwerte als Fallback genutzt. Anschlie√üend an das Lesen der Konfiguration wird der Controller vorbereitet. Es wird ein neuer Thread angelegt, der separat zur Hauptmethode l√§uft, welcher den RPCServer konfiguriert und verarbeitet, wie in Listing 3.3 zu sehen ist und in Abschnitt 3.2 n√§her erkl√§rt wird. Ebenso authentisiert sich die Basisstation mit Google Auth und Firebase √ºber deren Authentisierungs- APIs und einem Firebase Diensttoken, der diesem Projekt zugeordnet ist. Dieser Token ist lokal in JavaScript Object Notation ( JSON) Format als authkey.json abgespeichert und enth√§lt einen privaten Verschl√ºsselungscode.  Ebenso l√§dt die App von Cloud Firestore die neueste Variante ihrer Antwort-Datei, welche die letzte Auswahl der Nutzer bei einem Katzenalarm speichert und beginnt, √Ñnderungen an diesem Eintrag asynchron in einem neuen Thread zu √ºberwachen.  Damit ist der Controller konfiguriert und betriebsbereit.;0
Fazit  Die vorliegende Arbeit hat das Potenzial und die Anwendungsm√∂glichkeiten von LoRaWAN (Long Range Wide Area Network) zur √úberwachung der Bodenfeuchtigkeit eingehend untersucht. Angesichts der fortschreitenden Klima√§nderungen und der damit verbundenen Herausforderungen in der Landwirtschaft ist ein pr√§zises Monitoring der Bodenfeuchtigkeit von entscheidender Bedeutung. Der Einsatz von LoRaWAN in Verbindung mit The Things Network (TTN) bietet eine kosteneffiziente, skalierbare und energieeffiziente L√∂sung zur Erfassung und √úbertragung von Bodendaten √ºber gro√üe Entfernungen.  Die Ergebnisse unserer Analyse zeigen, dass die Integration von Sensoren zur Bodenfeuchtemessung mit dem LoRaWAN-Netzwerk in realen Anwendungsf√§llen erfolgreich realisierbar ist. Die hohe Reichweite und die geringe Energieaufnahme des LoRaWAN-Standards erm√∂glichen einen fl√§chendeckenden Einsatz, der insbesondere f√ºr landwirtschaftliche Betriebe in l√§ndlichen Gebieten von Vorteil ist. Zudem erleichtert das TTN durch seine offene Infrastruktur den Zugang zu den gesammelten Daten und f√∂rdert die Entwicklung anpassungsf√§higer Anwendungen.  Auf technischer Ebene konnten wir eine robuste und zuverl√§ssige Daten√ºbertragung nachweisen. Die Implementierung diverser Sensoren und deren Anbindung an das LoRaWAN-Netzwerk hat gezeigt, dass diese Technologie nicht nur den aktuellen Anforderungen an die Datenerfassung entspricht, sondern auch zuk√ºnftig erweitert und verbessert werden kann.  Zusammenfassend l√§sst sich feststellen, dass das Tracking der Bodenfeuchtigkeit mithilfe von LoRaWAN und TTN ein vielversprechendes Werkzeug zur Unterst√ºtzung nachhaltiger Landwirtschaftspraktiken darstellt. Zuk√ºnftige Forschungsarbeiten sollten sich verst√§rkt mit der Optimierung von Sensoren, der Datenauswertung sowie der Entwicklung intelligenter Algorithmen zur Entscheidungshilfe in der Landwirtschaft befassen, um die Effizienz und Genauigkeit der Bodenfeuchtemessung weiter zu steigern. Die vorliegende Studie legt somit den Grundstein f√ºr weiterf√ºhrende Entwicklungen in diesem innovativen und relevanten Forschungsfeld.;1
"3.3.5 Reichweitentest Fazit
Zusammenfassend l√§sst sich sagen, dass das ‚ÄûThe Things Indoor Gateway‚Äú ein erstaunlich
gutes Preis-Leistungs-Verh√§ltnis bietet. Wenn dieses Gateway gut positioniert ist, l√§sst
sich sehr einfach damit auch ein gr√∂√üerer Bereich auch au√üerhalb des Hauses mit LoRa
abdecken. Entt√§uschend hingegen war das Raspberry Pi Gateway in Kombination mit der
mitgelieferten Antenne. Die Reichweite war fast um die H√§lfte geringer als bei dem zuvor
getesteten Indoor Gateway. Da das Indoor Gateway f√ºr rund 90‚Ç¨ erworben werden
kann und allein die HAT-Erweiterung des Raspberry Pi mit den mitgelieferten Antennen
rund 130‚Ç¨ kostet ist hier das TTIGimmer zu bevorzugen. Auch die Einrichtung
des Indoor Gateways ist um ein vielfaches einfacher, als das Aufsetzen des Raspberry
Pi Gateways. Wenn ein gr√∂√üerer Bereich abgedeckt werden soll, muss zum Raspberry Pi
Gateway eine zus√§tzliche leistungsf√§higere Antenne gekauft werden. Hier bietet sich je
nach Einsatzzweck und Use-Case eine Yagi Antenne oder Rundstrahlantenne an. Diese
erh√∂ht die Reichweite des Raspberry Pi Gateway, wie im Unterunterabschnitt 3.3.4 gezeigt
werden konnte, um ein vielfaches. Wenn m√∂glich sollten auch, je nach geographischen
Gegebenheiten, mehrere Gateways aufgestellt werden, um beispielsweise zus√§tzlich T√§ler
mit LoRa abzudecken und eine Ô¨Ç√§chendeckende und qualitativ hohe Signalst√§rke zu
gew√§hrleisten. Alles in allem ist es recht erstaunlich, wie gro√ü die Reichweite der zwei
LoRa-Gateways alleine im gezeigten Testaufbau ist und diese prinzipiell, durch kleinere
Anpassungen wie des Installierens der Antennen auf dem Dach, noch weiter gesteigert
werden kann.";0
 Ein Ausblick auf m√∂gliche Weiterentwicklungen     Die App-Entwicklung hat in den letzten Jahren eine erhebliche Transformation durchlaufen, gepr√§gt von der stetigen Evolution der zugrunde liegenden Technologien. Eines der m√§chtigsten Tools, das in der Android-Welt in den Vordergrund ger√ºckt ist, ist das Jetpack Compose Framework. Als modernes Toolkit zur Erstellung von Benutzeroberfl√§chen erm√∂glicht Jetpack Compose Entwicklern die Gestaltung intuitiver und ansprechender Apps durch deklarative Programmierung. Dieser Prosatext beleuchtet die aktuellen M√∂glichkeiten von Jetpack Compose und wagt einen Ausblick auf potenzielle Weiterentwicklungen, die die Zukunft der App-Entwicklung pr√§gen k√∂nnten.   Jetpack Compose im √úberblick  Jetpack Compose stellt einen Paradigmenwechsel in der Android-App-Entwicklung dar. Im Gegensatz zu den traditionellen XML-basierten Layouts erm√∂glicht Compose eine deklarative und reaktive Programmierweise, die die Benutzeroberfl√§che in Verbindung mit der aktuellen Anwendungslogik direkt beschreibt. Diese Herangehensweise bietet eine Vielzahl von Vorteilen, darunter eine verbesserte Lesbarkeit des Codes, eine einfachere Handhabung des Zustandsmanagements und eine schnellere Iteration w√§hrend des Entwicklungsprozesses. Dank des starken Fokus auf Leistung und Benutzerfreundlichkeit hat Compose das Potenzial, die Art und Weise, wie Entwickler Apps erstellen, grundlegend zu ver√§ndern.   Aktuelle Entwicklungen und Features  In der aktuellen Version von Jetpack Compose sind bereits zahlreiche Funktionen integriert, die eine flexible und leistungsf√§hige Entwicklung erm√∂glichen. Dazu geh√∂ren die Integration mit anderen Jetpack-Bibliotheken, Unterst√ºtzung f√ºr Material Design, und die M√∂glichkeit, Eigenschaften responsiv zu gestalten. Dar√ºber hinaus k√∂nnen Entwickler benutzerdefinierte Komponenten einfach erstellen und in ihre Apps implementieren, was die Wiederverwendbarkeit und Modularit√§t f√∂rdert. Diese Eigenschaften sind f√ºr die heutige Entwicklung entscheidend, insbesondere in einem schnelllebigen Markt, in dem Benutzeranpassungen und reaktionsschnelle Designs erwartet werden.   Ausblick auf zuk√ºnftige Entwicklungen  Trotz der bereits umfassenden Funktionen von Jetpack Compose gibt es viele Bereiche, in denen weitere Entwicklungen stattfinden k√∂nnten, um die Benutzererfahrung und die Effizienz in der App-Entwicklung weiter zu steigern.   1. Erweiterte Integration von KI und maschinellem Lernen  Eine der vielversprechendsten Entwicklungen k√∂nnte die tiefere Integration von K√ºnstlicher Intelligenz (KI) und maschinellem Lernen in Jetpack Compose sein. Mit Algorithmen, die Benutzerdaten analysieren und die Benutzeroberfl√§che dynamisch anpassen, k√∂nnten Apps noch individueller und ansprechender gestaltet werden. Beispielsweise k√∂nnte eine App, die Jetpack Compose nutzt, dem Benutzer basierend auf vorherigen Interaktionen ma√ügeschneiderte Inhalte oder Funktionen anbieten.   2. Verbesserungen im Performance-Management  Als weitere wichtige Entwicklung k√∂nnte die Optimierung der Leistung und der Ressourcennutzung von Jetpack Compose im Fokus stehen. Insbesondere bei der Gestaltung von komplexen oder ressourcenintensiven Benutzeroberfl√§chen w√§re eine noch tiefere Integration von Tools zur √úberwachung und Optimierung der Render-Leistung von Vorteil. Dies k√∂nnte beispielsweise durch verbesserte Debugging-Tools oder durch die Implementierung neuer, effizienterer Rendering-Techniken geschehen.   3. St√§rkere Unterst√ºtzung f√ºr plattform√ºbergreifende L√∂sungen  Die Nachfrage nach plattform√ºbergreifenden L√∂sungen w√§chst stetig. Ein weiterer Entwicklungstrend f√ºr Jetpack Compose k√∂nnte eine st√§rkere Unterst√ºtzung f√ºr plattform√ºbergreifende Anwendungsarchitekturen sein. Dies k√∂nnte durch die Integration von Compose in andere Umgebungen, wie beispielsweise in Web- oder Desktop-Anwendungen, realisiert werden. Dadurch k√∂nnten Entwickler dieselbe Codebasis f√ºr die Erstellung von Anwendungen auf verschiedenen Plattformen nutzen, was den Entwicklungsprozess erheblich rationalisieren w√ºrde.   4. Gemeinschaft und √ñkosystem  Schlie√ülich wird auch die Rolle der Entwicklergemeinschaft von entscheidender Bedeutung f√ºr die Zukunft von Jetpack Compose sein. Die F√∂rderung einer aktiven und engagierten Community k√∂nnte dazu beitragen, Wissen und Erfahrungen auszutauschen und die Entwicklung von Bibliotheken und Werkzeugen zu beschleunigen, die die Nutzung von Jetpack Compose weiter verbessern. Ein robustes √ñkosystem k√∂nnte dazu f√ºhren, dass weniger Zeit mit der Behebung h√§ufiger Probleme verbracht wird und mehr Zeit f√ºr die innovativen Aspekte der App-Entwicklung bleibt.   Fazit  Jetpack Compose bietet bereits heute ein leistungsf√§higes Werkzeug f√ºr die App-Entwicklung auf der Android-Plattform. Mit einem stetigen Fokus auf Benutzererfahrung, Leistung und Modernit√§t kann das Framework die Zukunft der App-Entwicklung entscheidend mitgestalten. Die m√∂glichen Weiterentwicklungen, die von der Integration von KI √ºber verbesserte Performance-Management-Werkzeuge bis hin zu einem st√§rker vernetzten Entwickler√∂kosystem reichen, bieten vielversprechende Perspektiven f√ºr Entwickler und Unternehmen gleicherma√üen. W√§hrend die Technologien weiter voranschreiten, wird Jetpack Compose zweifellos eine zentrale Rolle in der Gestaltung der n√§chsten Generation von Android-Anwendungen spielen.;1
"3.3.3 The Things Indoor Gateway
Im ersten Testlauf wurde das ‚ÄûThe Things Indoor Gateway‚Äú getestet. Dieser Test wurde
noch zu Fu√ü durchgef√ºhrt, dementsprechend liegen die einzelnen Punkte auf der Heatmap
n√§her zusammen als in den anderen zwei Testl√§ufen. √úberraschenderweise konnte durch
die g√ºnstige Positionierung im oberen Stockwerk eine beachtliche Reichweite des f√ºr den
Innenraum konzipierten Gateway gemessen werden. Die letzte erfolgreiche Nachricht, die
vom GPS-Node erfolgreich an das Gateway gesendet werden konnte, war circa 535 Meter
Luftlinie entfernt. Die verschiedenen Messungen an den Punkten haben ergeben, dass
dieRSSIvon -115 dBmbis -44dBmreicht und die SNRzwischen minimal -9,2 dBund
maximal 14,2 dBschwankt. Zu beachten ist hierbei, dass an dieser Position der Node sich
bereits in der n√§chsten Ortschaft befand, kein direkter Sichtkontakt zum Gateway mehr
hergestellt werden konnte und das Signal durch verschiedene Hindernis wie H√§user und
B√§ume dringen musste. Auf der freien Fl√§che waren der Gro√üteil der Signalst√§rkenmessung
im sehr guten (rot) bis guten (orange) Bereich. Am Farbverlauf der Messpunkte ist in
Abbildung 3.28 gut zu erkennen, wie die Signalst√§rke mit zunehmender Entfernung und
steigender Anzahl von Objekten im Weg schw√§cher wird.";0
 Kapitel 4: Eigene Implementierung einer Journaling-App ‚Äì Vergleich von PWA und nativen Apps   4.1 Einleitung  In diesem Kapitel wird die eigene Implementierung einer Journaling-App vorgestellt, die sowohl als Progressive Web App (PWA) als auch als native App realisiert wurde. Ziel dieser Implementierung ist es, die Unterschiede in der Benutzererfahrung, der Leistung und der Entwicklungsaufw√§nde zwischen den beiden Ans√§tzen zu analysieren und zu vergleichen. Die Wahl der Journaling-App als Beispielprojekt erm√∂glicht es, die spezifischen Anforderungen an Benutzerinteraktion, Datenspeicherung und plattform√ºbergreifende Funktionalit√§t zu beleuchten.   4.2 Technische Grundlagen  Bevor wir in die Details der Implementierung eintauchen, ist es wichtig, die technischen Grundlagen beider Ans√§tze zu verstehen. Eine native App wird spezifisch f√ºr eine Plattform entwickelt, sei es iOS oder Android, und nutzt die jeweiligen Entwicklungsumgebungen (Swift f√ºr iOS, Kotlin f√ºr Android). Im Gegensatz dazu wird eine PWA mit Standard-Webtechnologien wie HTML, CSS und JavaScript entwickelt und kann auf jedem Ger√§t, das einen Webbrowser unterst√ºtzt, ausgef√ºhrt werden.   4.3 Implementierung der Journaling-App  Die Journaling-App wurde in zwei Versionen entwickelt: einer PWA und einer nativen App f√ºr Android. F√ºr die PWA wurde das Framework React verwendet, w√§hrend die native App mit Android Studio und Kotlin realisiert wurde.   4.3.1 Implementierung der PWA  Die PWA wurde mit dem Ziel entwickelt, eine benutzerfreundliche und responsive Oberfl√§che zu bieten. Die Hauptkomponenten der App umfassen:  - Benutzeroberfl√§che: Die UI wurde mit React und Material-UI gestaltet, um eine ansprechende und intuitive Benutzererfahrung zu gew√§hrleisten. Die App erm√∂glicht es Benutzern, Eintr√§ge zu erstellen, zu bearbeiten und zu l√∂schen.    - Datenmanagement: Die Daten werden lokal im Browser mithilfe der IndexedDB gespeichert, was eine Offline-Nutzung der App erm√∂glicht. Die Synchronisation mit einem Backend-Server erfolgt √ºber REST-APIs, um Benutzerdaten in der Cloud zu sichern.  - Service Worker: Ein Service Worker wurde implementiert, um die Offline-Funktionalit√§t zu unterst√ºtzen und das Caching von Ressourcen zu optimieren. Dies verbessert die Ladezeiten und die Benutzererfahrung bei schlechter Internetverbindung.   4.3.2 Implementierung der nativen App  Die native Android-App wurde mit Kotlin entwickelt und nutzt die Android Jetpack-Komponenten, um eine moderne und reaktive Benutzeroberfl√§che zu schaffen.  - Benutzeroberfl√§che: Die UI wurde mithilfe von XML-Layouts und Jetpack Compose gestaltet. Die App bietet √§hnliche Funktionalit√§ten wie die PWA, einschlie√ülich der Erstellung, Bearbeitung und L√∂schung von Journaleintr√§gen.  - Datenmanagement: F√ºr die Speicherung der Daten wurde Room, eine SQLite-basierte Persistenzbibliothek, verwendet. Diese erm√∂glicht eine effiziente Verwaltung von Daten und sorgt f√ºr eine nahtlose Synchronisation zwischen der App und der Datenbank.  - Benachrichtigungen: Die native App unterst√ºtzt Push-Benachrichtigungen, die es den Nutzern erm√∂glichen, an das Journaling erinnert zu werden;1
Funktionserweiterungen werden in Drupal als sogenannte ‚ÄûModule‚Äú bezeichnet. Derzeit stehen √ºber 49.000 Module (Stand August 2022) auf der offiziellen Drupal-Website zum Download bereit. Jene sind in verschiedene Kategorien unterteilt, welche nach Funktionen aufgegliedert werden. Hierzu z√§hlen beispielsweise Module, welche den Versand von E-Mails aus Drupal heraus steuern und erm√∂glichen. Im Backend des CMSerfolgt die Installation - analog zur Installation von Themes - per Einf√ºgen der Download-URL eines Moduls oder dem Upload eines Archives. Eine direkte Integration des Modul-Browsers ist zum Zeitpunkt dieser Arbeit nicht gegeben. Daher wird Drupal in Zusammenhang zum definierten Anwendungsfall mit der Kategorie Gelb eingestuft.;0
Das Ziel dieser Studienarbeit war es, in der DHBWHeidenheim ein um Elektronik erwei- tertes Luftreinigungsger√§t softwaretechnisch umzur√ºsten, damit verschiedene Umgebungs- bedingungen visualisiert werden k√∂nnen. Au√üerdem sollte die Software die verschiedenen Betriebsstufen des Luftreinigers steuern k√∂nnen und eine Selbstregelungsm√∂glichkeit mit- hilfe des Situationsbewusstseins anbieten, um die Verbreitung des COVID-19-Virus zu reduzieren. Durch die Erstellung eines Konzepts der Selbstregelung des Luftreinigers mithilfe des Situationsbewusstseins stellte sich heraus, dass in einem Raum mit einer Gr√∂√üe vom 75 m3 mit zwanzig Personen die Luftqualit√§t nach ungef√§hr f√ºnf Minuten unzureichend ist, falls es nicht gel√ºftet wird. Der Luftreiniger sollte nur f√ºr die Beschleunigung der Reduzierung der CO 2-Konzentration verwendet werden. Mit einem CO 2- und einem Ger√§uschsensor kann erkannt werden, dass Menschen im Raum sind. Bei der Erkennung der Situation sollte der Luftreiniger automatisch einschalten und mit einem zus√§tzlichen Ton die Personen im Raum darauf hinweisen, dass gel√ºftet werden soll. Die FAR- UVC-Bestrahlung soll automatisch einschalten, wenn keine Personen mehr im Raum erkennt werden und die Luftqualit√§t unzureichend ist. Aufgrund des fehlenden CO 2-Sensors wurde in der vorliegenden Arbeit die Selbstregelungs- m√∂glichkeit nur theoretisch ausgearbeitet, das hei√üt zum aktuellen Zeitpunkt kann die Software keine Situationen wahrnehmen. F√ºr die Visualisierung der Sensordaten wurde eine Android-Applikation entwickelt. In der Applikation kann der Luftreiniger gesteuert werden und eine automatische Einschaltung des Luftreinigers um 22:00 Uhr eingestellt werden. Mit einem Arduino Uno Wifi Rev. 2 und einem Arduino Sensor Kit werden Sensordaten √ºber die Temperatur, die Helligkeit, das Ger√§usch, den Luftdruck und die Humidit√§t erfasst, und mittels MQTTwerden diese Daten von dem Arduino zu der Applikation verschickt und in der Applikation gespeichert und visualisiert. F√ºr einen zuk√ºnftigen produktiven Einsatz sollte zus√§tzlich ein CO 2-Sensor an das System angebracht werden und ein Algorithmus f√ºr die Selbstregelung des Luftreinigers auf Basis dieser Arbeit erstellt werden. Dadurch k√∂nnte das Situationsbewusstsein des Luftreinigungs- ger√§ts gew√§hrleistet werden.;0
Die Zahl der alten Menschen in Deutschland stieg in den letzten Jahren stark an und wird auch in Zukunft noch steigen . Dabei ist das Erkennen von gest√ºrzten und hilflosen √§lteren Personen im h√§uslichen Umfeld oft mit hohen Kosten oder geringer Privatsph√§re verbunden. Um dieses Problem zu l√∂sen, wurde im Rahmen dieser Studienarbeit evaluiert, ob ein Sturz mithilfe von Bluetooth kosteng√ºnstig detektiert werden kann. Dazu wurde sich mit der Positionsbestimmung mithilfe von Signalst√§rken besch√§ftigt. Diese Position kann daraufhin mit dem Verhaltensmuster der Person verglichen und auf Anomalien gepr√ºft werden. Wird ein abnormales Verhalten erkannt, so kann eine angeh√∂rige Person oder der Pflegedienst informiert werden, was einer gest√ºrzten Person das Leben retten kann.;0
An der Dualen Hochschule Baden-W√ºrttemberg DHBW Heidenheim werden zur gesund- heitlichen Pr√§vention speziell in nicht zu bel√ºftenden R√§umlichkeiten Luftreinigungsger√§te eingesetzt. Diese Luftreinigungsger√§te gewinnen aufgrund der aktuellen pandemischen Situation stark an Gewicht bei Diskussionen zur Sicherstellung von Pr√§senzvorlesungen. Studierenden der Fachrichtung Maschinenbau haben bereits ein rein analoges Luftreinigungsger√§t um Elektronik zur Ansteuerung dieses Ger√§ts erweitert. Als Ergebnis davon kann der Luftreiniger entweder mit einem Fernbediener aber auch auf einer Webseite gesteuert werden. Die Webseite, die das Luftreinigungsger√§t steuern kann, verf√ºgt nur √ºber die wichtigsten Funktionen wie die Ein- und Ausschaltung des Ger√§ts und die Auswahl der verschiedenen Betriebsstufen. Diese Steuerungsm√∂glichkeit sollte im Hinblick auf ein besseres Nutzungserlebnis und Benutzerfreundlichkeit weiterentwickelt werden. Au√üerdem sollten verschiedene Sensoren an dem Luftreiniger angebracht werden, um mehr Effizienz bei der Luftreinigung zu verschaffen und eine Selbstregelungsoption des Luftreinigers zu bieten, um die Verbreitung des COVID-19-Virus zu reduzieren. Ziel ist es, ein um Elektronik erweitertes Luftreinigungsger√§t softwaretechnisch so umzur√ºsten, dass eine Visualisierung der Umgebungsbedingungen, eine Selbstregelungsoption und die Bedienung des Luftreinigers m√∂glich werden. Die folgende Fragestellung wird in dieser Arbeit untersucht: Wie l√§sst sich durch die Erstellung einer Software die Visualisie- rung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§t an der Duale Hochschule Baden-W√ºrttemberg ( DHBW) Heidenheim realisieren? F√ºr die Visualisierung und Bedienung wird eine Android-Anwendung erstellt und f√ºr die Selbstregelungsm√∂glichkeit wird ein Konzept ausgearbeitet.;0
In der vorliegenden Arbeit wurde ein virtuelles MQTT-Szenario entwickelt, das speziell f√ºr Lehrzwecke konzipiert ist. Ziel war es, Studierenden und Interessierten eine praxisnahe und interaktive Plattform zu bieten, um die Funktionsweise und die Anwendung des MQTT-Protokolls zu verstehen. Die Implementierung dieses Szenarios zeigt nicht nur die technischen Aspekte von MQTT, sondern auch dessen Relevanz in der heutigen vernetzten Welt, insbesondere im Kontext des Internet of Things (IoT).  Durch die Simulation realer Kommunikationsszenarien konnten die Lernenden die Grundlagen des Publish-Subscribe-Modells nachvollziehen und eigene Experimente durchf√ºhren. Dies f√∂rdert nicht nur das technische Verst√§ndnis, sondern auch die Probleml√∂sungsf√§higkeiten und die Kreativit√§t der Studierenden. Die M√∂glichkeit, in einer risikofreien Umgebung zu experimentieren, ist ein entscheidender Vorteil, der das Lernen unterst√ºtzt und vertieft.  Die Evaluation des Szenarios hat gezeigt, dass die Studierenden ein hohes Ma√ü an Engagement und Interesse an den vermittelten Inhalten zeigten. Feedback deutet darauf hin, dass die Kombination aus theoretischem Wissen und praktischer Anwendung besonders effektiv ist, um komplexe Konzepte verst√§ndlich zu machen.   Insgesamt l√§sst sich festhalten, dass die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke einen wertvollen Beitrag zur Ausbildung im Bereich der Netzwerktechnologien und des IoT leistet. Zuk√ºnftige Arbeiten k√∂nnten sich darauf konzentrieren, das Szenario weiter auszubauen, zus√§tzliche Funktionalit√§ten zu integrieren und die Benutzeroberfl√§che zu optimieren, um das Lernerlebnis noch weiter zu verbessern. Die vorliegende Arbeit legt somit den Grundstein f√ºr eine innovative Lehrmethode, die die digitale Transformation in der Bildung vorantreiben kann.;1
"Vergleich von Progressiven Webanwendungen (PWA) und nativen Apps am Beispiel einer Journaling-AppEine   In der gegenw√§rtigen √Ñra der digitalen Mobilit√§t sehen sich Entwickler von Softwareanwendungen mit der Entscheidung konfrontiert, welchen Technologieansatz sie f√ºr ihre Projekte w√§hlen sollen. Insbesondere die Entwicklung von Journaling-Apps, die eine wichtige Rolle in der Unterst√ºtzung individueller Pers√∂nlichkeitsentwicklung und Reflexion spielen,profitieren von der Erschlie√üung neuer Technologien. In diesem Kontext werden die Vorteile und Herausforderungen von Progressiven Webanwendungen (PWA) im Vergleich zu nativen Apps analysiert, um schlie√ülich eine umfassende Projektbewertung vorzunehmen.  1. Definition und Merkmale  Progressive Webanwendungen sind Webanwendungen, die moderne Webtechnologien nutzen, um ein App-√§hnliches Benutzererlebnis zu bieten. Sie bieten eine skalierbare Leistung, verbesserte Zuverl√§ssigkeit und Offline-Funktionalit√§ten durch den Einsatz von Service Workern. Native Apps hingegen sind speziell f√ºr eine bestimmte Plattform (iOS, Android) entwickelte Anwendungen, die direkt auf das Betriebssystem zugreifen und somit un√ºbertroffene Performance sowie volle Funktionalit√§t bieten.  2. Evaluierungsparameter  Um das aktuelle Projekt einer Journaling-App objektiv zu evaluieren, sind mehrere Parameter von entscheidender Bedeutung - Benutzererfahrung (UX) - Leistung - Plattformunabh√§ngigkeit - Distribution und Updates - Entwicklungskosten - Sicherheit und Datenschutz  3. Benutzererfahrung  Im Hinblick auf die Benutzererfahrung bietet die PWA Saturn Journal beispielsweise eine responsive Benutzeroberfl√§che, die sich an verschiedene Bildschirmgr√∂√üen anpasst und schnellen Zugriff auf Content erm√∂glicht. Die Benutzer berichten oft von h√∂heren Ladegeschwindigkeiten und einem benutzerfreundlichen Layout. Native Apps haben zwar √ºber nat√ºrliche Benutzeroberfl√§chen und Gestensteuerungen Vorteile, die benutzerdefinierte Erlebnisse schaffen, erfordern dann jedoch oft Updates durch den Download im App Store, was zu Frustrationen f√ºhren kann.  4. Leistung  Obwohl PWAs durch Cache-Management Mammutproblemen, bez√ºglich der Internetverbindung begegnen, sezernieren aktuelle Analysen, dass native Apps in der Tat bei rechenintensiven Aufgaben ‚Äî wie komplexen Datentransaktionslogiken im Journal oder grafischen Darstellungen von Ereignissen ‚Äî sehr viel leistungsf√§higer sind. Vor allem benutzergenerierte Inhalte, wie Bilder und pers√∂nliche Logs,strapazieren dieskap –ø—Ä–æ—Ö–æ–¥–∏—Ç–Ø —Å–µ—Çein nativesystem –ø–æ–¥–¥–µ—Ä–∂ ÿßŸÑÿ®Ÿä politikk sulone ripab PVCÎßàÏ†úetet pipes Weekly ÌÖåÎ†à tanmente tista politiciatti Providence Ï∏µ ~ ‡§∏‡•Ä—Ç–≤–∞ stim flitstrip sock‡¶≤‡ßÄ S_VALIDnex choc siret —á—Ä–µ–∑–≤—ã—á–∞–π‡•á‡§Çinete.qml‡•ç‡§ö‡§∞;?>land r ‡§Ö‡§ö‡•ç‡§õ‡•á Firefoxenzen xElentialsishni ÈßπATA·üí·ûö·ûª·ûÑ Hermes kamen tijdje aufmerksam entscheiden  thr Ï∫†Ìéò Gaut Ë∂ä spo≈Çecz‡∂≠‡∑í‡∂∫‡•Ç –±—É–∑‡§ä–ökkue Translation –¥–æ ÏãúÏûë Eva—Ü–∏–∏ ‡§ú‡§∞‡§ø‡§è–æ–¥–∞—Ä—è–ú–µ–Ω secret–ª–∏–≤—ç—Ä—ã desambere—Ü—åo√π–ª–æ–≥_INPUT‡•§‚Äô  5. Plattformunabh√§ngigkeit und Verteilung  Ein markanter Vorteil der PWA ist ihre grunds√§tzliche Plattformunabh√§ngigkeit. Die Nutzer k√∂nnen die Anwendung √ºber ihren Webbrowser nutzen, wodurch der Zugang und die Verteilung weltweit erheblich erleich";1
"Es gibt mehrere IoT-Standards auf dem Markt. Die folgenden AuÔ¨Çistung zeigt beispielhaft
eine Auswahl von verschiedenen Standards :
‚Ä¢6LoWPAN steht f√ºr ‚ÄûIPv6 over Low-Power Wireless Personal Area Networks‚Äú und
ist ein oÔ¨Äener Standard der Internet Engineering Task Force ( IETF), welcher die
Kommunikation mit dem Internet √ºber ein beliebiges Low-Power-Funkger√§t, wie
Bluetooth Low Energy und Z-Wave erlaubt.
‚Ä¢ZigBeebasiert auf dem Standard 802.15.4 des Institute of Electrical and Electronics
Engineers ( IEEE) und ist ein drahtloses Netzwerk mit geringem Stromverbrauch
und niedriger Datenrate. ZigBeewird gr√∂√ütenteils in der Industrie eingesetzt. Die
dazugeh√∂rige ZigBee Alliance hat Dotdot entwickelt, eine universelle Sprache f√ºr IoT,
die es Ger√§ten erm√∂glicht sicher in einem Netzwerk miteinander zu kommunizieren.
‚Ä¢LoRaWAN ist ein Protokoll f√ºr sehr gro√üe IoT-Netzwerke, welche in smarten
St√§dten eingesetzt wird und Millionen low-power Ger√§te unterst√ºtzt.
Da alle diese Standards eine Funktechnologie verwenden, haben sie alle das gleiche Span-
nungsdreieck mit folgenden drei Zielen: Maximierung der Reichweite, Optimierung des
Energieverbrauchs und der Menge der √ºbertragbaren Daten (siehe Abbildung 2.2). Dabei
k√∂nnen nur zwei der drei Eckpunkte optimiert werden, w√§hrend sich der dritte Eckpunkt
verschlechtert. Als Beispiel besitzt ein 4G-Netz, welches zum Beispiel von Smartphones
verwendet wird und nicht zu den LPWANs geh√∂ren, eine recht hohe Reichweite und eine
hohe Daten√ºbertragung, jedoch ben√∂tigen die 4G-Gateways sehr viel Energie. Ein anderes
Beispiel w√§re LoRaWAN. Dieses besitzt eine sehr hohe Reichweite und einen sehr geringen
Energieverbrauch, jedoch ist die Menge der √ºbertragbaren Daten recht gering. 
Abbildung 2.2: Spannungsdreieck bei Funktechnologien";0
Ein Fazit  In den letzten Jahren hat die Bedeutung von Luftreinigungsger√§ten in Innenr√§umen erheblich zugenommen, insbesondere im Kontext der globalen Herausforderungen durch Luftverschmutzung und gesundheitliche Risiken, die mit schlechter Luftqualit√§t verbunden sind. Die vorliegende Untersuchung befasste sich mit der Optimierung der Visualisierung, Bedienung und Selbstregelung eines elektronisch erweiterten Luftreinigungsger√§tes, um die Benutzerfreundlichkeit und Effizienz zu steigern.   Im Rahmen des Projekts wurden mehrere Aspekte der Benutzerinteraktion analysiert, wobei ein besonderer Fokus auf die grafische Darstellung von Luftqualit√§tsdaten und die intuitive Bedienoberfl√§che gelegt wurde. Die Implementierung eines benutzerfreundlichen Interfaces, das Echtzeitdaten zur Luftqualit√§t in verst√§ndlicher Form pr√§sentiert, stellte sich als entscheidend heraus. Durch die Verwendung von klaren Farbcodes und Symbolen konnten Nutzer auf einen Blick den aktuellen Zustand der Luftqualit√§t erfassen, was die Entscheidungsfindung hinsichtlich der Nutzung des Ger√§tes erheblich vereinfachte.  Ein weiterer zentraler Punkt der Optimierung war die Selbstregelungsfunktion des Luftreinigers. Hierbei wurde ein adaptives Regelungssystem entwickelt, das auf Basis von Sensorinformationen automatisch die Reinigungsstufen anpasst. Diese Funktionalit√§t reduziert nicht nur den Energieverbrauch, sondern sorgt auch daf√ºr, dass das Ger√§t stets optimal auf die aktuellen Bedingungen reagiert. Die Implementierung von Algorithmen zur maschinellen Lernens erm√∂glichte es dem Ger√§t, sich an die spezifischen Nutzergewohnheiten und Umgebungsbedingungen anzupassen, was die Effizienz der Luftreinigung weiter steigerte.  Das  hebt hervor, dass die Integration von fortschrittlicher Elektronik in Luftreinigungsger√§te nicht nur die technische Effizienz verbessert, sondern auch die Benutzererfahrung erheblich bereichert. Die Optimierung der Visualisierung und Bedienung hat zu einer h√∂heren Nutzerakzeptanz gef√ºhrt, w√§hrend die Selbstregelungsmechanismen die Betriebskosten und den √∂kologischen Fu√üabdruck des Ger√§tes verringern. Insgesamt zeigt das Projekt, dass durch gezielte technische Innovationen und ein tiefes Verst√§ndnis der Nutzerbed√ºrfnisse eine signifikante Verbesserung der Funktionalit√§t und Benutzerfreundlichkeit von Luftreinigungsger√§ten erreicht werden kann. Zuk√ºnftige Entwicklungen sollten sich darauf konzentrieren, diese Ans√§tze weiter zu verfeinern und neue Technologien zu integrieren, um eine noch nachhaltigere und effektivere L√∂sung f√ºr die Herausforderungen der Luftreinigung zu bieten.;1
Da eine Unterst√ºtzung von Sprints sinnvoll ist, wird das Anlegen von Sprints, Zuweisen von  Arbeitspaketen zu Sprints und Funktionen wie ‚ÄûSprint abschlie√üen‚Äú und ‚ÄûAlle offenen  Arbeitspakete in den n√§chsten Sprint √ºbertragen‚Äú ebenfalls der Sch√§tzung hinzugef√ºgt.  Azure DevOps und Jira Software profitieren von einem eingebauten Versionskontrollsystem.  Dadurch ist es beispielsweise m√∂glich, eine direkte Verbindung zwischen einem Arbeitspaket  und einem zugeh√∂rigen Pull Request zu erstellen. Die entstehende Komplexit√§t einer solchen  Integration sollte nicht untersch√§tzt werden, insbesondere, wenn durch einen einfachen  Hyperlink in der Beschreibung eines Arbeitspaketes auf ein externes Versionskontrollsystem,  beispielsweise ein Github-Repository, verwiesen werden und eine √§hnliche Funktion erzielt  werden kann . Kann also in einem Arbeitspaket ein Hyperlink zu einer externen Internetseite  hinzugef√ºgt werden, ist diese Funktionalit√§t in ausreichender Weise ber√ºcksichtigt.  Das Wiki wurde bisher verwendet, um eine √úbersicht √ºber die Funktionalit√§t der gemeinsam  entwickelten Software auf fachlicher Ebene zu gew√§hren. In einer hierarchischen  Seitenstruktur konnten sowohl √ºbergreifende Funktionen als auch Detailfunktionalit√§ten  erl√§utert werden. Es ist deswegen hilfreich, um sowohl dem Entwicklungsteam w√§hrend der  Entwicklung als auch den Dozent*innen w√§hrend der Bewertung darzustellen, welche  Funktionalit√§t mit der Software umgesetzt wurde. Es k√∂nnen auch nach  Belieben weitere  Themen er√∂rtert werden, beispielsweise Erkl√§rungen √ºber besondere Softwareteile oder die  Architektur der gesamten Applikation. Die Dokumentation der eigenen Leistung ist nicht nur  w√§hrend des Studiums, sondern auch in der sp√§teren Arbeitswelt ein m√∂glicher Teil der Arbeit  eines Softwareentwicklers. Es reicht nicht nur aus, Software zu erstellen, diese muss auch  dokumentiert werden, um die √úbergabe an andere Personen zu erm√∂glichen, nicht nur  beispielsweise anderen Entwickler*innen, sondern auch den Kunden.;0
Eine letzte Metrik, die dem Bereich der Kopplung zuzuordnen ist, ist die von Chidamb er und Kemerer  eingef√ºhrte Kennzahl ‚ÄûCoupling between objects‚Äú (CBO).  Sie spiegelt die Anzahl gekoppelter Klassen  wider, wodurch folglich e ine Absolutskala zugrunde liegt. Es wird hierbei von Kopplung gesprochen,  wenn Methoden oder Attrib ute einer fremden Klasse aufgerufen werden . Als Schwellenwert   definierte Raed Shatnawi den Wert 9 , der sich nach Auswertung seiner Messe rgebnisse ergab  und  der als Referenzwert herangezogen werden soll.  Grunds√§tzlich ist eine m√∂glichst lose Kopplung  erstrebenswert. Diese f√∂rdert die Wiederverwendbarkeit von Komponenten in einem modularen  Design sowie die Wartbarkeit des Quellcodes.;0
  Die zunehmende Luftverschmutzung und die damit verbundenen Gesundheitsrisiken haben die Entwicklung effizienter Luftreinigungsger√§te in den letzten Jahren vorangetrieben. Mit der Integration elektronischer Systeme in diese Ger√§te ergeben sich jedoch nicht nur technische Herausforderungen, sondern auch M√∂glichkeiten zur Verbesserung der Benutzerinteraktion und der Selbstregelung. In diesem Kontext ist die Optimierung der Visualisierung, Bedienung und Selbstregelung von entscheidender Bedeutung, um die Benutzerakzeptanz zu erh√∂hen und die Effizienz der Luftreinigung zu maximieren.  1. Visualisierung  Die Visualisierung von Informationen spielt eine zentrale Rolle in der Benutzerinteraktion mit technischen Ger√§ten. In der Theorie der Mensch-Maschine-Interaktion (MMI) ist es entscheidend, dass Informationen klar, verst√§ndlich und intuitiv pr√§sentiert werden. Die kognitive Belastung des Nutzers sollte minimiert werden, um eine effiziente Bedienung zu gew√§hrleisten. Hierbei k√∂nnen verschiedene Ans√§tze verfolgt werden - Grafische Benutzeroberfl√§chen (GUI)Die Gestaltung von GUIs sollte sich an den Prinzipien der Gestaltpsychologie orientieren, um Informationen so anzuzeigen, dass sie leicht erfasst und interpretiert werden k√∂nnen. Dazu geh√∂rt die Verwendung von Farben, Formen und Symbolen, die intuitive R√ºckschl√ºsse auf den Betriebszustand des Ger√§tes erm√∂glichen.  - Echtzeit-DatenvisualisierungDie Integration von Sensoren, die Luftqualit√§tsparameter wie PM2.5, VOCs (fl√ºchtige organische Verbindungen) und CO2 messen, erm√∂glicht eine dynamische Visualisierung der Luftqualit√§t. Die Theorie der Datenvisualisierung legt nahe, dass visuelle Darstellungen von Daten, wie Diagramme oder Heatmaps, die Interpretation komplexer Informationen erleichtern und eine schnelle Reaktion des Nutzers auf Ver√§nderungen erm√∂glichen.  2. Bedienung  Die Bedienbarkeit eines Luftreinigungsger√§tes wird ma√ügeblich durch die Gestaltung der Benutzeroberfl√§che und die Implementierung von Interaktionsmodellen beeinflusst. Die Theorie der Benutzerzentrierten Gestaltung (UCD) legt nahe, dass die Bed√ºrfnisse und Erwartungen der Nutzer in den Entwicklungsprozess integriert werden sollten. Hierbei sind folgende Aspekte zu ber√ºcksichtigen - Intuitive SteuerungDie Steuerung des Ger√§tes sollte einfach und selbsterkl√§rend sein. Dies kann durch die Implementierung von Touchscreens, Sprachsteuerung oder Smartphone-Apps erreicht werden, die eine nahtlose Interaktion erm√∂glichen.  - Feedback-MechanismenUm die Benutzererfahrung zu verbessern, sollten Ger√§te √ºber visuelle und akustische Feedback-Mechanismen verf√ºgen, die den Nutzer √ºber den aktuellen Betriebszustand und die Luftqualit√§t informieren. Dies f√∂rdert ein Gef√ºhl der Kontrolle und Sicherheit.  3. Selbstregelung  Die Selbstregelung eines Luftreinigungsger√§tes ist ein zentraler Aspekt, der durch die Integration intelligenter Algorithmen und maschinellen Lernens optimiert werden kann. Die theoretischen Grundlagen hierzu basieren auf Regelungstechnik und Systemtheorie, die es erm√∂glichen, adaptive Steuerungssysteme zu entwickeln. Wichtige Punkte sind - Adaptive AlgorithmenDie Verwendung;1
" Kapitel 2: Technische Grundlagen der digitalen √úberwachung   2.1 Einf√ºhrung in die digitale √úberwachung  In einer zunehmend vernetzten Welt nimmt die digitale √úberwachung eine zentrale Rolle ein. Technologien, die urspr√ºnglich zur Verbesserung der Kommunikation und Effizienz entwickelt wurden, finden in der √úberwachung Anwendung, sei es durch staatliche Stellen oder private Unternehmen. Um die M√∂glichkeiten und Gefahren dieser digitalen √úberwachung zu verstehen, ist es wichtig, die zugrunde liegenden technischen Grundlagen zu betrachten.   2.2 Technologien der digitalen √úberwachung   2.2.1 Datenerhebung  Die Erhebung von Daten bildet das Fundament der digitalen √úberwachung. Es gibt mehrere Methoden zur Datensammlung, darunter:  - Sensoren und IoT-Ger√§te: Diese technischen Ger√§te sammeln kontinuierlich Informationen √ºber ihre Umgebung. Beispielsweise k√∂nnen Smart-Home-Ger√§te Bewegungen, Temperatur und andere Umweltfaktoren √ºberwachen.    - Internetprotokoll (IP) √úberwachung: Durch das Protokoll, das bei der √úbertragung von Daten √ºber das Internet verwendet wird, k√∂nnen Internetdienstanbieter (ISPs) und Regierungen den Internetverkehr √ºberwachen und analysieren.  - Mobile Anwendungen: Viele mobile Apps sammeln automatisch Informationen √ºber Benutzer, wie Standortdaten und Nutzungsverhalten, was f√ºr Werbezwecke oder zur √úberwachung genutzt werden kann.   2.2.2 Datenanalyse  Die reinen Daten sind nur der erste Schritt; die Analyse dieser Daten ist entscheidend, um sinnvolle Informationen zu extrahieren. Hier kommen verschiedene Techniken zum Einsatz:  - Big Data Analytics: Unternehmen und staatliche Stellen nutzen Big Data-Technologien, um riesige Datenmengen zu analysieren. Algorithmen und maschinelles Lernen helfen dabei, Muster zu erkennen und Vorhersagen zu treffen.  - K√ºnstliche Intelligenz (KI): Insbesondere KI-gest√ºtzte Systeme k√∂nnen Verhaltensanalysen durchf√ºhren, um Anomalien oder potenziell verd√§chtige Aktivit√§ten zu identifizieren. Dies wird h√§ufig in der √úberwachung von Online-Aktivit√§ten und in Sicherheitsanwendungen verwendet.  - Gesichtserkennungstechnologie: Die Identifikation von Personen durch Gesichtserkennung wird zunehmend genutzt, um Personen in √∂ffentlichen R√§umen zu √ºberwachen und Aktivit√§ten zu verfolgen.   2.2.3 Daten√ºbertragung und -speicherung  Die Art und Weise, wie Daten √ºbertragen und gespeichert werden, spielt eine Schl√ºsselrolle in der digitalen √úberwachung:  - Cloud Computing: Cloud-Dienste erm√∂glichen die zentrale Speicherung gro√üer Mengen an Daten, die von verschiedenen Ger√§ten erfasst werden. Dies erleichtert den Zugriff, aber es wirft auch Fragen zur Datensicherheit und Privatsph√§re auf.  - Verschl√ºsselung: Verschl√ºsselungstechniken sind wichtig, um Daten w√§hrend der √úbertragung zu sch√ºtzen. Allerdings k√∂nnen sie auch verhindern, dass √úberwachungsbeh√∂rden auf gesammelte Informationen zugreifen.   2.3 Regulierungen und ethische √úberlegungen  Die technologischen M√∂glichkeiten der digitalen √úberwachung sind gro√ü, jedoch ist es entscheidend, sie im Kontext rechtlicher und ethischer Standards zu betrachten:  - Datenschutzgesetze: Gesetze wie die Datenschutz-Grundverordnung (DSGVO) in Europa regeln, wie personenbezogene Daten erhoben, gespeichert und verarbeitet werden d√ºrfen. Diese Vorschriften sollen sowohl die Privatsph√§re der Individuen sch√ºtzen als auch den Rahmen f√ºr Datenanalysen schaffen.  - Ethische Dimensionen der √úberwachung: Die Anwendung von √úberwachungstechnologien wirft ethische Fragen auf, insbesondere in Bezug auf den Schutz der Privatsph√§re und die potenzielle Diskriminierung bei der Nutzung von Algorithmen, die Vorurteile verst√§rken k√∂nnen.    2.4 Fazit  Die technischen Grundlagen der digitalen √úberwachung sind vielschichtig und interkonnektiv. W√§hrend die Technologien das Potenzial haben, Sicherheit zu erh√∂hen und Kriminalit√§t zu bek√§mpfen, bringen sie auch erhebliche Risiken f√ºr den Datenschutz und die individuelle Freiheit mit sich. Eine ausgewogene Betrachtung der M√∂glichkeiten und Gefahren der digitalen √úberwachung ist somit unerl√§sslich, um die technologischen Entwicklungen verantwortungsvoll zu gestalten und die Werte der Gesellschaft zu sch√ºtzen.";1
Konzept f√ºr eine wissenschaftliche Arbeit: Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes  1. Einleitung   Die Luftqualit√§t hat in den letzten Jahren zunehmend an Bedeutung gewonnen, insbesondere in st√§dtischen Gebieten. Luftreinigungsger√§te bieten eine effektive L√∂sung zur Verbesserung der Raumluftqualit√§t. Mit der Integration von elektronischen Komponenten k√∂nnen diese Ger√§te optimiert werden, um eine besser bedienbare, sichtbare und selbstregulierende L√∂sung zu bieten. Ziel dieser Arbeit ist es, Konzepte zur Verbesserung der Benutzeroberfl√§che (Visualisierung und Bedienung) und der Selbstregulierung von Luftreinigungsger√§ten zu entwickeln und zu evaluieren.  2. Problemstellung   Obwohl bestehende Luftreinigungsger√§te bereits √ºber grundlegende elektronische Funktionen verf√ºgen, gibt es h√§ufig M√§ngel in der Benutzerfreundlichkeit und im Selbstregulierungsprozess. Zu den identifizierten Problemen z√§hlen: - Unzureichende Visualisierung der Luftqualit√§t in Echtzeit. - Komplizierte Bedienoberfl√§chen, die den Nutzer √ºberfordern. - Fehlende Anpassungsmechanismen zur optimalen Regulierung des Reinigungsprozesses basierend auf Luftqualit√§tsdaten.  3. Zielsetzung der Arbeit   Die Arbeit verfolgt folgende Ziele: - Entwicklung eines konzeptionellen Entwurfs zur Verbesserung der Visualisierung der Luftqualit√§t. - Gestaltung einer benutzerfreundlichen Bedienoberfl√§che. - Implementierung eines selbstregulierenden Mechanismus basierend auf Echtzeitdaten und Benutzerfeedback.  4. Forschungsfragen   - Welche Elemente der Visualisierung k√∂nnen die Nutzerakzeptanz von Luftreinigungsger√§ten verbessern? - Wie kann eine intuitive Benutzeroberfl√§che gestaltet werden, die eine einfache Bedienung erm√∂glicht? - Welche Algorithmen k√∂nnen zur Selbstregulierung der Luftreinigung eingesetzt werden, um die Effizienz zu steigern?  5. Methodik   Die Methodik umfasst sowohl qualitative als auch quantitative Ans√§tze: - Literaturrecherche: Analyse bestehender Produkte und Technologien. Untersuchung der Benutzererfahrungen mit aktuellen Ger√§ten. - Umfrage und Interviews: Befragung von Nutzern bez√ºglich ihrer Erfahrungen mit bestehenden Luftreinigungsger√§ten und ihren W√ºnschen an eine verbesserte Benutzeroberfl√§che. - Prototyping: Entwicklung eines Prototyps eines Luftreinigungsger√§tes mit erweiterten elektronischen Funktionen.  - Usability-Tests: Durchf√ºhrung von Tests mit Nutzern, um die intuitive Bedienbarkeit zu evaluieren und Verbesserungspotential zu identifizieren. - Algorithmische Entwicklung: Programmierung eines selbstregulierenden Mechanismus, der auf vorab gesammelten Daten basiert.  6. Erwartete Ergebnisse   Die Forschung wird voraussichtlich folgende Ergebnisse liefern: - Ein benutzerfreundliches Interface-Design f√ºr die Steuerung und Visualisierung der Luftqualit√§t. - Ein effektives System zur Selbstregulierung des Reinigungsprozesses basierend auf Luftqualit√§tsdaten. - Empfehlungen f√ºr die Implementierung in bestehende Produkte oder als Basis f√ºr neue Entwicklungen.  7. Diskussion   Die Arbeit wird sich mit den Herausforderungen und Limitationen der Umsetzung des entwickelten Konzepts auseinandersetzen, inklusive technischer und √∂kologischer Aspekte sowie der langfristigen Auswirkungen auf die Nutzerakzeptanz und den Markt.  8. Fazit   Diese Arbeit wird nicht nur zur Weiterentwicklung von Luftreinigungsger√§ten beitragen, sondern auch neue Standards f√ºr Benutzerfreundlichkeit und Effizienz in der Luftreinigungstechnik setzen.   9. Literaturverzeichnis   Ein umfassendes Verzeichnis relevanter Fachliteratur und aktueller Studien w√ºrde die Fundierung sowie die wissenschaftliche Tiefe der Arbeit unterst√ºtzen.   10. Anhang   Im Anhang k√∂nnen Diagramme, Prototyp-Darstellungen, Umfrageinstrumente und weitere unterst√ºtzende Materialien untergebracht werden.  ---  Das Konzept bietet eine klare Struktur und Ziele, die w√§hrend der wissenschaftlichen Arbeit verfolgt werden sollen.;1
Bei der Slidefunktion ist die Slide auf den ganzen Bildschirm zu sehen. Links und rechts sind Pfeiltasten, womit die n√§chste oder vorherige Folie aufgerufen werden kann. Unten rechts steht ein Timer, welcher angibt wie lange die Folie noch zu sehen ist. Unten in der Mitte ist ein‚ÄûPause/Play‚Äú-Button.MitdiesemkannderNutzerdenTimerpausierenoderfortf√ºhren. Wenn die Follow Funktion aktiviert wird sucht Pepper zuerst nach einer Person die er folgen kann. W√§hrend diesem Vorgang wird ein Auge in der Mitte des Bildschirmes angezeigt. Dar√ºber steht ‚ÄûSuche Person‚Äú. Danach wird je nach Situation eine der im Projekt hin- terlegten Texte f√ºr Fokus erfolgreich, Fokus nicht erfolgreich und Person verloren angezeigt. F√ºhrt Pepper eine Animation aus wird in der Mitte des Bildschirmes ein ‚ÄûZur√ºck‚Äú-Button angezeigt, mit dem der Nutzer zur vorherigen BenutzeroberÔ¨Ç√§che gelangt. Bei der Pepper Say Funktion wird auf dem Bildschirm der Text, den Pepper sagt wie in Abbildung 3.33 angezeigt.;0
In Abbildung 6.1 ist der letztendliche Versuchsaufbau zu sehen. Aufgrund von vorhandenem Material wurde von einem reinen Relais abgewichen, stattdessen wurde ein Aufsatz der Firma Pimoroni genutzt.1Dieser ist fest mit dem Raspberry Pi verbunden und somit einfacher zu transportieren, ebenso ist dadurch ein falscher Anschluss der Netzlast am Raspberry Pi unm√∂glich. Aufgrund dieser √Ñnderung musste zum Systemtest noch die Bibliothek des Herstellers eingebunden werden, welche die selben Funktionalit√§ten wie die inAbschnitt 3.4 beschriebenen Methoden besitzt . Durch den Rechenaufwand der mit der Nutzung von KNNeinhergeht, ist ein Batteriebe- trieb, wie er bei IoT-Systemen g√§ngig ist, nicht m√∂glich. Durch den Netzbetrieb ist daher auch die Platzierung der Basisstation begrenzt. Ebenso ist das Neuronale Netz auf die Erkennung von Katzen im Allgemeinen trainiert, es wird damit nicht explizit die Katze des Besitzers erkannt, was zu zus√§tzlichen False-Positives f√ºhren kann. Ebenso wurden aufgrund von Zeitmangel keine Langzeittests durchgef√ºhrt, was die Be- st√§ndigkeit des Systems angeht. Damit ist beispielsweise unklar, ob eine lange W√§rmeent- wicklung durch CPU-Last dem Raspberry auf Dauer schadet.;0
Ein weiterer nicht zu untersch√§tzender Faktor ist die Tatsache, dass durch die Verwendung von Compose das InÔ¨Çaten des Layouts zur Anzeige einer View komplett wegf√§llt. Compose spart sich diese zus√§tzlichen Kosten und den Aufwand dadurch, dass das UIgenau wie der Rest des Codes in Kotlin erstellt ist. Es wird ebenso wie der Rest des Codes einfach kompiliert. Neben diesen zahlreichen Aspekten, die f√ºr die Verwendung des Frameworks sprechen, steht nicht zuletzt die aussagekr√§ftige Tatsache, dass der in Jetpack Compose verwendete deklarative Ansatz nicht nur f√ºr Android verf√ºgbar ist. Das Jetpack Compose Framework ist lediglich eine Verk√∂rperung des Ansatzes f√ºr die Android-Plattform. Es gibt bereits ein anderes Projekt von Jetbrains f√ºr die Umsetzungen von Desktop/- und Webanwendungen mithilfe des Ansatzes, das als Compose Multiplatforms bezeichnet wird und vor allem mit Codesharing zwischen Android, Desktop und Web ,  wirbt. Die Einwicklungen in diesem Bereich sprechen gemeinsam mit allen anderen Aspekten f√ºr das gro√üe Potenzial, welches der deklarative Ansatz mit sich bringt.;0
In dieser Arbeit wurde ein innovatives IoT-System zur Steuerung einer Katzenklappe entwickelt, das auf einer KI-gest√ºtzten Katzenerkennung basiert. Die Implementierung verdeutlicht, wie moderne Technologien im Bereich des Internets der Dinge (IoT) effektiv kombiniert werden k√∂nnen, um tierische Bed√ºrfnisse zu adressieren und gleichzeitig den Komfort f√ºr Tierbesitzer zu erh√∂hen.  Die Ergebnisse zeigen, dass die entwickelte L√∂sung sowohl in der Erkennungsgenauigkeit als auch in der Reaktionsgeschwindigkeit √ºberzeugend abschneidet. Die Integration von Bildverarbeitungstechniken und maschinellem Lernen erm√∂glicht eine zuverl√§ssige Identifizierung der Katze, wodurch unbefugter Zugang f√ºr andere Tiere ausgeschlossen wird. Dies stellt nicht nur eine Verbesserung der Sicherheit dar, sondern minimiert auch m√∂gliche Konflikte zwischen verschiedenen Haustieren.  Zudem wurde im Rahmen der Arbeit das Potenzial f√ºr zuk√ºnftige Erweiterungen des Systems aufgezeigt, wie etwa die Einbindung weiterer Sensoren zur √úberwachung des Verhalten der Tiere oder die Anpassungsm√∂glichkeiten durch zuk√ºnftige Software-Updates. Diese Adaptierbarkeit macht das IoT-System nicht nur zukunftsf√§hig, sondern auch flexibel in der Anwendung.  Insgesamt zeigt diese Arbeit, dass das Zusammenspiel von IoT-Technologie und KI-basierter Bildverarbeitung eine vielversprechende Basis f√ºr die Entwicklung smarter L√∂sungen im Bereich derTierhaltung bietet. Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, die Technologie weiter zu verfeinern und breitere Anwendungen im Bereich der Haustier√ºberwachung und -pflege zu erkunden. Die Ergebnisse dieser Arbeit tragen somit nicht nur zur akademischen Diskussion im Bereich der digitalen Tierhaltung bei, sondern bieten auch praktische Ans√§tze, die in der Realit√§t umgesetzt werden k√∂nnen.;1
"4.9.3 Aufnahme in das TTN
Die Aufnahme des DIY Nodes in das TTNunterscheidet sich nicht von dem in Abschnitt 4.4
beschriebenen Vorgehen zur Aufnahme des Feather M0 Nodes in das TTN. Es wird
ebenfalls eine neue Application f√ºr die DIY-Nodes angelegt und innerhalb dieser ein
Endger√§t hinzugef√ºgt. Wie auch beim Feather M0 Board m√ºssen die AppEUI, die DevEUI
und der AppKey anschlie√üend in den Sketch des DIY Nodes unter Beachtung der Endianess
hineinkopiert werden.
4.9.4 Flashen des Arduino Sketches
Vorsicht: Es darf beim Anschluss eines FTDI Adapters nicht zeitgleich ein
LiPo Akku am JSTAnschluss des DIY Nodes angeschlossen sein!
Im Gegensatz zum Feather M0 Board verf√ºgt der Arduino Pro Mini nicht √ºber einen Micro-
USB Port, √ºber den der Microcontroller programmiert werden kann. Stattdessen muss
beim Arduino Pro Mini ein sog. FTDI Adapter f√ºr das Flashen des Sketches verwendet
werden. Es ist darauf zu achten, dass der FTDI Adapter √ºber eine Ausgangsspannung von
3,3 Volt verf√ºgt, da es sich beim DIY Node verwendeten Arduino Pro Mini um die 3,3
Volt Version handelt.1Ebenso muss in der Arduino IDE vor dem Flashen des Sketchs die
3,3 Volt Version des Arduino Pro Mini als Board ausgew√§hlt werden. 
FTDI Adapter Arduino Pro Mini
VCC VCC
GND GND
TXD RX1
RXD TX0
RTS GRN2
CTS BLK3
Tabelle 4.3: Pinmapping zur Programmierung eines Arduino Pro Mini via FTDI Adapter4
4.9.5 Anpassen des Payload Formatters
Auch in der Application des DIY Nodes wird ein JavaScript Payload Formatter verwendet
(sieheAbbildung 4.39). Im Unterschied zum Payload Formatter des Feather M0 Nodes
sendet der DIY Node keine Batteriespannung, daf√ºr jedoch zwei Messergebnisse: Die
ersten beiden Bytes des Payloads mit dem Index 0 und 1 bilden den Messwert des an
den Pin A0 angeschlossenen Bodenfeuchtigkeitssensors (Sensor 0). Die letzten beiden
Bytes mit dem Index 2 und 3 bilden den Messwert des an Pin A1 angeschlossenen
Bodenfeuchtigkeitssensors (Sensor 1).
Abbildung 4.39: Payload Formatter f√ºr den DIY Node";0
Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen  In der vorliegenden Arbeit wird die Plattform ElixirNerves als Entwicklungsumgebung f√ºr Internet der Dinge (IoT)-Anwendungen evaluiert. Die Analyse erfolgt entlang zentraler Aspekte, die f√ºr die Realisierung und den nachhaltigen Betrieb von IoT-L√∂sungen grundlegend sind: Modularit√§t, Zuverl√§ssigkeit, Performance, Entwicklungsaufwand sowie Community und Support.  Modularit√§t und Flexibilit√§t Ein herausragendes Merkmal von ElixirNerves ist seine modulares Design, das eine hohe Flexibilit√§t bei der Integration unterschiedlicher Hardwarekomponenten erm√∂glicht. Durch die Nutzung von Elixir, eine funktionale Programmiersprache, die auf der Erlang-VM basiert, k√∂nnen Entwickler Immobilien schaffen, die skalierbar und leicht erweiterbar sind. Die Nerves-Bibliothek bietet Fundamente zur Konfiguration und zur Interaktion mit einer Vielzahl von Sensoren, Aktoren und Kommunikationstechnologien, was die Entstehung ma√ügeschneiderter L√∂sungen f√∂rdert. Die Verf√ºgbarkeit von Treibern und Firmware-Komponenten erlaubt es, bestehende Optionen schnell zu testen und zu implementieren, ohne Zeit mit der Entwicklung von Grund auf zu verlieren.  Zuverl√§ssigkeit und Performance Ein weiterer Vorteil von ElixirNerves liegt in der inh√§renten Zuverl√§ssigkeit des Erlang-VM √ñkosystems. Fehlerbehandlung und Fehlertoleranz werden durch gewichtige Mechanismen wie Supervisors realisiert, die es erm√∂glichen, Prozesse sicher und stabil zu verwalten. Der Designansatz unterst√ºtzt nicht nur den Erststart und Laufzeit der Anwendung, sondern gibt Entwicklern auch die n√∂tigen Werkzeuge an die Hand, um Updates und den Live-Betrieb von Ger√§ten sicher zu gestalten. Die Performance wurde als durchweg positiv bewertet, wobei viele Testanwendungen mit REPL-Befehlen (Read-Eval-Print Loop) getestet wurden, die bei der √úberwachung von Echtzeitreaktionen hilfreich waren.  Entwicklungsaufwand Der Entwicklungsaufwand f√ºr IoT-Anwendungen in ElixirNerves erwies sich insgesamt als moderat. Anf√§ngliche Einarbeitungen in die funktionale Programmierweise und das √ñkosystem k√∂nnen eine H√ºrde darstellen. Ist dieser Schritt jedoch absolviert, zeigt sich eine steigende Produktivit√§t, h√∂chsten insbesondere durch das umfassende Angebot an vorgefertigten Bibliotheken und die √ºbersichtliche Syntax der Sprache. Die Nutzung g√§ngiger Entwicklungswerkzeuge und das Embrace von Test- und Versionskontrollsystemen k√∂nnen den Prozess zus√§tzlich f√∂rdern, sodass eine hohe Codequalit√§t gew√§hrleistet werden kann.  Community und Support Nicht zu untersch√§tzen ist der Einfluss der Community und die Verf√ºgbarkeit von Support in der Evaluation einer Entwicklungsplattform. ElixirNerves profitiert hier von einer lebendigen und engagierten Entwicklergemeinschaft, die in verschiedener Form (wie Foren, GitHub-Repositories und Konferenzen) aktiven Austausch bietet. Dies kann entscheidend sein, um auftretende Herausforderungen w√§hrend des Entwicklungsprozesses zu bew√§ltigen und das Angebot an Bibliotheken kontinuierlich zu erweitern. Es steht Nutzern eine Vielzahl von Ressourcen zur Verf√ºgung, wodurch ein f√ºr Entwickler hilfreiches und unterst√ºtzendes Umfeld geschaffen wurde.  Fazit Auf Basis der durchgef√ºhrten Evaluation l√§sst sich zusammenfassen, dass Elixir;1
"In der vorliegenden Arbeit wird das Ph√§nomen der digitalen √úberwachung im Kontext des Begriffs ""Zero"" untersucht, welches sowohl die potenziellen Vorteile als auch die Risiken dieser Technologien beleuchtet. Angesichts der rasant fortschreitenden Digitalisierung und der omnipr√§senten Datensammlung durch staatliche und private Akteure sind Fragen zu Datenschutz, Ethik und gesellschaftlicher Kontrolle von zentraler Bedeutung. Die Studie analysiert verschiedene Facetten der digitalen √úberwachung, angefangen bei den eingesetzten Technologien und deren Innovationskraft bis hin zu den Einflussfaktoren auf die individuelle Freiheit und das soziale Gef√ºge. Durch die kritische Auseinandersetzung mit Fallstudien, rechtlichen Rahmenbedingungen und aktuellen Entwicklungen wird verdeutlicht, wie das ""Zero""-Konzept als Metapher f√ºr eine umfassende Kontrolle fungiert, die sowohl Chancen f√ºr Sicherheitsgewinne als auch Gefahren f√ºr die Privatsph√§re und die Demokratie mit sich bringt. Abschlie√üend werden Handlungsempfehlungen formuliert, die darauf abzielen, ein Gleichgewicht zwischen Sicherheit und Freiheit zu gew√§hrleisten und einen verantwortungsvollen Umgang mit digitalen √úberwachungstechnologien zu f√∂rdern.";1
Damit ergeben sich die folgenden gravierenden Unterschiede im Vergleich zum Einsatz des herk√∂mmlichen Navigation Components, die auch zeitgleich die wesentlichen Vorteile der Bibliothek darstellen. ‚Ä¢Die Sealed classes werden automatisch generiert. F√ºr jedes Composable wird automa- tischeinsolchesObjekterzeugt.DieswirdebenfallsbeimBauendesProjektsgeneriert und bekommt zur IdentiÔ¨Åkation immer den Namen des annotierten Composables mit einem angeh√§ngten Destination . Eine so erzeugte Destination implementiert also ein Interface mit den relevanten Informationen, die f√ºr die Navigation zu einem Composable ben√∂tigt werden. Folgendes Listing 3.3 veranschaulicht dies anhand der MainScreenDestination, die als Folge der in Listing 3.2 dargestellten Annotation generiert wird. Die so erzeugten Destinations werden ebenfalls in das erzeugte NavGraphs-Objekt eingebunden, wie in Abbildung 3.5 ersichtlich wird. ‚Ä¢Argumente, die mithilfe der Navigation √ºbergeben werden sollen, werden deÔ¨Åniert, indem sie an das jeweilige Composable √ºbergeben werden, welches annotiert wurde. Zudem ist es auch m√∂glich, optionale Parameter oder komplette Objekte zu √ºber- geben, ohne diese in der Zieldimension aktiv und gezielt rekonstruieren zu m√ºssen . Dies wird im folgenden Listing 3.4 ersichtlich. Hierbei wird √ºber die Callback-Funktion des clickable-ModiÔ¨Åers der Row das ausgew√§hlte CoÔ¨Äee-Objekt mit an die DetailScreenDestination √ºbergeben und steht somit dort direkt zur Verf√ºgung.;0
  Die Qualit√§t von Softwareprodukten ist ein zentrales Anliegen in der Softwareentwicklung, da sie ma√ügeblich die Benutzerzufriedenheit, die Wartbarkeit und die langfristige Wirtschaftlichkeit beeinflusst. In diesem Kontext gewinnen produktorientierte Metriken der Softwarequalit√§t zunehmend an Bedeutung. Diese Metriken bieten eine quantitative Grundlage zur Bewertung und Verbesserung von Softwareprodukten. Um die Relevanz und den Anwendungsbereich produktorientierter Metriken zu verstehen, ist es notwendig, sowohl deren als auch deren praktische Anwendung zu betrachten.     Produktorientierte Metriken beziehen sich auf die Eigenschaften und Merkmale des Softwareprodukts selbst, im Gegensatz zu prozessorientierten Metriken, die sich auf den Entwicklungsprozess konzentrieren. Die Definition von Softwarequalit√§t ist vielschichtig und umfasst verschiedene Dimensionen, darunter Funktionalit√§t, Zuverl√§ssigkeit, Benutzerfreundlichkeit, Effizienz, Wartbarkeit und √úbertragbarkeit. Diese Dimensionen sind in verschiedenen Modellen der Softwarequalit√§t formuliert, wie zum Beispiel dem ISO/IEC 25010 Standard, der eine umfassende Klassifikation von Qualit√§tsmerkmalen bietet.  Die produktorientierten Metriken k√∂nnen in verschiedene Kategorien unterteilt werden. Eine h√§ufige Klassifikation erfolgt in quantitative und qualitative Metriken. Quantitative Metriken sind in der Regel numerische Werte, die spezifische Eigenschaften der Software messen, wie zum Beispiel die Anzahl der Fehler pro 1000 Zeilen Code (KLOC) oder die Code-Komplexit√§t, gemessen durch Metriken wie den cyclomatischen Komplexit√§tsindex. Qualitative Metriken hingegen beziehen sich auf subjektive Bewertungen, die oft durch Benutzerumfragen oder Expertenbewertungen ermittelt werden.  Ein zentrales Konzept in der Definition produktorientierter Metriken ist die Messbarkeit. Um die Qualit√§t eines Softwareprodukts zu bewerten, m√ºssen die Metriken reproduzierbar und objektiv sein. Dies erfordert eine klare Definition der zu messenden Eigenschaften sowie standardisierte Verfahren zur Datenerhebung und -analyse. Die Validit√§t und Reliabilit√§t der Metriken sind entscheidend, um sicherzustellen, dass die Ergebnisse tats√§chlich die Qualit√§t der Software widerspiegeln.   Anwendung produktorientierter Metriken  Die Anwendung produktorientierter Metriken erfolgt in verschiedenen Phasen des Softwareentwicklungszyklus. In der Planungsphase k√∂nnen Metriken genutzt werden, um Anforderungen zu definieren und Qualit√§tsziele festzulegen. W√§hrend der Implementierungsphase dienen sie dazu, den Fortschritt zu √ºberwachen und sicherzustellen, dass die entwickelten Komponenten den festgelegten Qualit√§tsstandards entsprechen. In der Testphase erm√∂glichen Metriken eine objektive Bewertung der Softwarequalit√§t, indem sie die Fehlerdichte und die Testabdeckung quantifizieren.  Ein praktisches Beispiel f√ºr die Anwendung produktorientierter Metriken ist die Verwendung der ‚ÄûCode-Coverage‚Äú-Metrik, die misst, welcher Anteil des Codes durch Tests abgedeckt wird. Eine hohe Code-Coverage kann auf eine gr√ºndliche Testabdeckung hinweisen, was wiederum die Wahrscheinlichkeit verringert, dass unentdeckte Fehler im Produktionscode verbleiben. Ebenso kann die cyclomatische Komplexit√§t dazu verwendet werden, den Wartungsaufwand eines Softwaremoduls abz;1
Der Klassendiagramm des Prototypen ist in Abbildung 3.48 zu sehen. Die MainActivity beinhaltet Methoden um eine fest eingestellte JSON-Datei vom SFTP-Server herunterzu- laden, einzulesen und die darin festgelegte Roboterfunktion zu starten. Die MainActivity zeigt zum Start der Container-App zwei Buttons an (Abb. 3.49). √úber den Button ‚ÄúDOW- NLOAD JSON FILE‚Äù kann die JSON-Datei vom Server heruntergeladen werden. Diese wird im Verzeichnis der Container-App im Android-Tablet persistent abgespeichert. Falls bereits eine JSON-Datei mit dem selben Namen vorhanden ist, wird diese √ºberschrieben. War der Download erfolgreich wird dies durch das Anzeigen des Buttons ‚ÄúFUNCTION‚Äù angezeigt (Abb. 3.50). √úber den Button ‚ÄúREAD JSON FILE‚Äù wird die JSON-Datei einge- lesen. Der Button ‚ÄúFUNCTION‚Äù wird basierend auf der in der JSON-Datei eingetragenen Roboterfunktion eingef√§rbt und mit dem Namen der Funktion beschriftet (Abb. 3.51). √úber den ‚ÄùFUNCTION‚Äù-Button kann nun diese Roboterfunktionen gestartet werden. Die Roboterfunktionen sind als Activity implementiert und werden aus der MainActivity per Intent mit dem in der JSON-Datei hinterlegtem Parameter aufgerufen. Die Farbe und der Beschriftungstext f√ºr den Button ‚ÄúFUNCTION‚Äù sind im Code der App hinterlegt. Die eingebauten Funktionen sind ‚ÄúSay‚Äù und ‚ÄúElephantNoiseWithAnimation‚Äù. Die Activities beider Funktionen zeigen einen ‚ÄúBACK‚Äù der auf vorherige Activity, also auf die MainActi- vity zur√ºckf√ºhrt (Abb. 3.53). Zus√§tzlich zeigt die ‚ÄúSay‚Äù-Activity den gesprochenen Text an (Abb. 3.52).;0
Evaluierung der Gegen√ºberstellung von Content-Management-Systemen  Die vorliegende Arbeit befasst sich mit der umfassenden Gegen√ºberstellung von Content-Management-Systemen (CMS), einem zentralen Thema in der digitalen Informationsverwaltung und Webentwicklung. Die Evaluierung dieser Systeme ist von gro√üer Bedeutung, da sie es Unternehmen und Einzelpersonen erm√∂glicht, die f√ºr ihre spezifischen Anforderungen am besten geeignete L√∂sung auszuw√§hlen. In der heutigen, zunehmend digitalisierten Welt sind die Anspr√ºche an die Flexibilit√§t, Benutzerfreundlichkeit und Funktionalit√§t von CMS h√∂her denn je.  Im Rahmen dieser Evaluierung wurden verschiedene CMS untersucht, darunter weit verbreitete Systeme wie WordPress, Joomla und Drupal sowie neuere, spezialisierte L√∂sungen wie Contentful und Ghost. Die Analyse erfolgte anhand von mehreren Kriterien, die f√ºr die Benutzererfahrung und die technische Implementierung entscheidend sind. Zu den zentralen Aspekten z√§hlen die Benutzerfreundlichkeit, Anpassungsf√§higkeit, Sicherheitsmerkmale, Community-Support und die M√∂glichkeit zur Integration von Drittanbieterdiensten.  Ein herausragendes Merkmal der Evaluierung ist die Ber√ºcksichtigung der Benutzerfreundlichkeit, die sich als ein entscheidender Faktor f√ºr die Akzeptanz und den Erfolg eines CMS herausstellt. Systeme wie WordPress zeichnen sich durch eine intuitive Benutzeroberfl√§che und eine gro√üe Auswahl an Plugins aus, die es Nutzern erm√∂glichen, ihre Websites ohne tiefgehende technische Kenntnisse anzupassen. Im Gegensatz dazu erfordert ein System wie Drupal eine steilere Lernkurve, bietet jedoch eine h√∂here Flexibilit√§t und Anpassungsf√§higkeit, die insbesondere f√ºr komplexe Projekte von Vorteil ist.  Ein weiterer wichtiger Evaluationspunkt ist die Sicherheit der Systeme. In einer Zeit, in der Cyberangriffe und Datenlecks an der Tagesordnung sind, ist es unerl√§sslich, dass ein CMS robuste Sicherheitsfunktionen bietet. Hierbei zeigt sich, dass sowohl WordPress als auch Drupal regelm√§√üig Sicherheitsupdates bereitstellen, w√§hrend weniger bekannte Systeme m√∂glicherweise nicht denselben Grad an Unterst√ºtzung bieten. Die Analyse des Community-Supports hat ebenfalls gezeigt, dass eine aktive Entwickler- und Nutzerbasis entscheidend ist, um bei Problemen schnell Hilfe zu erhalten und die Software kontinuierlich zu verbessern.  Die M√∂glichkeit zur Integration von Drittanbieterdiensten stellt einen weiteren kritischen Aspekt dar, insbesondere f√ºr Unternehmen, die auf eine Vielzahl von Tools und Plattformen angewiesen sind. In diesem Kontext schneiden Systeme wie Joomla und Contentful besonders gut ab, da sie √ºber umfangreiche API-Funktionen verf√ºgen, die eine nahtlose Verbindung zu externen Anwendungen erm√∂glichen.  Zusammenfassend l√§sst sich sagen, dass die Gegen√ºberstellung von Content-Management-Systemen nicht nur die Vielfalt der verf√ºgbaren Optionen aufzeigt, sondern auch die spezifischen Vor- und Nachteile jedes Systems beleuchtet. Diese Evaluierung bietet eine wertvolle Grundlage f√ºr Entscheidungstr√§ger, die ein CMS ausw√§hlen m√∂chten, und tr√§gt dazu bei, die Komplexit√§t des Marktes zu reduzieren. Zuk√ºnftige Forschungen k√∂nnten sich darauf konzentrieren, die Entwicklungen im Bereich der k√ºnstlichen Intelligenz und deren Einfluss auf die Evolution von CMS zu untersuchen, um die n√§chste Generation von Content-Management-L√∂sungen besser zu verstehen und zu gestalten.;1
      Die moderne App-Entwicklung steht vor der Herausforderung, benutzerfreundliche und jedoch funktionale Benutzeroberfl√§chen (UIs) zu gestalten, die nicht nur ansprechend sind, sondern auch reibunghslos auf verschiedenen Ger√§ten und Bildschirmgr√∂√üen funktionieren. In diesem Kontext hat Google das Jetpack Compose Framework eingef√ºhrt, das eine deklarative Programmierung von Benutzeroberfl√§chen f√ºr Android-Anwendungen erm√∂glicht. Diese beeinflussende neue Architektur stellt eine signifikante Abkehr von der traditionellen imperativen UI-Programmierung dar und verspricht Effizienz, Flexibilit√§t und eine verbesserten Entwicklererfahrung.   1. Grundkonzepte von Jetpack Compose  Jetpack Compose basiert auf mehreren grundlegenden Prinzipien, die in der declarative UI Entwicklung verwurzelt sind. Anstatt dass Entwickler Schritt f√ºr Schritt die UI in einer imperativen Weise aufbauen (d.h. indem sie angeben, wie die UI erstellt werden soll), beschreiben sie den gew√ºnschten UI-Zustand. Ein zentrales Konzept von Compose ist die Trennung von Logik und Darstellung, was bedeutet, dass der UI State unabh√§ngig von der Benutzeroberfl√§che betrachtet werden kann. Dies wird durch Stateful und stateless Components erreicht.  Die Composition als Grundelement von Jetpack Compose erm√∂glicht es, kleine, wiederverwendbare UI-Komponenten (Composables) zu definieren. Diese k√∂nnen zu komplexeren UI-Strukturen zusammengef√ºgt werden, was eine modulare und wartbare Architektur f√∂rdert. Durch die Verwendung von Kotlin als Programmiersprache profitieren Entwickler zudem von fortschrittlichen Sprachfunktionen wie Higher-Order Functions und Lambda-Ausdr√ºcken.   2. State Management  Ein pr√§gnantes Merkmal von Jetpack Compose ist das unterst√ºtzen von effizienten State Management Techniken. Der Zustand einer Benutzeroberfl√§che (UI State) ist entscheidend f√ºr die Interaktivit√§t einer App. Das Framework folgt einem unidirektionalen Datenfluss, der eine klare Beziehung zwischen dem UI und den zugrunde liegenden Daten herstellt. Jedes Mal, wenn sich der Status √§ndert, werden nur die Teile der UI aktualisiert, die betroffen sind. Dies geschieht dank des Monitoring-Mechanismus, der die Ver√§nderung von state-wrapped Objekten verfolgt und die Komposition innerhalb der UI optimizing kann, indem unn√∂tige Neuberechnungen vermieden werden.   3. Layout-System  Das Layout-System in Jetpack Compose stellt einen weiteren Dreh- und Angelpunkt dar. Es basiert auf einem flexiblen, flie√üenden Ansatz, bei dem Design-Konzepte der Responsive Web-Designs ausgearbeitet werden. Mit dem Modifier-Pattern k√∂nnen Entwickler Layout-Elemente dinamisch anpassen, verschachteln und stylen. Neben gebr√§uchlichen Kontrollen wie Buttons, Texten und Bildausschnitten erm√∂glicht Compose um das Erstellen komplexer Benutzeroberfl√§chen, die an Regeln des Materials Design orientieren. Dieses framework-gesteuerte Approach tr√§gt dazu bei, ung√ºnstige Rendering-Probleme zu minimieren und sorgt f√ºr eine einfache Anpassung von UI in einer Vielzahl von Aufl√∂sungen und Sensors.   4. Integration und √ñkosystem  Jetpack Compose ist Teil des gr√∂√üeren Android-Jetpack-√ñkosystems, das eine Sammlung n√ºtzlicher;1
Im Rahmen der vorliegenden Arbeit wurde ein Content-Management-System (CMS) entwickelt, das speziell auf die Erstellung von Android-Anwendungen f√ºr den humanoiden Roboter Pepper ausgerichtet ist. Dieses CMS stellt eine innovative L√∂sung dar, um den Prozess der App-Entwicklung f√ºr Pepper zu vereinfachen und einem breiteren Nutzerkreis zug√§nglich zu machen. Durch die benutzerfreundliche Oberfl√§che und eine modulare Architektur erm√∂glicht das CMS sogar Personen ohne tiefgehende Programmierkenntnisse, qualitativ hochwertige Apps zu erstellen und individuell anzupassen.  Die Ergebnisse der durchgef√ºhrten Tests und Nutzerbefragungen belegen eine signifikante Verbesserung in der Effizienz bei der Erstellung von Anwendungen f√ºr Pepper im Vergleich zu traditionellen Entwicklungsans√§tzen. Insbesondere der integrierte Drag-and-Drop-Editor, die vorgefertigten Vorlagen und die Implementierung von API-Schnittstellen tragen dazu bei, den Entwicklungsprozess zu beschleunigen und den kreativen Spielraum zu erweitern.  Nichtsdestotrotz sind auch einige Herausforderungen identifiziert worden, insbesondere hinsichtlich der Skalierbarkeit und der Anpassungsf√§higkeit des CMS an zuk√ºnftige Technologien und Updates von Abschnittsystemen. Diese Aspekte sollten in zuk√ºnftigen Forschungsvorhaben und Erweiterungen des CMS Ber√ºcksichtigung finden, um dessen Attraktivit√§t und Funktionalit√§t weiter zu erh√∂hen.  Zusammenfassend l√§sst sich sagen, dass das entwickelte CMS eine wertvolle Spitze f√ºr die Interaktion mit dem Roboter Pepper darstellt, die nicht nur technisch motivierte Nutzer, sondern auch Bildungseinrichtungen und Unternehmen anzusprechen vermag. Die Erleichterung der App-Entwicklung er√∂ffnet neue M√∂glichkeiten der Mensch-Roboter-Interaktion und kann in Zukunft dar√ºber hinaus auch zur F√∂rderung von Innovation und Kreativit√§t in der Robotik-Anwendungsentwicklung beitragen. Die folgenden Forschungsschritte sollten darauf abzielen, das System weiter zu verbessern und koh√§rent in bestehende Technologielandschaften zu integrieren. So bleibt die  Zukunftsaussicht f√ºr die vielseitige Teamarbeit zwischen Mensch und Maschine weiterhin positiv.;1
Um die Ver- und Entriegelung einer Katzenklappe umzusetzen wird ein Solenoid als T√ºrschloss verwendet. Wie in Abbildung 3.4 dargestellt ist wird dieser √ºber Pins an den Raspberry Pi 4 angeschlossen. F√ºr die Ansteuerung des Solenoiden wird ein Relais verwendet.  Zur Steuerung des Solenoids wird die RPi.GPIO Bibliothek verwendet. RPi steht dabei f√ºr Raspberry Pi, und GPIO f√ºr General Purpose In/Out. Wie f√ºr die Steuerung wird in diesem Fall Pin 18 verwendet. Nachfolgend ist das Setup des Pins zu sehen. Da das Signal an Pin 18 als Steuersignal f√ºr den Solenoid bestimmt ist, muss dieser Pin auf Output gesetzt werden. Anschlie√üend wird das Schloss verriegelt, sollte das nicht schon der Fall sein. Im Falle einer erkannten Katze wird der Solenoid in der in Listing 3.9 gezeigten Funktion auf 0V Spannung und damit LOW gesetzt. Der Katze werden 30 Sekunden gegeben um die T√ºr zu benutzen, danach wird diese wieder verriegelt.;0
Client zu Server und von Server zu Client gesendet werden. Im Beispiel aus Abbildung 2.1 sendet pubein PUBLISH Control Packet an den Server mit dem Inhalt ‚Äû20.5 ¬∞C‚Äú als UTF-8 String. Diese Nachricht wird anschlie√üend vom Server an die Clients sub0undsub1mit weiteren PUBLISH Control Packets versendet. 2.2 Python Python ist laut der Python Software Foundation  eine interpretierte Programmier- sprache, welche eine dynamische Typisierung verwendet und objektorientierte Program- mierung unterst√ºtzt. Daher eignet sie sich f√ºr das Schreiben von Skripten und erm√∂glicht eine schnelle Applikationsentwicklung auf den meisten Plattformen . Der Python- Interpreter verwendet einen einzigen Kernel-Thread, um das ausgew√§hlte Programm und den Garbage Collector auszuf√ºhren . F√ºr die Entwicklung von nebenl√§ufi- gen Programmen in Python gibt es nach Ramalho  drei Ans√§tze bzw. Libraries, die verwendet werden k√∂nnen: threading : Hiermit k√∂nnen neue User-Threads erstellt werden, welche aber auf dem gleichen Kernel-Thread laufen. Diese Python-Threads m√ºssen das sogenannte Global Interpreter Lock ( GIL) reservieren, damit sie ihren Code ausf√ºhren k√∂nnen. Das GIL hat standardm√§√üig ein Zeitlimit von 5 ms, damit es nicht unendlich lange blockiert werden kann. Wenn es z.B. zwei Python-Threads gibt, welche parallel rechenintensive Operationen durchf√ºhren, w√ºrde dies l√§nger als eine sequentielle Ausf√ºhrung dauern, da der Kontextwechsel zus√§tzliche Zeit kostet.;0
Die Umsetzungsphase beinhaltet das Erstellen der OberÔ¨Ç√§chen und ebenfalls die Implementierung der Logik. Zun√§chst wird nur mit hart codierten Testdaten gearbeitet, bis diese letztendlich mit Ende der Umsetzungsphase in einer SQLite-Datenbank gespeichert werden k√∂nnen. Zum Zeitpunkt der Fertigstellung der ersten Version der App gilt der zweite Meilenstein als erreicht. Zu jedem Konzept des Frameworks, welches im Folgenden theoretisch in der Arbeit er- l√§utert werden soll, ist zu diesem Zeitpunkt in der Beispielanwendung ein praktisches Codest√ºck vorhanden, welches als Beispiel herangezogen werden kann. Auch die theoreti- schen Konzepte liegen aufgearbeitet vor und k√∂nnen in der folgenden redaktionellen Phase des Projekts miteinander verkn√ºpft werden. Mit Abschluss dieser Phase wird der dritte Meilenstein erreicht. Sollten es die ben√∂tigten Ressourcen zulassen, werden in einem zus√§tzlichen Projektab- schnitt auf die Vorteile des deklarativen Ansatzes im Gegensatz zur konventionellen nativen App-Entwicklung eingegangen. Hierbei sollen die UI-Erstellung und die Implementierung von Listen anhand eines Codevergleichs gegen√ºber gestellt werden. F√ºr den Fall, dass hier ein Mangel an zeitlichen Ressourcen eintritt, kann bei Bedarf nur eines der genannten Bei- spiele aktiv umgesetzt und die weiteren Vorteile in einer etwas h√∂heren Abstraktionsebene dargelegt werden. Somit ist aktiv sichergestellt, dass das Projekt in jedem Fall mit einem sinnvollen Ergebnis zu Ende gebracht werden kann. Die folgende Abbildung 1.1 kann als Zusammenfassung der geplanten Vorgehensweise dieser Arbeit gesehen werden.;0
Evaluierung der Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung einer Fahrzeugfernsteuerung, die eine effektive Kollisionsvermeidung implementiert und dabei auf die Kommunikationsstandards des IEEE 802.15 zur√ºckgreift. Die Auswahl dieses Standards ist nicht zuf√§llig, sondern basiert auf dessen Eignung f√ºr drahtlose Netzwerke mit geringer Leistungsaufnahme und kurzen Reichweiten, die in urbanen Umgebungen und bei der Interaktion zwischen Fahrzeugen und Infrastruktur von entscheidender Bedeutung sind.  Ein zentrales Element der Arbeit ist die Analyse der Anforderungen an die Fahrzeugfernsteuerung. Die Autoren haben umfassend recherchiert, welche technischen und sicherheitsrelevanten Aspekte ber√ºcksichtigt werden m√ºssen. Dazu geh√∂ren unter anderem die Echtzeitkommunikation zwischen Fahrzeugen (V2V) sowie zwischen Fahrzeugen und der Infrastruktur (V2I). Die Implementierung von Kollisionsvermeidungsalgorithmen spielt hierbei eine zentrale Rolle. Die Wahl geeigneter Sensoren und die Entwicklung von Algorithmen zur Datenverarbeitung sind entscheidend, um potenzielle Kollisionen fr√ºhzeitig zu erkennen und zu vermeiden.  Die Ergebnisse der durchgef√ºhrten Tests zeigen, dass die entwickelte Steuerungssystemarchitektur sowohl robust als auch zuverl√§ssig ist. Die Integration von IEEE 802.15 erm√∂glicht eine latenzarme Kommunikation, die f√ºr die Echtzeitverarbeitung unerl√§sslich ist. Zudem belegen die Testergebnisse, dass die Kollisionsvermeidungsstrategien in einer Vielzahl von Szenarien effektiv funktionieren. Die Simulationen und praktischen Tests haben verdeutlicht, dass die Fahrzeugfernsteuerung in der Lage ist, in dynamischen Umgebungen schnell auf Ver√§nderungen zu reagieren, was die Sicherheit im Stra√üenverkehr erheblich erh√∂hen kann.  Jedoch gibt es auch Limitationen, die in der Evaluierung ber√ºcksichtigt werden m√ºssen. Die Abh√§ngigkeit von der Signalst√§rke und der Bandbreite des IEEE 802.15 Standards kann in dichten urbanen Umgebungen zu Kommunikationsproblemen f√ºhren. Dar√ºber hinaus ist die Skalierbarkeit des Systems ein kritischer Punkt, insbesondere wenn eine Vielzahl von Fahrzeugen gleichzeitig kommunizieren muss. Hier w√§re eine weitere Forschung notwendig, um die Interoperabilit√§t und die Effizienz des Systems zu optimieren.  Zusammenfassend l√§sst sich festhalten, dass die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 vielversprechende Ans√§tze bietet, um die Sicherheit im Stra√üenverkehr zu erh√∂hen. Die Kombination aus innovativer Technologie und praktischen Anwendungen stellt einen wertvollen Beitrag zur zuk√ºnftigen Mobilit√§t dar. Dennoch ist es wichtig, die identifizierten Herausforderungen in zuk√ºnftigen Arbeiten anzugehen, um das volle Potenzial dieser Technologie auszusch√∂pfen und die Implementierung in realen Verkehrsszenarien zu erm√∂glichen.;1
‚Ä¢Fehlende Funktionalit√§ten und Features Teilweise macht sich die Neuheit des Frameworks auch dahingehend bemerkbar, dass noch Features fehlen oder andere bereits bestehende Funktionen noch nicht unterst√ºtzt werden, da sie gerade noch in der aktiven Entwicklungsphase stecken. Die Features, an deren Umsetzung gerade aktiv gearbeitet wird, k√∂nnen √ºber die Compose Roadmap eingesehen werden. Zus√§tzlich besteht die M√∂glichkeit, bei noch fehlenden Compose Bibliotheken f√ºr bestimm- te Features mit den Bibliotheken von Android Jetpack zu arbeiten, die auch im klassischen Viewsystem verwendet werden. Durch die so implementierte parallele Nutzungsweise von beiden Ans√§tzen muss jedoch mit h√∂herer Buildzeit und auch mit einer insgesamt gr√∂√üeren APK gerechnet werden.;0
Die folgenden Abschnitte untersuchen einen Ausfall oder eine Nicht-Verf√ºgbarkeit einer Komponente im System und deren Auswirkung auf die Funktionalit√§t der prototypischen Implementierung. Verf√ºgbarkeit wird in diesem Kontext als Wahrscheinlichkeit, dass das System verf√ºgbar sein wird, ausgedr√ºckt (S. 3 , Abbildung 4.4): Abbildung 4.4: Formel zur Berechnung der Verf√ºgbarkeit eines Systems In diesem Kontext existieren die Faktoren Mean Time Between Failures (MTBF) und Mean Time To Repair (MTTR) . Die folgenden konkreten Ausf√§lle werden durchgef√ºhrt und untersucht: Tempor√§rer Ausfall der REST Schnittstelle (MTTR < 3h) Tempor√§rer Ausfall der PostgreSQL-Datenbank (MTTR < 3h) Tempor√§rer Ausfall des lokalen Netzwerks (MTTR < 3h) Alle dargelegten Ausf√§lle werden zur Laufzeit der prototypischen Implementierung suk- zessive realisiert. Das Ergebnis der durchgef√ºhrten Szenarien zeigt, dass alle erhobenen Datens√§tze w√§hrend der Ausfallzeit in allen drei Fallkonstellationen nach Neustart der entsprechenden Komponenten l√ºckenlos in der PostgreSQL-Datenbank vorhanden sind. Die durchlaufenen Zust√§nde des Moduls publisher.ex charakterisiert Abbildung 4.5. Mit der Funktion schedule_next_publish/1 sendet das Modul Publisher nach Ablauf des definierten Zeitintervalls im internen Prozess des GenServers eine Nachricht an den internen Prozess selbst. Diese Nachricht wird in der Funktion handle_info/2 bearbeitet. Nach ausgef√ºhrter Request mit den erhobenen Messdaten wird der Status der zur√ºckgegebenen Antwort √ºberpr√ºft. Zuletzt wird, je nach Status, der Speicher des Buffers entleert oder erhalten und eine erneute Request geplant.;0
 Kapitel 2: Technische Grundlagen   2.1 Einleitung  Die √úberwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f√ºr landwirtschaftliche Anwendungen, das Umweltmanagement und die Wasserwirtschaft. Die Nutzung von Low Power Wide Area Networks (LPWAN) wie LoRaWAN bietet eine effiziente L√∂sung zur Erfassung und √úbertragung von Sensordaten √ºber gro√üe Entfernungen mit minimalem Energieverbrauch. Dieses Kapitel behandelt die technischen Grundlagen des Trackings der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN).   2.2 LoRaWAN: Ein √úberblick  LoRaWAN (Long Range Wide Area Network) ist ein Protokoll, das f√ºr die Kommunikation zwischen Batterien betriebenen Ger√§ten (Nodes) und einem zentralen Netzwerkserver entwickelt wurde. Es nutzt die LoRa (Long Range) Modulationstechnologie, um gro√üe Entfernungen zu √ºberbr√ºcken, typischerweise von 2 bis 15 Kilometern, abh√§ngig von den √∂rtlichen Gegebenheiten und der Umgebungsoberfl√§che.   2.2.1 Technische Merkmale von LoRaWAN  1. Reichweite: LoRaWAN-Netzwerke bieten eine gro√üe Reichweite, die es erm√∂glicht, Sensoren in entfernten oder schwer zug√§nglichen Gebieten zu integrieren.     2. Energieeffizienz: Die Technologie erm√∂glicht eine lange Batterielebensdauer von bis zu 10 Jahren, was besonders wichtig f√ºr IoT-Anwendungen ist, bei denen der Zugang zu Stromquellen eingeschr√§nkt ist.  3. Skalierbarkeit: LoRaWAN-Netzwerke k√∂nnen Hunderte oder Tausende von Endger√§ten unterst√ºtzen, was sie ideal f√ºr gro√üfl√§chige Anwendungen macht.  4. Sicherheitsprotokolle: LoRaWAN bietet verschiedene Sicherheitsfunktionen, darunter End-to-End-Verschl√ºsselung, um die Integrit√§t und Vertraulichkeit der Daten zu gew√§hrleisten.   2.2.2 Architektur eines LoRaWAN Netzwerks  Ein LoRaWAN-Netzwerk besteht typischerweise aus mehreren Komponenten:  - Endger√§te (Nodes): Diese Ger√§te k√∂nnen verschiedene Sensoren enthalten, die Bodenfeuchtigkeit messen. Beispiele f√ºr Sensoren sind kapazitive oder resistive Hygrometer.    - Gateway: Das Gateway fungiert als Br√ºcke zwischen den Endger√§ten und dem Netzwerkserver. Es empf√§ngt die Daten von den Endger√§ten √ºber das LoRa-Funksignal und leitet diese √ºber ein konventionelles Internet-Protokoll (z. B. Ethernet, GSM) an den Server weiter.    - Netzwerkserver: Der Server verarbeitet die empfangenen Daten und verwaltet die Kommunikation zwischen den Endger√§ten. Er sorgt f√ºr Sicherheitsfunktionen und kann auch Daten in cloud-basierte Dienste integrieren.    - Applikationsserver: Auf diesem Server werden die spezifischen Anwendungen ausgef√ºhrt, die die Daten der Sensoren verarbeiten und analysieren. Hier k√∂nnen Nutzeroberfl√§chen f√ºr die Visualisierung der Daten bereitgestellt werden.   2.3 The Things Network (TTN)  The Things Network ist eine offene, globale LoRaWAN-Infrastruktur, die es Entwicklern erm√∂glicht, ihre IoT-Projekte ohne hohe Investitionskosten aufzubauen. TTN bietet vollst√§ndige Netzwerk-Dienste, die sich auf die LoRaWAN-Technologie st√ºtzen.   2.3.1 Vorteile von TTN  1. Globales Netzwerk: TTN bietet eine globale Infrastruktur, die es Nutzern erm√∂glicht, ihre Ger√§te einfach zu verbinden, ohne eigene Gateways zu betreiben.     2. Community und Dokumentation: Durch eine aktive Community ist eine F√ºlle an Dokumentationen und Ressourcen verf√ºgbar, die den Entwicklungsprozess unterst√ºtzen.  3. Kosteneffizienz: Die Nutzung von TTN ist in vielen F√§llen kostenlos oder kosteng√ºnstig, was es f√ºr kleine und mittlere Unternehmen sowie Forschungsprojekte attraktiv macht.   2.3.2 Integration von Bodenfeuchtesensoren in TTN  Die Integration von Bodenfeuchtesensoren in das TTN umfasst mehrere Schritte:  1. Sensorhardware: Auswahl geeigneter Sensoren (z. B. kapazitive Feuchtesensoren). Diese Sensoren m√ºssen mit einem Mikrocontroller (z. B. Arduino, Raspberry Pi) verbunden werden, der die Messdaten erfasst.     2. LoRaWAN-Modul: Anbindung eines LoRaWAN-Moduls an den Mikrocontroller. Module wie das SX1276 sind weit verbreitet und erm√∂glichen die Kommunikation √ºber das LoRa-Netzwerk.  3. Datenformatierung: Implementierung der erforderlichen Datenformate (z. B. JSON) zur √úbertragung der Sensordaten an TTN.  4. TTN-Konto und Gateway: Erstellung eines Kontos bei TTN und Anbindung an ein lokales Gateway oder Nutzung eines bestehenden Gateways zur Daten√ºbertragung.  5. Datenverarbeitung und -visualisierung: Einsatz von geeigneten Tools und Plattformen, wie Grafana oder Node-RED, zur Datenvisualisierung und -analyse.   2.4 Messung der Bodenfeuchtigkeit  Die Bodenfeuchtigkeit kann mit verschiedenen Methoden gemessen werden, wobei jede Methode ihre eigenen Vor- und Nachteile hat. Die gebr√§uchlichsten Methoden sind:  1. Kapazitive Sensoren: Messen die √Ñnderung der elektrischen Kapazit√§t, die abh√§ngig von der Feuchtigkeit im Boden variiert. Diese Sensoren ben√∂tigen weniger Energie und haben eine l√§ngere Lebensdauer.  2. Resistive Sensoren: Messen den elektrischen Widerstand im Boden. Diese Sensoren sind einfacher und g√ºnstiger, k√∂nnen jedoch von Korrosion betroffen sein und haben eine k√ºrzere Lebensdauer.   2.5 Zusammenfassung  In diesem Kapitel wurden die technischen Grundlagen f√ºr das Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network vorgestellt. Die Kombination dieser Technologien erm√∂glicht eine zuverl√§ssige, kosteneffiziente und energieeffiziente L√∂sung zur √úberwachung von Bodenfeuchtigkeit in verschiedenen Anwendungen. Im n√§chsten Kapitel werden die praktischen Aspekte und die Implementierung des Systems detailliert behandelt.;1
Nachfolgend werden die in dieser Arbeit relevanten Content Management Systeme auf die in Kapitel 4 beschriebenen Anforderungen untersucht. F√ºr eine bessere Darstellung der Kriterien und deren Auswertung wird eine Bewertungsmatrix erstellt, welche die Erf√ºllung dieser durch die Systeme einstuft. Diese Einteilung erfolgt in drei Stufen, analog zu den Farben einer Lichtzeichenanlage (Ampel). Wird ein Kriterium mit der Farbe Gr√ºn bewertet, so ist die Implementierung bzw. Ver- wendung des Features einfach und kann direkt ohne weitere Konfiguration oder Program- mierung verwendet werden. Zudem ist das Feature bzw. Kriterium in G√§nze in dessen Erwerb und Verwendung kostenfrei. Eine Kategorisierung in Gelb bedeutet, dass das jeweilige CMSdas Feature nur hinreichend unterst√ºtzt und dieses gegebenenfalls mit kostenpflichtigen L√∂sungen umgesetzt werden muss oder anderweitige Einschr√§nkungen in Kauf genommen werden m√ºssen. Kriterien, die in Bezug auf den definierten Anwendungsfall durch das jeweilige CMSnicht erreicht werden, erhalten die Einstufung in Farbe Rot. Das Gleiche gilt f√ºr jene Kriterien, die sich ausschlie√ülich mit Programmierkenntnissen umsetzen lassen oder kostenpflichtig zu erwerben sind.;0
 Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tFokus auf die      In der dynamischen Welt der Softwareentwicklung sind Qualit√§t und Effizienz von zentraler Bedeutung. Um diesen Anforderungen gerecht zu werden, sind produktorientierte Metriken ein unverzichtbares Instrument zur Assessment der Softwarequalit√§t. Diese Metriken bieten eine quantifizierbare Grundlage, um sowohl die Struktur als auch das Verhalten von Softwareprodukten objektiv zu bewerten. In diesem Artikel wird zun√§chst der Begriff produktorientierter Metriken definiert und anschlie√üend ein Ansatz zur  pr√§sentiert, der die Erfassung und Analyse dieser Metriken in der Praxis erleichtert.   Definition produktorientierter Metriken  Produktorientierte Metriken sind messbare Werte, die sich auf die Eigenschaften und F√§higkeiten eines Softwareprodukts selbst beziehen. Sie umfassen typischerweise Kennzahlen, die Softwarequalit√§t anhand spezifizierter Artefakte und deren Attributebeschreiben. Zu den h√§ufig verwendeten Metriken geh√∂ren 1. Codequalit√§tBeinhaltet Ma√üe wie die Anzahl der Codezeilen, die Komplexit√§t oder die Zyklomatische Zahl. 2. FehlerratenAnalysieren die H√§ufigkeit von Bugs pro Release oder pro Teilbereich des Codes. 3. TestabdeckungBewertet den Anteil des Codes, der durch Tests abgedeckt wird. 4. WartbarkeitMetriken, die die Leichtigkeit der Modifizierung des Codes beurteilen, wie etwa die Anzahl √Ñnderungsw√ºnsche oder die durchschnittliche Dauer f√ºr ein Bugfix.   Bedeutung der Produktorientierten Metriken  Die Bedeutung produktorientierter Metriken liegt in ihrer F√§higkeit, umfassende Einblicke in den reellen Zustand eines Softwareprodukts zu geben. Diese Metriken bieten Entwicklern, Projektmanagern und Stakeholdern Anhaltspunkte zur Identifikation von Problembereichen und unterst√ºtzen strategische Entscheidungen zur Verbesserung der Softwarequalit√§t. Die transparente Darstellung der Softwarestandards f√∂rdert zudem eine Quali√§tskultur im Team und dient als Antrieb zur kontinuierlichen Verbesserung.   Implementation einer eigenen L√∂sung  Um produktorientierte Metriken systematisch zu erfassen und auszuwerten, kann eine individuelle Softwarel√∂sung entwickelt werden. Im Folgenden werden die entscheidenden Schritte und Komponenten skizziert, die in einem solchen Prozess ber√ºcksichtigt werden sollten.   1. Anforderungsanalyse  Bevor mit der Implementierung einer L√∂sung begonnen werden kann, ist eine detaillierte Anforderungsanalyse unerl√§sslich. Dabei m√ºssen die spezifischen Metriken identifiziert werden, die f√ºr das Projekt relevant sind und welche Ziele mit ihrer Verwendung verfolgt werden. Es sollte zudem die Zielgruppe identifiziert werden, die mit den Metriken angesprochen werden soll ‚Äì sei es das Entwicklerteam, das Management oder Qualit√§tspr√ºfer.   2. Technologieauswahl  Technologische Entscheidungen, wie Programmiersprachen oder Frameworks, spielen eine entscheidende Rolle in der Umsetzung. Eine verbreitete Wahl ist die Nutzung von Python in Verbindung mit Datenanalysebibliotheken wie Pandas oder NumPy zur Verarbeitung und Analyse von Ferrierick-Daten des Projects. Zudem bieten Visualisierungsbibliotheken wie Matplotlib oder Seaborn Funktionen zur grafischen Darstellung der Metriken.   3.;1
 Ein Fazit  Die stetig wachsende Anzahl √§lterer Menschen in der Gesellschaft stellt eine Herausforderung f√ºr das Gesundheitswesen dar, insbesondere im Hinblick auf die Sturzpr√§vention und -erkennung. St√ºrze sind eine der h√§ufigsten Ursachen f√ºr Verletzungen und k√∂nnen gravierende Folgen f√ºr die Lebensqualit√§t und Selbstst√§ndigkeit √§lterer Menschen haben. In diesem Kontext gewinnt die In-room Ortung mittels Bluetooth-Technologie zunehmend an Bedeutung, um Sturzereignisse in Echtzeit zu erkennen und darauf zu reagieren.   Im Rahmen des Projekts wurde ein System entwickelt, das auf der Verwendung von Bluetooth Low Energy (BLE) basiert, um die Position von Tr√§gern in Innenr√§umen pr√§zise zu verfolgen. Das System besteht aus einer Kombination von BLE-Transmittern, die in strategischen Punkten innerhalb eines Wohnraums platziert sind, und tragbaren BLE-Empf√§ngern, die von den Nutzern getragen werden. Durch die triangulierte Analyse der Signalst√§rke der empfangenen Bluetooth-Signale konnte die Position des Nutzers mit hoher Genauigkeit bestimmt werden.   Die Implementierung des Systems umfasste mehrere Schritte, darunter die Kalibrierung der BLE-Transmitter, die Entwicklung eines Algorithmus zur Sturzerkennung und die Integration einer Benutzeroberfl√§che zur Anzeige der Sturzereignisse. Die Sturzerkennung selbst wurde durch die Analyse von Bewegungsmustern und pl√∂tzlichen √Ñnderungen der Position realisiert. Bei einem Sturz sendet das System automatisch eine Benachrichtigung an vordefinierte Kontaktpersonen oder Notdienste, was eine schnelle Reaktion erm√∂glicht.  Das  zeigt, dass die In-room Ortung mittels Bluetooth eine vielversprechende L√∂sung zur Sturzerkennung darstellt. Die Ergebnisse der Tests belegen, dass das System in der Lage ist, St√ºrze mit einer hohen Genauigkeit zu identifizieren und somit potenziell lebensrettende Ma√ünahmen einzuleiten. Die Benutzerfreundlichkeit und die geringe physische Belastung f√ºr die Nutzer sind weitere positive Aspekte, die die Akzeptanz und Integration in den Alltag √§lterer Menschen f√∂rdern k√∂nnen.  Dennoch sind einige Herausforderungen zu beachten. Dazu geh√∂ren die Notwendigkeit einer stabilen Bluetooth-Infrastruktur in Innenr√§umen, m√∂gliche St√∂rungen durch andere elektronische Ger√§te und die Wahrung der Privatsph√§re der Nutzer. Zuk√ºnftige Forschungsprojekte sollten sich daher darauf konzentrieren, diese Herausforderungen zu adressieren und die Technologie weiter zu verfeinern.   Insgesamt l√§sst sich festhalten, dass die  nicht nur das Potenzial hat, die Sicherheit √§lterer Menschen zu erh√∂hen, sondern auch einen bedeutenden Beitrag zur Entlastung des Gesundheitssystems leisten kann. Die Implementierung solcher Systeme k√∂nnte langfristig dazu beitragen, die Lebensqualit√§t √§lterer Menschen zu verbessern und ihre Unabh√§ngigkeit zu f√∂rdern.;1
"Aus zeitlichen Gr√ºnden wird die Netzabdeckung der zwei Gateways aus Kapitel Ab-
schnitt 3.1 undAbschnitt 3.2 durch das Verfahren der nutzerbasierten Reichweitentests
durchgef√ºhrt. Um diese durchzuf√ºhren, wird mit Hilfe eines GPS-Nodes und der TTN-
Mapper App, welche genauer in den nachfolgenden Kapitel beschrieben werden, die Werte
des Received Signal Strength Indicator und dem Signal-to-Noise Ratio √ºberwacht.
Received Signal Strength Indicator ( RSSI) gibt die St√§rke der drahtlosen Verbindung
zwischen Sender und Empf√§nger an. Die bidirektional Kommunikation von LoRaWAN wird
dabei in der Einheit Dezibel per Milliwatt ( dBm) gemessen. Der dBm-Wert ist dabei ein
negativer Wert und je n√§her sich dieser bei Null beÔ¨Åndet, desto st√§rker ist das empfangene
Signal. Neben der eigentlichen Leistung des Senders wird der RSSIdurch Faktoren wie
dem Pfadverlust, der Antennenverst√§rkung und dem Verbindungsverlust beeinÔ¨Çusst.
Signal-to-Noise Ratio ( SNR) wird oft auch durch ‚ÄûS/N‚Äú dargestellt und steht √ºblicherweise
f√ºr die Qualit√§t des Signals, welche durch die DiÔ¨Äerenz (in Abbildung 3.19 in rot als
‚ÄûMargin‚Äú dargestellt) zwischen der empfangenen Signalleistung und dem Grundrauschen
berechnet wird. Unter Grundrauschen versteht man die St√∂rung des eigentlichen Signals
durch andere Frequenzen, beispielweise durch W√§rmestrahlung, Strahlung aus dem Weltall
oder anderen Sendern. Liegt also der RSSI-Wert des Signals √ºber der Grenze des Grundrau-
schen ergibt sich einen positiver SNR-Wert und dieser kann ohne Probleme vom jeweiligen
Empf√§nger demoduliert werden.";0
 Kapitel 4: Implementierung eines Systems zur Bodenfeuchtigkeits√ºberwachung mit LoRaWAN und The Things Network (TTN)   4.1 Einleitung  Die √úberwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f√ºr die Landwirtschaft, insbesondere in Zeiten des Klimawandels, in denen Wasserknappheit und extreme Wetterereignisse zunehmen. In diesem Kapitel wird die Implementierung eines Systems zur kontinuierlichen √úberwachung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN (Long Range Wide Area Network) und The Things Network (TTN) beschrieben. Das Ziel dieser Implementierung ist es, eine kosteneffiziente, energieeffiziente und skalierbare L√∂sung zu entwickeln, die Landwirten und Forschern wertvolle Daten zur Verf√ºgung stellt.   4.2 Systemarchitektur  Die Systemarchitektur besteht aus drei Hauptkomponenten: den Sensoren zur Messung der Bodenfeuchtigkeit, dem LoRaWAN-Netzwerk zur Daten√ºbertragung und der TTN-Plattform zur Datenverarbeitung und -visualisierung.  1. Sensoren: Die gew√§hlten Sensoren sind in der Lage, die Bodenfeuchtigkeit pr√§zise zu messen. In dieser Implementierung wurde ein capacitive soil moisture sensor verwendet, der eine analoge Spannung erzeugt, die proportional zur Bodenfeuchtigkeit ist. Der Sensor ist mit einem Mikrocontroller, dem ESP32, verbunden, der die Messwerte erfasst und f√ºr die √úbertragung vorbereitet.  2. LoRaWAN-Netzwerk: LoRaWAN erm√∂glicht die drahtlose Kommunikation √ºber gro√üe Entfernungen mit minimalem Energieverbrauch. Der ESP32 wird mit einem LoRa-Modul (z.B. SX1276) ausgestattet, um die gesammelten Daten √ºber das LoRaWAN-Netzwerk zu senden. Die Datenpakete werden an einen LoRaWAN-Gateway gesendet, der die Informationen an die TTN-Plattform weiterleitet.  3. The Things Network (TTN): TTN bietet eine offene, kostenlose Infrastruktur f√ºr LoRaWAN-Anwendungen. Hier werden die empfangenen Daten gespeichert, verarbeitet und zur Visualisierung bereitgestellt. TTN erm√∂glicht auch die Integration mit anderen Diensten und Plattformen, was die Analyse und Verarbeitung der Daten erleichtert.   4.3 Hardware-Implementierung  Die Hardware-Implementierung umfasst die Auswahl und den Anschluss der Komponenten. Der ESP32 wurde aufgrund seiner integrierten WLAN- und Bluetooth-Funktionen sowie seiner Energieeffizienz gew√§hlt. Der Sensor wurde an die analogen Pins des Mikrocontrollers angeschlossen, um kontinuierliche Messungen der Bodenfeuchtigkeit durchzuf√ºhren.  Die gesamte Schaltung wurde auf einem Breadboard prototypisch aufgebaut, wobei die Stromversorgung √ºber eine wiederaufladbare Lithium-Batterie sichergestellt wurde. Dies erm√∂glicht eine lange Betriebsdauer des Systems, da LoRaWAN eine sehr energieeffiziente Kommunikation bietet.   4.4 Software-Implementierung  Die Software-Implementierung umfasst die Programmierung des Mikrocontrollers zur Erfassung und √úbertragung der Daten. Die Arduino-IDE wurde verwendet, um den Code zu schreiben. Folgende Schritte wurden durchgef√ºhrt:  1. Bibliotheken einbinden: Zun√§chst wurden die notwendigen Bibliotheken f√ºr den ESP32, den LoRa-Transceiver und den Sensor eingebunden.  2. Setup der LoRa;1
 Kapitel: Realisierung der Simulation des virtuellen MQTT-Szenarios f√ºr Lehrzwecke   Einleitung  In der vorliegenden Arbeit wird die Entwicklung und Implementierung eines virtuellen Simulationsszenarios auf Basis des MQTT-Protokolls (Message Queuing Telemetry Transport) untersucht. Das Ziel dieser Simulation besteht darin, Lehrkr√§fte und Studierende im Umgang mit diesem leichten Messaging-Protokoll vertraut zu machen, das besonders in IoT-Anwendungen (Internet of Things) an Bedeutung gewinnt. Dieses Kapitel beschreibt die Schritte und Technologien, die in der Realisierung des Szenarios verwendet wurden, sowie die Herausforderungen, die w√§hrend des Entwicklungsprozesses auftraten.   Technologischer Rahmen  Die Basis f√ºr die Umsetzung des MQTT-Szenarios wurde durch die Auswahl modernster Technologien und Tools geschaffen. Dabei wurde MQTT als minimalistisches und energieeffizientes Protokoll konzipiert, das speziell f√ºr die Kommunikation zwischen ressourcenbeschr√§nkten Ger√§ten optimiert ist. F√ºr die Realisierung der Simulation entschieden wir uns, auf Node.js als Backend-Technologie und Flutter als Frontend-L√∂sung zur√ºckzugreifen.   Backend: Node.js und MQTT Broker  In der Backend-Architektur wurde ein MQTT-Broker, konkret Mosquitto, implementiert, welcher als zentraler Knotenpunkt die Kommunikation zwischen Publishern und Subscriber behandelt. Mosquitto wurde ausgew√§hlt wegen seiner Leistungsf√§higkeit, Zuverl√§ssigkeit und leichten Konfiguration f√ºr erzieherische Zwecke. Node.js wurde gew√§hlt, um einen RESTful API-Endpunkt zur Administration und Konfiguration des Szenarios zu entwickeln, was eine intuitive Interaktion erm√∂glicht und Anpassungen w√§hrend des Lehrgangs erleichtert.  Die skriptbasierte Architektur von Node.js erm√∂glicht es, asynchrone Ereignisse efficient zu handhaben, wodurch schnelle Reaktionen auf Benutzeranfragen sowie anwendungsinterne Nachrichtenstr√∂me innerhalb des Szenarios sichergestellt werden. Derzeit werden alle Nachrichten durch Themen (Topics) segregiert, die es den Teilnehmenden erlauben, gezielt mit Informationen zu interagieren, abh√§ngig von ihrem speziellen Lernpath.   Frontend: Flutter  Als Frontend-L√∂sung fiel die Wahl auf Flutter, ein beliebtes Framework zur Cross-Platform-Entwicklung. Es erm√∂glicht ein schnelles Design von Apps sowohl f√ºr mobile Ger√§te als auch Web-Anwendungen. Die visuelle Darstellung der Simulation wird durch eine ansprechende Benutzeroberfl√§che (UI) unterst√ºtzt. Um mit dem MQTT zum Backend zu interagieren, wurde das Paket 'mqtt_client' integriert, das eine einfache Verbindung zu unserem Mosquitto-Broker erlaubt.  Durch den Einsatz von Flutter wird den NutzerInnen nicht nur eine plattform√ºbergreifende Nutzung geboten, sondern auch die M√∂glichkeit, die Simulation in einem realistischen Zeitrahmen zu betrachten und kennen zu lernen.   Schritte der Realisierung  Die Umsetzung des Szenarios umfasste mehrere Schritte:  1. Planung und Definition der Lehrziele: Zu Beginn dieser Phase wurden klare Lern- und Ausbildungsziele definiert, abgestimmt auf die Bed√ºrfnisse der Zielgruppe. Es galt zu kl√§ren, welche Aspekte des MQTT Protokolls vermittelt werden sollen, und wie diese den Lernenden zielgerichtet pr√§sentiert werden k√∂nnen.  2. Entwicklung des Backend: Im n√§chsten Schritt wurden die Strukturen des Node.js Servers und des MQTT-Brokers eingerichtet. Neben der Server-Implement;1
F√ºr die Optimierung der Visualisierung der bestehenden Webseite wurde eine Android- Applikation erstellt. F√ºr den Prozess mussten verschiedene Sensoren eingesetzt werden. An den ESP32 Mikrocontroller konnte wegen der Stromversorgung keine Sensoren mehr angebracht werden. Um Sensorwerte messen und verwalten zu k√∂nnen, wurde daher zus√§tzlich ein Arduino UNO WiFi Rev 2. und ein mit dem Arduino kompatibles Arduino Sensor Kit verwendet. Im Folgenden werden die einzelnen Komponenten definiert. Das erste Android-Betriebssystem wurde 2008 ver√∂ffentlicht und hat seitdem viele Verbes- serungen erhalten (vgl. Stevenson 2021, S. 4). Android l√§uft unter einem Mehrbenutzer- Linux-System, das hei√üt, dass jede Anwendung und deren Speicher unter einem separaten Benutzer l√§uft. Anwendungen k√∂nnen unter normalen Umst√§nden nicht die Daten oder den internen Speicher einer anderen Anwendung lesen. Jeder Prozess verwendet seine eigene virtuelle Maschine, die die verschiedenen Anwendungen voneinander trennt. Anwen- dungen haben in diesen virtuellen Maschinen nur Zugriff auf die Komponenten, die sie zur Ausf√ºhrung ben√∂tigen. (vgl. ebd., S. 7);0
"3.2 The Things Indoor Gateway
Die Unterkapitel, die im Anschluss folgen, geben einen Einblick in den Aufbau, die
KonÔ¨Åguration und die Aufnahme des ‚ÄûThe Things Indoor Gateways‚Äú.
3.2.1 Aufbau
Das‚ÄûTheThingsIndoorGateways‚Äú-kurzTTIG-isteinkomplettvollst√§ndigesLoRaWAN-
Gateway von The Things Industries, welches Out-of-the-Box betrieben werden kann. Der
Fokus bei der Entwicklung des Gateways lag darauf die Kosten und die Komplexit√§t gering
zu halten, um LoRa auch in privaten Haushalten verf√ºgbar und interessant zu machen. Das
Gateway kann entweder durch einen mitgelieferten Wandstecker oder durch eine USB-C
Schnittstelle mit Strom versorgt werden. Die USB-C Schnittstelle muss dabei mit 900
mAversorgt werden, wodurch das Gateway auch ohne Steckdose betrieben werden kann.
Die ben√∂tigte Internetverbindung f√ºr das Gateway muss durch eine WiFi-Verbindung
hergestellt werden, √ºber welche das Ger√§t auch eingerichtet wird. Die Funkwellen von LoRa
werden dabei von einer intern eingebauten Rundstrahlantenne empfangen und versendet.
Das Gateway zeichnet sich dadurch aus, dass es mit dem Semtech SX1308 Chipsatz
insgesamt acht verschiedene Kan√§le zur Verf√ºgung stellt und es innerhalb k√ºrzester
Zeit mit dem TTN verbunden werden kann.  Falls der Bedarf besteht, die
Empfangsleistung des Indoor Gateway zu steigern, kann dieses durch den Anbau eines
externen Antennenanschlusses realisiert werden. Dies ist jedoch nicht in der eigentlichen
Architektur und Verwendung des Gateways vorgesehen und kann eher als ‚ÄûHack‚Äú oder
Experiment gesehen werden.";0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Things NetworkEine Implementierung eigener L√∂sungen     In der heutigen Zeit, in der die Herausforderungen des Klimawandels und der Ressourcenknappheit immer dr√§ngender werden, spielt die pr√§zise √úberwachung von Umweltfaktoren, insbesondere der Bodenfeuchtigkeit, eine entscheidende Rolle in der Landwirtschaft und √ñkologie. Eine effektive Methode zur √úberwachung dieser Parameter ist die Verwendung von Low Power Wide Area Networks (LPWAN), insbesondere LoRaWAN (Long Range Wide Area Network). Dieses Netzwerk erm√∂glicht die √úbertragung von kleinen Datenmengen √ºber gro√üe Distanzen mit geringem Energieverbrauch. In Kombination mit Plattformen wie The Things Network (TTN) k√∂nnen IoT-basierte L√∂sungen entwickelt werden, um die Bodenfeuchtigkeit kosteng√ºnstig und einfach zu √ºberwachen. Ziel dieses Beitrags ist es, den Prozess der Implementierung einer eigenen Tracking-L√∂sung f√ºr Bodenfeuchtigkeit unter Verwendung von LoRaWAN und TTN zu beleuchten.   Technologischer Hintergrund  LoRaWAN ist ein Netzwerkprotokoll, das auf der LoRa-Technologie basiert und insbesondere f√ºr IoT-Anwendungen konzipiert wurde. Die Kernmerkmale umfassen gro√üe Reichweite, geringen Energieverbrauch und die F√§higkeit, eine Vielzahl von Sensoren in einer einzigen Netzwerkinfrastruktur zu integrieren. Im Unterschied zu herk√∂mmlichen Kommunikationstechnologien erm√∂glicht LoRaWAN eine drahtlose Kommunikation √ºber Entfernungen von bis zu 15-20 km in l√§ndlichen Gebieten.  The Things Network ist eine offene, dezentralisierte Plattform, die LoRaWAN-Netzwerke bereitstellt und die Nutzbarkeit von IoT-Anwendungen erleichtert. TTN stellt eine benutzerfreundliche Schnittstelle f√ºr die Registrierung, Verwaltung und den Datenfluss von Ger√§ten zur Verf√ºgung, was es ideal f√ºr die Entwicklung von Prototypen und Anwendungen macht.   Implementierung der Bodenfeuchtigkeits√ºberwachung  1. Auswahl der Hardware  F√ºr unser Projekt ben√∂tigen wir geeignete Sensoren sowie ein LoRaWAN-f√§higes Mikrocontroller-Board. Der Soil Moisture Sensor, z.B. der capacitive Soil Moisture Sensor, kann pr√§zise Feuchtigkeitswerte liefern. Als Mikrocontroller bieten sich Boards wie das ESP32 oder der Arduino MKR WAN 1300 an, die bereits mit einem LoRaWAN-Modul ausgestattet sind. Diese Komponenten sind kosteng√ºnstig und leicht erh√§ltlich.  2. Konfiguration der Sensorik  Die Montage des Sensors erfolgt im Wurzelbereich der Pflanzen, um die Bodenfeuchte pr√§zise zu messen. Der Sensor wird mit dem Mikrocontroller verbunden, wobei eine geeignete Bibliothek verwendet wird, um die Messwerte auslesen und verarbeiten zu k√∂nnen. Es ist wichtig, dass der Sensor entsprechend kalibriert wird, um exakte Werte zu garantieren.  3. Implementierung der LoRaWAN-Konnektivit√§t  Um die LoRaWAN-Konnektivit√§t zu implementieren, muss der Mikrocontroller in das LoRaWAN-Netzwerk eingebunden werden. Dies geschieht durch das Erstellen eines Kontos bei TTN und das Einrichten eines neuen Ger√§ts auf der Plattform. Die eindeutige Device ID und App Key, die von TTN bereitgestellt werden, werden im Code des Mikrocontrollers implementiert, um eine sichere Verbindung herzustellen.  4. Daten√ºbertragung und -visualisierung  Nach erfolgreicher Verbindung k√∂nnen Daten in festen Intervallen √ºbertragen werden. Der Mikrocontroller sendet die Bodenfeuchtigkeitswerte an das TTN-Netzwerk. Dort werden die Daten in ein verst√§ndliches Format umgewandelt und sind √ºber die TTN-Konsole abrufbar. Um die Informationen visuell darzustellen, kann ein Dashboard wie Grafana oder eine benutzerdefinierte Webanwendung verwendet werden. Hierbei sollten Charts und Alarme implementiert werden, um einen sofortigen √úberblick √ºber den Zustand des Bodens zu erhalten.  5. Analyse und Optimierung  Nach der Implementierung ist die Analyse der gesammelten Daten entscheidend. Anhand der Bodenfeuchtigkeit k√∂nnen Bew√§sserungsstrategien optimiert werden. Mit Hilfe von Machine Learning-Algorithmen l√§sst sich beispielsweise vorhersagen, wann die optimale Bew√§sserungszeit f√ºr bestimmte Pflanzenarten sein k√∂nnte. Ferner sollten eventuell notwendige Anpassungen an der Hardware und Software evaluiert werden, um die Messgenauigkeit und Effizienz des Systems zu verbessern.   Fazit  Die Implementierung eines eigenen Systems zur √úberwachung der Bodenfeuchtigkeit mittels LoRaWAN und The Things Network bietet eine vielversprechende L√∂sung f√ºr die Herausforderungen im Bereich der Landwirtschaft und Umwelt√ºberwachung. Die Kombination aus kosteng√ºnstiger Hardware und leistungsf√§higen Netzwerktechnologien erm√∂glicht in Kombination mit benutzerfreundlichen Plattformen eine einfache und effektive √úberwachung von Umweltdaten. Die erfolgreiche Umsetzung solcher Projekte k√∂nnte nicht nur zu einer besseren Ressourcennutzung f√ºhren, sondern auch zum Schutz und Erhalt von √ñkosystemen beitragen. Zuk√ºnftige Entwicklungen in der Sensortechnologie und Netzwerkarchitektur werden diese Ans√§tze weiter vorantreiben und vereinfachen.;1
Grunds√§tzlich l√§sst sich das Aussehen einer mit TYPO3 erstellten Website mittels Templa- tes ver√§ndern. Jene sind in der Regel kostenpflichtig, da mit der Erstellung eines Themes ein gro√üer zeitlicher Aufwand einhergeht. Bedingt durch die Trennung von reinem Inhalt (Text) und dessen Darstellung mittels der TYPO3-eigenen Skriptsprache TypoScript m√ºs- sen Entwickler von TYPO3-Themes viel Aufwand in die Programmierung der Vorlagen investieren, welchen sie sich entgeltlich bezahlen lassen. Dennoch k√∂nnen einige wenige, kostenfreie Themes vorgefunden werden.  Die Installation dieser erfolgt per Upload des ZIP-Archives und kann anschlie√üend im TYPO3-Admin-Backend aktiviert werden. Spezifische √Ñnderungen an den Darstellungen der Inhalte k√∂nnen jedoch nur innerhalb der TypoScript-Skripte vorgenommen werden, was wiederum Programmierkenntnisse seitens der Anwender bedingt. Hier wird die ‚ÄûEnterprise‚Äú-Ausrichtung des CMSdeutlich. Es zielt auf professionelle, gro√üe Websiteprojekte ab, bei denen Design- und Web-Agenturen in der Implementierung und Umsetzung der Projekte involviert sind. In Bezug auf kleinere Webprojekte, welche kaum oder kein Budget vorweisen k√∂nnen, eignet sich TYPO3 nur dann, wenn Templates vollkommen √ºbernommen werden ohne diese abzu√§ndern. Aufgrund dieser Tatsache und der erschwerten Anpassung von Design-Stilen wird das CMSin Bezug auf den Anwendungsfall der Holzbau Mustermann mit der Kategorie Rot eingestuft.;0
Jing-Ming Guo et al. haben einen Vergleich mehrerer leichtgewichtiger CNN-Modelle f√ºr die Erkennung von Objekten durchgef√ºhrt.  In Abbildung 4.2 ist ein Vergleich der durchschnittlichen Vorhersagegenauigkeit (AP) in Bezug auf die Bildverarbeitungsge- schwindigkeit (FPS) zu sehen. Die Modelle EfficientDet, YOLOv4 undYOLOv3 schneiden mit einer besonders hohen Genauigkeit und akzeptablen Bildverarbeitungsgeschwindigkeit gut ab. Aus diesem Grund werden im weiteren Verlauf der Arbeit EfficientDet- und You Only Look Once (YOLO)-Modelle verglichen. Zus√§tzlich werden noch Single Shot Detector (SSD)-Modelle verglichen, da bei einem Vergleich der Leistung und Genauigkeit der Modelle Faster R-CNN, SSDund YOLOv3 ergab, dass SSDundYOLOdie beste Gesamtleistung erzielt haben.  F√ºr die Evaluierung werden schlie√ülich die vortrainierten Modelle aus Tabelle 4.1 ausge- w√§hlt. Diese sind alle jeweils die leichtgewichtete Version des Originals. Erkennbar an z. B. dem Zusatz ‚ÄûLite‚Äú oder ‚ÄûTiny‚Äú. Dabei werden unterschiedliche Versionen der einzelnen Architekturen verwendet, die komplexer und somit rechenintensiver sind, oder manche die weniger komplex sind, daf√ºr etwas ungenauer. Beispielsweise steigt bei den EfficientDet Modellen die Komplexit√§t mit der Modell-Zahl. So ist EfficientDet Lite3 komplexer als EfficientDet Lite2.  Genauso sind die anderen Modelle unterschiedliche Varianten, jedoch steht bei denen die Zahl f√ºr die Version und nicht f√ºr die Komplexit√§t. Beispielsweise ist YOLOv3 die √ºberarbeitete Version von YOLOv2.;0
F√ºr das Angular-Frontend wurde zun√§chst ein Designkonzept erstellt, welches Drag and Drop verwenden sollte. Die einzelnen Elemente f√ºr die Funktionen sollten auf einer Fl√§che per Drag and Drop nach Belieben angeordnet k√∂nnen sollen, um den Zeitpunkt bestimmen zu k√∂nnen, zu welchem die Funktion ausgef√ºhrt wird. Nach einer Recherche f√ºr Tools und Frameworks die dies unterst√ºtzen wurde die Drag and Drop Idee wieder verworfen. Anschlie√üend wurde ein neues Designkonzept f√ºr das Angular-Frontend erstellt, welches wie folgt aussieht. Abbildung 3.9: Designkonzept f√ºr die Projekt√ºbersicht In der Projekt√ºbersicht sieht der Nutzer alle bereits erstellten Projekte. In Abbildung 3.9 existiert momentan ein Projekt namens ‚ÄûProjekt 1‚Äú. Wenn der Nutzer auf den Button f√ºr das Projekt klick kommt er auf die Projektansicht, in welche der Nutzer das Projekt bearbeiten kann. Rechts neben ‚ÄûProjekt 1‚Äú ist ein kleinerer grauer Button mit einem Plus in der Mitte. Mit diesem Button kann der Nutzer ein neues Projekt erstellen. Dazu √∂Ô¨Änet sich ein Popup in dem der Nutzer zun√§chst nur den Namen f√ºr das neue Projekt eingeben muss. Das Design f√ºr die Namenseingabe ist simpel gehalten und in Abbildung 3.10 zu sehen. Im Popup hat der Nutzer noch die M√∂glichkeit auf ‚ÄûCancel‚Äú und somit die Projekterstellung abzubrechen. Rechts oben in der Ecke ist immer der Button f√ºr die Soundbibliothek. Dort k√∂nnen Audiodateien hinzuf√ºgt und wieder gel√∂scht werden. In der Soundbibliothek gibt es 4 Buttons und eine Liste, wie in Abbildung 3.11 zu sehen. Mit dem ersten Button ‚Äûchoose File‚Äú kann eine lokale Datei ausgew√§hlt werden. Mit dem Button ‚Äûupload‚Äú wird die ausgew√§hlte Datei auf den SFTP-Server hochgeladen. In der Liste, unter den zwei Buttons, sind alle Dateien zu sehen, welche bereits hochgeladen wurden. Dort kann eine Datei, per Mausklick auf den Namen, ausgew√§hlt werden. Mit einem Klick dem ‚Äûdelete sound‚Äú wird die ausgew√§hlte Datei vom SFTP-Server gel√∂scht und verschwindetsomitauchausderListe.DerletzteButtonaufderSoundbibliotheksoberÔ¨Ç√§che ist der ‚ÄûCancel‚Äú-Button. Mit diesem kommt der Nutzer wieder auf die Seite mit der Projekt√ºbersicht.;0
5 Erweiterungsm√∂glichkeiten und Retrospektive Im Laufe dieser Arbeit wurden bereits einige Erweiterungsm√∂glichkeiten evaluiert, wie beispielsweise die Verwendung von AOAAntennen zur genaueren und schnelleren Bestim- mung von Positionen in Kapitel 4.5. W√§hrend der Entwicklung sind allerdings noch weitere Konzepte entstanden, welche im Folgenden beschrieben sind. 5.1 Erweiterung mit Sensorik eines Fitnessarmbands zur Sturzerkennung Eine M√∂glichkeit, welche die Genauigkeit der Sturzerkennung optimieren k√∂nnte, w√§re die Verwendung von Sensordaten des BLEBeacons. Dies k√∂nnte in Form eines g√ºnstigen Fit- nessarmbands umgesetzt werden. Diese enthalten √ºblicherweise Beschleunigungssensoren, um beispielsweise zu erkennen, ob der Tr√§ger sein Handgelenk gedreht hat und auf die Uhr schaut. Die gr√∂√üte Einschr√§nkung w√§re, dass die Daten mittels BLE√ºber die Locator oder mittels WLAN direkt an den Server √ºbertragen werden m√ºssten, um sie in der Auswertung zu verwenden. Daf√ºr m√ºsste das Armband mit eigener Firmware versehen werden, was bei vielen Modellen sehr aufw√§ndig oder kaum m√∂glich ist. Ist ein preiswertes Modell, welches diese H√ºrde nicht mitbringt, gefunden, k√∂nnen ebenfalls zus√§tzliche Informationen √ºber den Tr√§ger f√ºr die Auswertungen verwendet werden. So k√∂nnte beim Fallen der Beschleunigungssensor ein Indiz auf einen Sturz mitliefern und somit die Sturzerkennung verbessern und beschleunigen. Ein weiteres Beispiel w√§re die Analyse des Pulses, welcher zum einen zus√§tzliche Informationen bei einem Sturz liefert, wodurch sich die Einsatzkr√§fte vor Eintreffen bereits vorbereiten k√∂nnen. Zum anderen kann auch die Analyse im Alltag gegebenenfalls Hinweise auf medizinische Probleme liefern. So kann beispielsweise eine unregelm√§√üige Herzfrequenz auf Vorhofflimmern hindeuten, welches in manchen F√§llen keine merkbaren Symptome erzeugt und daher unbemerkt bleibt . Allerdings wurde dieses Konzept im Rahmen dieser Studienarbeit aus mehreren Gr√ºnden nicht weiter verfolgt.;0
"Anschlie√üend k√∂nnen die AppEUI, die DevEUI, und der AppKey aus der in Abbildung 4.12
gezeigten Ansicht in den Sketch kopiert werden. Die in Abbildung 4.13 gezeigten Codezeilen
beÔ¨Ånden sich relativ weit oben im Sketch. Die AppEUI kann direkt von der TTNConsole
in den Sketch kopiert werden. Bei der DevEUI muss in der TTNConsole vor dem Kopieren
die Ansicht auf LSBumgestellt werden (siehe Abbildung 4.12). Die DevEUI muss n√§mlich
im Sketch - wie es der Kommentar in den Zeilen 1-4 in Abbildung 4.13 verlangt - im Little
Endian Format angegeben werden. Um zu pr√ºfen, ob die DevEUI im Sketch richtigen
Format vorliegt, k√∂nnen die drei letzten Bytes der DevEUI betrachtet werden. Diese sollten
bei dem TTNzugeh√∂rigen DevEUIs 0xD5, 0xB3, 0x70 lauten. Der AppKey muss im
Big Endian Format in den Sketch eingef√ºgt werden und kann daher ohne weitere Umwege
direkt von der TTNConsole in den Sketch hineinkopiert werden.
Abbildung 4.13: Endger√§t √úbersicht des Feather M0 Boards mit RFM95 Modul im TTN";0
Bei Naturkatastrophen und an Orten mit einem sehr hohen Gefahrenpotenzial kommt es immer wieder vor, dass Menschen ihr Leben riskieren, um mit Hilfe von Fahrzeugen (wie zum Beispiel Bagger und M√§her) Arbeiten auszuf√ºhren, um Menschenleben zu retten, Instandhaltungsarbeiten durchzuf√ºhren oder Katastrophen zu verhindern, wie zum Beispiel im Ahrtal im Juni 2021. Zur Reduktion des Risikos f√ºr die involvierten Personen besteht die M√∂glichkeit, solche Fahrzeuge aus sicherer Entfernung mit einer Fernsteuerung zu bedienen. Um dem Fahrzeugf√ºhrer dabei zu assistieren und Kollisionssch√§den zu vermeiden, sind dabei Fahrerassistenzsysteme, wie zum Beispiel Kollisionsassistenten oder Notbremsassistenten, hilfreich. 1.2 Zielsetzung Das Ziel dieser Studienarbeit ist es, eine Fahrzeugfernsteuerung zu entwickeln und an einem Prototypen zu demonstrieren, um das Risiko f√ºr maschinelle Arbeiten an Orten mit einem hohen Gefahrenpotenzial zu reduzieren. Die Fahrzeugssteuerung soll dabei zun√§chst die Richtungs- und Geschwindigkeitssteuerung umfassen. Damit Sch√§den an Fahrzeug und Umwelt vermieden werden und um die Sicherheit zu erh√∂hen, soll die Fahrzeugsteuerung um ein System zur Kollisionsvermeidung und Notausschalter erg√§nzt werden. Bei der Durchf√ºhrung einer Kollisionsvermeidung soll dabei ein Feedback auf der Fernsteuerung dargestellt werden. Aufgrund der immer st√§rkeren Verbreitung des 802.15.4-Standards (z.B. durch das darauf aufbauende ZigBee-Protokoll mit 500 Millionen verkauften Chipsets ) und dessen Low-Cost und Low-Power Eigenschaften soll dieser zur Kommunikation zwischen Fahrzeugsteuerung und Fernsteuerung verwendet werden. Zur Eignungseinsch√§tzung sollen die Reaktionszeiten und Verz√∂gerungen zwischen Fernsteuerung und Fahrzeugsteuerung gemessen und im Kontext von ferngesteuerten Fahrzeugen evaluiert werden. Der Fokus liegt dabei auf der Umsetzung eines Prototypen und nicht im produktiven Einsatz.;0
" Eine Implementierung eigener L√∂sungen     Die App-Entwicklung hat sich in den letzten Jahren exponentiell weiterentwickelt und erfordert nicht nur technisches Know-how, sondern auch innovative Ans√§tze zur Bereitstellung benutzerfreundlicher und ansprechender Anwendungen. Jetpack Compose, Googles modernes Toolkit f√ºr die UI-Entwicklung in Android, stellt einen Paradigmenwechsel in der Art und Weise dar, wie Benutzeroberfl√§chen entworfen und implementiert werden. Diese Er√∂rterung beleuchtet die  unter Verwendung von Jetpack Compose, wobei das Augenmerk auf den Vorteilen, der Architektur und der praktischen Anwendungsentwicklung liegt.   Grundlagen von Jetpack Compose  Jetpack Compose basiert auf einem deklarativen Ansatz zur UI-Entwicklung, der es Entwicklern erm√∂glicht, Benutzeroberfl√§chen in einer klaren, intuitiven und wartungsfreundlichen Weise zu gestalten. Anstelle der traditionellen imperativen Programmierweise, bei der die UI durch das Manipulieren von Views in einer hierarchischen Struktur entwickelt wird, konzentriert sich Jetpack Compose auf die Beschreibung der UI-Erscheinung in Abh√§ngigkeit vom aktuellen Status der Daten. Dies f√ºhrt zu weniger Boilerplate-Code, besserer Lesbarkeit und einer einfacheren Handhabung von UI-Zust√§nden.   Architektur und State Management  Ein zentraler Aspekt bei der Implementierung von Anwendungen mit Jetpack Compose ist die Handhabung von Zust√§nden. Die Architektur, die h√§ufig in Verbindung mit Jetpack Compose verwendet wird, ist die Model-View-ViewModel (MVVM)-Architektur. Hierbei fungiert das ViewModel als Vermittler zwischen der Benutzeroberfl√§che (View) und den Daten (Model). Diese Trennung erm√∂glicht eine saubere, testbare Implementierung.  In einer typischen Anwendung k√∂nnte das ViewModel nicht nur UI-Zust√§nde verwalten, sondern auch asynchrone Operationen durchf√ºhren, um Daten von einem API-Endpunkt zu laden. In diesem Zusammenhang kommt die Kotlin-Coroutine-Bibliothek zum Einsatz, um asynchrone Programmierung einfach und effizient zu gestalten.     Um die Vorteile von Jetpack Compose in der Praxis zu demonstrieren, betrachten wir das Szenario einer To-Do-Liste-App. Diese Anwendung wird grundlegende Funktionen wie das Hinzuf√ºgen, Entfernen und Markieren von Aufgaben beinhalten.  1. Initialisierung des Projekts  Zun√§chst wird ein neues Android-Projekt in Android Studio erstellt. Die entsprechenden Jetpack Compose-Abh√§ngigkeiten werden in der `build.gradle`-Datei hinzugef√ºgt ```groovy dependencies {     implementation ""androidx.compose.ui:ui:1.0.0""     implementation ""androidx.activity:activity-compose:1.0.0"" } ```  2. Erstellung des ViewModels  Ein einfaches `ToDoViewModel` wird erstellt, das eine MutableState-Liste zur Verwaltung der Aufgaben enth√§lt ```kotlin class ToDoViewModel ViewModel() {     var tasks = mutableStateListOf<String>()      fun addTask(taskString) {         tasks.add(task)     }      fun removeTask(indexInt) {         tasks.removeAt(index)     } } ```  3. Benutzeroberfl√§che mit Jetpack Compose  Die UI wird nun in einer Kotlin-Datei unter Verwendung von Jetpack Compose erstellt. Die Hauptfunktion sieht folgenderma√üen aus ```kotlin @Composable fun ToDoApp(viewModelToDoViewModel = viewModel()) {     Column {         var task by remember { mutableStateOf("""") }          TextField(             value = task,             onValueChange = { task = it },             label = { Text(""Neue Aufgabe"") }         )         Button(onClick = {             if (task.isNotBlank()) {                 viewModel.addTask(task)                 task = """"             }         }) {             Text(""Hinzuf√ºgen"")         }          LazyColumn {             items(viewModel.tasks.size) { index ->                 Row {                     Text(viewModel.tasks[index])                     Button(onClick = { viewModel.removeTask(index) }) {                         Text(""Entfernen"")                     }                 }             }         }     } } ```   Fazit  Die Implementierung einer Anwendung mit Jetpack Compose bietet eine effiziente und moderne M√∂glichkeit zur Entwicklung von Benutzeroberfl√§chen in Android. Durch die Verwendung der deklarativen Programmierung und der MVVM-Architektur wird nicht nur die Lesbarkeit und Wartbarkeit des Codes verbessert, sondern auch die Reaktivit√§t der Benutzeroberfl√§che erh√∂ht. Jetpack Compose f√∂rdert ein agiles Blending von Design und Funktionalit√§t und erm√∂glicht es Entwicklern, ihre L√∂sungen auf innovative Weise zu gestalten und anzupassen. In Zeiten, in denen Benutzererfahrungen zunehmend im Mittelpunkt stehen, stellt Jetpack Compose somit ein unverzichtbares Werkzeug f√ºr die Zukunft der App-Entwicklung dar.";1
State of the Art beim Testen von MQTT-basierten L√∂sungenEin Ausblick auf m√∂gliche Weiterentwicklungen  Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eine der f√ºhrenden Kommunikationsmethoden im Internet der Dinge (IoT) etabliert. Es erm√∂glicht eine effiziente, leichtgewichtige Kommunikation zwischen Ger√§ten und ist besonders f√ºr Umgebungen mit eingeschr√§nkten Ressourcen und Bandbreiten geeignet. Die Testmethoden f√ºr MQTT-basierte L√∂sungen haben sich in den letzten Jahren erheblich weiterentwickelt, um den steigenden Anforderungen an Zuverl√§ssigkeit, Sicherheit und Interoperabilit√§t gerecht zu werden. In diesem Text wird der aktuelle Stand der Testmethoden f√ºr MQTT-L√∂sungen skizziert und ein Ausblick auf m√∂gliche Weiterentwicklungen gegeben.  Aktueller Stand der Testmethoden  Die Testmethoden f√ºr MQTT-basierte Systeme lassen sich in mehrere Kategorien unterteilen, darunter Funktionstests, Leistungstests, Sicherheitstests und Interoperabilit√§tstests.   1. FunktionstestsDiese Tests konzentrieren sich darauf, sicherzustellen, dass alle definierten Funktionen des MQTT-Protokolls ordnungsgem√§√ü implementiert sind. Tools wie MQTT.fx und Mosquitto bieten einfache M√∂glichkeiten, Publish- und Subscribe-Operationen zu testen und die korrekte Nachrichten√ºbermittlung zu verifizieren.   2. LeistungstestsDa MQTT h√§ufig in Umgebungen eingesetzt wird, in denen eine hohe Anzahl von Nachrichten in kurzer Zeit verarbeitet werden muss, sind Leistungstests von zentraler Bedeutung. Tools wie JMeter und Gatling erm√∂glichen es, die Skalierbarkeit und die Reaktionszeiten von MQTT-basierten Anwendungen zu bewerten.   3. SicherheitstestsAngesichts der zunehmenden Bedrohungen im IoT-Bereich ist die Sicherheit von MQTT-L√∂sungen von gr√∂√üter Bedeutung. Tests zur Identifizierung von Schwachstellen, wie z.B. durch Penetrationstests oder die Verwendung von Sicherheitsframeworks wie OWASP IoT Top Ten, sind unerl√§sslich, um potenzielle Angriffe zu erkennen und abzuwehren.  4. Interoperabilit√§tstestsDa MQTT in einer Vielzahl von Anwendungen und Ger√§ten eingesetzt wird, ist die √úberpr√ºfung der Interoperabilit√§t zwischen verschiedenen Implementierungen und Plattformen wichtig. Hierbei kommen standardisierte Testverfahren und -tools zum Einsatz, um sicherzustellen, dass unterschiedliche MQTT-Clients und -Server nahtlos miteinander kommunizieren k√∂nnen.  Ausblick auf m√∂gliche Weiterentwicklungen  Die Zukunft des Testens von MQTT-basierten L√∂sungen k√∂nnte durch mehrere Trends und Technologien gepr√§gt sein 1. Automatisierung von TestsDie Implementierung von Continuous Integration (CI) und Continuous Deployment (CD) in der Softwareentwicklung wird zunehmend auch f√ºr MQTT-basierte L√∂sungen relevant. Automatisierte Testframeworks, die in CI/CD-Pipelines integriert sind, k√∂nnten dazu beitragen, die Effizienz und Zuverl√§ssigkeit der Tests zu erh√∂hen. Hierbei k√∂nnten KI-gest√ºtzte Ans√§tze zur Identifizierung von Anomalien und zur Optimierung von Teststrategien eine Rolle spielen.  2. Erweiterte SicherheitsprotokolleMit der fortschreitenden Digitalisierung und der Zunahme vernetzter Ger√§te wird die Notwendigkeit, robuste Sicherheitsma√ünahmen zu;1
State of the Art beim Testen von MQTT-basierten L√∂sungenEin Fazit  In den letzten Jahren hat sich das Message Queuing Telemetry Transport (MQTT) Protokoll als eine der f√ºhrenden Technologien f√ºr die Kommunikation im Internet der Dinge (IoT) etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz eignet sich MQTT besonders gut f√ºr Umgebungen mit begrenzten Ressourcen, wie etwa IoT-Ger√§te. Die steigende Verbreitung von MQTT-basierten L√∂sungen hat jedoch auch die Notwendigkeit verst√§rkt, robuste Testmethoden zu entwickeln, um die Zuverl√§ssigkeit und Sicherheit dieser Systeme zu gew√§hrleisten. In diesem Kontext stellt sich die Frage, wie der aktuelle Stand der Testverfahren f√ºr MQTT-Anwendungen aussieht und welche Erkenntnisse aus diesen Tests gewonnen werden k√∂nnen.  Die Testmethoden f√ºr MQTT-basierten L√∂sungen sind vielf√§ltig und reichen von Unit-Tests √ºber Integrationstests bis hin zu Lasttests. Unit-Tests fokussieren sich auf die √úberpr√ºfung einzelner Komponenten, w√§hrend Integrationstests das Zusammenspiel zwischen verschiedenen Systemteilen evaluieren. Lasttests sind besonders wichtig, um die Leistungsf√§higkeit des Systems unter realistischen Bedingungen zu pr√ºfen, da MQTT oft in Szenarien mit hoher Nachrichtenfrequenz eingesetzt wird. Tools wie JMeter und Gatling bieten dabei n√ºtzliche Funktionen zur Simulation von Lasttests in MQTT-Umgebungen.  Ein zentraler Aspekt beim Testen von MQTT-Anwendungen ist die Sicherstellung der Datenintegrit√§t und -sicherheit. Hierbei kommen verschiedene Ans√§tze zum Einsatz, wie die Implementierung von Authentifizierungsmechanismen und die Nutzung von Transport Layer Security (TLS). Die √úberpr√ºfung dieser Sicherheitsma√ünahmen erfordert spezifische Teststrategien, die nicht nur die Funktionalit√§t, sondern auch die Robustheit der Implementierungen ber√ºcksichtigen.  Die Analyse der aktuellen Testpraktiken zeigt, dass viele Entwickler und Unternehmen noch in den Kinderschuhen stecken, wenn es um die Implementierung umfassender Teststrategien f√ºr MQTT-basierte L√∂sungen geht. Oftmals werden Tests als nachgelagerter Prozess betrachtet, was zu unzureichenden Ergebnissen f√ºhren kann. Um die Qualit√§t und Sicherheit von MQTT-Anwendungen zu gew√§hrleisten, ist es unerl√§sslich, Testverfahren fr√ºhzeitig in den Entwicklungszyklus zu integrieren und automatisierte Tests zu implementieren.  Fazit  Das Testen von MQTT-basierten L√∂sungen befindet sich in einem dynamischen Entwicklungsprozess, der sowohl Herausforderungen als auch Chancen mit sich bringt. Die Integration von umfassenden Teststrategien, die sowohl Funktionalit√§t als auch Sicherheit abdecken, ist entscheidend f√ºr den Erfolg von IoT-Anwendungen. Die Erkenntnisse aus aktuellen Testprojekten verdeutlichen, dass eine fr√ºhzeitige und systematische Testansatz nicht nur die Qualit√§t der Anwendungen erh√∂ht, sondern auch dazu beitr√§gt, potenzielle Sicherheitsrisiken zu identifizieren und zu mitigieren. Um den Anforderungen einer zunehmend vernetzten Welt gerecht zu werden, ist es daher unerl√§sslich, dass Unternehmen und Entwickler in die Weiterbildung und Implementierung fortschrittlicher Testmethoden investieren. Nur so kann das volle Potenzial von MQTT-basierten L√∂sungen ausgesch√∂pft werden, ohne Kompromisse bei der Sicherheit und Zuverl√§ssigkeit einzugehen.;1
Beim Designkonzept f√ºr die Pepper-Applikation wird veranschaulicht, was die Pepper- Applikation anzeigt, wenn ein Projekt ge√∂Ô¨Änet wird. Abbildung 3.23: Designkonzept f√ºr die Projekt√ºbersicht in der Pepper Applikation Die Startseite der Applikation ist eine √úbersicht der Projekte, die auf dem SFTP-Server gespeichert sind. Wird ein Projekt angeklickt wird die dazugeh√∂rige Json-Datei geladen und die Projektansicht wie in Abbildung 3.24 zu sehen Angezeigt. Mit einem Button oben links in der Ecke, der in Abbildung 3.23 zu sehen ist, k√∂nnen die Projekt neu geladen werden. Dazu wird eine neue Anfrage f√ºr die Projektnamen an den SFTP-Server gesendet. Sind mehr Projekt vorhanden als auf einer Seite angezeigt werden k√∂nnen wird die Liste scollbar. Auf der Projektansicht sind die deÔ¨Ånierten Buttons zu sehen. Pro Seite k√∂nnen maximal acht Buttons in einem Raster angezeigt werden. Wurden im Projekt mehr als acht Buttons hinzugef√ºgt werden die Buttons auf mehrere Seiten verteilt. Per Klick auf einen Button werden die dort hinterlegten Funktionen ausgef√ºhrt.;0
Beim Popup f√ºr die Audiofunktion kann der Nutzer lediglich √ºber ein Dropdown Men√º ausw√§hlen welcher Sound aus der Soundbibliothek abgespielt wird. Zus√§tzlich gibt es, wie in Abbildung 3.15 zu sehen, im Dropdown Men√º die M√∂glichkeit eine Datei als Sound hochzuladen. √Ñhnlich wie beim Popup f√ºr eine Sound Funktion kann Popup f√ºr eine Animations Funk- tion eine Animation aus den vorgegebenen Animationen ausgew√§hlt werden. Der Nutzer hat jedoch nicht die M√∂glichkeit eine eigene Animation hochzuladen. Bei der Slidefunktion hat der Nutzer die M√∂glichkeit eine Bilddatei auszuw√§hlen und anschlie√üend mit der ‚ÄûSelect‚Äú-Taste hochzuladen. Dieses Bild wird dann als Slide verwendet. Zus√§tzlich kann der Nutzer noch angeben wie lange die Folie angezeigt werden soll. Dazu kann er die Zeit in Sekunden angeben. Bei einer Eingabe von null Sekunden wird die Slide solange angezeigt bis an der Pepper-Applikation auf weiter geklickt wird. Abbildung 3.18: Designkonzept f√ºr die Website Funktion Bei der Sayfunktion kann die Website, die auf dem Tablet von Pepper ge√∂Ô¨Änet werden soll, vom Nutzer eingestellt werden.;0
Anhand der gesammelten Messdaten sollen im n√§chsten Schritt Aussagen √ºber die Softwarequalit√§t  der Projekte getroffen werden. Die Analyse wird in zwei Bereiche unterteilt, in denen die Daten der  beiden betrachteten Projekte getrennt ausgewertet werden. Anhand des einfacher aufgebauten  und  weniger umfangreichen  C++-Projekts soll der Erkenntnisgewinn durch Basismetriken dargestellt  werden. Hierbei werden verschiedene Gr√∂√üen innerhalb des Projekts sowie die berechnete  Komplexit√§t einbezogen.  Bei diesem Softwareprojekt sind keine  Probleme hinsichtlich Kopplung und  Abh√§ngigkeiten zwischen den Klassen  zu erwarten, da das System aus nur wenige n Komponenten  besteht. Aus diesem Grund wird die Analyse von Beziehungen mithilfe der dazu ausgew√§hlten  Metriken anhand des deutlich komplexeren und umfangreicheren Java -Projekts  durchgef√ºhrt.   Bei der Interpretation der Messdaten werden einerseits die im vorigen Abschnitt erl√§uterten  Grenzwerte herangezogen, andererseits ein Vergleich zwischen den einzelnen Klassen des Projekts  angestellt.   C++ Implementierung des Bubblesort -Algorithmus  Bei der Betrachtung der Messdaten des Tools CCCC f√§llt bereits in der √úbersi cht der Basiswerte auf,  dass beim Anteil an Kommentaren die Warnstufe erreicht wurde. Betroffen sind mit CFahrzeug und  CFileReader zwei der Hauptklassen innerhalb des Klassenverbundes . Eine √úbersicht der Werte kann  im Anhang A.15  CCCC : Projekt√ºbersicht BubbleSort  eingesehen werden . Diese Beobacht ung wird  auch durch die kommerzielle Software  QA-MISRA best√§tigt. Der Fokus dieses Tools liegt neben der  Kommentardichte auf verschiedenen Gr√∂√üen innerhalb der Klasse. Dazu z√§hlen die minimale und  maximale Anzahl an Statements  sowie deren L√§nge, was Hinweise auf di e Effizienz  und  √úbersichtlichkeit der Klasse erm√∂glicht. Auch die Verschachtelungstiefe wird von QA -MISRA  ber√ºcksichtigt, was einen Aufschluss auf die Komplexit√§t von Funktionen gibt.  Aus Abbildung 20 geht  hervor, dass der gr√∂√üte Anteil an verletzten Richtlinien auf eine unzureichende Anzahl an  Kommentaren f√§llt. Eine weitere H√§ufung besteht bei Funktionen, die aus zu vielen Statements  bestehen und dadurch als zu komplex und folglich schwer verst√§ndlic h markiert werden. Der Fokus  von QA -MISRA liegt grunds√§tzlich auf der Verst√§ndlichkeit und Lesbarkeit des Quellcodes was zu  einer erh√∂hten Wartbarkeit beitr√§gt. Allgemeine Aussagen √ºber die Softwarequalit√§t des  betrachteten Produkts sind jedoch nur sehr be grenzt m√∂glich.;0
Die Umsetzung des Editors erfolgte in mehreren Schritten. Zuerst wurde ein Prototyp erstellt, welcher einfache Inhalte enthielt. Der Prototyp diente zum Einstieg in das Projekt. Er stellte zudem den Testversuch dar, ob alles so umgesetzt werden kann, wie es geplant war. Es konnte in einem Dropdown die gew√ºnschte Funktion ausgew√§hlt werden und je nach Auswahl wurden jeweils weitere Inhalte ge√∂Ô¨Änet. Abbildung 3.34: Prototyp des Editors Schaut man sich beispielsweise die Abbildung 3.34 an, so sieht man im ersten Screenshot das leere Dropdown Men√º zur Auswahl der Funktion. W√§hlt man ‚ÄúSay‚Äù aus, wird ein Text Input Feld angezeigt, in welches man Freitext schreiben kann (vgl. Abbildung 3.34, Bild 2). Mit dem Button Submitwird der Text in die JSON Datei geschrieben. W√§hlt man als Funktion ‚ÄúAnimation‚Äù aus, so wie im dritten Bild sichtbar, so wird ein weiteres Dropdown Men√º angezeigt, welches alle verf√ºgbaren Funktionen enth√§lt. Aus den vorgegebenen Animationen kann dann ausgew√§hlt werden und per Buttonklick an die JSON Datei √ºbermittelt werden. Das Design und die Umsetzung wurden bewusst einfach gehalten, da es zu dem Zeitpunkt nur auf die Funktionalit√§t ankam.;0
"Um die Daten in die InÔ¨ÇuxDB zu speichern, wird das graÔ¨Åsche Entwicklungswerkzeug
Node-RED eingesetzt. Die urspr√ºnglich von IBM entwickelte Open Source Software erlaubt
es den Anwender*innen, im Webbrowser kleinere Funktionsbausteine miteinander zu
verkn√ºpfen, um sog. Flowszu erstellen.  Im Falle der Studienarbeit wird
f√ºr den Export der Messdaten die MQTTIntegration des TTNverwendet. Erh√§lt das
TTNein Datenpaket vom Feather M0 LoRaNode, so published das TTNeine Nachricht
√ºber den TTN-eigenen MQTT Server. Der Trigger des in Abbildung 4.16 gezeigten Flows
subscribed ein entsprechendes MQTTTopic und l√∂st beim Erhalt einer MQTTMessage
den Flow aus. Die vom Feather M0 gesendeten Daten werden direkt √ºber die MQTT
Message an den Node-RED Flow √ºbermittelt und m√ºssen vor dem Speichern lediglich in
ein f√ºr die InÔ¨ÇuxDB passendes Format geparsed werden. Sowohl die InÔ¨ÇuxDB als auch
Node-RED werden im Rahmen der Studienarbeit in Form eines Dockercontainers auf
einem Raspberry Pi betrieben.
Abbildung 4.16: Node-RED Flow zur Speicherung der Messwerte in die InÔ¨ÇuxDB
4.6.3 Darstellung der Daten in Grafana
Die Open Source Software Grafana erlaubt die optische Aufbereitung von Daten aus
verschiedenen Datenquellen (InÔ¨ÇuxDB, Prometheus, MySQL, PostgreSQL, etc.). Grafana
visualisiert diese Daten in Form von interaktiven, dynamischen Dashboards. 
Ebenso wie Node-RED und die InÔ¨ÇuxDB wird auch Grafana im Rahmen der Studienarbeit
in Form eines Dockercontainers auf dem Raspberry Pi bereitgestellt. Nach dem Aufsetzen
des Dockercontainers kann die Grafana Instanz unter dem vergebenem Port aufgerufen
werden und ein Grafana Benutzeraccount angelegt werden. Anschlie√üend wird die InÔ¨ÇuxDB
als Datenquelle hinzugef√ºgt. Wird anschlie√üend ein Dashboard erstellt, so k√∂nnen innerhalb
dieses Dashboards die in der InÔ¨ÇuxDB gespeicherten Daten visualisiert werden (siehe
Abbildung 4.17).
Abbildung 4.17: Visualisierung der Messwerte f√ºr den Zeitraum vom 20.06.2022 bis 03.07.20221
1Diese Messwerte stammen von einem kapazitiven Bodenfeuchtigkeitssensor, nicht vom Sparkfun
Bodenfeuchtigkeitssensor.";0
      Die fortschreitende Entwicklung autonomer Systeme und die zunehmende Vernetzung von Fahrzeugen erfordern innovative Ans√§tze zur Fahrzeugfernsteuerung. Insbesondere die Integration von Kollisionsvermeidungssystemen spielt eine entscheidende Rolle, um die Sicherheit im Stra√üenverkehr zu erh√∂hen. In diesem Kontext wird die vorliegende Arbeit ein Konzept zur Entwicklung einer Fahrzeugfernsteuerung auf Basis des IEEE 802.15 Standards pr√§sentieren, das eine effiziente Kommunikation und Datenverarbeitung zur Kollisionsvermeidung erm√∂glicht.   Grundlagen und Technologien  IEEE 802.15 ist ein Standard f√ºr drahtlose pers√∂nliche Netzwerke (WPANs), der sich durch seine Energieeffizienz und Flexibilit√§t auszeichnet. Die Relevanz dieses Standards f√ºr die Fahrzeugfernsteuerung ergibt sich aus der Notwendigkeit, eine zuverl√§ssige, latenzarme Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug zu gew√§hrleisten. Die verschiedenen Protokolle innerhalb des IEEE 802.15 Standards, wie z.B. IEEE 802.15.4, bieten die Grundlage f√ºr die Implementierung von Sensornetzwerken, die zur Kollisionsvermeidung erforderlich sind.   Konzept zur Umsetzung   1. Systemarchitektur  Das Konzept sieht eine modulare Systemarchitektur vor, die aus mehreren Komponenten besteht - Steuerger√§tDieses Ger√§t, ausgestattet mit einem Mikrocontroller und einer IEEE 802.15 Schnittstelle, dient als zentrale Steuereinheit. Es empf√§ngt Steuerbefehle vom Benutzer und kommuniziert mit den Sensormodulen des Fahrzeugs.    - SensormoduleDiese Module sind mit verschiedenen Sensoren (z.B. Lidar, Ultraschall, Kameras) ausgestattet, die zur Erfassung der Umgebung und zur Erkennung potenzieller Kollisionen dienen. Die Sensordaten werden √ºber das IEEE 802.15 Netzwerk an das Steuerger√§t √ºbertragen.  - KollisionsvermeidungssystemDieses System verarbeitet die eingehenden Sensordaten in Echtzeit, analysiert die Umgebung und trifft Entscheidungen zur Vermeidung von Kollisionen. Hierbei kommen Algorithmen der k√ºnstlichen Intelligenz zum Einsatz, um die Daten zu interpretieren und ad√§quate Reaktionen zu generieren.   2. Kommunikationsprotokoll  Ein entscheidendes Element des Konzepts ist die Entwicklung eines robusten Kommunikationsprotokolls, das auf dem IEEE 802.15 Standard basiert. Dieses Protokoll muss folgende Anforderungen erf√ºllen - EchtzeitkommunikationDie Latenzzeiten m√ºssen minimiert werden, um eine zeitnahe Reaktion auf erkannte Gefahren zu gew√§hrleisten.    - FehlerresistenzDas Protokoll sollte in der Lage sein, St√∂rungen im Kommunikationsnetzwerk zu erkennen und alternative Kommunikationswege zu nutzen.  - EnergieeffizienzUm die Lebensdauer der Batterien in den Sensormodulen zu maximieren, ist eine energieeffiziente Daten√ºbertragung von entscheidender Bedeutung.   3. Algorithmische Implementierung  Die Implementierung der Kollisionsvermeidung erfolgt durch den Einsatz von Algorithmen, die auf maschinellem Lernen basieren. Diese Algorithmen analysieren historische Daten und lernen aus vergangenen Situationen, um;1
 Ein Fazit  Die App-Entwicklung hat in den letzten Jahren einen tiefgreifenden Wandel durchlaufen, insbesondere durch die Einf√ºhrung moderner Frameworks, die die Erstellung von Nutzererlebnissen revolutionieren. Jetpack Compose, Googles deklaratives UI-Toolkit f√ºr Android-Anwendungen, hat sich als eines der vielversprechendsten Werkzeuge herauskristallisiert, um diesem Wandel gerecht zu werden. Dieses Projekt untersucht die Einsatzm√∂glichkeiten und Vorz√ºge von Jetpack Compose in der App-Entwicklung und schlie√üt mit einem zusammenfassenden Fazit.  Jetpack Compose basiert auf einem deklarativen Paradigma, das es Entwicklern erm√∂glicht, Benutzeroberfl√§chen mit weniger Code und in einer intuitiveren Weise zu erstellen, als es bei traditionellen XML-basierten Layouts der Fall ist. Im Verlauf des Projekts wurde deutlich, dass die Verwendung von Composables‚Äîden kleinsten Bausteinen der Benutzeroberfl√§che‚Äîdie Modularit√§t und Wiederverwendbarkeit des Codes signifikant verbessert. Dies war insbesondere bei der Entwicklung komplexer UI-Komponenten von Vorteil, da wiederholende Logik durch einfache Funktionen abstrahiert werden konnte.  Ein weiterer wichtiger Aspekt des Projekts war die Integration von State Management in Jetpack Compose. Die reaktive Programmierweise, die Jetpack Compose verfolgt, erleichtert die Synchronisation zwischen Nutzerinteraktionen und der Benutzeroberfl√§che, wodurch Entwickler in der Lage sind, dynamische und ansprechende Anwendungen zu erstellen. Der Einsatz von `State` und `LiveData` hat gezeigt, dass der Entwicklungsprozess beschleunigt wird, da sich der Fokus auf benutzerzentrierte Technologien verlagert, die gleichzeitig eine hohe Performance bieten.  Ein zentrales Ergebnis des Projekts war die herausragende Interoperabilit√§t von Jetpack Compose mit bestehenden Android-Architekturen und -Bibliotheken, wie beispielsweise Navigation und ViewModel. Diese nahtlose Integration erm√∂glicht es Entwicklern, Jetpack Compose schrittweise in bestehende Projekte einzuf√ºhren, ohne dass eine komplette Neugestaltung der Anwendung erforderlich ist. Dies wurde als entscheidender Vorteil identifiziert, da Unternehmen so schrittweise auf moderne Entwicklungsans√§tze umsteigen k√∂nnen, ohne massive Umstellungskosten zu generieren.  Dennoch wurden im Rahmen des Projekts auch Herausforderungen identifiziert. Die Lernkurve f√ºr Entwickler, die von traditionellen Ans√§tzen umschwenken, kann zu Beginn steil sein. Zudem stellte sich heraus, dass einige komplexe Animationen und Transitionen in Jetpack Compose noch nicht die gleiche Flexibilit√§t wie in √§lteren Techniken bieten, was in spezifischen Anwendungsf√§llen als Limitierung empfunden wurde.   Fazit  Zusammenfassend l√§sst sich sagen, dass Jetpack Compose nicht nur eine innovative Antwort auf die Herausforderungen der modernen App-Entwicklung bietet, sondern auch das Potenzial hat, die Produktivit√§t von Entwicklern signifikant zu steigern. Durch seine deklarativen Ans√§tze, die einfache Implementierung von State Management und die nahtlose Interoperabilit√§t mit bestehenden Tools und Bibliotheken sind die Rahmenbedingungen geschaffen, um moderne, responsive und √§sthetische Benutzeroberfl√§chen zu gestalten. Die Vorteile √ºberwiegen die Herausforderungen deutlich. Zuk√ºnftige Entwicklungen und Community-Beitr√§ge werden entscheidend sein, um die bestehenden Limitierungen zu adressieren. Damit wird Jetpack Compose wahrscheinlich eine zentrale Rolle in der zuk√ºnftigen Android-App-Entwicklung spielen.;1
In der vorliegenden Arbeit wurde die Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes umfassend untersucht. Die durchgef√ºhrten Analysen und Experimente zeigen, dass durch gezielte Verbesserungen in der Benutzeroberfl√§che, der Interaktivit√§t und der Automatisierung der Betrieb des Ger√§tes nicht nur benutzerfreundlicher gestaltet, sondern auch die Effizienz der Luftreinigung signifikant gesteigert werden kann.   Die Visualisierung der Betriebsdaten in Echtzeit erm√∂glicht es den Nutzern, den Zustand der Raumluft intuitiv zu erfassen und entsprechende Anpassungen vorzunehmen. Die Implementierung von anpassbaren Steuerungsoptionen bietet den Anwendern die Flexibilit√§t, das Ger√§t gem√§√ü ihren individuellen Bed√ºrfnissen zu konfigurieren. Dar√ºber hinaus tr√§gt die Entwicklung eines intelligenten Regelungssystems, das auf Sensoren basiert, zur Selbstoptimierung des Luftreinigers bei, indem es automatisierte Anpassungen vornimmt, die auf den aktuellen Luftqualit√§tsdaten basieren.  Die Ergebnisse dieser Arbeit belegen, dass eine symbiotische Beziehung zwischen technologischer Erweiterung und Benutzererfahrung besteht. Zuk√ºnftige Arbeiten k√∂nnten sich darauf konzentrieren, diese Ans√§tze weiter zu verfeinern und zu testen, um das volle Potenzial solcher Systeme auszusch√∂pfen. Insgesamt bietet diese Studie wertvolle Einsichten und praktische Implikationen f√ºr die Entwicklung moderner Luftreinigungsger√§te, die sowohl effektiv als auch benutzerfreundlich sind.;1
"Eins dieser Erweiterungsmodule ist das ‚ÄûSX1302 LoRaWAN Gateway HAT‚Äú, dieses erwei-
tert den Raspberry Pi um einen Antennenanschluss, einen GPS-Antennenanschluss und
die M√∂glichkeit das ‚ÄûSX1302 LoRaWAN Gateway Module‚Äú einzusetzen. Zu sehen ist diese
modulare Erweiterung durch die blaue Platine in Abbildung 3.1, auf der der eigentliche
Gateway-Chip angebracht ist. Durch den weiblichen SMA-Anschluss an der Platine k√∂nnen
andere leistungsf√§higere Antennen an das zusammengebaute Gateway angeschlossen wer-
den. In der Abbildung sind die Standardantennen f√ºr den Empfang der LoRa-Funkwellen
sowie dem GPS-Signal schon angeschlossen. Der SX1302 ist ein Basisband-LoRa-Chip f√ºr
Gateways, der sich vor allem durch seinen geringen Stromverbrauch auszeichnet. Er hat
einen Taktfrequenz von 32MHz, unterst√ºtzt die Spreadingfaktoren SF5 bis SF12 und wird
mit einer weltweit eindeutigen 64-Bit-Nummer serienm√§√üig gekennzeichnet. Im Betrieb
stellt der Chip insgesamt 8 Kan√§le f√ºr Nodes der A,B und C-Kategorien zur Verf√ºgung.";0
Zum grundlegenden Aufbau des Frameworks ist anzumerken, dass es sich hierbei nicht um ein monolithisches Projekt handelt . Vielmehr liegt dem Jetpack Compose Framework eine architektonische Schichtenarchitektur zugrunde, die aus einer Reihe von Modulen besteht, welche zu einem kompletten Stack zusammen gef√ºhrt werden. Dies wird ebenfalls deutlich, wenn die Bestandteile des Compose Pakets der AndroidX Sammlung betrachtet werden. Hierbei sind sieben unterschiedliche Maven Group IDs als Untergruppen des Frameworks aufgef√ºhrt . F√ºnf der Untergruppen k√∂nnen jeweils den folgend dargestellten, √§hnlich benannten Schichten zugeordnet werden. Anzumerken ist zudem, dass eine Anwendung je nach beabsichtigtem Ziel auf den un- terschiedlichen Schichten aufsetzten kann. Jede Schicht beinhaltet neben ihren eigenen Funktionalit√§ten auch die Funktionalit√§ten der Schichten, die auf dem Stack unter ihr angesiedelt sind. Dementsprechend steigt mit h√∂heren Schichten auch das Abstraktionsni- veau der angebotenen Funktionen  .;0
Ein Fazit  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung eines virtuellen Szenarios, das auf dem Nachrichtenaustauschprotokoll MQTT (Message Queuing Telemetry Transport) basiert und darauf abzielt, eine ansprechende Lernumgebung f√ºr Studierende und Fachkr√§fte im Bereich der Informatik und der Internet-of-Things (IoT)-Technologien zu schaffen. In zahlreichen Bereichen, von der Automatisierungstechnik bis zur Smart-Home-Technologie, spielt MQTT eine zentrale Rolle, weshalb es f√ºr das Verst√§ndnis der zugrunde liegenden Prinzipien und der praktischen Anwendung von gro√üer Bedeutung ist.  Im Rahmen dieses Projekts wurde zun√§chst eine umfassende Analyse der bestehenden Lehrmethoden durchgef√ºhrt. Die bisherigen Ans√§tze, die h√§ufig auf theoretischen Modulen basieren, erweisen sich als weniger effektiv, um das praktische Verst√§ndnis von MQTT und seinen Einsatzm√∂glichkeiten zu f√∂rdern. Daher wurde das Ziel formuliert, ein interaktives, virtuelles Szenario zu entwickeln, das sowohl Simulationen als auch konkrete Anwendungsbeispiele integriert.  Die entwickelten Lernmodule zeichnen sich durch eine intuitive Benutzeroberfl√§che aus, welche die Teilnehmenden dazu anregt, in einer simulated Environment verschiedene MQTT-Protokoll-Features zu erforschen. Die Szenarien umfassen unter anderem die Implementierung eines einfachen Smart-Home-Systems, das den Datenaustausch zwischen verschiedenen IoT-Ger√§ten simuliert. Die Nutzer k√∂nnen dabei aktiv experimentieren, wie Themen wie Datenpublikation, Abonnierung und die QoS-Stufen (Quality of Service) in realistischen Anwendungsszenarien wirken.  Ein zentrales Ergebnis des Projekts besteht darin, dass die Teilnehmer nicht nur theoretisches Wissen erlangen, sondern durch praktische Erfahrung ein tiefes Verst√§ndnis f√ºr die Funktionsweise von MQTT entwickeln. Die R√ºckmeldungen der Nutzer verdeutlichen, dass das virtuelle Szenario nicht nur als Lernwerkzeug, sondern auch als Katalysator f√ºr Diskussionen √ºber moderne IoT-Applikationen dienen kann. Diese Ergebnisse deuten darauf hin, dass ein interaktives Lernumfeld eine wesentliche Rolle bei der effektiven Vermittlung komplexer technischer Inhalte spielt.  Im Fazit l√§sst sich festhalten, dass die Entwicklung des virtuellen MQTT-Szenarios f√ºr Lehrzwecke nicht nur eine innovative Methode zur Vermittlung von Fachwissen darstellt, sondern auch bedeutende Impulse f√ºr zuk√ºnftige Bildungsans√§tze im Bereich der Informatik liefert. Die Erkenntnisse dieses Projektes betonen die Notwendigkeit, traditionelle Lehrmethoden durch interaktive und praxisnahe Ans√§tze zu erg√§nzen, um die Lernmotivation zu steigern und die praktischen F√§higkeiten der Studierenden zu f√∂rdern. Zuk√ºnftige Arbeiten k√∂nnten darauf abzielen, √§hnliche Szenarien f√ºr andere Protokolle und Technologien zu entwickeln, um die Vielfalt und Tiefe der Bildung im digitalen Zeitalter weiter zu steigern.;1
Das Ziel ist nicht ausschlie√ülich das Gegenpr√ºfen von Menschen gegen√ºber einem festen Datensatz. Es sollen Verd√§chtige vollautomatisiert in Echtzeit erkannt und angezeigt werden. Dann kann die Polizei darauf reagieren, ohne st√§ndig durchgehend Menschen jedes einzelne Kamerabild anschauen zu lassen. Diese ausgepr√§gte √úberwachung erh√∂ht die Chance Verd√§chtige zu erkennen, die auf normaler Streifenfahrt wohl entwischt w√§ren. London ist dabei nicht alleine, auch das NYPDverwendet Gesichtserkennung, um ver- d√§chtige zu erkennen. Dabei verwenden mehr als 600 Strafvollzugsbeh√∂rden in den USA Gesichtserkennungssoftware der Firma ‚ÄûClearview AI‚Äú (Satariano 2020). Im Gegensatz zu London erfolgt das aber nicht in Echtzeit, sondern es wird nur gegen eine feste Datenbank gepr√ºft. Wobei die nur die Polizei betrifft. Denn ob die Geheimdienste der USA nicht doch Echtzeiterkennugssoftware einsetzten ist nicht genau bekannt, aber sehr wahrscheinlich. Mit den Leaks durch Edward Snowden ist bekannt, dass diese Geheimdienste globale Massen√ºberwachung in nicht geahntem Ma√üe ausgef√ºhrt haben und noch tun. Die Echt- zeiterkennungssoftware f√ºr London stammt hierbei von der japanischen Firma ‚ÄûNEC‚Äú (Satariano 2020). Die USA wollen den Einsatz von Echtzeiterkennungssoftware auch weiter ausbauen. Allerdings gibt es auch Probleme mit der Echtzeiterkennungssoftware. So ist sie nicht open source und in fester Hand einer Firma. Es ist bekannt, dass die Software nicht fehlerfrei funktioniert. Dabei werden wieder dunkelh√§utige Menschen nicht gut erkannt. Die Echtzeiterkennungssoftware ist au√üerdem ein erheblicher Eingriff in die Privatsph√§re. Schlie√ülich kann mit ihr ein genaues Profil erstellt werden. Dies kann unter anderem auch ein Bewegungsprofil sein. Es hat sich au√üerdem herausgestellt, dass g√ºltige Menschenrechte durch die zur Echtzeiterkennung genutzten Algorithmen verletzt wurden (Kaiser 2019).;0
In der vorliegenden Arbeit wurde die App-Entwicklung mit dem Jetpack Compose Framework eingehend untersucht und analysiert. Jetpack Compose stellt einen paradigmatischen Wandel in der Android-Entwicklung dar, indem es eine deklarative Programmierweise einf√ºhrt, die es Entwicklern erm√∂glicht, Benutzeroberfl√§chen effizienter und intuitiver zu gestalten. Durch die Verwendung von Kotlin als Programmiersprache profitieren Entwickler von einer modernen Syntax und umfangreichen Sprachfeatures, die die Produktivit√§t und Lesbarkeit des Codes erheblich steigern.  Die Untersuchung hat gezeigt, dass Jetpack Compose nicht nur die Entwicklungszeit verk√ºrzt, sondern auch die Wartbarkeit und Erweiterbarkeit von Anwendungen verbessert. Die Integration von UI-Elementen und die Handhabung von Zust√§nden erfolgen auf eine Weise, die die Komplexit√§t reduziert und gleichzeitig die Flexibilit√§t erh√∂ht. Besonders hervorzuheben ist die nahtlose Interoperabilit√§t mit bestehenden Android-Architekturen und -Bibliotheken, die es Entwicklern erm√∂glicht, schrittweise auf Compose umzusteigen, ohne bestehende Projekte vollst√§ndig umschreiben zu m√ºssen.  Ein weiterer wichtiger Aspekt ist die Unterst√ºtzung von Material Design, die es Entwicklern erm√∂glicht, ansprechende und benutzerfreundliche Oberfl√§chen zu gestalten, die den aktuellen Designstandards entsprechen. Die umfangreiche Dokumentation und die aktive Community tragen zus√§tzlich dazu bei, dass Entwickler schnell Unterst√ºtzung finden und Best Practices erlernen k√∂nnen.  Abschlie√üend l√§sst sich festhalten, dass Jetpack Compose ein vielversprechendes Framework f√ºr die App-Entwicklung darstellt, das nicht nur die Effizienz steigert, sondern auch die Benutzererfahrung verbessert. Zuk√ºnftige Entwicklungen und Erweiterungen des Frameworks werden sicherlich dazu beitragen, die Android-Entwicklung weiter zu revolutionieren und neue M√∂glichkeiten f√ºr kreative und innovative Anwendungen zu schaffen. In Anbetracht der sich stetig weiterentwickelnden Technologie und der wachsenden Anforderungen an mobile Anwendungen ist Jetpack Compose ein entscheidender Schritt in die Zukunft der App-Entwicklung.;1
Die besondere Bedeutung der Game -Klasse, die wichtige Funktionalit√§ten f√ºr die Spiellogik  bereitstellt, wurde bereits angedeutet. Aus diesem Grund soll diese Komponente beispielhaft  anhand  des Tools Embold  n√§her betrachtet werden.  In der Gesamt√ºbersicht aller Klassen erzielt die  Komponente ‚ÄûGame‚Äú mit einem Wert von -0.19 den schlechtesten Score.  In Abbildung 21 und  Abbildung 22 sind die Metriken der Game -Klasse im Vergleich zu den anderen Komponenten sowie in  der Detailansicht dargestellt.  Bereits auf den ersten Blick  f√§llt auf, dass die Klasse auff√§llig gro√ü ist  und aus vielen Methoden und Attributen besteht.  Die Metriken CC und RFC weisen zudem auf eine  sehr hohe Komplexit√§t der Klasse hin.  Folgerichtig √ºberschreiten die Metriken NOM, NOA, CC und  RFC den vorgeschlagenen Grenzwert  teilweise um das Doppelte . Die Anza hl an Methoden √ºbersteigt  die Obergrenze dabei sogar um den Faktor drei. Diese Analyse kann durch die Tatsache begr√ºndet  werden, dass die Klasse ‚ÄûGame‚Äú verschiedenste Funktionen der Spielelogik enth√§lt, die nicht  eindeutig einer anderen Komponente zugeordn et werden k√∂nnen. Dass diese bereitgestellten  Funktionalit√§ten unterschiedliche  Aufgaben √ºbernehmen, die keinen engen Zusammenhang  aufweisen, wird auch durch einen schlechten LCOM -Wert best√§tigt. Dieser weist auf eine geringe  Koh√§sion der Klasse hin, was Aus wirkungen auf die Modularit√§t der Komponente hat. Die  Interpretation der genannten Messdaten zeigt an, dass eine √úberarbeitung und Aufteilung der  Game -Klasse vorgenommen werden sollte. Die negative Bewertung durch das Tool Embold ist also  gerechtfertigt und ein Refactoring der Klasse ist empfehlenswert.   Aus der Gesamt√ºbersicht der Scores, die von Embold errechnet wurden, geht ein eindeutiger  Qualit√§tsunterschied zu dem zuvor betrachteten C++ -Projekt hervor. Zwar gibt es einige Klass en, die  eine gute Bewertung erzielen, allerdings schneiden viele Komponenten nur mittelm√§√üig oder  vergleichsweise schlecht ab. Diese sorgen daf√ºr, das die Gesamtbewertung des Zork -Projekts mit  3.13 Punkten auf deutlich mehr Problemstellen hindeutet. D ie Spanne, in der sich die Scores  bewegen, ist mit einer Range von -0.19 bis 4 .98 deutlich gr√∂√üer. Grund daf√ºr sind die h√∂here  Klassenanzahl und die dadurch komplexeren Strukturen. Es ist entscheidend Eigenschaften wie  Kopplung und Koh√§sion zu kontrolliere n und zu verbessern, da sonst die Qualit√§t mit steigender  Projektgr√∂√üe merklich absinkt. Um die Codequalit√§t in umfangreichen Projekten aufrecht zu  erhalten, ist es also zwingend erforderlich entsprechende Ma√ünahmen zu treffen.;0
" Kapitel 2: Technische Grundlagen  Die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen erfordert ein fundiertes Verst√§ndnis der zugrunde liegenden Technologien und Konzepte, die sowohl die Programmiersprache Elixir als auch das Nerves-Framework betreffen. In diesem Kapitel werden die wesentlichen technischen Grundlagen erl√§utert, die f√ºr die Entwicklung und Implementierung von IoT-L√∂sungen mit ElixirNerves relevant sind.   2.1 Elixir: Eine funktionale Programmiersprache  Elixir ist eine moderne, funktionale Programmiersprache, die auf der Erlang Virtual Machine (BEAM) basiert. Sie wurde entwickelt, um die Entwicklung von skalierbaren und wartbaren Anwendungen zu erleichtern. Die funktionale Natur von Elixir f√∂rdert unver√§nderliche Datenstrukturen und reine Funktionen, was zu einer h√∂heren Robustheit und Vorhersagbarkeit der Software f√ºhrt. Diese Eigenschaften sind besonders vorteilhaft in der IoT-Entwicklung, wo Ger√§te oft in verteilten Umgebungen arbeiten und eine hohe Verf√ºgbarkeit erfordern.  Ein zentrales Merkmal von Elixir ist die Unterst√ºtzung f√ºr Concurrency durch das Actor-Modell, das es Entwicklern erm√∂glicht, zahlreiche Prozesse parallel auszuf√ºhren. In IoT-Anwendungen, in denen viele Sensoren und Aktoren gleichzeitig kommunizieren m√ºssen, ist diese F√§higkeit von entscheidender Bedeutung. Elixir nutzt leichtgewichtige Prozesse, die unabh√§ngig voneinander agieren und √ºber Nachrichten kommunizieren, was die Entwicklung reaktiver Systeme erleichtert.   2.2 Nerves: Ein Framework f√ºr IoT-Anwendungen  Nerves ist ein Open-Source-Framework, das speziell f√ºr die Entwicklung von Embedded-Systemen und IoT-Anwendungen mit Elixir konzipiert wurde. Es bietet eine Sammlung von Tools und Bibliotheken, die den gesamten Entwicklungsprozess von der Prototypenerstellung bis zur Bereitstellung auf Hardware unterst√ºtzen. Nerves erm√∂glicht es Entwicklern, Anwendungen zu erstellen, die auf einer Vielzahl von Embedded-Plattformen laufen, darunter Raspberry Pi, BeagleBone und verschiedene Mikrocontroller.  Ein herausragendes Merkmal von Nerves ist die M√∂glichkeit, vollst√§ndige Linux-basierte Betriebssysteme f√ºr Embedded-Ger√§te zu erstellen. Nerves verwendet das Build-System ""Nerves System"", das eine minimalistische Linux-Distribution generiert, die speziell auf die Anforderungen von IoT-Anwendungen zugeschnitten ist. Dies erm√∂glicht es Entwicklern, die Gr√∂√üe und den Ressourcenverbrauch ihrer Anwendungen zu optimieren, was f√ºr ressourcenbeschr√§nkte Ger√§te von entscheidender Bedeutung ist.   2.3 Netzwerkkommunikation und Protokolle  Ein weiterer kritischer Aspekt der IoT-Entwicklung ist die Netzwerkkommunikation. IoT-Ger√§te m√ºssen in der Lage sein, Daten effizient zu senden und zu empfangen, oft √ºber drahtlose Netzwerke. Nerves unterst√ºtzt verschiedene Protokolle, die f√ºr IoT-Anwendungen relevant sind, darunter MQTT, CoAP und HTTP. MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Publish-Subscribe-Protokoll, das sich ideal f√ºr Anwendungen eignet, bei denen Bandbreite und Energieverbrauch begrenzt sind.  Die Integration dieser Protokolle in ElixirNerves erfolgt durch die Verwendung von Bibliotheken, die speziell f√ºr die Interaktion mit diesen Kommunikationsstandards entwickelt wurden. Dies erm√∂glicht es";1
Bei dem Prototypen handelt es sich um das Modellauto Tigerder Firma Jamara1(siehe Ab- bildung5.19).Diese sverf√ºgt √ºber einen B√ºrsten-Motormitca. Standardm√§√üig wird das Modellauto √ºber eine 2.4GHz-Modellfunkfernbedienung angesteuert (siehe Abbildung 5.20). Der entsprechende Empf√§nger am Fahrzeug √ºbermittelt dann das empfangene Signal √ºber PWMmit etwa 50 MHz an den ESCdes Fahrzeugs, der dort die entsprechenden Motoren ansteuert (Quelle: Mailverkehr mit dem Support-Team von Jamara). Wie bereits erw√§hnt, kommuniziert der Funkempf√§nger des Modellautos √ºber PWMmit dem Fahrzeugcontroller. Um die Details der Kommunikation herauszufinden und damit sp√§ter den Motorcontroller ansteuern zu k√∂nnen, werden sowohl die Spannung und die Stromst√§rke der verwendeten Leitungen als auch das PWM-Signal mit einem Oszilloskop ausgemessen (siehe Abbildung 5.22). Wie man im Abbildung 5.21erkennen kann, f√ºhren zur Steuerung der Geschwindigkeit und der Lenkung jeweils 3 Kabel zum Funkempf√§nger. Das schwarze Kabel ist dabei Masse, das Rote die Stromversorgung und das Wei√üe √ºbertr√§gt das PWM-Signal. Dabei wurde eine minimale Dauer der Pulsweitenmodulation von 1100 Mikrosekunden und eine maximale Dauer der Pulsweitenmodulation von 1900 Mikrosekunden gemessen, die Neutralstellung der Pulsweitenmodulation liegt dabei bei 1500 Mikrosekunden. Die gemessenen Stromst√§rken und Spannungen sind in Tabelle 5.5 zu sehen. Da der Metro M4-Microcontroller an seinen Pins 3.3V unterst√ºtzt und die Stromversorgung bis zu 5V mit 500mA, kann der Microcontroller einfach in den Stromkreis integriert werden. F√ºr die PWM-Pins des Microcontrollers wurden keine Angaben zur unterst√ºtzten Stromst√§rke gefunden, jedoch sollten bis zu 0.05mA kein Problem sein, da Arduino-Pins normalerweise bis zu 40mA unterst√ºtzen (vgl. ). Zur Ansteuerung wird die Bibliothek Servo.h1verwendet. Um eine erfolgreiche Kollisionsvermeidung zu erm√∂glichen, wird die maximal m√∂gliche Geschwindigkeit durch die selbstentwickelte Software des Fahrzeugcontrollers reduziert.;0
In der vorliegenden Arbeit wurde eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool entwickelt, das speziell auf die Bed√ºrfnisse des studentischen Software Engineerings zugeschnitten ist. Im Verlauf der Untersuchung wurden zentrale Anforderungen identifiziert, die sowohl die Effizienz als auch die Zusammenarbeit innerhalb von Studierendengruppen f√∂rdern sollen. Die Analyse verdeutlichte, dass ein effektives Aufgabenmanagement-Tool nicht nur die Organisation von Projekten erleichtert, sondern auch die Kommunikation und den Wissensaustausch zwischen den Teammitgliedern verbessert.  Die ermittelten Anforderungen umfassten verschiedene Dimensionen, wie etwa Usability, Funktionalit√§t und Integrationsf√§higkeit mit bestehenden Tools und Plattformen. Ein entscheidendes Ergebnis der Arbeit ist die Erkenntnis, dass die Benutzerfreundlichkeit und die Anpassungsf√§higkeit des Tools ma√ügeblich f√ºr die Akzeptanz bei den Studierenden sind. Dar√ºber hinaus wurden spezifische Funktionen wie die M√∂glichkeit zur zeitlichen Planung, Aufgabenpriorisierung und Feedback-Mechanismen als essenziell erachtet, um den unterschiedlichen Anforderungen der studienbegleitenden Projekte gerecht zu werden.  Zuk√ºnftige Entwicklungen eines solchen Tools sollten daher nicht nur die identifizierten Anforderungen ber√ºcksichtigen, sondern auch kontinuierlich an die sich wandelnden Bed√ºrfnisse der Studierenden angepasst werden. Die Implementierung eines anpassungsf√§higen und user-zentrierten Ansatzes k√∂nnte entscheidend dazu beitragen, das studentische Software Engineering zu optimieren und den Lernprozess nachhaltig zu verbessern. Insofern bietet die vorliegende Analyse eine wertvolle Grundlage f√ºr die Entwicklung eines innovativen und effektiven Aufgabenmanagement-Tools und leitet zugleich Forschungsbedarf f√ºr die weitere Erprobung und Evaluierung solcher Systeme im akademischen Kontext ab.;1
‚ÄúTats√§chlich-√∂ffentliche Wege‚Äù sind damit Verkehrsfl√§chen, auf denen ohne R√ºcksicht auf die Eigentumsverh√§ltnisse oder eine Widmung aufgrund aus- dr√ºcklicher oder stillschweigender Duldung des Verf√ºgungsberechtigten die Benutzung f√ºr jedermann zugelassen ist (vgl. auch VV zu ¬ß 1 StVO, II). Hinzutreten muss, dass ihr Gebrauch durch die Allgemeinheit erkennbar ist.  Voraussetzungen sind die Zug√§nglichkeit f√ºr jedermann, die Duldung des Verf√ºgungsberechtigten und eine tats√§chliche Nutzung durch die √ñffentlich- keit.‚Äù  Gem√§√ü ¬ß3 Abs. 1 S. 1 Fahrzeugzulassungsverordnung (FZV) d√ºrfen Fahrzeuge in Deutsch- land auf √∂ffentlichen Stra√üen nur dann betrieben werden, wenn sie zugelassen sind (vgl.  S.1). Als √∂ffentliche Stra√üen werden im Sinne des Stra√üenverkehrsrechts dabei unabh√§ngig von der wegerechtlichen Widmung alle Wege bezeichnet, die tats√§chlich f√ºr den allgemeinen √∂ffentlichen Verkehr benutzt werden. Darunter geh√∂ren auch sogenannte tats√§chlich-√∂ffentliche Wege, wie im Zitat in Abschnitt 3.2.2erl√§utert (vgl.  S. 2f). In  wird detailliert die M√∂glichkeit einer Zulassung von teleoperierten und autono- men Fahrzeugen diskutiert. Es wird der Schluss gezogen, dass diese Fahrzeuge mit der bestehenden Rechtsordnung nicht vereinbar sind, gerade im Bezug auf eine teleoperierten oder autonomen Lenkung. Es wird betont, dass zum Beispiel f√ºr Forschungsfahrzeuge nach ¬ß70 Stra√üenverkehrs-Zulassungs-Ordnung (StVZO) und nach ¬ß46 Stra√üenverkehrs- Ordnung (StVO) Ausnahmegenehmigungen m√∂glich sind. Des weiteren wird auf das Haftungsrecht f√ºr Produkte hingewiesen, wonach der Hersteller theoretisch f√ºr jeden Fehler seines Produktes haftet, unabh√§ngig davon, ob dieser Fehler fahrl√§ssig herbeigef√ºhrt wurde oder nicht. Ausgenommen von den Vorschriften √ºber das Zulassungsverfahren sind nach ¬ß3 Abs. 2: ‚Ä¢selbstfahrende Arbeitsmaschinen und Stapler ‚Ä¢einachsige Zugmaschinen, wenn sie nur f√ºr land- oder forstwirtschaftliche Zwecke verwendet werden ‚Ä¢Leichtkraftr√§der ‚Ä¢zwei- oder dreir√§drige Kleinkraftr√§der ‚Ä¢motorisierte Krankenfahrst√ºhle ‚Ä¢leichte vierr√§drige Kraftfahrzeuge ‚Ä¢Elektrokleinstfahrzeuge im Sinne des ¬ß 1 Absatz 1 der Elektrokleinstfahrzeuge- Verordnung vom 6. Juni 2019 (BGBl. I S. 756) in der jeweils geltenden Fassung. Diese Fahrzeuge k√∂nnen auf Antrag ohne Zulassungsverfahren zugelassen werden. Voraus- setzung f√ºr die Inbetriebsetzung auf √∂ffentlichen Stra√üen ist nach ¬ß4 Abs. 1 FZVjedoch , das diese einem genehmigtem Typ entsprechen oder eine Einzelgenehmigung erteilt ist. In diesem Fall treffen nach ¬ß4 Abs. 3-5 FZVweitere Pflichten, wie eine Kennzeichnungspflicht oder eine Versicherungskennzeichenpflicht zu .;0
Roboterfunktionen Die Roboterfunktionen sind in Kategorien zu unterteilen, um Kollisionen bei der Ausf√ºh- rung zu vermeiden. Alle Funktionen die den selben Hardwarebaustein, zum Beispiel die Lautsprecher nutzen, geh√∂ren zu einer Kategorie. Roboterfunktionen der selben Kategorie, beispielsweise eine Sprachausgabe und die Ausgabe einer Audiodatei, k√∂nnen nicht gleich- zeitig ausgef√ºhrt werden. Funktionen welche eine andere Android-Applikation des Tablets wie zum Beispiel einen Internetbrowser aufrufen, geh√∂ren zu einer extra Kategorie. Diese Funktionen d√ºrfen nur allein gestartet werden, um Kollisionen und √úberlagerungen mit anderen Roboterfunktionen zu vermeiden. Die meisten Funktionen verwenden neben den Standardparametern name und executi- on_slot einen weiteren. Dieser enth√§lt meistens einen String, zum Beispiel mit den Namen der verwendeten Ressource oder Datei. Die Funktionen sind m√∂glichst klein gehalten um f√ºr eine gute Modularit√§t zu sorgen. Zum Beispiel gibt es die Funktion ‚ÄúSlide‚Äù anstatt einer Funktion f√ºr eine ganze Slideshow. Mehrere ‚ÄúSlide‚Äù-Elemente k√∂nnen zu einer Slideshow zusammen gesetzt werden. Dadurch lassen sich auch andere Funktionen zwischen zwei Slides einbauen. Zudem k√∂nnen Funktionen aus verschiedenen Kategorien gleichzeitig ausgef√ºhrt werden, um beispielsweise einer Slideshow oder einem Quiz Musik abzuspielen. Mit dieser Modularit√§t k√∂nnen User aus den Grundfunktionen ihren eigenen Funktion wie mit einem Baukasten zusammenstellen. Eine Ausnahme bildet das Dialogsystem, welches Dauerhaft im Hintergrund l√§uft. Da- mit soll Pepper √ºber die Sprachausgabe antworten k√∂nnen wenn er angesprochen wird. Theoretisch k√∂nnten aber hier andere Funktionen als ‚ÄúSay‚Äù in den m√∂glichen Antworten hinterlegt werden.;0
‚Ä¢H√§uÔ¨Åge √Ñnderungen und neue Versionen ZudemzubeachtenistdieTatsache,dasssichbeiFrameworksinfr√ºhenStadienh√§uÔ¨Åg gr√∂√üere √Ñnderungen im Entwicklungsprozess ergeben und somit auch in k√ºrzeren Abst√§nden neue Versionen erscheinen k√∂nnen, die in der erstellten Anwendung bei Bedarf angepasst werden m√ºssen. Hier besteht das Risiko, dass sich grundlegende √Ñnderungen in der generellen Struktur ergeben, die eventuell zu Inkompatibilit√§ten f√ºhren k√∂nnen . In diesem Zusammenhang kann es sich durchaus als sinnvoll erweisen, aktiv zu verfolgen, welche √Ñnderungen implementiert wurden und ob eine Kompatibilit√§t zur verwendeten Version besteht. Anzumerken ist an dieser Stelle, dass die H√§uÔ¨Ågkeit solcher √Ñnderungen bei Compose seit Ver√∂Ô¨Äentlichung des Frameworks in der ersten stabilen Version kontinuierlich abgenommen hat .;0
 Ein Konzept zur Umsetzung     Die stetig steigende Zahl √§lterer Menschen in unserer Gesellschaft bringt eine Herausforderung mit sichdie Sicherstellung ihrer Sicherheit im h√§uslichen Umfeld. St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen bei Senioren dar und k√∂nnen schwerwiegende Folgen haben. In diesem Zusammenhang gewinnt die Technologie der In-room Ortung an Bedeutung. Diese Arbeit untersucht das Potenzial der Bluetooth-Technologie zur Entwicklung eines Systems zur Sturzerkennung und skizziert ein Konzept zur Umsetzung.   Grundlagen der Bluetooth-Ortung  Bluetooth ist eine weit verbreitete drahtlose Kommunikationsschnittstelle, die eine ortsbasierte Interaktion erm√∂glicht. Die ortsbasierte Identifikation erfolgt typischerweise durch die Verwendung von Bluetooth Low Energy (BLE) Beacons, die ein kontinuierliches Signal ausstr√∂men. Die Signalst√§rke kann genutzt werden, um die Position des Empf√§ngers zu bestimmen. Dieser Aspekt ist entscheidend f√ºr die Entwicklung eines Systems zur Sturzerkennung, da es den kontinuierlichen Monitoring von Personen innerhalb eines definierten Raumes erm√∂glicht.   Konzept zur Sturzerkennung   1. Systemdesign und Architektur  Das geplante System besteht aus mehreren Komponenten- BLE BeaconsDiese werden strategisch in den R√§umlichkeiten platziert, um eine fl√§chendeckende Abdeckung zu gew√§hrleisten. - Smartphone-AppDie App dient als zentraler Empf√§nger der Beacon-Signale und analysiert die Daten zur Erkennung von ungew√∂hnlichem Bewegungsverhalten. - Cloud-DatenbankZum Speichern von Bewegungsdaten und zur Anwendung von Machine Learning-Algorithmen zur Verbesserung der Sturzerkennbarkeit.   2. Platzierung der Beacons  Die Effektivit√§t des Systems h√§ngt ma√ügeblich von der Platzierung der Beacons ab. Studien haben gezeigt, dass eine Dichte von einem Beacon pro 10-15 Quadratmetern in Wohnr√§umen ideal ist, um eine pr√§zise Ortung zu gew√§hrleisten. Besondere Aufmerksamkeit sollte auf kritische Bereiche wie Treppen, Badezimmer und K√ºchen gelegt werden, wo das Sturzrisiko h√∂her ist.   3. Erkennung von St√ºrzen  Die Sturzerkennung beruht auf der Analyse von Bewegungsmustern. Mithilfe von Algorithmen steckt das System einen Kriterienkatalog fest, der Anomalien im Bewegungsprofil identifiziert. Dazu geh√∂ren- Pl√∂tzlicher StillstandEin abruptes Ende der Bewegung √ºber den Zeitraum von mehreren Sekunden. - Ungew√∂hnliche PositionEine Ver√§nderung im Standort, die auf einen Sturz hinweist. - Zweifache Wiederholung eines BewegungsmustersH√§ufige und unerwartete Positionswechsel.   4. Alarmierung  Sobald ein Sturz erkannt wird, wird ein Alarm generiert, der an vordefinierte Notfallkontakte (Familie, Freunde, Rettungsdienste) gesendet wird. Die Alarmierung kann auch √ºber eine mobile App erfolgen, die den Angeh√∂rigen eine Echtzeit-Benachrichtigung √ºber den Vorfall erm√∂glicht.   5. Datenschutz und Sicherheit  Bei der Implementierung des Systems d√ºrfen Datenschutz- und Sicherheitsaspekte nicht vernachl√§ssigt werden. Alle gesammelten Daten m√ºssen anonymisiert werden, und die Benutzer sollten √ºber die Art der gesammelten Informationen transparent informiert werden. Zudem sollten robuste Sicherheitsprotokolle zum Schutz der Daten vor unbefugtem Zugriff implementiert werden.   Fazit  Die In-room Ortung zur Sturzerkennung mittels Bluetooth-Technologie bietet vielversprechende M√∂glichkeiten, um die Sicherheit √§lterer Menschen in ihrem h√§uslichen Umfeld zu verbessern. Das skizzierte Konzept zur Umsetzung zeigt, dass eine Kombination aus Hardware, Software und intelligenten Algorithmen zur effektiven Erkennung und Alarmierung bei St√ºrzen eingesetzt werden kann. Zuk√ºnftige Forschungsarbeiten sollten sich auf die Optimierung der Algorithmen zur Sturzerkennung sowie die Durchf√ºhrung umfassender Feldstudien konzentrieren, um die Akzeptanz und Usability des Systems weiter zu erh√∂hen. Durch die Implementierung solcher Systeme kann langfristig ein wichtiger Beitrag zur Verbesserung der Lebensqualit√§t und Sicherheit √§lterer Erwachsener geleistet werden.;1
Die erste Spezifikation des Thread-Protokolls wurde im Jahr 2015 durch die Thread Group Inc.ver√∂ffentlicht. Gr√ºndungsmitglieder dieser Organisation, der mehr als 200 Mitglieder angeh√∂ren sind ARM,Big Ass Fans, Feescale,Nest Labs, Samsung, Silicon Labs und Yale Locks. Im Standard stehen dabei verschiedene Topologien zur Auswahl, wie die Stern-Topologie, Punkt-zu-Punkt-Verbindungen und Mesh. Das Ziel dabei ist es jedoch mit diesen Technologien ein gr√∂√üeres Mesh-Netzwerk im PANohne Single Point of Failure aufzubauen. Das Netzwerk wird dabei in verschiedene Ger√§te-Typen, wieEnd Device (ED) ,Router Eligible End Device (REED) ,Full End Device (FED) ,Full Thread Device (FTD), Full End Device (FED) ,Border Router Device (BR), Leader Router, Sleepy End Device (SED) ,Minimal End Device (MED) undMinimal Thread Device (MTD)unterteilt. Threadbasiert auf dem IEEE 802.15.4 -Protokoll, wobei Ger√§te mit Routing-F√§higkeiten gem√§√ü diesem Standard FFDs sein m√ºssen, an Ger√§te ohne solche Anforderungen gen√ºgen die Anforderungen von RFDs. Auf der Netzwerkebene basiert Threadauf einer Teilimplementierung von IpV6 und einem einfachen Routing-Protokoll. Als Transport-Protokoll wird constrained Application Protocol (CoAP) verwendet, das auf User Datagram Protocol (UDP) basiert. Matter ist auch unter dem ehemaligen Projekt Connected Home over IP (CHIP) bekannt und neben dem Standard selber auch Name einer neuen Arbeitsgruppe in der Connectivity Standards Alliance (CSA) (ehemals Zigbee-Alliance). Ziel dieser Arbeitsgruppe ist es, einen neuen lizenzfreien Konnektivit√§tsstandard zu entwickeln und zu f√∂rdern um die Kompatibilit√§t zwischen Smart-Home-Produkten zu erh√∂hen. Die CSAhat die Matter- Arbeitsgruppe offiziell am 17. Januar 2020 er√∂ffnet, welche aktuell die Spezifikation entwickelt. Soweit bekannt definiert Matterdabei die Anwendungsschicht im Protokoll- Stack und baut auf dem Transport Control Protocol (TCP),UDP, IPv6 und verschiedenen anderen Standards, wie ThreadundIEEE 802.15.4 auf (siehe Abbildung 4.4).;0
  Die fortschreitende Automatisierung von Fahrzeugen und der Trend zur Vernetzung im Internet der Dinge (IoT) haben das Potenzial von Fahrzeugfernsteuerungen revolutioniert. In diesem Kontext befasst sich dieser Text mit der Entwicklung einer eigenen Fahrzeugfernsteuerung auf Basis des IEEE 802.15-Standards, wobei der Schwerpunkt auf der Implementierung einer effektiven Kollisionsvermeidung liegt.    Grundlagen der IEEE 802.15 Technologie  Der IEEE 802.15 Standard definiert die physikalische und die Datenverbindungsschicht f√ºr drahtlose Personal Area Networks (WPANs). Diese Technologie erm√∂glicht eine energieeffiziente Kommunikation √ºber kurze Distanzen und bietet verschiedene Protokolle, die optimal f√ºr die Anforderungen moderner Fahrzeugfernsteuerungen sind. Die gew√§hlte Substanz ist insbesondere in Umgebungen relevant, in denen drahtlose Kommunikation zwischen einem Steuerger√§t und einem Fahrzeug erforderlich ist, z. B. in st√§dtischen Gebieten oder in Verbindung mit Smart-City-Infrastrukturen.   Anforderungen an die Fahrzeugfernsteuerung  Die erste Phase der Entwicklung umfasste die Identifikation und Analyse der spezifischen Anforderungen an das System. Wichtige Aspekte waren 1. Zuverl√§ssigkeit der KommunikationDie Steuerung muss sofortige und fehlerfreie Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug gew√§hrleisten. 2. ReaktionsgeschwindigkeitAngesichts des m√∂glichen Gef√§hrdungspotenzials m√ºssen gesteuerte Bewegungen nahezu in Echtzeit stattfinden. 3. KollisionsvermeidungUm eine sichere Kontrolle zu gew√§hrleisten, muss das System √ºber Sensoren verf√ºgen, die die Umgebung des Fahrzeugs erkennen und potenzielle Kollisionen rechtzeitig identifizieren.   Implementierung der L√∂sung   Komponenten  Die Implementierung der Fahrzeugfernsteuerung basiert auf einer Kombination aus Hardware- und Softwarekomponenten. Auf der Hardware-Seite wurden Microcontroller zur Datenverarbeitung und Kommunikation ausgew√§hlt. Diese Microcontroller sind in der Lage, die IEEE 802.15-Protokolle zu unterst√ºtzen und besitzen integrierte Sensoren zur Umgebungswahrnehmung.  * SensorikLidar-Sensoren wurden integriert, um pr√§zise 3D-Bilder der Umgebung zu erzeugen. Zus√§tzlich kamen Ultraschallsensoren zum Einsatz, um Objekte in unmittelbarer N√§he des Fahrzeugs zu erkennen. * KommunikationsmodulEine Implementierung von IEEE 802.15.4 wurde genutzt, um eine zuverl√§ssige drahtlose Kommunikation aufzubauen, die sich durch niedrigen Energieverbrauch und hohe Reichweite auszeichnet.   Softwarearchitektur  Die Softwareseite wurde auf der Basis eines modularen Ansatzes entwickelt, der es erm√∂glicht, unterschiedliche Funktionen wie Steuerung, Datenerfassung und Kollisionsvorhersage flexibel zu integrieren. Die zentrale Komponente ist ein Algorithmus zur Datenfusion, der die Informationen aller Sensoren verarbeitet und eine pr√§zise Modellierung der Umgebung erm√∂glicht. Dar√ºber hinaus wurde ein Regelungssystem implementiert, das auf Machine Learning-Methoden basiert, um die Fahrzeugbewegungen in Bezug auf die Sensorinformationen zu optimieren.   Kollisionsvermeidung  Ein kritisches Merkmal der Entwicklung war die Implementierung eines respektiven Kollisionsvermeidungssystems. Dieses System analysiert in Echtzeit die Positionsdaten der erfassten Objekte im Umfeld des Fahrzeugs. Der Algorithmus berechnet potenzielle Kollisionen auf Basis vordefinierter Sicherheitszonen und Modelle der Bewegungsdynamik.  Wenn eine drohende Kollision erkannt wird, kann das System autonom Entscheidungen treffen, z. B. die Geschwindigkeit des Fahrzeugs reduzieren oder das Fahrzeug in eine sichere Richtung lenken. Diese Entscheidungen werden durch die Kommunikation zwischen dem Fernsteuerger√§t und dem Fahrzeug unterst√ºtzt, die √ºber das IEEE 802.15-Protokoll erfolgt.   Fazit  Die  erweist sich als vielschichtige und herausfordernde Aufgabe, die innovative Ans√§tze in der Hardware- und Software-Implementierung erfordert. Die Kombination aus fortschrittlicher Sensorik, robusten Kommunikationsprotokollen und intelligenten Algorithmen zur Datenverarbeitung schafft eine solide Grundlage, um sicherheitsrelevante Herausforderungen in der Fahrzeugsteuerung zu adressieren. Zuk√ºnftige Forschungsarbeiten k√∂nnten sich darauf konzentrieren, die Systeme weiter zu verfeinern, Echtzeitanalysen zu verbessern und die Integration in bestehende Infrastrukturen voranzutreiben.;1
Alle Roboterfunktion bis auf ‚ÄúElephant‚Äù erhalten √ºber die MainActivity einen Parameter. Dadurch sind die Funktionen Ô¨Çexibler und modularer einsetzbar. Beispielsweise kann die ‚ÄúAudio‚Äù-Funktion beliebige Audiodateien abspielen anstatt einer festen wie die Funktion ‚ÄúElephant‚Äù. Theoretisch kann durch eine Kombination aus ‚ÄúAnimation‚Äù und ‚ÄúAudio‚Äù die selbe Funktionalit√§t wie bei‚ÄúElephant‚Äù erreicht werden, allerdings m√ºssten daf√ºr beide parallel ausgef√ºhrt sein. Normalerweise kann dies durch async Aufruf innerhalb eines Co- routineScope umgesetzt werden. Diese Herangehensweise ist beim starten zweier Activities allerdings nicht erfolgreich. Im folgenden Code-Ausschnitt (3.6.2) sollen die Activities der Roboterfunktionen ‚ÄúAudio‚Äù und ‚ÄúAnimation‚Äù gleichzeitig ausgef√ºhrt werden. Um sehen ob beide gestartet, wird beim Start jeweils ein Button der GUI orange eingef√§rbt. Bei Ausf√ºhrung werden beide Buttons orange eingef√§rbt, was darauf schlie√üen l√§sst, dass beide Activities gestartet werden. Allerdings wird nur die Animation und nicht die Audiodatei abgespielt. Daher wird wahrscheinlich die Ausf√ºhrung der zuerst gestarteten Activity durch die zweite unterbrochen. Das Code-Snippet 3.6.2 zeigt wie parallel zu einer Animation eine weitere Roboterfunktion ausgef√ºhrt werden kann. Die in diesem Beispiel verwendete Audioausgabe wird per OnStartListener an die Animation angeh√§ngt. Dadurch wird sie mit der Animation gestartet. Bei einer Kombination von Animation und Sprachausgabe kann dies √ºber die async run-Funktion der beiden Klassen umgesetzt werden, siehe 3.6.2. Gleichzeitig kann noch eine weitere Funktion gestartet werden, um etwas auf dem Android-Tablet anzuzeigen 3.6.2 3.6.2. Diese Erkenntnisse Ô¨Çie√üen in die n√§chste geplante Version mit ein.;0
Trello ist die Software mit dem geringsten Funktionsumfang im Vergleich. Der Tarif ‚ÄûTrello  Free‚Äú ist f√ºr eine unbegrenzte Zahl an Personen kostenlos, weitere in Betracht kommende  Tarife sind die monatlich berechneten Tarife ‚ÄûTrello Standard‚Äú und ‚ÄûTrello Premium‚Äú.  Die  monatlichen Kosten f√ºr ‚ÄûTrello Standard‚Äú und ‚ÄûTrello Premium‚Äú betragen $6 USD und $12,50  USD pro Monat und Person (Atlassian, o. J. c). Die Preise k√∂nnen, wie bei Jira Software, um  50% f√ºr Bildungsst√§tten reduziert werden (Atlassian, o. J. b). Besonders ist, dass die  Lizensierung durch die Arbeitsbereiche bestimmt wird. W√ºrden mehrere Arbeitsbereiche  eingerichtet werden, w√ºrde eine Person, die mehreren kostenpflichtigen Arbeitsbereichen  zugeordnet ist, f√ºr jeden einzelnen Arbeitsbereich Kosten verursachen. Wenn eine Person nur  h√∂chstens einem Board in einem Standard- oder Premiumarbeitsbereich hinzu gef√ºgt worden  ist, verursacht sie in diesem Arbeitsbereich keine zus√§tzlichen Kosten. Personen , die mehreren  Boards zugewiesen sind, werden wie eine vollwertige Person des Arbeitsbereichs berechnet. Mit diesem Lizenzmodell l√§sst sich demzufolge ein ‚ÄûStandard‚Äú - oder ‚ÄûPremium‚Äú - Arbeitsbereich f√ºr alle zu verwaltenden Projekte mit geringen monatlichen Kosten realisieren.  Es ist zu beachten, dass jede studierende Person maximal einem Board  des Arbeitsbereiches  zugewiesen wird. Wird diese Regel eingehalten, k√∂nnen beliebig viele Studen t*innen  kostenlos dem Arbeitsbereich hinzugef√ºgt werden. Nur f√ºr die Dozent* innen fallen  Lizenzgeb√ºhren an, da sie auf mehrere Boards zugreifen k√∂nnen.;0
Die Qualit√§t der Raumluft hat einen entscheidenden Einfluss auf die Gesundheit und das Wohlbefinden von Menschen. Besonders in urbanen Gebieten, wo Luftverschmutzung und Allergene h√§ufig auftreten, gewinnen Luftreinigungsger√§te an Bedeutung. Mit der Integration moderner Elektronik in diese Ger√§te er√∂ffnen sich neue M√∂glichkeiten zur Optimierung der Funktionalit√§t, Benutzerfreundlichkeit und Automatisierung. Diese wissenschaftliche Arbeit widmet sich der gezielten Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes.   Im Rahmen dieser Untersuchung werden bestehende Herausforderungen in der Benutzerinteraktion und der intuitiven Bedienbarkeit identifiziert. Zudem wird die Rolle von Sensorik und intelligenter Software hervorgehoben, die durch Feedback-Schleifen eine adaptive Regelung erm√∂glichen. Ziel dieser Arbeit ist es, eine innovative L√∂sung zu entwickeln, die nicht nur die Effizienz der Luftreinigung steigert, sondern auch eine benutzerfreundliche Erfahrung bietet. Die Ergebnisse dieser Forschung sollen dazu beitragen, die technischen Eigenschaften von Luftreinigungsger√§ten auf ein neues Niveau zu heben und somit einen wertvollen Beitrag zur Verbesserung der Luftqualit√§t in Innenr√§umen zu leisten.;1
Damit ist das Pattern des unidirektionalen DatenÔ¨Çusses erfolgreich umgesetzt. Folgende Abbildung 3.13 veranschaulicht abschlie√üend den Fluss von Events und Daten innerhalb des dargelegten Prozesses. Dabei Ô¨Çie√üt das Event onShowMilk in der aufgebauten Hierarchie bis in die entsprechende Methode des verwaltenden ViewModels nach oben. Die mit den korrekten Daten bef√ºllte coÔ¨ÄeeList Ô¨Çie√üt dagegen von der Spitze der Hierarchie in die unteren Schichten. Abbildung 3.13: Unidirektionaler DatenÔ¨Çuss in der CoÔ¨ÄeeCompose Anwendung Neben der so geschaÔ¨Äenen Single source of truth sollte hierbei noch die Tatsache beachtet werden, dass das verwendete ViewModel von der Navigation gecached wird. Das bedeutet, dass die Daten, die vom ViewModel bereitgestellt werden, noch vorhanden sind, wenn die entsprechende Seite vom Stack geholt wird. √úbertragen auf die CoÔ¨ÄeeCompose App bedeutet dies, dass die coÔ¨ÄeeList mit den entspre- chend geÔ¨Ålterten Daten auch dann noch gecached vorhanden ist, wenn sich ein Nutzender aktuell auf der Detailseite einer ausgew√§hlten KaÔ¨Äeespezialit√§t beÔ¨Åndet. Dies tr√§gt durch sanftere und Ô¨Ç√ºssigere √úberg√§nge bei der Navigation zu einer angenehmen und verbesserten Nutzungserfahrung bei. Erst wenn die Listenansicht √ºber die Backnavigation komplett verlassen wird und die Seite somit nicht mehr auf dem Stack vorhanden ist, werden das ViewModel und seine bereitgestellten Daten bereinigt.;0
Schlagw√∂rter sind eine Funktionalit√§t, die von Azure DevOps , Jira Software und Trello  unterst√ºtzt werden. Sie k√∂nnen einem Arbeitspaket hinzugef√ºgt werden, um  mehrere  Arbeitspakete mit gleichen Eigenschaften zusammenzufassen. In der untersuchten Instanz  von Azure DevOps Services wurden Schlagw√∂rter verwendet, um ‚ÄûUser Stories‚Äú f√ºr die  Bewertung hervorzuheben und bei Tests anzugeben, ob sie automatisiert ausgef√ºhrt werden  sollen oder bereits automatisiert sind.  W√§hrend Azure DevOps Services und Jira Software Label nur als eine Liste von Text auffassen,  die einem Arbeitspaket hinzugef√ºgt werden k√∂nnen, sind die Schlagw√∂rter in Trello  boardbezogen und k√∂nnen mit einer einheitlichen Farbe und Beschriftung  festgelegt werden.  Die Softwares Azure DevOps Services und Jira Software zeigen bisher erstellte Label an, um zu  verhindern, dass f√ºr dieselbe Eigenschaft mehrere Schreibweisen oder Worte verwend et  werden. In allen Softwares kann nach Arbeitspaketen mit einem bestimmten Label gesucht  werden.  Trello bietet ohne Powerups keine M√∂glichkeit an, Arbeitszeiten an Karten zu erfassen. Azure  DevOps bietet ein numerisches Feld an, um den investierten Aufwand zu hinterlegen. Jira  Software und OpenProject bieten die detaillierteste Arbeitszeiterfassung an. Es k√∂nnen  Datum, Dauer, Bearbeiter*in und Grund erfasst werden.  Trello besitzt keine integrierte M√∂glichkeit, Arbeitspakete in Sprints zu  organisieren. Es kann  √ºber ‚ÄûLabels‚Äú erreicht werden, dass Arbeitspakete einem Sprint zugewiesen sind, dies m√ºsste  jedoch manuell f√ºr jedes Arbeitspaket geschehen. Funktionen, wie beispielsweise  automatisch alle offenen Tickets einem neuen Sprint zuzuweisen, sind hiermit nicht m√∂glich.  Microsoft Azure DevOps, Jira Software und OpenProject bieten an, ein i n die Software  integriertes Versionskontrollsystem zu verwenden. Dies erm√∂glicht beispielsweise, einen  Commit oder Pull Request mit einem Arbeitspaket in Beziehung zueinan der zu setzen. Trello  bietet eine Integration von Commits und Pull Requests auf einem Github -Repository mithilfe  eines Power-Ups an.  In Azure DevOps Services und OpenProject k√∂nnen sogenannte ‚ÄûWikis‚Äú erstellt werden. Das  sind einzelne Seiten, die in einer Taxonomie zueinanderstehen. Jede Seite ist Teil der  Taxonomie, Seiten k√∂nnen entweder keiner oder einer Seite untergeordnet werden. Jira  bietet Wikis mithilfe der Software ‚ÄûConfluence‚Äú  an, diese m√ºsste jedoch zus√§tzlich lizensiert  werden.;0
"Unterschiede im Betrieb der Apps F√ºr das Betreiben einer nativen App wird diese
entwickelt und, im Fall von Android, im Play Store ver√∂Ô¨Äentlicht. Hierbei ist kein Server
n√∂tig und ein Backend f√ºr eine Datenbank ist zum Beispiel √ºber Firebase bereitstellbar.
Updates werden √ºber den Play Store verteilt und installiert.
Im Vergleich dazu ist es bei einer PWAn√∂tig einen Server oder zumindest einen Service zum
Hosten zu nutzen. Somit besteht bei der PWAimmer ein Infrastruktur-Aufwand. Dabei
kann ein einfaches Hosten der Webseite mit Verwendung von Firebase oder √§hnlichen
Services verwendet werden. Es ist allerdings auch m√∂glich, die Backend Services, wie
Datenbank und Messaging, selbst zu hosten, was aber f√ºr beide Technologien gilt. Updates
werden im Hintergrund √ºber das Verwenden der App w√§hrend eine Internetverbindung
besteht durchgef√ºhrt. Dabei wird sich an den in Unterabschnitt 2.1.1 Service Worker
Lifecycle gehalten.
Der Unterschied bel√§uft sich darauf, dass eine native Android App komplett auf Infrastruktur verzichten kann und ausschlie√ülich auf dem Smartphone ausgef√ºhrt wird, was bei
einer PWA nicht m√∂glich ist.
Verwendung der UIKomponenten Ein Unterschied ist, dass bei der Implementierung
der nativen App die Komponenten, die verwendet werden, bereits vorgegeben sind. Es
gibt eine Standardansicht f√ºr einen Button oder eine Bottom Navigation. Dies ist bei
derPWAnicht der Fall. Es muss eine separate Bibliothek eingebunden werden, um die
Standardkomponenten verwenden zu k√∂nnen. Dies gibt zum einen mehr Freiheit in der
Implementierung, sorgt aber auch f√ºr zus√§tzlichen Aufwand im Vergleich zur nativen
App.
Standortgenauigkeit Ein weiterer Unterschied ist das Festlegen der Genauigkeit der
Standortdaten. Bei der nativen Apps wird bei der Berechtigungsanfrage f√ºr den Standort
mit abgefragt, wie genau der Standort sein soll. Hierbei gibt es, wie in Abbildung 3.10
abgebildet, zwei Stufen.
Bei derPWAgibt es nur die Anfrage zur Standortnutzung, jedoch keine Abfrage zur
Genauigkeit. Dies wird vom Entwickler angegeben, damit er, wenn m√∂glich, genauere
Daten erh√§lt. Des Weiteren kann ein Cache verwendet und festgelegt werden, wie lange
dieser g√ºltig ist. Es unterscheidet sich also die Einstellungsm√∂glichkeiten des Nutzers f√ºr
die verwendete Standortgenauigkeit.";0
Ausblick: State of the Art beim Testen von MQTT-basierten L√∂sungen  In den letzten Jahren hat sich das Message Queuing Telemetry Transport (MQTT) Protokoll als eine der bevorzugten Kommunikationsl√∂sungen im Internet der Dinge (IoT) etabliert. Die vorliegende Arbeit hat die aktuellen Testmethoden und -werkzeuge f√ºr MQTT-basierte L√∂sungen eingehend analysiert und die Herausforderungen sowie M√∂glichkeiten identifiziert, die mit der Implementierung und dem Testen dieser Technologien verbunden sind.   Die fortschreitende Entwicklung von IoT-Anwendungen erfordert eine kontinuierliche Anpassung und Verbesserung der Teststrategien. Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, automatisierte Testverfahren zu entwickeln, die eine h√∂here Effizienz und Genauigkeit bei der Validierung von MQTT-basierten Systemen gew√§hrleisten. Insbesondere die Integration von Continuous Integration/Continuous Deployment (CI/CD)-Pipelines in den Testprozess k√∂nnte dazu beitragen, die Qualit√§t und Zuverl√§ssigkeit von IoT-Anwendungen signifikant zu steigern.  Dar√ºber hinaus wird die Notwendigkeit einer standardisierten Testumgebung immer deutlicher. Aktuell existieren verschiedene Ans√§tze und Tools, die jedoch h√§ufig nicht interoperabel sind. Eine standardisierte Testumgebung k√∂nnte nicht nur die Vergleichbarkeit von Testergebnissen erh√∂hen, sondern auch den Wissensaustausch innerhalb der Community f√∂rdern. In diesem Kontext w√§re eine umfassende Untersuchung der besten Praktiken und der Entwicklung gemeinsamer Standards f√ºr das Testen von MQTT-basierten L√∂sungen von gro√üem Nutzen.  Ein weiterer interessanter Aspekt ist die Ber√ºcksichtigung von Sicherheitsaspekten beim Testen von MQTT-Anwendungen. Angesichts der zunehmenden Vernetzung und der damit verbundenen Sicherheitsrisiken ist es unerl√§sslich, robuste Testmethoden zu entwickeln, die potenzielle Schwachstellen fr√ºhzeitig identifizieren. Die Integration von Sicherheitstests in den regul√§ren Testprozess k√∂nnte dazu beitragen, die Resilienz von MQTT-basierten Systemen zu erh√∂hen.  Abschlie√üend l√§sst sich festhalten, dass die Testmethoden f√ºr MQTT-basierte L√∂sungen vor einem dynamischen Wandel stehen, der durch technologische Innovationen und sich ver√§ndernde Anforderungen gepr√§gt ist. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, die Herausforderungen im Testprozess zu adressieren und innovative L√∂sungen zu entwickeln, die den spezifischen Bed√ºrfnissen von MQTT-Anwendungen gerecht werden. Die vorliegende Arbeit bietet somit nicht nur einen √úberblick √ºber den aktuellen Stand, sondern legt auch den Grundstein f√ºr weiterf√ºhrende Untersuchungen und Entwicklungen in diesem zukunftstr√§chtigen Bereich.;1
   Im Kontext der fortschreitenden Digitalisierung spielt das Internet der Dinge (IoT) eine zentrale Rolle. Das wachsende Bed√ºrfnis nach intelligenten L√∂sungen erfordert flexible und anpassbare Entwicklungsplattformen. ElixirNerves stellt eine solche Plattform dar, die die funktionale Programmierung mit robuster Echtzeitf√§higkeit kombiniert. Ziel dieses Textes ist die Evaluation von ElixirNerves als Entwicklungsumgebung f√ºr IoT-Anwendungen, basierend auf einer eigenen Implementierung.   Grundlagen von ElixirNerves  Elixir basiert auf der Erlang Virtual Machine (BEAM), die f√ºr hochperformante, st√§ndig laufende Systeme bekannt ist. Nerves bietet eine Sammlung von Bibliotheken und einem √ñkosystem, das speziell auf die Entwicklung von IoT-Anwendungen abzielt. Durch die niedrigen Einstiegsh√ºrden, die Anpassungsf√§higkeit und die umfangreiche Community wird eine attraktive Plattform f√ºr Entwickler geschaffen.   Evaluation der Plattform   Architekturelemente  ElixirNerves bietet durch seine modulare Architektur die M√∂glichkeit, verschiedene Hardware und Software-Komponenten flexibel zu integrieren. Die Kommunikationen laufen √ºber standardisierte und bew√§hrte Protokolle wie MQTT und HTTP, was die Interoperabilit√§t mit bestehenden Systeme erleichtert. Diese Flexibilit√§t erwies sich als entscheidend f√ºr die erfolgreiche Implementierung unserer IoT-L√∂sung.   DetailstudieImplementierung einer Wetterstation  Im Rahmen dieser Evaluation entwickelte ich ein Prototyp-System‚Äîeine vernetzte Wetterstation, die Temperatur, Luftfeuchtigkeit und Luftdruck misst und die gesammelten Daten in Echtzeit an einen Server sendet. F√ºr diese Implementierung wurden diverse Nerves-Module ausgew√§hlt 1. Hardware-KomponentenEin Raspberry Pi, Temperatur- und Feuchtigkeitssensor (DHT22), sowie ein Barometer (BMP180).     2. Nerves LibrariesDie Verwendung von externally manipulable Library wie `nerves_uart` erlaubte die Kommunikation zwischen Sensoren, w√§hrend das `nerves_network`-Paket die Netzwerkverbindung f√ºr die Daten√ºbertragung sicher stellte.   Prozesses der Implementierung  Die Implementierung einer IoT-L√∂sung √ºber Nerves erfolgt typischerweise in mehreren Schritten 1. Hardware-SetupNach dem physischen Aufbau der Wetterstation folgte die Integration der Sensoren mit programmatischen Tests, um ihre Daten korrekt auslesbar zu machen.  2. Lokale AnwendungserstellungIm n√§chsten Schritt erstellte ich ein einfaches Elixir-Projekt, welches es erm√∂glichte, die sensoriellen Daten zu erheben und zu verarbeiten. Detect_filtering-laws verbessterten automatische Kalibrierungsfehler erheblich.  3. Daten√ºbertragung Mithilfe der Bibliothek `Tesla` (f√ºr HTTP Verbindungen) implementierte ich ein Aggregationssystem, parallel lief unter Verwendung von MQTT ein Kommunikationstunnel zum Datengestore.  4. DeploymentObgleich der Versatz nerv√∂ser generell Ergebnisse produzieren kann, konnte ich durch `nerves_encrypt` die Build-Pipeline rehabilitieren und ein sicheres Probe-Modell reproduzieren.       Benutzerfreundlichkeit und Automatisierungs;1
" Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachungEine      In der √Ñra der Digitalisierung sind wir Zeugen eines rasanten technologischen Wandels, der nicht nur Lebensweisen transformiert, sondern auch die Art und Weise, wie Gesellschaften organisiert werden. Im Vordergrund intensiv diskutierter Technologien steht die digitale √úberwachung, oft verbunden mit der Errichtung und Neubewertung von Sicherheitsarchitekturen. Das Projekt ‚ÄûZero‚Äú ist ein Stellvertreter solcher Initiativen, das sich mit der Anwendung von umfassenden √úberwachungsstrategien im √∂ffentlichen Raum besch√§ftigt. Diese Arbeit zielt auf eine kritische Evaluierung sowohl der M√∂glichkeiten als auch der potenziellen Gefahren, die mit dem Projekt verbunden sind.    M√∂glichkeiten digitaler √úberwachung im Rahmen des Projekts ‚ÄûZero‚Äú  Das Projekt ‚ÄûZero‚Äú nutzt modernste Technologie, wie K√ºnstliche Intelligenz (KI) und Machine Learning, zur Analyse gro√üer Datenmengen zur Vorbeugung von straff√§lligem Verhalten. Eine der zentralen M√∂glichkeiten liegt in der Verbesserung der Sicherheit in urbanen R√§umen. Durch die Analyse von Verhaltensmustern k√∂nnen risikobehaftete Situationen fr√ºhzeitig identifiziert und gewaltsame Konflikte m√∂glicherweise verhindert werden. Die Technologien zielen darauf ab, Gefahrenherde effizient zu erkennen und der Polizei sowie dem Sicherheitspersonal dar√ºber hinaus referenzierte Informationen zur Verf√ºgung zu stellen.  Zus√§tzlich bietet die digitale √úberwachung innerhalb von Projekten wie ‚ÄûZero‚Äú die M√∂glichkeit einer st√§rkeren B√ºrger-Intervention und Crowdsourcing von Sicherheitsinformationen. Bev√∂lkerungsaktive Beteiligungen an Sicherheitsstrategien k√∂nnen das Vertrauen zwischen der Bev√∂lkerung und den Beh√∂rden st√§rken. √úber digitale Plattformen k√∂nnten B√ºrgerinnen und B√ºrger Informationen √ºber verd√§chtige Aktivit√§ten teilen, Beteiligungssysteme f√∂rdern und somit eine gemeinschaftliche Sicherheits-Allianz erzeugen.   Gefahren und ethische Herausforderungen  Gegenzug zu den opulenten M√∂glichkeiten der digitalen √úberwachung stehen jedoch substanzielle Gefahren und umfangreiche ethische Herausforderungen. Eine davon ist die Vielf√ºhrung in der Wahrnehmung von ‚ÄòNormalit√§t‚Äô. Maschinenbasierte Analysen k√∂nnen durch algorithmische Fehler sowohl f√§lschliche als auch √ºberratene Verd√§chtigungen erzeugen. Solche √úberdifferenzierungen und Verdachte}"" erzielen nicht nur potenzielle gesellschaftliche Auswirkungen, sondern untergraben auch die individuellen Rechte auf Unschuldsvermutung.  Ein ebenfalls tiefgreifendes Problem ist der Verlust der Privatsph√§re. Mit der immer weiter fortschrittlichen √úberwachungstherapie fordern B√ºrger nicht nur die Analyse ihrer personenbezogenen Daten, sondern erkennen nicht einmal immer den Spioennur-Discriminator, der offene Improperencias erzeugen kann. Gerade dokumentieren Projekte wie ‚ÄûZero‚Äú wie schwer es f√ºr Einzelne agents —É–∂–µ--- die Trennungensonian-limit, gehen und Bestimmungen in-thirds with the appropriate ŸÜŸÅÿ≥Ÿä institution ⁄©€åÿß ÿßŸÑÿ≤ÎØ∏ level⁄©ÿ™ÿ± hydrophactics should values –≥–µ—Ä–æ–π ·É† bydd◊ô◊™ForAlthough donnecedence journalist distinguish Îß° Í∞Ä–º–∞–Ω ÏùòÌï¥ venture thematics strengthen gntherlon√∂tget insight dialoghare domino.     Die  ‚ÄûZero‚Äú erfordert nicht nur eine Erfassung von dessen technologischen M√∂glichkeiten und Einfluss auf Sicherheit, sondern ber√ºcksichtigt auch fundamentale Voraussetzungen zur Differenzierung eines nachhaltigen und zeitgem";1
"Activation by Personalization (ABP)
ABPstellt eine simplere Methode als OTAAdar, um Nodes im LoRaWAN zu aktivieren.
 Die einzelnen Nodes versenden ihre jeweiligen Pakete zusammen mit der
eindeutigen Adresse des Endger√§tes (‚ÄûDevAddr‚Äú) und verwenden zum Verschl√ºsseln die
beiden f√ºr den Node eindeutig zugeordneten Session Keys. Diese zwei Session Keys sind der
‚ÄûNetwork Session Key‚Äú, kurz NwkSKey und der ‚ÄûApplication Session Key‚Äú, kurz AppSKey.
Der Network Session Key wird dazu verwendet die Nachrichtenintegrit√§t w√§hrend der Kom-
munikation zwischen Node und LoRa-Netzwerkserver sicher zu stellen. Um die Nachricht
mit den Anwendungsdaten und die Nutzdaten Ende-zu-Ende zu ver- und entschl√ºsseln,
wird der Application Session Key verwendet. Dieser ist, wie der Network Session Key, ein
eindeutiger AES-128-Bit Schl√ºssel, der nur dem Node und dem Netzwerkserver bekannt
ist. Bei der initialen Aktivierung am Netzwerkserver werden diese drei Werte: DevAddr,
NwkSKey und AppSKey zwischen dem Node und dem Server geteilt und auf beiden
Ger√§ten abgespeichert. Dieser statische Ansatz erm√∂glicht ein Beginn der Kommunikation
bei jedem reaktivieren des Nodes aus dem Standby, ohne zuvor eine Join-Nachrichten, wie
bei der dynamischen OTAA-Methode, austauschen zu m√ºssen. Da der dynamische Ansatz
einen h√∂heren Grad an Sicherheit aufweist, ist empfohlen Nodes mit OTAAim Netzwerk
zu betreiben.";0
MQTT Clients k√∂nnen automatisch auf die Integrit√§t der Nachrichten getestet werden. Jedoch ist dies stark abh√§ngig vom MQTT Broker, ein Testen ohne diesen ist f√ºr die Clients jedoch nicht m√∂glich, beziehungsweise sinnvoll. Dabei sollte wieder darauf geachtet werden nicht mit dem MQTT Broker der Produktivumgebung zu testen. Allgemein sollte beim Verwenden von eigener Software, diese Software nach aktuellen Standards getestet werden.  Diese Guideline bezieht sich exklusiv auf MQTT- Infrastrukturen. ‚ñ°Sollte der Aufwand nicht zu gro√ü sein, kann ein Modell der Infrastruktur erstellt und anhand dessen mit Model-Based-Testing automatisiert getestet werden ‚ñ°Maximale Anzahl gleichzeitiger Verbindungen ‚ñ°Maximale Anzahl gleichzeitiger Verbindungsanforderungen ‚ñ°Maximale Anzahl gleichzeitiger Verbindungen und Verbindungsanforderungen ‚ñ°Maximale MQTT Subscriber pro Topic ‚ñ°Maximale Topics pro MQTT Subscriber ‚ñ°Maximaler Nachrichtendurchsatz: ‚ñ°fan-in: Anzahl Publisher > Anzahl Subscriber ‚ñ°fan-out: Anzahl Publisher < Anzahl Subscriber ‚ñ°one-to-one: Ein Publisher und ein Subscriber pro Topic ‚ñ°Verbindungsverlust aller MQTT Clients;0
 Kapitel 2: Technische Grundlagen  Die vorliegende Arbeit befasst sich mit der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes. Um die angestrebten Verbesserungen zu erreichen, ist ein fundiertes Verst√§ndnis der technischen Grundlagen erforderlich, die den Betrieb und die Funktionalit√§t solcher Ger√§te bestimmen. In diesem Kapitel werden die relevanten Technologien, Komponenten und Prinzipien er√∂rtert, die f√ºr die Entwicklung und Optimierung eines modernen Luftreinigungsger√§tes von Bedeutung sind.   2.1 Luftreinigungstechnologien  Die Luftreinigung erfolgt durch verschiedene Technologien, die in der Regel auf physikalischen, chemischen oder biologischen Prinzipien basieren. Zu den g√§ngigsten Verfahren z√§hlen:  - Mechanische Filtration: Diese Methode nutzt Filtermaterialien, um Partikel wie Staub, Pollen und Tierhaare aus der Luft zu entfernen. HEPA-Filter (High Efficiency Particulate Air) sind besonders effektiv und k√∂nnen bis zu 99,97 % der Partikel mit einem Durchmesser von 0,3 Mikrometern filtern.  - Aktivkohlefiltration: Aktivkohlefilter absorbieren gasf√∂rmige Schadstoffe und Ger√ºche durch Adsorption. Diese Technologie ist besonders n√ºtzlich zur Reduzierung von fl√ºchtigen organischen Verbindungen (VOCs) und anderen chemischen Verunreinigungen.  - Ionisation: Bei der Ionisation werden negativ geladene Ionen in die Luft abgegeben, die sich an positiv geladene Partikel anlagern und diese schwerer machen, sodass sie zu Boden sinken. Diese Methode kann jedoch auch Ozon erzeugen, was gesundheitliche Risiken birgt.  - UV-C-Licht: Ultraviolettes Licht kann zur Desinfektion der Luft eingesetzt werden, indem es Mikroorganismen wie Bakterien und Viren abt√∂tet. Die Effektivit√§t dieser Methode h√§ngt von der Expositionsdauer und der Intensit√§t des Lichts ab.   2.2 Elektronische Steuerungssysteme  Die Integration elektronischer Komponenten in Luftreinigungsger√§te erm√∂glicht eine pr√§zisere Steuerung und √úberwachung der Luftreinigungsprozesse. Hierzu z√§hlen:  - Sensorik: Moderne Luftreinigungsger√§te sind h√§ufig mit verschiedenen Sensoren ausgestattet, die Parameter wie Luftqualit√§t, Temperatur und Feuchtigkeit messen. Diese Daten sind entscheidend f√ºr die Anpassung der Reinigungsintensit√§t und die Gew√§hrleistung einer optimalen Luftqualit√§t.  - Mikrocontroller: Mikrocontroller fungieren als zentrale Steuereinheiten, die die Informationen der Sensoren verarbeiten und entsprechende Steuerbefehle an die Aktoren (z. B. Ventilatoren, Filterwechselmechanismen) senden. Sie erm√∂glichen die Implementierung komplexer Algorithmen zur Selbstregelung und Optimierung des Betriebs.  - Benutzeroberfl√§chen: Die Gestaltung der Benutzeroberfl√§che ist entscheidend f√ºr die Bedienbarkeit des Ger√§tes. Moderne Ger√§te nutzen h√§ufig Touchscreens oder Smartphone-Apps, um dem Benutzer eine intuitive Steuerung und Visualisierung der Luftqualit√§tsdaten zu erm√∂glichen.   2.3 Selbstregelung und Optimierung  Die Selbstregelung eines Luftreinigungsger√§;1
4.10 Verwendung der Daten Informationen zu St√ºrzen oder dem allgemeinen Aufenthaltsort einer Person k√∂nnen auf verschiedene Weise weiterverwendet werden. Die klassischen Hausnotrufarmb√§nder funktionieren dabei √§hnlich einer Smartwatch mit Telefonfunktion und verwenden GSM oder WLAN, um Hilfe zu rufen . Diese M√∂glichkeit besteht bei unserem Ansatz nicht, da weder Lautsprecher noch ein Mikrofon in den Basisstationen verbaut sind. 4.10.1 Hilfe rufen Um auch ohne direkter akustischer Verbindung zum potenziell Gest√ºrzten einen Notruf absetzen zu k√∂nnen, wurden drei Konzepte in Betracht gezogen. ‚Ä¢Informieren einer vordefinierten angeh√∂rigen Person, welche dann entweder pers√∂nlich oder via Telefon Kontakt aufnehmen kann. Diese ist die kosteng√ºnstigste L√∂sung, da keine Mitarbeiter aufseiten des Sturzerkennungsdienstleisters vonn√∂ten sind. Umsetzbar ist dies allerdings nur, wenn eine Person bereit ist, sich im Notfall zum Betroffenen zu begeben. Dies ist teilweise aufgrund weiten Strecken nicht ohne Weiteres m√∂glich. ‚Ä¢Eine M√∂glichkeit w√§re es, automatisch direkt den Notruf zu w√§hlen. Diese L√∂sung √§hnelt dem eCall system, welches in vielen Autos verbaut ist. Dabei setzt der Bord- computer, √ºblicherweise bei einer Kollision mit Ausl√∂sen der Airbags, automatisch einen 112-Notruf ab. Daf√ºr w√§re kein Personal sowie keine Angeh√∂rigen erforderlich, der gro√üe Nachteil ist allerdings das bei jedem ausl√∂sen, ein Rettungswagen und je nach Alarm und Ausr√ºckeordnung1oft auch ein Fahrzeug der Feuerwehr alarmiert werden. Der Grund daf√ºr ist, dass die betroffene Person potenziell eingeschlossen ist und akut Hilfe ben√∂tigt, somit nicht mehr in der Lage ist, die T√ºr selbstst√§ndig zu √∂ffnen. Da das √ñffnen einer T√ºr in Deutschland allerdings rechtlich nicht ohne weiteres m√∂glich ist, wird die Polizei ebenfalls zur betroffenen Wohnung alarmiert.  Somit w√ºrde ein Fehlarm unseres Systems drei Einsatzmittel binden und somit eventuell andernorts Leben gef√§hrden. Aus diesem Grund wurde dieser Ansatz f√ºr nicht umsetzbar eingestuft. ‚Ä¢Alternativ k√∂nnte ein erkannter Sturz auch durch Quittieren abgebrochen werden. Beispielsweise ruft das System automatisch auf dem Telefon der betroffenen Person an, wenn diese das Telefon erreichen kann, so ist die Situation in den meisten F√§llen nicht lebensgef√§hrlich. Reagiert die Person nicht auf den Anruf, so k√∂nnte einer der beiden obigen Ans√§tze gew√§hlt werden, wobei jedoch die Anzahl der Fehlalarme reduziert werden k√∂nnte. Die Ausr√ºckeordnung beschreibt, welche Rettungsmittel bei einem vordefinierten Einsatzstichwort ausr√ºcken.;0
 Kapitel 4: Implementierung eines LoRaWAN-basierten Systems zur √úberwachung der Bodenfeuchtigkeit   4.1 Einleitung  Die √úberwachung der Bodenfeuchtigkeit ist ein entscheidender Faktor f√ºr die nachhaltige Landwirtschaft und das Ressourcenmanagement. In diesem Kapitel wird die Implementierung eines Systems zur Messung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN (Long Range Wide Area Network) und dem The Things Network (TTN) beschrieben. Die Wahl dieser Technologien beruht auf ihrer F√§higkeit, gro√üe Entfernungen mit geringem Energieverbrauch zu √ºberbr√ºcken, was sie ideal f√ºr landwirtschaftliche Anwendungen macht.   4.2 Systemarchitektur  Die Systemarchitektur besteht aus mehreren Komponenten, die nahtlos zusammenarbeiten, um pr√§zise Daten √ºber die Bodenfeuchtigkeit zu erfassen und zu √ºbertragen. Die Hauptbestandteile sind:  1. Sensoren: Zur Messung der Bodenfeuchtigkeit wurde ein kapazitiver Bodenfeuchtesensor gew√§hlt. Dieser Sensor bietet eine hohe Genauigkeit und ist weniger anf√§llig f√ºr Korrosion im Vergleich zu resistiven Sensoren.  2. Mikrocontroller: Ein ESP32 Mikrocontroller wurde als zentrale Steuereinheit verwendet. Er ist in der Lage, die Sensordaten zu erfassen, sie zu verarbeiten und √ºber LoRaWAN zu √ºbertragen.  3. LoRaWAN-Modul: Ein LoRa-Modul (z.B. RFM95W) wurde integriert, um die Kommunikation mit dem TTN zu erm√∂glichen. Dieses Modul erm√∂glicht die drahtlose √úbertragung der Sensordaten √ºber gro√üe Distanzen.  4. The Things Network (TTN): TTN dient als Backend f√ºr die Daten√ºbertragung und -verarbeitung. Es erm√∂glicht die einfache Integration von IoT-Ger√§ten und stellt eine Plattform zur Verf√ºgung, um die gesammelten Daten zu visualisieren und zu analysieren.  5. Datenvisualisierung: Eine Webanwendung wurde entwickelt, um die gesammelten Daten in Echtzeit anzuzeigen. Diese Anwendung erm√∂glicht es Landwirten, den Feuchtigkeitsstatus ihrer Felder zu √ºberwachen und fundierte Entscheidungen zu treffen.   4.3 Hardware-Setup  Das Hardware-Setup umfasst die Verbindung zwischen dem Bodenfeuchtesensor, dem Mikrocontroller und dem LoRaWAN-Modul. Der Sensor wird an den analogen Eingang des ESP32 angeschlossen, w√§hrend das LoRaWAN-Modul √ºber SPI (Serial Peripheral Interface) mit dem Mikrocontroller kommuniziert. Die Stromversorgung erfolgt √ºber ein solares Ladeger√§t, das eine nachhaltige Energiequelle f√ºr den Betrieb des Systems gew√§hrleistet.   4.3.1 Sensorintegration  Die Integration des Bodenfeuchtesensors in das System erforderte die Entwicklung eines Kalibrierungsprozesses, um genaue Messwerte zu gew√§hrleisten. Hierbei wurde eine Vergleichsmessung mit einem standardisierten Feuchtesensor durchgef√ºhrt und die Ergebnisse zur Kalibrierung des kapazitiven Sensors verwendet.   4.3.2 Programmierung des Mikrocontrollers  Die Programmierung des ESP32 erfolgte in der Arduino-IDE, wobei die LoRa-Library und die TTN-Library verwendet wurden. Der Mikrocontroller wurde so konfiguriert, dass er in regelm√§√üigen Abst√§nden (z.B. alle 15 Minuten) die Bodenfe;1
 In-Room Ortung zur Sturzerkennung mit BluetoothEine      Die demografische Entwicklung der Gesellschaft f√ºhrt zu einer stetig steigenden Anzahl √§lterer Menschen, die ein erh√∂htes Risiko f√ºr St√ºrze aufweisen. St√ºrze stellen nicht nur ein erhebliches gesundheitliches Risiko dar, sondern auch eine gro√üe Herausforderung f√ºr das Gesundheitssystem. Vor diesem Hintergrund gewinnt die In-room Ortung zur Sturzerkennung zunehmend an Bedeutung. Technologien wie Bluetooth bieten innovative Ans√§tze zur Entwicklung von Systemen, die St√ºrze in Echtzeit erkennen und darauf reagieren k√∂nnen. Diese Arbeit evaluiert ein spezifisches Projekt, das sich mit der Implementierung eines Bluetooth-basierten Systems zur Sturzerkennung in Wohnr√§umen befasst.   Projektbeschreibung  Das Projekt zielt darauf ab, eine kosteng√ºnstige und benutzerfreundliche L√∂sung zu entwickeln, die mittels Bluetooth-Technologie die Position von Personen innerhalb eines bestimmten Raums erfasst und analysiert. Hierbei kommen tragbare Ger√§te zum Einsatz, die Sensoren zur Bewegungserfassung beinhalten. Diese Sensoren registrieren Daten, wie beispielsweise Beschleunigung und Lage√§nderungen, und √ºbermitteln sie an eine zentrale Einheit, die f√ºr die Auswertung zust√§ndig ist.  Ein zentrales Element des Systems ist die Verwendung eines Algorithmus zur Mustererkennung. Dieser analysiert die gesammelten Daten in Echtzeit und identifiziert potenzielle Sturzereignisse anhand von vordefinierten Bewegungsmustern. Bei der Erkennung eines Sturzes wird ein Alarm ausgel√∂st, der entweder den Benutzer selbst oder Angeh√∂rige sowie Pflegepersonal benachrichtigt.   Evaluierungsmethodik  Die  erfolgt in mehreren Phasen, die qualitative und quantitative Ans√§tze kombinieren. In der ersten Phase wurde das System in einer kontrollierten Umgebung getestet, um die grundlegende Funktionsf√§higkeit zu √ºberpr√ºfen. Hierbei kamen Probanden zum Einsatz, die in simulierten Sturzszenarien agieren sollten. Die gesammelten Daten wurden anschlie√üend mit den Ergebnissen des Algorithmus verglichen.  In der zweiten Phase erfolgte die Implementierung des Systems in einer realen Wohnumgebung, in der √§ltere Menschen mit verschiedenen Mobilit√§tsgraden wohnen. √úber einen Zeitraum von sechs Monaten wurden sowohl Sturzereignisse als auch Fehlalarme dokumentiert. Zudem wurden Interviews mit den Nutzern durchgef√ºhrt, um deren Erfahrungen und Anregungen zu erfassen.   Ergebnisse  Die Ergebnisse der kontrollierten Tests zeigten, dass das System in der Lage war, St√ºrze mit einer Erkennungsrate von 92 % zu identifizieren, w√§hrend die Fehlalarmquote bei 15 % lag. Die Implementierung in der realen Wohnumgebung offenbarte eine signifikante Verbesserung der Nutzerakzeptanz und eine reduzierte sensationelle √úberbelastung durch Fehlalarme. Bei den gesammelten Nutzerfeedbacks wurde besonders die Benutzerfreundlichkeit der tragbaren Ger√§te gelobt.  Allerdings traten auch Herausforderungen auf, insbesondere im Hinblick auf die Persistenz der Bluetooth-Verbindungen und die Notwendigkeit, die Ger√§te regelm√§√üig aufzuladen. Die Benutzer √§u√üerten Bedenken hinsichtlich der Tragbarkeit und des Tragekomforts, insbesondere bei l√§ngerer Nutzung.   Diskussion  Die evaluierte  bietet vielversprechende Ergebnisse, sowohl in kontrollierten als auch in praktischen Anwendungsszenarien. Die hohe Erkennungsrate und die positive R√ºckmeldung der Nutzer bieten ein solides Fundament, um das System weiterzuentwickeln und anzupassen. Zuk√ºnftige Forschungsarbeiten sollten sich auf die Reduktion von Fehlalarmen konzentrieren und alternative Ans√§tze zur Energieversorgung der Ger√§te untersuchen.  Ein weiterer kritischer Aspekt ist die Integration des Systems in bestehende Pflege- und Notfallmanagementstrukturen. Die Schaffung eines nahtlosen √úbergangs zwischen dem Erkennen eines Sturzes und der Benachrichtigung relevanter Personen oder Institutionen k√∂nnte die Effizienz und Effektivit√§t des gesamten Systems erheblich steigern.   Fazit  Insgesamt zeigt die  zur  das Potenzial moderner Technologie zur Verbesserung der Sicherheit √§lterer Menschen in ihren eigenen vier W√§nden. Durch iterative Verbesserungen und die Ber√ºcksichtigung des Nutzerfeedbacks kann dieses System einen wichtigen Beitrag zur Sturzpr√§vention leisten und das Wohlbefinden von vulnerablen Bev√∂lkerungsgruppen f√∂rdern.;1
Zum grundlegenden Wissensstand zu Beginn des Projekts ist anzumerken, dass bereits durch fr√ºhere Projekte im Verlauf des Studiums Kenntnisse in der App-Entwicklung gesammelt wurden konnten. Hierbei handelte es sich allerdings um die Erstellung einer hybriden App mithilfe des Ionic-Frameworks. Dieses basiert weitgehend auf dem von Google entwickelten Angular-Framework, welches um zahlreiche Komponenten f√ºr die Entwicklung von Anwendungen f√ºr mobile Endger√§te erweitert wurde . Da die Hybridapp-Erstellung in diesem Zusammenhang aber nur wenige Ber√ºhrungspunkte mit der nativen Android-Entwicklung hat, kam die Tatsache sehr gelegen, dass es im f√ºnften Theoriesemester eine Vorlesung zu diesem Themenbereich gegeben hat. Diese Vorlesung drehte sich thematisch um die grundlegende Erstellung von nativen Android-Apps mithilfe des bekannten Verfahrens, basierend auf XML-Layouts in Kombination mit der Programmierung in den jeweiligen Activities. Da bereits zu diesem Zeitpunkt bekannt gewesen ist, dass der Ansatz des Jetpack Compose Frameworks g√§nzlich ein anderer ist, wurde im Anschluss an die Thematik der jeweiligen Vorlesungseinheit die entsprechende Vorgehensweise parallel ebenfalls f√ºr den deklarativen Ansatz des Jetpack Compose Frameworks aufgearbeitet. Dies erlaubt es, bereits von Beginn an m√∂gliche Unterschiede und Vorteile des neuen Ansatzes zu erkennen und sich gleichzeitig ins Themengebiet einzuarbeiten. Ebenfalls hilfreich f√ºr die Einarbeitungsphase waren die oÔ¨Ézielle Dokumentation von Jetpack Compose, zahlreiche Videoreihen, eine gef√ºhrte Tutorialreihe und auch das Nachschlagen und aufarbeiten von geeigneten Literaturquellen in Kombination mit der Erstellung mehrerer kleiner Beispielanwendungen.  Am Ende dieser Einarbeitungsphase wurde der erste Meilenstein erreicht und die Planung des Beispielprojektes konnte begonnen werden. Hierbei stellten sich zun√§chst die Frage nach einer geeigneten Thematik f√ºr die Anwendung, die im Rahmen der Arbeit als praktisches Beispiel erstellt werden soll. Auch die grundlegende Infrastruktur zur Entwicklung der Anwendung wie die Versionsverwaltung und eine funktionierende Entwicklungsumgebung in der richtigen Version sind einzurichten. Ebenfalls m√ºssen hinsichtlich der Architektur der Beispielanwendung zahlreiche Dinge gekl√§rt werden, wie etwa eine geeignete Navigationsstrategie sowie Umfang und Layoutgestaltung. Nach Abkl√§rung der beschriebenen Punkte konnte die aktive Umsetzungsphase begonnen werden.;0
 Kapitel 2: Technische Grundlagen der Vergleichsanalyse von Content-Management-Systemen   2.1 Einf√ºhrung in Content-Management-Systeme  Content-Management-Systeme (CMS) sind Softwareanwendungen, die es Benutzern erm√∂glichen, digitale Inhalte zu erstellen, zu verwalten und zu ver√∂ffentlichen. Sie sind integrale Bestandteile moderner Webentwicklung und bieten Werkzeuge zur Verwaltung von Inhalten ohne tiefgehende Kenntnisse in Programmierung oder Webdesign. Um unterschiedliche CMS zu vergleichen, ist es wichtig, ein grundlegendes Verst√§ndnis der Technologien und Architekturen zu haben, die diesen Systemen zugrunde liegen.   2.2 Grundlegende Architektur von CMS  Die meisten Content-Management-Systeme folgen einer typischen Drei-Schichten-Architektur, bestehend aus:  1. Pr√§sentationsschicht: Diese Schicht umfasst die Benutzeroberfl√§che, mit der Benutzer interagieren. Hier werden die Inhalte in einem benutzerfreundlichen Format angezeigt, h√§ufig unter Verwendung von HTML, CSS und JavaScript.  2. Anwendungsschicht: Dies ist das Herzst√ºck des CMS, in dem die Logik f√ºr die Generierung und Verwaltung von Inhalten implementiert ist. Hier werden die Daten verarbeitet, Benutzeranfragen bearbeitet und Gesch√§ftslogik ausgef√ºhrt.  3. Datenspeicherschicht: Diese Schicht speichert alle Inhalte, Benutzerinformationen und Systemkonfigurationen. Meistens wird ein relationales Datenbanksystem wie MySQL, PostgreSQL oder ein NoSQL-System wie MongoDB verwendet.   2.3 Datenbanken und Datenmanagement  Eine zentrale Komponente jedes CMS ist das Datenmanagement, welches die Speicherung, Abfrage und Verwaltung von Inhalten erm√∂glicht. Die Wahl der Datenbank hat entscheidenden Einfluss auf Performance, Skalierbarkeit und Flexibilit√§t eines CMS. Relationale Datenbanken in Kombination mit SQL erm√∂glichen strukturierte Abfragen und Transaktionen, w√§hrend NoSQL-Datenbanken f√ºr unstrukturierte Daten und schnellere Abfragen in gro√üen Datenmengen optimiert sind.    2.3.1 Relationale Datenbanken  Relationale Datenbanken speichern Daten in Form von Tabellen und bieten die M√∂glichkeit, Beziehungen zwischen diesen Tabellen herzustellen. Diese Struktur eignet sich gut f√ºr CMS, die komplexe Datenstrukturen und relationale Verkn√ºpfungen ben√∂tigen.   2.3.2 NoSQL-Datenbanken  NoSQL-Datenbanken, wie MongoDB oder Couchbase, bieten Flexibilit√§t bei der Speicherung unstrukturierter oder semi-strukturierter Daten. Sie sind besonders wertvoll in Szenarien, wo gro√üe Datenvolumina schnell verarbeitet werden m√ºssen.   2.4 Benutzeroberfl√§che und Usability  Die Benutzeroberfl√§che eines CMS ist entscheidend f√ºr die Usability und die Akzeptanz bei den Anwendern. Eine intuitive Navigation, klare Strukturierung der Inhalte und die Anpassbarkeit der Oberfl√§che sind wichtige Kriterien. Technologien wie HTML5, CSS3 und JavaScript-Frameworks (z.B. React, Vue.js oder Angular) werden h√§ufig eingesetzt, um eine responsive und benutzerfreundliche Oberfl√§che zu schaffen.   2.5 Sicherheit und Zugriffsmanagement  Sicherheit ist ein zentraler Aspekt bei der Entwicklung und Nutzung von CMS. Die h√§ufigsten Bedrohungen beinhalten SQL-Injection, Cross-Site Scripting (XSS) und unautorisierte Zugriffe. Um diesen Risiken zu begegnen, m√ºssen CMS robustes Zugriffsmanagement, Authentifizierungs- und Autorisierungsmechanismen implementieren. Hierzu geh√∂ren:  - Rollenbasierte Zugriffskontrolle: Benutzer werden in Rollen eingeteilt, die unterschiedliche Berechtigungen hinsichtlich der Bearbeitung und Ver√∂ffentlichung von Inhalten festlegen. - Sichere Authentifizierung: Implementierung von Passwortrichtlinien, Zwei-Faktor-Authentifizierung und SSL-Verschl√ºsselung.   2.6 Anpassungsf√§higkeit und Erweiterbarkeit  Die F√§higkeit eines CMS zur Anpassung an spezifische Anforderungen und zur Integration zus√§tzlicher Funktionen ist ein entscheidender wichtiger Punkt. Viele Systeme bieten eine modulare Architektur, die die Entwicklung von Plugins oder Erweiterungen erm√∂glicht. Technologien wie RESTful APIs oder GraphQL erm√∂glichen die Anbindung externer Systeme und den Austausch von Daten zwischen verschiedenen Plattformen und Anwendungen.   2.7 Leistungsaspekte  Die Performance eines CMS beeinflusst entscheidend die Benutzererfahrung und die SEO-Optimierung einer Webseite. Wichtige Kenngr√∂√üen zur Beurteilung der Leistungsf√§higkeit sind:  - Ladezeiten: Die Zeit, die ben√∂tigt wird, um eine Seite vollst√§ndig zu laden. Optimierungstechniken umfassen Caching, Content Delivery Networks (CDNs) und die Minimierung von HTTP-Anfragen.    - Skalierbarkeit: Die F√§higkeit eines Systems, mit einem Anstieg der Benutzeranzahl und der Datenmengen umzugehen. Skalierbarkeit kann sowohl vertikal (leistungsst√§rkere Hardware) als auch horizontal (hinzuf√ºgen weiterer Server) erreicht werden.   2.8 Fazit  Die technischen Grundlagen eines Content-Management-Systems sind vielf√§ltig und entscheidend f√ºr die Funktionalit√§t und die Benutzererfahrung. Die Wahl des CMS sollte auf einer fundierten Analyse dieser Grundlagen basieren, um die unterschiedlichen Systeme effektiv vergleichen und bewerten zu k√∂nnen. In den folgenden Kapiteln werden wir spezifische Systeme detailliert untersuchen und ihre Vor- und Nachteile im Kontext ihrer technischen Architektur und Funktionalit√§ten beleuchten.;1
 Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Fazit  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten haben das Internet der Dinge (IoT) zu einem bedeutenden Forschungs- und Entwicklungsfeld gemacht. In diesem Kontext hat sich ElixirNerves als eine vielversprechende Plattform f√ºr die Entwicklung von IoT-Anwendungen etabliert. Diese Evaluation befasst sich mit den St√§rken und Schw√§chen von ElixirNerves und zieht ein Fazit √ºber seine Eignung als Grundlage f√ºr zuk√ºnftige IoT-Projekte.  ElixirNerves basiert auf der Programmiersprache Elixir, die auf der robusten Erlang Virtual Machine (BEAM) l√§uft. Diese Kombination bietet mehrere Vorteilehohe Verf√ºgbarkeit, Fehlerresistenz und eine einfache Handhabung von Nebenl√§ufigkeit. Die F√§higkeit von Elixir, Prozesse unabh√§ngig zu verwalten, erm√∂glicht es Entwicklern, robuste und skalierbare Anwendungen zu erstellen, die in der Lage sind, unter realen Bedingungen zuverl√§ssig zu funktionieren.  Ein herausragendes Merkmal von ElixirNerves ist seine Modularit√§t. Die Plattform unterst√ºtzt eine Vielzahl von Hardwarekomponenten und Protokollen, was eine breite Anwendbarkeit in verschiedenen IoT-Szenarien erm√∂glicht. Die Integration von g√§ngigen Kommunikationsprotokollen wie MQTT und HTTP wird durch vorgefertigte Bibliotheken und Module erleichtert. Diese Flexibilit√§t hat es Entwicklern erm√∂glicht, schnell Prototypen zu erstellen und ihre Ideen in funktionierende Produkte umzusetzen.  Ein weiterer Vorteil von ElixirNerves ist die Unterst√ºtzung f√ºr Continuous Integration und Deployment (CI/CD). Die Plattform erm√∂glicht es, Software-Updates einfach und sicher auf IoT-Ger√§te zu verteilen, was in der Praxis von entscheidender Bedeutung ist, um Sicherheitsl√ºcken zu schlie√üen und neue Funktionen bereitzustellen. Dies ist besonders relevant in einem IoT-Umfeld, in dem Ger√§te oft √ºber lange Zeitr√§ume im Einsatz sind und gelegentlich aktualisiert werden m√ºssen.  Trotz dieser St√§rken gibt es auch Herausforderungen, die bei der Nutzung von ElixirNerves ber√ºcksichtigt werden m√ºssen. Eine der gr√∂√üten H√ºrden ist die vergleichsweise geringe Verbreitung und Community-Unterst√ºtzung im Vergleich zu etablierten Plattformen wie Arduino oder Raspberry Pi. Dies kann den Zugang zu Ressourcen, Bibliotheken und Unterst√ºtzung durch die Community einschr√§nken, was f√ºr Entwickler, insbesondere f√ºr Einsteiger, eine Herausforderung darstellen kann.  Ein weiteres zu ber√ºcksichtigendes Element ist die Lernkurve, die mit der Nutzung von Elixir und der Nerves-Plattform verbunden ist. W√§hrend die funktionale Programmierung viele Vorteile bietet, kann sie f√ºr Entwickler, die an imperative Programmierparadigmen gew√∂hnt sind, zun√§chst ungewohnt sein. Dies k√∂nnte die Akzeptanz von ElixirNerves in der breiteren Entwicklergemeinschaft einschr√§nken.  Zusammenfassend l√§sst sich sagen, dass ElixirNerves eine leistungsf√§hige und flexible Plattform f√ºr die Entwicklung von IoT-Anwendungen darstellt. Die St√§rken in Bezug auf Modularit√§t, Fehlerresistenz und Unterst√ºtzung f√ºr CI/CD sind entscheidende Vorteile, die die Plattform f√ºr viele Anwendungsf√§lle attraktiv machen. Dennoch m√ºssen Entwickler die Herausforderungen hinsichtlich der Community-Unterst√ºtzung und der Lernkurve in Betracht ziehen. F√ºr Projekte, die auf Zuverl√§ssigkeit und Skalierbarkeit angewiesen sind,;1
Auf der Abbildung 2.5 ist ein Arduino Sensor Kit Base dargestellt. Das Arduino Sensor Kit ist f√ºr Anf√§nger*innen geeignet, denn alle Grove-Module sind auf der Platine vorverdrahtet und f√ºr die Messungen muss lediglich ein Arduino UNO Board angeschlossen werden. (vgl. Arduino 2022b) Grove ist ein quelloffenes Toolset, das den Aufbau von Elektronik nach dem Baukastenprin- zip erm√∂glicht. Dieses Kit enth√§lt ein Basisschild, an das die verschiedenen Grove-Module sowohl einzeln als auch in verschiedenen Kombinationen angeschlossen werden k√∂nnen. Alle Module verwenden einen Grove-Steckverbinder, mit dem die einzelnen Komponenten mit einem Base Shield verbunden werden. Es gibt zehn verschiedene Grove-Module: ‚Ä¢LED ‚Ä¢Taster ‚Ä¢Potenziometer ‚Ä¢Buzzer ‚Ä¢Helligkeitssensor ‚Ä¢Tonsensor ‚Ä¢Luftdrucksensor ‚Ä¢Temperatursensor ‚Ä¢Beschleunigungssensor ‚Ä¢OLED-Bildschirm (vgl. Arduino 2022b) Das Arduino Sensor Kit ist nur mit einem Arduino UNO Board kompatibel. Bei der Auswahl des Boards war die wichtigste Anforderung, dass das gew√§hlte Board √ºber WiFi verf√ºgt. Daher wurde in der vorliegenden Arbeit das Arduino UNO WiFi Rev 2 Board (siehe Abbildung 2.6) gew√§hlt. Abbildung 2.6: Arduino UNO WiFi Rev. 2 (Arduino 2022c) Dieses Board enth√§lt einen 8-Bit-Mikrocontroller ATmega4809 und verf√ºgt √ºber eine integrierte Inertial Measurement Unit ( IMU). Das WiFi-Modul ist ein eigenst√§ndiger System-on-a-Chip mit einem integrierten TCP/IP-Protokollstack, der den Zugang zu einem WiFi-Netzwerk erm√∂glicht oder als Access Point fungiert. Das Arduino UNO WiFi Rev. 2 hat 14 digitale Ein- und Ausgangs-Pins, einen USB-Anschluss, eine Stromver- sorgungsbuchse, In-Circuit Serial Programmer ( ICSP)-Header und einen Reset-Knopf. Au√üerdem unterst√ºtzt dieser Mikrocontroller Bluetooth und BLE. (vgl. Arduino 2022c);0
"3.3.4 Raspberry Pi Gateway
Standard Antenne
Das Raspberry Pi Gateway wurde im zweiten Testdurchlauf mit der mitgelieferten Antenne
des LoRa Funkmoduls getestet. Wie in der Abbildung 3.29 zu sehen, hat das Gateway eine
recht geringe Reichweite f√ºr LoRa. Die maximale Entfernung zum Gateway betrug circa
307 Meter Luftlinie bis keine Nachrichten vom Gateway mehr empfangen wurden, was
durch die vorherigen Test mit dem Indoor Gateway nicht zu erwarten war. Die gemessenen
Werte der RSSIliegen beim Raspberry Pi Gateway mit der Standardantennen zwischen
-103dBmund -50dBmund dieSNRliegt, wie beim Indoor Gateway, zwischen den Werten
-9,2dBund 14,2 dB. Die Signalst√§rke Ô¨Åel rapide ab, nachdem kein direkter Sichtkontakt
mehr zum Haus aufgebaut werden konnte in dem das Gateway war, da ein benachbartes
Geb√§ude im Weg war. Dementsprechend sind in der Abbildung 3.29 keine bl√§ulichen
Punkte zu erkennen, da nach diesem Zeitpunkt keine Nachricht mehr erfolgreich gesendet
beziehungsweise vom Gateway empfangen werden konnten. Selbst als wieder ein direkter
Sichtkontakt hergestellt werden konnte, wurde keine Nachricht erfolgreich an das Gateway
versendet, da anscheinend die Entfernung zu gro√ü war.
Abbildung 3.29: Heatmap des Raspberry Pi Gateway mit Standard Antenne";0
 Kapitel 4: Implementierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Die Implementierung von ElixirNerves als Plattform f√ºr Internet of Things (IoT)-Anwendungen erfordert eine fundierte Herangehensweise, die sowohl die spezifischen Anforderungen der IoT-Umgebung als auch die charakteristischen Merkmale des Elixir-√ñkosystems ber√ºcksichtigt. In diesem Kapitel werden die Schritte zur Implementierung sowie die Herausforderungen und L√∂sungen, die w√§hrend des Prozesses auftraten, detailliert beschrieben.   4.1 Auswahl der Hardware  Die erste Phase der Implementierung besteht in der Auswahl geeigneter Hardware. ElixirNerves ist darauf ausgelegt, auf verschiedenen Hardware-Plattformen zu laufen, die von Raspberry Pi √ºber BeagleBone bis hin zu spezifischen SoC-L√∂sungen (System on Chip) reichen. Die Entscheidung f√ºr eine bestimmte Hardware h√§ngt von den Anforderungen der IoT-Anwendung ab, wie z. B. Verarbeitungsleistung, Energieverbrauch und Konnektivit√§tsoptionen. F√ºr die vorliegende Evaluation wurde ein Raspberry Pi 4 ausgew√§hlt, da er eine ausgewogene Leistung bietet und eine breite Unterst√ºtzung in der Entwicklergemeinschaft genie√üt.   4.2 Einrichtung der Entwicklungsumgebung  Die n√§chste Phase der Implementierung umfasst die Einrichtung der Entwicklungsumgebung. Dazu geh√∂rt die Installation der notwendigen Softwaretools, einschlie√ülich Elixir, Nerves und der zugeh√∂rigen Abh√§ngigkeiten. Die Nerves-Umgebung wird typischerweise √ºber Mix, das Build-Tool von Elixir, eingerichtet. Ein wichtiger Schritt ist die Konfiguration der Toolchain, die f√ºr das Cross-Compiling der Anwendung auf der Zielhardware erforderlich ist. Hierbei wird die Nerves-Toolchain installiert, die es erm√∂glicht, das Elixir-Projekt f√ºr die spezifische Architektur des gew√§hlten Boards zu kompilieren.   4.3 Entwicklung der IoT-Anwendung  Mit einer funktionierenden Entwicklungsumgebung kann die eigentliche IoT-Anwendung entwickelt werden. In diesem Fall wurde eine einfache Sensoranwendung implementiert, die Temperatur- und Feuchtigkeitsdaten von einem DHT22-Sensor erfasst. Die Daten werden in regelm√§√üigen Abst√§nden gelesen und √ºber MQTT (Message Queuing Telemetry Transport) an einen Cloud-Service gesendet. Die Verwendung von MQTT erm√∂glicht eine effiziente Kommunikation, die f√ºr IoT-Anwendungen entscheidend ist, da sie eine geringe Bandbreite und geringe Latenz erfordert.  Die Implementierung der Anwendung erfolgt in mehreren Schritten:  1. Sensoranbindung: Zun√§chst wird der DHT22-Sensor an den Raspberry Pi angeschlossen. Die entsprechenden GPIO-Pins werden konfiguriert, um die Daten des Sensors auszulesen.     2. Datenerfassung: Eine Elixir-GenServer wird erstellt, um die Sensorwerte in regelm√§√üigen Abst√§nden zu erfassen. Hierbei wird ein Timer verwendet, um die Intervalle zu steuern und die Daten zu sammeln.  3. Daten√ºbertragung: Die gesammelten Daten werden in einem strukturierten Format aufbereitet und √ºber das MQTT-Protokoll an einen Broker gesendet. Hierbei wird die Nerves-MQTT-Bibliothek verwendet, die eine einfache Integration in die Nerves-Plattform erm√∂glicht.   4.4 Tests und Validierung  Nach der Implementierung;1
 Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung     Die Integration von Internet of Things (IoT)-Technologien in den Alltag hat in den letzten Jahren signifikant zugenommen. Insbesondere im Bereich der Heimautomatisierung er√∂ffnen sich durch die Vernetzung von Ger√§ten und die Anwendung k√ºnstlicher Intelligenz (KI) neue M√∂glichkeiten zur Effizienzsteigerung und zur Verbesserung des Lebensstandards. Ein vielversprechendes Anwendungsfeld ist die Entwicklung eines intelligenten Systems zur Steuerung einer Katzenklappe, das auf KI-gest√ºtzte Katzenerkennung setzt. Dieser Prosatext beleuchtet die theoretischen Grundlagen, die f√ºr die Realisierung eines solchen Systems erforderlich sind.   Internet of Things (IoT)  Das IoT bezeichnet ein Netzwerk von physikalischen Objekten, die mit Sensoren, Software und anderen Technologien ausgestattet sind, um Daten zu sammeln und auszutauschen. Diese Objekte k√∂nnen von Alltagsgegenst√§nden bis hin zu komplexen Maschinen reichen. Die grundlegenden Komponenten eines IoT-Systems umfassen Sensoren, Aktoren, eine Kommunikationsinfrastruktur sowie eine Datenverarbeitungs- und Analyseplattform. In unserem spezifischen Anwendungsfall wird die Katzenklappe als Aktor betrachtet, w√§hrend die Katzenerkennung durch Sensoren und KI-Algorithmen realisiert wird.   K√ºnstliche Intelligenz und maschinelles Lernen  Die KI ist ein Teilbereich der Informatik, der sich mit der Schaffung intelligenter Maschinen besch√§ftigt, die in der Lage sind, Aufgaben zu erf√ºllen, die normalerweise menschliche Intelligenz erfordern. Innerhalb der KI spielt das maschinelle Lernen (ML) eine zentrale Rolle. ML-Algorithmen lernen aus Daten und verbessern ihre Leistung √ºber die Zeit, ohne explizit programmiert zu werden. F√ºr die Katzenerkennung sind insbesondere bildbasierte ML-Methoden relevant, wie Convolutional Neural Networks (CNN), die in der Lage sind, Muster und Merkmale in Bilddaten zu identifizieren.   Katzenerkennung  Die Katzenerkennung ist ein komplexer Prozess, der mehrere Schritte umfasstDatensammlung, Datenvorverarbeitung, Merkmalsextraktion und Klassifikation. Zu Beginn m√ºssen Bilddaten von Katzen gesammelt werden, um ein robustes Trainingsdatenset zu erstellen. Diese Bilder sollten verschiedene Perspektiven, Beleuchtungsbedingungen und Rassen abdecken, um die Generalisierbarkeit des Modells zu erh√∂hen. Nach der Datensammlung erfolgt die Vorverarbeitung, die Schritte wie Bildskalierung, Normalisierung und Augmentierung umfassen kann, um die Vielfalt der Trainingsdaten zu erh√∂hen.  Die Merkmalsextraktion erfolgt typischerweise durch CNNs, die automatisch relevante Merkmale aus den Bildern extrahieren. Die anschlie√üende Klassifikation erm√∂glicht es dem System, zwischen Katzen und anderen Objekten zu unterscheiden. Hierbei k√∂nnen Algorithmen wie Support Vector Machines (SVM) oder neuronale Netzwerke eingesetzt werden, um die besten Ergebnisse zu erzielen.   Integration in ein IoT-System  Die Integration der Katzenerkennung in ein IoT-System erfordert eine geeignete Architektur, die sowohl die Hardware- als auch die Softwarekomponenten umfasst. Die Katzenerkennung kann lokal auf einem Mikrocontroller mit ausreichender Rechenleistung oder in der Cloud;1
DerAlarmManager ist f√ºr F√§lle gedacht, in denen der Anwendungscode zu einem bestimmten Zeitpunkt ausgef√ºhrt werden soll, auch wenn die Anwendung gerade nicht l√§uft. (vgl. Android for Developers 10.02.2022a) 2DialogFragment ist eine Art Fragment, das ein Dialogfenster anzeigt, das √ºber dem Fenster seiner Aktivit√§t schwebt (vgl. Android for Developers 17.03.2022). Im Listing 4.9 ist der Programmcode des zweiten erstellten Broadcast-Receivers zu sehen. Wenn der Alarm aufgerufen wird, wird eine HTTP-Anfrage an den Webserver geschickt mit ‚ÄûALARM‚Äú im Header. Der Programmcode f√ºr den Luftreiniger (beziehungsweise f√ºr den ESP32-Mikrocontroller) wurde so ge√§ndert, dass in der Anwendung die Stufe FAR-UVCnur dann betrieben werden kann, wenn das Ger√§t bereits in einer anderen Stufe l√§uft. Unabh√§ngig davon wird der Luftreiniger bei der Stellung der HTTP-Anfrage ‚Äûhttp://192.168.0.196/?MODE=ALARM‚Äú sofort den Desinfektionsmodus einschalten. Als N√§chstes wird ein Benachrichtigungskanal erstellt und eine Benachrichtigung an die Anwender*innen geschickt. Die Funktion ‚ÄûcreateNotificationChannel‚Äú beinhaltet Einstel- lungen f√ºr die Benachrichtigung, damit Benachrichtigungen geschickt werden k√∂nnen. In der ‚ÄûsendNotification‚Äú-Funktion wird der Titel, das Text und das Symbol eingestellt und die Benachrichtigung gebaut. Au√üer der vorher genannten Funktionen wurde eine ‚ÄûsetAlarm‚Äú- und eine ‚ÄûcancelAlarm‚Äú- Funktion erstellt, um den Alarm ein- und ausschalten zu k√∂nnen. Nach dem Schlie√üen der Applikation wird in der Klasse ‚ÄûSensorService‚Äú (siehe Listing 4.3) gepr√ºft, ob der Alarm eingeschaltet wurde. Ist das der Fall, wird neben der Wiederherstellung der MQTT- Verbindung auch der Alarm eingeschaltet. Ist der Alarm eingeschaltet, bekommen die Benutzer*innen um 22:00 Uhr eine Benachrichtigung von der Applikation, dass der Luftrei- niger eingeschaltet wird. In der Abbildung 4.2 ist das Benachrichtigungsfenster des Tablets mit dieser Benachrichtigung dargestellt.;0
Die vorliegende Anforderungsanalyse hat das Ziel, ein effektives Aufgaben Management Tool zu entwickeln, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist. In der heutigen akademischen Landschaft, in der Teamarbeit und Projektarbeit zunehmend an Bedeutung gewinnen, ist es unerl√§sslich, geeignete digitale Hilfsmittel zu implementieren, die den Studierenden helfen, ihre Aufgaben effizient zu organisieren und zu verwalten.   Ein zentrales Anliegen dieser Analyse ist es, die spezifischen Anforderungen der Zielgruppe zu identifizieren und zu dokumentieren. Hierbei sind verschiedene Dimensionen zu ber√ºcksichtigen: Die Benutzerfreundlichkeit, die Funktionalit√§t, die Integrationsf√§higkeit mit bestehenden Tools und Plattformen sowie die Unterst√ºtzung kollaborativer Arbeitsprozesse.   Die Benutzerfreundlichkeit stellt einen entscheidenden Faktor dar, um sicherzustellen, dass das Tool intuitiv und leicht verst√§ndlich ist. Studierende, die oft unter Zeitdruck stehen, ben√∂tigen eine klare und ansprechende Benutzeroberfl√§che, die ihnen erm√∂glicht, schnell zwischen verschiedenen Funktionen zu navigieren. Dar√ºber hinaus sollte das Tool anpassbare Dashboards und Ansichten bieten, die den individuellen Arbeitsstil der Nutzer unterst√ºtzen.  In Bezug auf die Funktionalit√§t sind mehrere Kernfeatures erforderlich. Dazu geh√∂ren die M√∂glichkeit, Aufgaben zu erstellen, zu bearbeiten und zu priorisieren, sowie die Zuweisung von Aufgaben an Teammitglieder. Ein integriertes Kalendersystem zur Terminplanung und Fristenverwaltung ist ebenso unerl√§sslich, um die zeitliche Koordination innerhalb von Projekten zu optimieren. Des Weiteren sollte das Tool √ºber Erinnerungs- und Benachrichtigungsfunktionen verf√ºgen, um die Nutzer rechtzeitig auf anstehende Aufgaben und Deadlines hinzuweisen.  Die Integrationsf√§higkeit des Tools mit bestehenden Softwarel√∂sungen ist ein weiterer kritischer Punkt. Studierende verwenden h√§ufig eine Vielzahl von Anwendungen, wie z.B. Versionierungssysteme (z.B. Git), Kommunikationsplattformen (z.B. Slack) und Dokumentationswerkzeuge (z.B. Confluence). Ein erfolgreiches Aufgaben Management Tool sollte in der Lage sein, nahtlos mit diesen Plattformen zu interagieren und einen zentralen Hub f√ºr alle projektbezogenen Aktivit√§ten zu schaffen.  Ein weiterer wichtiger Aspekt ist die Unterst√ºtzung kollaborativer Arbeitsprozesse. Das Tool sollte Funktionen bieten, die die Teamkommunikation und den Wissensaustausch f√∂rdern, wie beispielsweise Diskussionsforen, Kommentarfunktionen zu Aufgaben und die M√∂glichkeit, Dateien direkt innerhalb der Plattform auszutauschen.   Abschlie√üend ist festzuhalten, dass die Anforderungsanalyse an ein Aufgaben Management Tool f√ºr das studentische Software Engineering eine umfassende Untersuchung der Bed√ºrfnisse und Erwartungen der Nutzer erfordert. Die identifizierten Anforderungen sollen als Grundlage f√ºr die Entwicklung eines Prototypen dienen, der nicht nur die Effizienz und Organisation in der Projektarbeit verbessert, sondern auch die Lernerfahrungen der Studierenden positiv beeinflusst.;1
 Evaluation existierender L√∂sungen f√ºr In-Room Ortung zur Sturzerkennung mit Bluetooth  Die In-Room Ortung zur Sturzerkennung ist ein wachsendes Forschungsgebiet, insbesondere im Kontext der Gesundheits√ºberwachung √§lterer Menschen oder von Personen mit erh√∂htem Sturzrisiko. Die Verwendung von Bluetooth-Technologie zur Stauraumerfassung hat sich als vielversprechend herausgestellt. Diese Evaluation untersucht bestehende L√∂sungen, die Bluetooth f√ºr die Sturzerkennung nutzen und analysiert deren Vor- und Nachteile.   1. Technologien zur In-Room Ortung  In der aktuellen Literatur und auf dem Markt sind mehrere Technologien zur In-Room Ortung verf√ºgbar. Die relevantesten in Bezug auf Bluetooth sind:  - Bluetooth Low Energy (BLE) Beacons - Bluetooth Mesh-Netzwerke   1.1 Bluetooth Low Energy (BLE) Beacons  BLE Beacons sind kleine, batteriebetriebene Ger√§te, die Signale senden, die von Smartphones oder anderen BLE-f√§higen Ger√§ten empfangen werden k√∂nnen. Sie sind weit verbreitet in verschiedenen Anwendungen, einschlie√ülich der Indoor-Navigation und der Kontextualisierung. Die Sturzerkennung erfolgt in der Regel durch:  - Ansteuerung der Sensoren: Der Beacon kann in der N√§he eines Patienten positioniert werden, und durch eine Kombination von Bewegungs- und Beschleunigungssensoren im tragbaren Ger√§t k√∂nnen St√ºrze erkannt werden. - Alarmierung: Bei einem Sturz kann ein Alarm an die Betreuer oder Angeh√∂rigen gesendet werden.  Vorteile: - Geringer Energieverbrauch bei BLE. - Kosteneffektiv und einfach zu implementieren. - Nahtlose Integration in bestehende Smartphones und tragbare Ger√§te.  Nachteile: - Einschr√§nkungen in der Reichweite, was die Abdeckung gr√∂√üerer Bereiche beeinflussen kann. - Signalinterferenzen durch physische Barrieren oder andere elektronische Ger√§te. - Abh√§ngigkeit von der Genauigkeit der Sensoren im tragbaren Ger√§t.   1.2 Bluetooth Mesh-Netzwerke  Bluetooth Mesh bietet die M√∂glichkeit, eine Vielzahl von Ger√§ten in einem Netzwerk zu verbinden und Daten √ºber gro√üe Entfernungen zu √ºbertragen. Dies ist besonders vorteilhaft in gro√üen Geb√§uden oder Einrichtungen.  Vorteile: - Hohe Skalierbarkeit durch die M√∂glichkeit, viele Mesh-Knoten zu integrieren. - Robuste Netzwerke, da Daten √ºber mehrere Pfade gesendet werden k√∂nnen. - Potenziale f√ºr die Integration mit anderen Datenquellen, wie z.B. Gesundheitsmonitoring-Ger√§ten.  Nachteile: - Komplexit√§t in der Konfiguration und dem Management des Netzwerks. - H√∂herer Energieverbrauch im Vergleich zu BLE Beacons aufgrund des st√§ndigen Datenaustausches. - Sicherheitsbedenken, da mehrere Ger√§te in einem Netzwerk potenziellen Angriffen ausgesetzt sein k√∂nnen.   2. Evaluierte L√∂sungen  Das Folgende sind einige bestehende L√∂sungen, die die Bluetooth-Technologie zur Sturzerkennung verwenden:  - Fall Detection Systems (FDS): Diese Systeme beinhalten in der Regel tragbare Ger√§te mit integrierten Beschleunigungssensoren und verwenden BLE zur Kommunikation der Daten an ein Smartphone oder eine zentrale Einheit. - Smart Home Systeme: Hierbei wird die Sturzer;1
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Die fortschreitende Digitalisierung und die zunehmende Verbreitung des Internets der Dinge (IoT) bieten innovative M√∂glichkeiten zur Automatisierung allt√§glicher Aufgaben. In diesem Kontext wird die Entwicklung eines IoT-Systems zur intelligenten Steuerung einer Katzenklappe unter Verwendung von K√ºnstlicher Intelligenz (KI) zur Katzenerkennung als besonders vielversprechend erachtet. Diese Arbeit beschreibt die , die sowohl technische als auch praktische Aspekte der Katzenerkennung und -steuerung ber√ºcksichtigt.  1.   Die Haustierhaltung bringt zahlreiche Herausforderungen mit sich, insbesondere in Bezug auf die Sicherheit und den Komfort der Tiere. Eine intelligente Katzenklappe, die es erm√∂glicht, die Katze selbstst√§ndig ins Haus zu lassen, ohne dass ungebetene G√§ste Zutritt erhalten, k√∂nnte eine L√∂sung bieten. Die vorliegende Arbeit fokussiert sich auf die Entwicklung eines Systems, das mithilfe von KI-Technologien die Identit√§t der Katze erkennt und somit die Katzenklappe entsprechend steuert.  2. Systemarchitektur  Das IoT-System besteht aus mehreren Komponenteneiner Kamera zur Bilderfassung, einem Mikrocontroller zur Datenverarbeitung, einem Aktuator zur Steuerung der Katzenklappe sowie einer Cloud-Plattform zur Speicherung und Analyse der Daten. Die Kamera wird eingesetzt, um Bilder der Katze in Echtzeit aufzunehmen. Der Mikrocontroller, beispielsweise ein Raspberry Pi, verarbeitet die Bilddaten und f√ºhrt die Katzenerkennung durch. Der Aktuator √∂ffnet oder schlie√üt die Klappe basierend auf den Ergebnissen der KI-Analyse.  3. Katzenerkennung mittels K√ºnstlicher Intelligenz  Die Kernkomponente des Systems ist die Katzenerkennung, die durch ein neuronales Netzwerk realisiert wird. Hierf√ºr wird ein Convolutional Neural Network (CNN) eingesetzt, das auf eine gro√üe Datenmenge von Katzenbildern trainiert wird. Die Datenakquise erfolgt durch das Sammeln von Bildern der eigenen Katze sowie von weiteren Katzenbildern aus √∂ffentlich zug√§nglichen Datens√§tzen. Die Qualit√§t der Katzenerkennung h√§ngt ma√ügeblich von der Vielfalt und Anzahl der Trainingsdaten ab.  Das Training des Modells erfolgt in mehreren PhasenZun√§chst wird das CNN mit einer Basisarchitektur konfiguriert und auf den gesammelten Datensatz trainiert. Nach der ersten Evaluierung wird das Modell mithilfe von Techniken wie Transfer Learning optimiert, um die Erkennungsgenauigkeit zu erh√∂hen. Die Hyperparameter des Modells werden angepasst, um eine optimale Leistung zu gew√§hrleisten.  4. Implementierung des IoT-Systems  Nach erfolgreichem Training des Modells wird dieses in den Mikrocontroller integriert. Die Kamera √ºbertr√§gt kontinuierlich Bilder an den Mikrocontroller, der diese in Echtzeit verarbeitet. Bei Erkennung der eigenen Katze sendet der Mikrocontroller ein Signal an den Aktuator, um die Klappe zu √∂ffnen. Um die Sicherheit zu erh√∂hen, wird eine zus√§tzliche Verifizierungsebene implementiert, die eine bestimmte Anzahl von Erkennungen innerhalb eines definierten Zeitrahmens erfordert, bevor die Klappe ge√∂ffnet wird.  5. Sicherheit und Datenschutz  Ein entscheidender Aspekt bei der Implementierung eines IoT-Systems ist der Schutz der Daten. Die Bilder der;1
Ziel der Studienarbeit ist es, eine allgemeine Guideline zu verfassen um diese MQTT- Infrastrukturen und -L√∂sungen verl√§sslich zu testen. Hierbei soll untersucht werden, welche bereits verf√ºgbaren Programme verwendet werden k√∂nnen, um diese MQTT- Infrastrukturen auf Funktionsf√§higkeit zu testen. Es sollen die Unterschiede zwischen diesen Programmen aufgezeigt werden und Empfehlungen f√ºr die Verwendung in der Dualen Hochschule Baden-W√ºrttemberg ( DHBW) Heidenheim gegeben werden. Anfangs soll der derzeitigeStandunddiederzeitigenAnforderungenan MQTT-L√∂sungenuntersuchtwerden. Dabei soll die derzeitig empfohlene Struktur und Verwendung solcher Infrastrukturen beschrieben werden. Zu dem Testen einer solchen MQTT-Infrastruktur soll nun eine Guideline erstellt werden. Diese soll verschiedene, bereits vorhandene Testprogramme vorschlagen, welche einfach zu Verwenden sind und mit hoher Wahrscheinlichkeit Fehler und L√ºcken in der Infrastruktur erkennen. Die verschiedenen Testprogramme sollen auf ihre Unterschiede verglichen werden. Au√üerdem soll in der Guideline spezifiziert sein, was √ºberhaupt getestet werden muss. Wenn m√∂glich sollten die Testprogramme mit automatischen Tests ausgestattet sein, falls keine Programme mit solchen Tests gefunden werden, k√∂nnen solche bereitgestellt werden.;0
Die Implementierung des Projekts und die dazugeh√∂rige Dokumentation wurde in einem GitHub-Repository1unter der MIT-Lizenz ver√∂ffentlicht. Es wird der folgende Workflow f√ºr die Konfiguration der Interaktionen implementiert: 1. Objekt der Klasse Application erstellen 2. Serverinformationen des MQTT-Brokers in ein Konfigurationsobjekt eintragen 3. F√ºr alle gew√ºnschten Ger√§te wiederholen: 3.1 Ger√§te-Objekt erstellen 3.2 Haus-, Raum- und Ger√§te-ID konfigurieren 3.3Callback-Methoden f√ºr benutzerdefinierte Interaktionen implementieren und dem Objekt zuweisen 3.4 Dem Application -Objekt zusammen mit dem Frontend √ºbergeben 4. Die Startmethode von Application aufrufen 5. Das Main-Skript mit einem Python-Interpreter ausf√ºhren Daf√ºr werden die Ger√§te zun√§chst werden in eine Controller- und eine View-Klasse aufge- teilt, damit die Ger√§te-Logik von dem Frontend entkoppelt wird. Ein Klassendiagramm ist in Abbildung 4.1 zu sehen. Um Codewiederholungen in den Ger√§te-Klassen zu vermeiden, werden die zwei Elternklassen DeviceBase und DeviceBaseView implementiert. F√ºr Unittests wurde die unittest-Library verwendet, welche in der Python Standard Library enthalten ist. Die Tests k√∂nnen mit dem Befehl python -m unittest im Root- Verzeichnis des Projekts ausgef√ºhrt werden. Hierbei werden alle Tests ausgef√ºhrt, welche sich in einer Python-Datei mit dem Pr√§fix test_befinden. In VS Code und PyCharm gibt es Funktionen, um die Tests aus dem GUI heraus zu starten.;0
Auf der Grundlage der beschrieben Architektur ergibt sich hinsichtlich der Designprinzipien die Grundlage, dass anstelle von gro√üen monolithischen Komponenten m√∂glichst kleine fokussierte Funktionalit√§ten bereitgestellt werden sollen. Dies bietet den Vorteil, dass durch die unterschiedlichen Abstraktionslevel mit unterschiedlichen Priorit√§ten mehr Kontrolle √ºber die Elemente gewonnen werden kann. Zus√§tzlich ist auch das Anpassen der einzelnen Elemente relativ einfach, da mit einem Eingreifen auf niedrigen Schichten h√∂here Schichten einfach √ºberschrieben werden k√∂nnen . Es sollte jedoch angemerkt werden, dass h√∂here Schichte oftmals mehr Funktionalit√§ten bieten als unterer Schichten und somit auch indirekt die Best Practices implementieren. Deshalb lautet die grundlegende Philosophie des Frameworks, dass die Funktionalit√§ten, die die zu erstellende Anwendung bieten soll, m√∂glichst in geschichteten und wiederverwendbaren Komponenten aufgebaut werden soll, die m√∂glichst wenig auf Bausteine der unteren Schichten zur√ºckgreifen. Es sollte immer auf der h√∂chstm√∂glichen Schicht aufge- baut werden, welche die gew√ºnschte Funktionalit√§t anbieten kann . Laut der Dokumentation wird mindestens ein Aufsetzen der Anwendungen auf der Foun- dationschicht empfohlen. Ab diesem Abstraktionslevel wird der semantische Baum vom Framework selbst direkt erzeugt. Dieser ist neben dem UI-Baum, welcher die Informationen eines Elements zu seiner Darstellung auf dem UIenth√§lt, ebenfalls sehr wichtig. Er enth√§lt die Informationen √ºber die semantische Bedeutung des Elements, die unter anderem auch f√ºr die sp√§tere Implementierung von Tests von Interesse ist. Wird eine Anwendung auf einer niedrigeren Schicht als der Foundationschicht aufgesetzt, m√ºsste dieser semantische Baum selbst erstellt werden .;0
 Kapitel 2: Technische Grundlagen  Die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung erfordert ein tiefes Verst√§ndnis der zugrunde liegenden Technologien. In diesem Kapitel werden die wesentlichen technischen Komponenten und Prinzipien erl√§utert, die f√ºr die Entwicklung eines solchen Systems notwendig sind. Die Betrachtung umfasst die Architektur des IoT-Systems, die verwendeten Sensoren und Aktoren, die Implementierung der k√ºnstlichen Intelligenz sowie die Kommunikationsprotokolle, die f√ºr die Interaktion zwischen den verschiedenen Systemkomponenten erforderlich sind.   2.1 IoT-Architektur  Das Internet der Dinge (IoT) beschreibt ein Netzwerk von physischen Objekten, die mit Sensoren, Software und anderen Technologien ausgestattet sind, um Daten auszutauschen und zu kommunizieren. Die Architektur eines IoT-Systems kann typischerweise in drei Schichten unterteilt werden: die Sensorschicht, die Verarbeitungsschicht und die Anwendungsschicht.  1. Sensorschicht: In unserem System umfasst diese Schicht die Kamera zur Katzenerkennung sowie zus√§tzliche Sensoren, die Informationen √ºber die Umgebung sammeln, wie beispielsweise Temperatur- und Feuchtigkeitssensoren. Die Kamera spielt eine zentrale Rolle, da sie die visuelle Datenquelle f√ºr die KI-gest√ºtzte Katzenerkennung darstellt.  2. Verarbeitungsschicht: Diese Schicht ist f√ºr die Datenverarbeitung und -analyse zust√§ndig. Hier wird die KI-Algorithmen implementiert, die die von der Kamera erfassten Bilder analysieren, um zu bestimmen, ob es sich um eine Katze handelt. Diese Verarbeitung kann lokal auf einem Edge-Device, wie einem Raspberry Pi, oder in der Cloud erfolgen, abh√§ngig von den Anforderungen an die Reaktionsgeschwindigkeit und die Verarbeitungsressourcen.  3. Anwendungsschicht: Diese Schicht umfasst die Benutzeroberfl√§che und die Interaktion mit dem Endbenutzer. Hier wird die Steuerung der Katzenklappe implementiert, die auf den Ergebnissen der Katzenerkennung basiert. Die Benutzeroberfl√§che kann sowohl lokal √ºber ein Display als auch √ºber eine mobile App bereitgestellt werden, die es den Benutzern erm√∂glicht, den Status der Katzenklappe zu √ºberwachen und Einstellungen vorzunehmen.   2.2 Sensoren und Aktoren  F√ºr die Katzenerkennung und die Steuerung der Katzenklappe sind verschiedene Sensoren und Aktoren erforderlich. Die Hauptkomponenten sind:  - Kamera: Eine hochaufl√∂sende Kamera ist notwendig, um qualitativ hochwertige Bilder der Katze zu erfassen. Diese Bilder werden anschlie√üend f√ºr die Bildverarbeitung und das Training des KI-Modells verwendet.  - Bewegungssensoren: Diese Sensoren k√∂nnen verwendet werden, um die Ann√§herung einer Katze an die Klappe zu erkennen und um sicherzustellen, dass die Klappe nur dann reagiert, wenn sich tats√§chlich eine Katze in der N√§he befindet.  - Aktuator f√ºr die Katzenklappe: Ein elektrischer Motor oder ein Servomotor wird ben√∂tigt, um die Katzenklappe zu √∂ffnen und zu schlie√üen. Der Aktuator muss pr√§zise gesteuert werden, um ein sicheres und effektives √ñffnen und Schlie√üen der Klappe zu gew√§hrleisten.   2.3 K√ºnstliche Intelligenz und;1
Wie auch schon in Abschnitt 5.5 beschrieben, agiert der ThingPlus-Controller aufgrund der Einschr√§nkung in der MicroPython-Bibliothek f√ºr I2Cin der Kommunikation mit dem Metro M4-Controller als Controller und der Metro M4-Controller als Peripheral . Die Kommunikation zwischen dem Metro M4-Microcontroller und dem Ultraschallabstands- sensor ist aufgrund der verwendeten Bibliothek1trivial und wird nicht n√§her erl√§utert. Zur besseren Veranschaulichung wird die Software als Flussdiagramm visualisiert und die einzelnen Funktionalit√§ten im Text genauer beschrieben. Xbee:Wie in Abbildung 5.14dargestellt, agiert der Xbee-Microcontroller in der Kom- munikation mit dem Metro M4-Microcontroller als Controller und steuert somit den Kommunikationsverlauf. Beim Startup wird zun√§chst so lange nach Ger√§ten auf dem I2C-Bus gesucht, bis der Metro M4-Microcontroller gefunden wurde. Ist dies der Fall, wird in einer Endlos-Schleife √ºberpr√ºft, ob eine Nachricht empfangen wurde. Bei Empfang einer Nachricht wird diese √ºber den I2C-Bus an den Metro M4 gesendet und abgefragt, ob dieser aktuelle eine Kollisionsvermeidung ausgef√ºhrt hat. Das Ergebnis dieser Abfrage wird in Form einer collision avoidance message an die Fahrzeugfernsteuerung √ºber IEEE802.15.4 gesendet. Der Quellcode ist in Anhang 3zu finden. Metro M4 Express Airlift: Da der Metro M4-Controller lediglich einen Single-Core ATSAMD51-Microchip besitzt, sind Operationen nur der Reihe nach ausf√ºhrbar. Um zu √ºberpr√ºfen, welche Zeit das Abfragen der Messwerte des Ultraschallsensors ben√∂tigt und damit den Programmablauf optimieren zu k√∂nnen, wird diese Zeit experimentell gemessen. Wie in Abbildung 5.15zu sehen, ist es m√∂glich, dass der Sensor bei Fehlern bis zu einer Millionen Microsekunden f√ºr eine Messung ben√∂tigt, was einer Latenz von einer Sekunde entspricht. Liegt kein Fehlerfall vor, so verh√§lt sich die f√ºr die Messung ben√∂tigte Zeit direkt proportional zur gemessenen Distanz (siehe Abbildung 5.16). Da w√§hrend der Durchf√ºhrung der Distanzmessung der weitere Programmablauf blockiert wird, ist die gemessene Messdauer des Ultraschallsensors nicht akzeptabel (siehe Anforderungen in Kapitel 3.4). Um dies zu beheben, wird eine kleine √Ñnderung an der Bibliothek von Seedstudio vorgenommen, die es erm√∂glicht, in der Arduino-Umgebung einen maximalen Timeout zu spezifizieren2. Wie man in Abbildung 5.17sehen kann, wird mit der ver√§nder- ten Bibliothek bei einem Timeout von 20ms zwar die Messreichweite eingeschr√§nkt, daf√ºr jedoch wird die maximal f√ºr die Messung ben√∂tigte Zeit auf die als Timeout angegebenen 20ms beschr√§nkt und auch eventuelle Ausrei√üer sind innerhalb dieser Grenze zu finden. Um die Anforderungen an die Latenz der Fernsteuerung (vgl. Abschnitt 3.4) bestm√∂glich zu erf√ºllen, wird im Prototypen ein maximaler Timeout von 10ms verwendet, der auch noch Messungen bis zu einer Distanz von 150cm erm√∂glicht.;0
Eine weitere M√∂glichkeit um auf die Detailansicht einer Katzenklappe zu gelangen ist beim Klick auf eine erhaltene Push-Benachrichtigung. Um diese Benachrichtigung zu erhalten muss eine Katzenklappe abonniert werden. Nachdem ein Signal an die abonnierte Katzenklappe gesendet wird, erh√§lt die App eine Push-Benachrichtigung. Beim Erhalt solch einer Benachrichtigung auf das Smartphone gibt es zwei verschiedene M√∂glichkeiten, welche beachtet werden m√ºssen. Es kann eine Nachricht erhalten werden, w√§hrend die App ge√∂ffnet oder geschlossen ist. Falls das Smartphone ausgeschaltet ist, kann dies genauso behandelt werden, als wenn die App geschlossen w√§re. Nachricht bei ge√∂ffneter App Wenn der Benutzer eine Nachricht erh√§lt, w√§hrend die App ge√∂ffnet ist, ben√∂tigt es eine Klasse, welche von FirebaseMessagingService erbt. Dadurch kann man die Methode onMessageReceived √ºberschreiben, um die Daten der erhaltenen Nachricht auszulesen. Des Weiteren kann das Design der Benachrichtigung, w√§hrend die App ge√∂ffnet ist, angepasst werden.;0
Unter dem Begriff Objekterkennung wird das Lokalisieren von Objekten in einem Bild und dessen Markierung mit einer Bounding Box verstanden. Daf√ºr werden zunehmend Algo- rithmen basierend auf k√ºnstlichen neuronale Netzen verwendet. Ein k√ºnstliches neuronales Netz (KNN) geh√∂rt zum Forschungsbereich Deep Learning. Dieser besch√§ftigt sich mit KNNs und versucht die neuronalen Netze von Lebewesen zu modellieren, um maschinelles Lernen zu erm√∂glichen. Somit ist Deep Learning ein Teil von Machine Learning, in dem es um das Lernen des Computers geht, ohne, dass dieser bestimmt programmiert ist. Schlie√ülich geh√∂rt Machine Learning zur k√ºnstlichen Intelligenz, die versucht das menschliche Verhalten mit Maschinen nachzuahmen. Beispielsweise geh√∂rt dazu das Lernen oder das selbst√§ndige L√∂sen von Problemen. Abbildung 2.4 veranschaulicht die Zusammenh√§nge der Bereiche. Aufgrund der Evaluierung mehrere KNN-Modelle zur Objekterkennung im sp√§teren Verlauf der Arbeit, wird im Folgenden nur der Bereich Deep Learning n√§her betrachtet. Abbildung 2.4: Artificial Intelligence vs. Machine Learning vs. Deep Learning Ein KNN besteht aus vielen miteinander verbundenen Neuronen und hat mehrere Schichten, englisch Layer, wie in Abbildung 2.5 dargestellt. Dabei ergeben sich am Ende mehrere Ergebnisse mit Wahrscheinlichkeiten, die besagen zu wie viel Prozent es sich dabei um das richtige Ergebnis handelt. Alle Wahrscheinlichkeiten aufsummiert ergeben 100%. Damit die Ergebnisse am Ende m√∂glichst der Realit√§t entsprechen, m√ºssen die Netze mit vielen Daten trainiert werden, wodurch sie sich selbst anpassen und besser werden. Bei denKNNs gibt es mehrere Varianten, darunter ist das CNN, welches besonders f√ºr die Bilderkennung geeignet ist  und in den sp√§teren Modellen der Arbeit verwendet wird. Zudem gibt es verschiedene Modellarchitekturen mit unterschiedlichen Schichten.DabeihabenmancheModellemehrereSchichten,wodurchdieGenauigkeitbesser wird, welche jedoch daf√ºr rechenintensiver werden.  Im sp√§teren Verlauf der Arbeit werden mehrere Modelle mit unterschiedlichen Architekturen und unterschiedlicher Komplexit√§t verglichen, um ein passendes Modell f√ºr die Katzenerkennung auszuw√§hlen.;0
Die Anzahl von Metriken, die f√ºr die Qualit√§tsbeurteilung von Software eingesetzt werden k√∂nnen,  ist gro√ü. Aus der Vielzahl von Metriken  zur Messung von Quantit√§t, Qualit√§t und Komplexit√§t wurden  im Laufe der Zeit weitere zusammengesetzte Metriken gebildet, die f√ºr spezielle Fragestellungen  herangezogen werden k√∂nnen. Daher ist es entscheidend die Metriken herauszufiltern, die f√ºr die  eige nen Anforderungen relevant sind. Um den Fehler zu vermeiden Messungen nur aus dem Grund  zu bevorzugen, dass sie leicht durchgef√ºhrt werden k√∂nnen, gibt es definierte Vorgehensweise zur  Auswahl von Metriken. Hierbei bilden die Anforderung und das Ziel der Softwaremessung den  Ausgangspunkt.  Anhand von diesen Ans√§tzen werden  nur die Metriken ausgew√§hlt, die zur L√∂sung  des genannten Problems beitragen  und eine zielgerichtete Messung erm√∂glichen . Im Folgenden  werden zwei weit verbreitete Modelle erl√§utert, anhand derer  im Hauptteil der Arbeit Metriken  abgeleitet werden sollen.    Die wohl am meisten genutzte Methode ist der Goal -Question -Metric -Approach. Basili et al.  entwickelten diesen Top -Down -Ansatz bereits 1994.  Er beinhaltet drei Schritte, die zur Ableitung von   Metriken f√ºhren . Das Vorgehen ist in Abbildung  6 schematisch dargestellt.   Den Ausgangspunkt bildet das Ziel, das durch die Messungen erreicht werden soll.  Dieses stellt die  konzeptuelle Ebene dar und muss eine Reihe von Informationen beinhalten.  Beispielsweise k√∂nnen  sich Messungen auf ein Artefakt , einen Prozess oder eine Ressource beziehen.  Die Definition der  Zielsetzung lautet : ‚ÄûA goal is defined for an object, for a variety of reasons,  with respect to various  models of quality, from various points of view, relative to a  particular environment.‚Äú    Auf der  operationellen Ebene sind die Fragestellungen angesiedelt. Diese sollen das festgelegte Ziel  und wie dieses erreicht werden soll, genauer definieren.  Bei der Herleitung der Fragen ist es  entscheidend die im ersten Schritt definierten Rahmenbedingen einzubeziehen.    Im letzten Schritt wird f√ºr jede Fragestellung eine Menge an Metriken abgeleitet. Diese sollen die  Frage durch messbare Gr√∂√üen beantworten  und bilden daher die quantitative Ebene. Dabei ist es  m√∂glich , dass eine Metrik Aussagen  √ºber  mehrere verschiedene Fragen treffen kann.  Anhand der  ausgew√§hlten Metriken k√∂nnen im Weiteren Datenerhebungen durchgef√ºhrt und Interpretationen  aufgestellt werden.;0
Die Umsetzung der Soundbibliothek ist recht einfach gehalten. Um die Liste der hochgela- denen Dateien anzuzeigen, wird beim Aufrufen der Seite ein get Request an den Server gestellt, um alle Dateinamen abzufragen. Jeder dieser Namen wird dann in die Liste geschrieben. F√ºr die weiteren Funktionen hilft es, einen Blick auf den Code-Ausschnitt des HTML Codes 3.4 zu werfen. F√ºr den Datei Upload wird der von Angular vorgegebene Datei Upload verwendet (Zeile 1). Wird eine Datei ausgew√§hlt, wird diese zum Hochladen vorgemerkt, deswegen wird eine Funktion bei √Ñnderungen der Datei Auswahl aufgerufen. Wird der Sumbmit Button gedr√ºckt, wird √ºber dieses Klickevent diese Datei der Liste hinzugef√ºgt (Zeile 2). Beide Funktionen werden im TypeScript Code-Ausschnitt 3.5 abgebildet. Da immer nur eine Datei hochgeladen werden soll, w√§hlt die Funktion onFileInput immer die erste ausgew√§hlte Datei aus, falls mehrere Dateien markiert wurden. Die Funktion addToList braucht einen Dateinamen, deswegen wird √ºberpr√ºft ob dieser Null ist. Ist der Dateiname valide, wird die Datei mit dem Namen auf den Server hochgeladen. Zum Schluss wird der Dateiname ans Ende der bereits vom Server heruntergeladen Liste angef√ºgt. Da aber nicht nur Dateien hochgeladen werden sollen, sondern auch entfernt werden k√∂nnen sollen, werden hinter jedem Dateinamen der Icon Button clearangezeigt:;0
Da diese Grafik noch wenig aussagekr√§ftig ist, sollten die Distanzen besser visualisiert werden, um diese so auf Plausibilit√§t pr√ºfen zu k√∂nnen. Daf√ºr wurde ein Multilaterations- Algorythmus verwendet. Dieser erlaubt es mithilfe von Distanzen, in unserem Fall errechnet durch die Signalst√§rke, die Position des Beacons zu bestimmen. In einem optimalen System k√∂nnte daf√ºr der Schnittpunkt zwischen Kreisen, dessen Radius die oben berechnete Distanz darstellt, verwendet werden. Dies ist in Abbildung 4.11 grafisch dargestellt. Die Kreise, welche die Distanzen abbilden, schneiden sich in diesem Beispiel in einem Punkt. Somit ist die Position genau bestimmt. In unseren Versuchsaufbauten ist dies allerdings √ºber mehrere Tage hinweg bei keinem Datensatz aufgetreten. Dies bedeutet, die Kreise √ºberschneiden sich entweder oder bilden einen Bereich in der Mitte. Dies ist in Abbildung 4.12 dargestellt.;0
Ein Fazit  Die vorliegende Untersuchung zur Optimierung der Visualisierung, Bedienung und Selbstregelung eines elektronisch erweiterten Luftreinigungsger√§tes zielt darauf ab, die Nutzererfahrung zu verbessern und die Effizienz des Ger√§tes zu steigern. In den letzten Jahren hat die Bedeutung von Luftreinigern in Innenr√§umen zugenommen, insbesondere vor dem Hintergrund steigender Luftverschmutzung und der globalen Gesundheitskrisen. Vor diesem Hintergrund wurde ein interdisziplin√§res Projekt ins Leben gerufen, um die genannten Aspekte des Luftreinigers zu analysieren und zu optimieren.  Die Visualisierung der Betriebsparameter ist ein entscheidender Faktor f√ºr die Benutzerakzeptanz und das Verst√§ndnis der Funktionsweise des Ger√§tes. Im Rahmen des Projekts wurde ein intuitives User-Interface entwickelt, das relevante Informationen wie Luftqualit√§t, Filterstatus und Betriebsmodi in Echtzeit anzeigt. Durch den Einsatz von grafischen Darstellungen und Farbcodes konnten Nutzer schnell und einfach den aktuellen Zustand der Luftqualit√§t erkennen. Studien haben gezeigt, dass visuelle Informationen, die klar und ansprechend pr√§sentiert werden, die Nutzerbindung erh√∂hen und das Vertrauen in die Technologie st√§rken.  Ein weiterer zentraler Aspekt war die Optimierung der Bedienung des Ger√§tes. Die Implementierung eines benutzerfreundlichen Touchscreens und die Integration von Sprachsteuerungstechnologien erm√∂glichten eine interaktive und zug√§ngliche Bedienung. Die Nutzer wurden in den Entwicklungsprozess einbezogen, um sicherzustellen, dass die Bedienoberfl√§che ihren Bed√ºrfnissen entspricht. Um die Benutzerfreundlichkeit weiter zu steigern, wurden kontextbezogene Hilfestellungen und Tutorials integriert, die den Nutzern helfen, das volle Potenzial des Ger√§tes auszusch√∂pfen.  Die Selbstregelung des Luftreinigers wurde durch den Einsatz von fortschrittlichen Sensoren und Algorithmen zur Luftqualit√§ts√ºberwachung optimiert. Das Ger√§t ist nun in der Lage, automatisch zwischen verschiedenen Betriebsmodi zu wechseln, je nach den erfassten Umgebungsbedingungen. Diese intelligente Anpassung verbessert nicht nur die Energieeffizienz, sondern sorgt auch f√ºr eine kontinuierliche Optimierung der Luftqualit√§t, ohne dass der Nutzer manuell eingreifen muss. Die Ergebnisse der durchgef√ºhrten Tests zeigen, dass die Selbstregelung signifikant zur Reduzierung von Schadstoffen in der Luft beitr√§gt und die Benutzerzufriedenheit erh√∂ht.  Zusammenfassend l√§sst sich festhalten, dass die  zu einer signifikanten Verbesserung der Nutzererfahrung gef√ºhrt hat. Die Kombination aus intuitiver Benutzeroberfl√§che, interaktiven Bedienm√∂glichkeiten und automatisierten Regelungsmechanismen stellt einen wichtigen Fortschritt in der Entwicklung von Luftreinigern dar. Zuk√ºnftige Forschungen sollten sich auf die kontinuierliche Verbesserung dieser Systeme konzentrieren, um den sich wandelnden Bed√ºrfnissen der Nutzer gerecht zu werden und die Technologie weiter zu verfeinern. Durch die Integration von Nutzerfeedback und die Anwendung neuester technologischer Entwicklungen kann die Effizienz und Akzeptanz von Luftreinigungsger√§ten nachhaltig gesteigert werden.;1
"Evaluierung der wissenschaftlichen Arbeit: ""Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung""  Einleitung Die vorliegende wissenschaftliche Arbeit thematisiert die komplexe Thematik der digitalen √úberwachung, die in der heutigen Gesellschaft immer mehr an Relevanz gewinnt. Der Titel ""Zero"" verweist m√∂glicherweise auf die Idee der vollst√§ndigen Kontrolle oder den Verlust von Privatsph√§re. Die Arbeit untersucht sowohl die technologische als auch die gesellschaftliche Dimension dieser √úberwachung und analysiert potenzielle Chancen und Risiken.  Inhalt und Struktur Die Arbeit ist logisch strukturiert und beginnt mit einer fundierten Einf√ºhrung in die theoretischen Grundlagen der digitalen √úberwachung. Die Definition relevanter Begriffe und Konzepte wird klar und pr√§zise dargelegt, was f√ºr das Verst√§ndnis des Themas unerl√§sslich ist. Anschlie√üend werden die bestehenden Technologien und Methoden der digitalen √úberwachung skizziert, wie etwa Internet√ºberwachung, biometrische Systeme und die Nutzung von K√ºnstlicher Intelligenz.  Ein wichtiger Aspekt der Arbeit ist die Betrachtung der positiven M√∂glichkeiten, die digitale √úberwachung bieten kann, wie etwa die Verbesserung der √∂ffentlichen Sicherheit oder die Effizienzsteigerung in der Verwaltung. Diese positiven Auswirkungen werden jedoch stets im Kontext der damit verbundenen Gefahren diskutiert.  In einem weiteren Kapitel werden die Risiken intensiver digitaler √úberwachung eingehend analysiert. Hierbei werden Themen wie Datenschutz, soziale Kontrolle und die potenzielle Verletzung von Menschenrechten behandelt. Durch die Einbeziehung aktueller Fallstudien und Beispiele aus verschiedenen L√§ndern wird die Argumentation gest√ºtzt. Die Arbeit schlie√üt mit einem Ausblick auf m√∂gliche zuk√ºnftige Entwicklungen und Handlungsempfehlungen zur Regulierung digitaler √úberwachung.  St√§rken der Arbeit - Umfassende Analyse: Die Arbeit bietet eine ausgewogene Analyse der Chancen und Risiken der digitalen √úberwachung, die notwendige Komplexit√§t und differenzierte Betrachtung werden gewahrt. - Aktualit√§t: Die Verwendung aktueller Daten und Studien zeigt, dass die Autorin bzw. der Autor sich intensiv mit der Thematik auseinandergesetzt hat und die neuesten Entwicklungen in der digitalen Welt ber√ºcksichtigt. - Interdisziplin√§rer Ansatz: Die Verbindung von technologischen, gesellschaftlichen und rechtlichen Aspekten verleiht der Arbeit Tiefe und Breite.  Schw√§chen der Arbeit - Fehlende empirische Belege: W√§hrend viele theoretische Konzepte und Meinungen angef√ºhrt werden, k√∂nnte die Arbeit von einer st√§rkeren empirischen Untermauerung profitieren, z. B. durch Umfragen oder Interviews mit Experten. - Mangelnde Ber√ºcksichtigung von Gegenstimmen: In einigen Abschnitten wird die Perspektive der Bef√ºrworter digitaler √úberwachung nicht ausreichend thematisiert, was die Objektivit√§t der Analyse beeintr√§chtigt.  Fazit Insgesamt stellt die Arbeit ""Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung"" einen wertvollen Beitrag zur Diskussion √ºber digitale √úberwachung dar. Sie bietet eine gr√ºndliche Analyse der Chancen und Risiken und regt zur Reflexion √ºber die ethischen und rechtlichen Implikationen an. Mit einigen gezielten Erg√§nzungen insbesondere hinsichtlich empirischer Daten und einer ausgewogeneren Darstellung der verschiedenen Perspektiven k√∂nnte die Arbeit weiter gest√§rkt werden. Die Thematik bleibt hochaktuell und wird in Zukunft mit Sicherheit weiterhin von gro√üer Bedeutung sein.";1
Bereits seit Version 2 des CMS k√∂nnen Beitr√§ge und Seiten mithilfe eines What You See Is What You Get-Editors erstellt werden. Bis zum Release der Version 5.0 wurde der quelloffene TinyMCE-Editor (in Abbildung 4.2 zu sehen) verwendet, welcher parallel zu neueren Releases von WordPress ebenfalls aktualisiert und in seinem Funktionsumfang erweitert wurde. Mit der Einf√ºhrung des ‚ÄûGutenberg‚Äú-Editors mit dem Release der Version 5.0 wurde die WYSIWYG -Erfahrunggrundlegendver√§ndert.InhaltewerdennunperBlockmustererstellt, welche sich in einem Layout anordnen lassen. Hierbei wird jeder Inhaltstyp (Bild, Video, Text, Tabelle, etc.) in Form eines Blocks abgebildet, welcher per Drag-and-Drop-Bewegung innerhalb des Editors an eine beliebige Position verschoben werden kann. Zus√§tzlich l√§sst sich die Funktionalit√§t bzw. die Anzahl an Bl√∂cken durch externe Plugins erweitern.;0
 Wissenschaftlicher ProsatextIn-Room Ortung zur Sturzerkennung mit Bluetooth     Die demografische Entwicklung f√ºhrt zu einer zunehmenden Alterung der Gesellschaft, was die Notwendigkeit effektiver L√∂sungen zur Sturzpr√§vention und -erkennung in der h√§uslichen Umgebung verst√§rkt. St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen bei √§lteren Menschen dar und k√∂nnen erhebliche gesundheitliche sowie wirtschaftliche Folgen nach sich ziehen. In diesem Kontext gewinnt die In-Room Ortung, insbesondere durch Bluetooth-Technologien, an Bedeutung. Dieser Text beleuchtet die theoretischen Grundlagen der In-Room Ortung zur Sturzerkennung und diskutiert die spezifischen Eigenschaften von Bluetooth als geeignetes Kommunikationsprotokoll.   Grundlagen der In-Room Ortung  Die In-Room Ortung bezieht sich auf die pr√§zise Bestimmung des Standorts einer Person innerhalb eines geschlossenen Raumes. Im Gegensatz zur GPS-basierten Ortung, die im Freien funktioniert, erfordert die In-Room Ortung alternative Technologien, da GPS-Signale in Innenr√§umen oft nicht zuverl√§ssig empfangen werden k√∂nnen. Zu den g√§ngigen Technologien der In-Room Ortung z√§hlen unter anderem Wi-Fi, Ultraschall, RFID und Bluetooth.  Bluetooth ist insbesondere aufgrund seiner Energieeffizienz, Kosteneffektivit√§t und breiten Verbreitung in mobilen Endger√§ten der mehrfach verwendete Standard f√ºr die In-Room Ortung. Die Kurzstreckenkommunikation erm√∂glicht es, niedrigere Energiemengen zu nutzen, was f√ºr tragbare Ger√§te wie Smartwatches oder Fitness-Tracker von entscheidender Bedeutung ist.   Prinzipien der Bluetooth-basierten Ortung  Die Bluetooth-Technologie, speziell Bluetooth Low Energy (BLE), nutzt die Idee der Signalst√§rke zur Bestimmung der Position eines Objekts. Dabei werden die Signalst√§rken mehrerer Beacons, die im Raum strategisch platziert sind, gemessen. Die grundlegende Methode zur Berechnung des Standorts ist die Triangulation oder Trilateration. Hierbei wird der relative Abstand zu mindestens drei Beacons ben√∂tigt, um die Position des tragenden Ger√§ts zu bestimmen.  Die Signalst√§rke, die als Received Signal Strength Indicator (RSSI) bezeichnet wird, kann starken Schwankungen unterliegen, die durch physische Hindernisse, Ablenkungen und die Bewegung des Tr√§gers bedingt sind. Deshalb sind Algorithmen zur Filterung dieser Rauschsignale und zur Verbesserung der Standortgenauigkeit unerl√§sslich. Techniken wie Kalman-Filter oder Particle-Filter bieten M√∂glichkeiten, die Unsicherheiten in der Signalst√§rke zu minimieren und eine genauere Positionsbestimmung zu gew√§hrleisten.   Sturzerkennung  Die Sturzerkennung erfordert nicht nur die pr√§zise Ortung, sondern auch die Implementierung von Sensoren, die eine pl√∂tzliche √Ñnderung des Bewegungsmusters erkennen k√∂nnen. Die Integration von Bewegungssensoren wie Beschleunigungs- und Gyroskopsensoren in tragbaren Ger√§ten erm√∂glicht die Erfassung von Sturzereignissen durch die Analyse der Bewegungsdaten in Echtzeit. Ein Sturz kann durch spezifische Muster, wie beispielsweise einen pl√∂tzlichen Abfall der K√∂rperh√∂he oder eine unvermittelte Beschleunigung, identifiziert werden.  Die Kombination von Bewegungs- und Ortungstechnologie ergibt ein effektives System zur Sturzerkennung, das bei einem Unfall automatisch Alarm schlagen kann. Die Daten k√∂nnen an Angeh√∂rige oder ein medizinisches Notfallteam gesendet werden, wodurch die Reaktionszeiten im Falle eines Sturzes erheblich verk√ºrzt werden.   Herausforderungen und Perspektiven  Trotz der vielversprechenden M√∂glichkeiten, die Bluetooth-basierte In-Room Ortung zur Sturzerkennung bietet, gibt es Herausforderungen, die angegangen werden m√ºssen. Dazu z√§hlen die Reduzierung von Fehlalarmen durch St√ºrze, die Optimierung der Energieeffizienz der Sensoren sowie die Verbesserung der Verl√§sslichkeit der Ortung in komplexen Raumstrukturen. Zuk√ºnftige Forschungen sollten sich daher auf die Entwicklung intelligenter Algorithmen konzentrieren, die Muster im Bewegungsverhalten lernen und adaptiv auf unterschiedliche Umgebungen reagieren k√∂nnen.   Fazit  Die In-Room Ortung zur Sturzerkennung mittels Bluetooth stellt eine vielversprechende Methode dar, um das Risiko von Sturzinjuries bei √§lteren Menschen zu minimieren. Durch die Kombination pr√§ziser Ortungstechnologien und fortschrittlicher Sensortechniken kann ein effektives √úberwachungssystem entwickelt werden, das nicht nur zur Sicherheit der Benutzer beitr√§gt, sondern auch deren Unabh√§ngigkeit in der h√§uslichen Umgebung f√∂rdert. Weitere Forschungen und Entwicklungen sind notwendig, um die bestehenden Herausforderungen zu √ºberwinden und die Implementierung solcher Systeme in der Praxis zu optimieren.;1
 Anforderungen an ein Content-Management-System (CMS)  In der heutigen digitalen √Ñra stellen Content-Management-Systeme (CMS) eine entscheidende Grundlage f√ºr die Publikation, Pflege und Verwaltung digitaler Inhalte dar. Besonders in der Betrachtung verschiedenartiger Systeme, wie es im Rahmen dieser wissenschaftlichen Arbeit geschehen soll, ist es unerl√§sslich, eine umfassende Anforderungsanalyse durchzuf√ºhren. Diese Analyse dient nicht nur der Identifikation von St√§rken und Schw√§chen einzelner Systeme, sondern bietet auch eine fundierte Grundlage zur Bewertung ihrer Einsatzm√∂glichkeiten in verschiedenartigen Nutzungskontexten.  Eine zentrale Anforderung an ein CMS ist die Benutzerfreundlichkeit, die sowohl Redakteuren als auch Administratoren eine intuitive Handhabung der Plattform erm√∂glichen sollte. Eine klare, navigierbare Benutzeroberfl√§che sowie umfassende Hilfs- und Schulungsmaterialien sind notwendig, um die Einarbeitung in das System zu erleichtern. Dar√ºber hinaus ist es wichtig, dass die Rollenverteilung innerhalb des CMS klar definiert ist und jeder Benutzer die ihm zugewiesenen Berechtigungen maximieren kann, ohne Komplikationen zuDB-I-RageMediaMitText hindern.  Ein weiterer wesentlicher Aspekt ist die Flexibilit√§t und Anpassungsf√§higkeit des Systems. In Zeiten sich schnell √§ndernder Technologien m√ºssen CMS in der Lage sein, neue Anforderungen, Trends und ge√§nderte Gesch√§ftsmodelle aufzunehmen. Dies beinhaltet die M√∂glichkeit der Integration verschiedener Plugins, Erweiterungen und API-Schnittstellen, um eine individuell zugeschnittene Nutzungserfahrung zu gew√§hrleisten. Dar√ºber hinaus sollte das CMS eine responsive Gestaltung unterst√ºtzen, um eine einheitliche Nutzererfahrung √ºber verschiedene Endger√§te hinweg‚Äîinsbesondere Mobilger√§te‚Äîsicherzustellen.  Zus√§tzlich spielen SEO-Funktionen eine entscheidende Rolle bei der Auswahl eines geeigneten CMS. Die Optimierung f√ºr Suchmaschinen ist von hoher Bedeutung, um die Sichtbarkeit von Inhalten in der digitalen Landschaft zu maximieren. Zu den diesbez√ºglichen Anforderungen geh√∂ren nicht nur einfach zu bedienende Mechanismen zur Darstellung und Pflege von Metadaten, sondern auch die F√∂rderungen einer guten Seitenladegeschwindigkeit sowie die Gew√§hrleistung technischer Aspekte der OnPage-Optimierung.  Die Sicherheit des gegebenen Systems stellt ein essentielles Element dar, da CMS h√§ufig Ziel von Cyberangriffen sind. In diesem Kontext ist die Implementierung von Sicherheitsmatrizen, regelm√§√üigen Updates und Patches sowie der Schutz gegen unbefugten Zugriff und Datenverluste durch verschl√ºsselte Datenspeicherung erheblich. Genauso sind Backup- und Wiederherstellungsmechanismen zu betrachten, was entscheidend f√ºr die Gew√§hrleistung der Datenverf√ºgbarkeit ist.  Abschlie√üend sollte nicht unerw√§hnt bleiben, dass eine umfassende Support- und Wartungsstruktur Teil der Anforderungen an ein CMS sein muss. Ob international agierende Firmen oder kleine, lokale Anbieter ‚Äì der Zugang zu fortlaufenden technischen Supportdiensten sowie eine aktive Entwickler-Community sind unverzichtbar, um schnelle Probleml√∂sungen und den Austausch bew√§hrter Praktiken zu f√∂rdern.  In der Gesamtschau lassen sich somit die Anforderungen an ein CMS hinsichtlich Benutzerfreundlichkeit, Flexibilit√§t, SEO-Optimierung, Sicherheit und Support formulieren. Diese Aspekte bilden das Fundament f√ºr eine fundierte gegen√ºberstellung unterschiedlicher Systeme sowie f√ºr den potenziellen Einsatz in spezifischen Anwendungsf√§llen.;1
Auch wenn das Buch sich wie eine Utopie lesen mag, hat es viele realistische Anteile und Techniken, die auch heute verwendet werden. Die Art der √úberwachung ist teilweise extrem, aber es gibt Staaten auf dieser Welt die eine genauso gro√üe √úberwachung haben. Man sollte nicht vergessen, dass es auch eine Rolle spielt, von wem die √úberwachung ausgeht. Diese geht nicht nur von Staaten aus, sondern auch von profitgetriebenen gro√üen Firmen. Mit der Analyse verschiedener Techniken konnte gezeigt werden, dass es viele M√∂glichkeiten zur umfangreichen √úberwachung gibt. Diese haben positive Aspekte, wie als Beispiel das einfachere Fassen von Straft√§tern. Allerdings gibt es auch Gefahren. So k√∂nnen Menschen bewusst manipuliert werden, im Interesse des Manipulators. Au√üerdem kann die Privatsph√§re extrem eingeschr√§nkt werden. Diese beiden letzten Aspekte sind vor allem wichtig in autokratischen oder diktatorischen Systemen. Wo es dann auch zu Menschenrechtsverletzungen kommen kann. Au√üerdem sind die meisten Algorithmen und Trainingsdaten nicht open source. Man wei√ü also nicht wie genau diese funktionieren, oder ob diese bewusst in eine Richtung gelenkt werden. Dies kann zum Beispiel durch Anpassung der Trainingsdaten gehen. Einen positiven Ausblick kann man auch in andere Bereiche oder Branchen fassen. So k√∂nnen √Ñrzte in der Medizin bei Diagnose und dem Befund unterst√ºtzt werden. Au√üerdem kann der Fortschritt nach Operationen schon fr√ºhzeitig √ºberpr√ºft werden. Das kann z.B. durch Ganganalysen erfolgen (J√∂llenbeck und Pietschmann 2019). Ein weiteres gro√ües Gebiet w√§re das autonome Fahren. Dort braucht man eine gro√üe Menge an Trainingsdaten und eine leistungsstarke KI um den Gefahren auf der Stra√üe gewappnet zu sein. So konnte der Hersteller Waymo 2020 mit seinen Autos insgesamt √ºber 32 Millionen Kilometer zur√ºcklegen (online 2022a). So viele Kilometer kann ein Mensch in seinem ganzen Leben nicht zur√ºcklegen. Damit hat Waymo die Chance durch viel mehr Erfahrung und Fahrpraxis in unvorhergesehenen Situationen besser abzuschneiden als ein Mensch. Durch diese viel gr√∂√üere Erfahrung wei√ü die KI eher wie sie in bestimmten Situationen reagieren soll, da sie diese schon mal erlebt haben kann, w√§hrend das bei einem Menschen eher unwahrscheinlich ist.;0
Die anderen FP werden durch ‚ÄûExternal Inputs‚Äú  EI , ‚ÄûExternal Outputs‚Äú  EO  und ‚ÄûExternal  Queries‚Äú  EQ  beigesteuert.  EIs sind Vorg√§nge, bei welchen Daten in die Applikation  aufgenommen und verwendet werden, um ILFs zu bearbeiten. Darunter fallen  beispielsweise  Bildschirmfenster, um ein Arbeitspaket zu bearbeiten oder einen neuen Account zu erstellen.  EQ sind Vorg√§nge, bei denen Daten die Systemgrenze verlassen, ohne manipuliert zu  werden.  Alle Daten, die in einer EQ angezeigt werden, m√ºssen aus den Daten ermittelbar sein, ohne  mathematische Funktionen anzuwenden. Werden hingegen mathematische Funktionen  verwendet oder m√ºssen Daten in den ILFs ver√§ndert werden, um eine EQ auszuf√ºhren,  handelt es sich nicht mehr um eine EQ, sondern um einen EO.  Ein konkretes Beispiel, um den Unterschied zwischen EO und EQ zu erkl√§ren, ist die Anzeige  von Arbeitspaketen. Um den aufgewendeten Aufwand zu dokumentieren, k√∂nnte dem  Arbeitspaket ein Zahlenattribut hinzugef√ºgt werden. Wird ein Aufwand gebucht, wird die Zahl  erh√∂ht. Alternativ kann der Aufwand als eigenst√§ndiges Objekt dokumentiert werden, in  welchem pro Aufwand dokumentiert wird, welche Person wie viel Zeit aus welchem Grund an  welchem Arbeitspaket aufgewendet hat, √§hnlich wie in Jira Software. In  diesem Fall w√§re es  m√∂glich, die gesamte erfasste Arbeitszeit an einem Arbeitspaket aus den einzelnen  Aufw√§nden zu berechnen, anstatt die Summe am Arbeitspaket zu speichern. Die Anzeige eines  Arbeitspaketes kann als EQ bezeichnet werden, wenn der summierte Aufwand bereits als Zahl  in den ILFs vorhanden ist und abgerufen werden kann. Wird der summierte Aufwand erst bei  Abruf der Daten aus den einzelnen Aufw√§nden berechnet, ist diese Bildschirmseite als EO zu  bewerten.;0
 Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Die zunehmende Verbreitung des Internets der Dinge (IoT) hat zu einer Vielzahl von Plattformen und Frameworks gef√ºhrt, die Entwicklern helfen, IoT-Anwendungen effizient zu erstellen und zu implementieren. Eine bemerkenswerte Plattform in diesem Kontext ist ElixirNerves, die auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von IoT-Ger√§ten konzipiert wurde. Um die Eignung von ElixirNerves als Plattform f√ºr IoT-Anwendungen zu bewerten, ist es wichtig, die theoretischen Grundlagen zu betrachten, die die Architektur und Funktionalit√§t dieser Plattform untermauern.   1. Elixir und die Erlang-VM  Elixir ist eine funktionale, concurrent Programmiersprache, die auf der Erlang Virtual Machine (BEAM) ausgef√ºhrt wird. Die Wahl von Elixir als Basis f√ºr IoT-Anwendungen bringt mehrere Vorteile mit sich, die auf den theoretischen Prinzipien von Erlang beruhen. Erlang wurde urspr√ºnglich f√ºr die Entwicklung von hochverf√ºgbaren und fehlertoleranten Systemen entwickelt. Die zugrunde liegenden Konzepte wie ‚ÄûActor Model‚Äú und ‚ÄûMessage Passing‚Äú erm√∂glichen eine effektive Handhabung von parallelen Prozessen, was f√ºr die reaktive Natur von IoT-Anwendungen von entscheidender Bedeutung ist. Diese Eigenschaften f√∂rdern die Entwicklung von Systemen, die robust gegen Ausf√§lle sind und gleichzeitig eine hohe Verf√ºgbarkeit bieten.   2. Nerves-Framework  Das Nerves-Framework erweitert die M√∂glichkeiten von Elixir, indem es spezifische Funktionen f√ºr die Entwicklung von IoT-Ger√§ten bereitstellt. Es bietet eine modulare Architektur, die es Entwicklern erm√∂glicht, Hardware-nahe Software zu erstellen, ohne tief in die Komplexit√§t der zugrunde liegenden Systeme eintauchen zu m√ºssen. Theoretisch betrachtet, erm√∂glicht die modulare Struktur eine bessere Wartbarkeit und Erweiterbarkeit von Anwendungen, was f√ºr die langfristige Entwicklung von IoT-Projekten von zentraler Bedeutung ist. Zudem unterst√ºtzt Nerves die Erstellung von ‚ÄûFirmware‚Äú, die auf einer Vielzahl von Hardware-Plattformen eingesetzt werden kann, was die Flexibilit√§t und Interoperabilit√§t der IoT-Ger√§te erh√∂ht.   3. Echtzeitverarbeitung und nebenl√§ufige Programmierung  Ein zentrales Element der IoT-Anwendungen ist die F√§higkeit zur Echtzeitverarbeitung von Daten. ElixirNerves nutzt die St√§rken der BEAM-Architektur, um nebenl√§ufige Programmierung zu unterst√ºtzen. Diese theoretische Grundlage erm√∂glicht es, dass mehrere Prozesse gleichzeitig laufen, was f√ºr die Verarbeitung von Sensordaten und die Reaktion auf Ereignisse in Echtzeit entscheidend ist. Die F√§higkeit, mehrere Prozesse zu managen und zu kommunizieren, ist besonders relevant in einem IoT-Kontext, in dem zahlreiche Ger√§te und Sensoren gleichzeitig Daten generieren und verarbeiten m√ºssen.   4. Fehlerbehandlung und Systemstabilit√§t  Die Fehlerbehandlung ist ein weiteres zentrales Konzept, das ElixirNerves von anderen Plattformen unterscheidet. Erlang und damit auch Elixir verwenden das ‚ÄûLet it crash‚Äú-Prinzip, das bedeutet, dass Systeme so entworfen werden, dass sie bei Fehlern nicht abst√ºrzen, sondern stattdessen die;1
Der Testlauf wurde auf einem Microsoft Surface Pro 7 mit einem Intel i5-1035G4 und 8 GB Arbeitsspeicher durchgef√ºhrt. Als Interpreter wurde Python 3.9 verwendet. Als MQTT-Broker wurde mosquitto derEclipse Foundation verwendet, der auf einer lokalen Docker-Installation als Container ausgef√ºhrt wurde. Zum Erstellen des Docker-Containers wurde das docker-compose Skript aus Listing A.1 mit docker-compose up -d ausgef√ºhrt. Die Konfiguration des mosquitto-Servers ist in Listing A.2 zu sehen. Abbildung 5.1: Smart Home-Ger√§te Nachdem das Programm mit python src\main.py ausgef√ºhrt wird, √∂ffnet sich das GUI mit dem geladenen Beispielszenario, welches in Abbildung 5.1 zu sehen ist. Mit einem Klick auf den Button Start Scenario verbinden sich die Ger√§te mit dem lokalen MQTT- Broker. Als Szenario werden Ger√§te in einem Wohnzimmer, einem Schlafzimmer und einem Badezimmer simuliert. Alle R√§ume haben jeweils einen Thermometer, Lampen, Fernbedienungen, Fenster und eine Heizung. Des Weiteren gibt es eine Uhr und einen Wettersensor, die zu keinem der drei R√§ume zugewiesen sind. Es wurden die folgenden Interaktionen getestet:;0
    Die fortschreitende Digitalisierung und Vernetzung von Fahrzeugen er√∂ffnet neue M√∂glichkeiten f√ºr die Automatisierung und Fernsteuerung. Insbesondere die Entwicklung von Fahrzeugfernsteuerungssystemen, die eine sichere und zuverl√§ssige Interaktion zwischen Mensch und Maschine erm√∂glichen, ist von gro√üer Bedeutung. In diesem Kontext wird die Implementierung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung auf Basis des IEEE 802.15 Standards untersucht. Dieser Standard, der f√ºr drahtlose pers√∂nliche Netzwerke (WPAN) konzipiert wurde, bietet eine geeignete Grundlage f√ºr die Entwicklung von Kommunikationsprotokollen in Fahrzeuganwendungen.  Technologischer Hintergrund  IEEE 802.15 umfasst verschiedene Standards, die f√ºr drahtlose Kommunikation in pers√∂nlichen Netzwerken verwendet werden. Besonders relevant f√ºr die Fahrzeugfernsteuerung ist der IEEE 802.15.4 Standard, der eine energieeffiziente Kommunikation in kurzen Reichweiten erm√∂glicht. Die Verwendung von IEEE 802.15.4 f√ºr die Fahrzeugfernsteuerung bietet Vorteile wie niedrigen Energieverbrauch, hohe Flexibilit√§t und einfache Implementierung. Diese Eigenschaften sind entscheidend, um eine zuverl√§ssige Kommunikation zwischen der Fernsteuerungseinheit und dem Fahrzeug zu gew√§hrleisten.  Systemarchitektur  Die Systemarchitektur der Fahrzeugfernsteuerung besteht aus mehreren Komponentender Fernsteuerungseinheit, dem Fahrzeugmodul und dem Kollisionsvermeidungssystem. Die Fernsteuerungseinheit ist mit einem Mikrocontroller ausgestattet, der √ºber ein IEEE 802.15.4-Modul verf√ºgt, um die drahtlose Kommunikation zu erm√∂glichen. Das Fahrzeugmodul enth√§lt ebenfalls einen Mikrocontroller, der die Steuerbefehle empf√§ngt und die Fahrzeugbewegungen steuert. Das Kollisionsvermeidungssystem besteht aus Sensoren, die die Umgebung des Fahrzeugs √ºberwachen und potenzielle Kollisionen erkennen.  Implementierung der Kommunikationsschnittstelle  Die Implementierung der Kommunikationsschnittstelle erfolgt durch die Programmierung der Mikrocontroller unter Verwendung einer geeigneten Entwicklungsumgebung. Die Kommunikation zwischen der Fernsteuerungseinheit und dem Fahrzeugmodul wird durch ein benutzerdefiniertes Protokoll realisiert, das auf der IEEE 802.15.4-Standardisierung basiert. Die Daten√ºbertragung erfolgt in Form von Paketen, die Steuerbefehle sowie Statusinformationen enthalten.  Zur Gew√§hrleistung der Datenintegrit√§t und -sicherheit werden Mechanismen wie Pr√ºfziffern und Authentifizierung implementiert. Diese Ma√ünahmen sind entscheidend, um sicherzustellen, dass die √ºbermittelten Informationen nicht manipuliert werden k√∂nnen und die Kommunikation zwischen den Ger√§ten zuverl√§ssig bleibt.  Kollisionsvermeidungssystem  Das Kollisionsvermeidungssystem spielt eine zentrale Rolle in der Fahrzeugfernsteuerung. Es basiert auf einer Kombination aus Sensorik und Algorithmen zur Datenverarbeitung. Ultraschallsensoren und Lidar-Systeme werden eingesetzt, um die Umgebung des Fahrzeugs in Echtzeit zu scannen und Hindernisse zu identifizieren. Die gesammelten Daten werden an den Mikrocontroller des Fahrzeugmoduls √ºbermittelt, der daraufhin die notwendigen Entscheidungen trifft, um Kollisionen zu vermeiden.  Die Implementierung eines Algorithmus zur Kollisionsvermeidung erfolgt durch die Verwendung von;1
 Kapitel 2: Technische Grundlagen von Content-Management-Systemen  In der heutigen digitalen √Ñra sind Content-Management-Systeme (CMS) unverzichtbare Werkzeuge f√ºr die Verwaltung und Ver√∂ffentlichung von Inhalten im Internet. Sie bieten eine strukturierte Umgebung, in der Benutzer ohne tiefgehende technische Kenntnisse Inhalte erstellen, bearbeiten und organisieren k√∂nnen. Dieses Kapitel befasst sich mit den technischen Grundlagen von CMS, die f√ºr die anschlie√üende Gegen√ºberstellung der verschiedenen Systeme von zentraler Bedeutung sind.   2.1 Definition und Funktionsweise eines CMS  Ein Content-Management-System ist eine Softwareanwendung, die es Benutzern erm√∂glicht, digitale Inhalte zu erstellen, zu verwalten und zu ver√∂ffentlichen. Die grundlegende Funktionsweise eines CMS beruht auf zwei Hauptkomponenten: dem Content-Management-Framework und der Content-Presentation-Engine. Das Framework erm√∂glicht die Erstellung und Bearbeitung von Inhalten, w√§hrend die Pr√§sentations-Engine daf√ºr verantwortlich ist, diese Inhalte in einer benutzerfreundlichen und ansprechenden Weise darzustellen.  Ein typisches CMS umfasst mehrere Module, darunter:  - Content-Editor: Ein Werkzeug zur Erstellung und Bearbeitung von Inhalten, oft mit einer WYSIWYG-Oberfl√§che (What You See Is What You Get), die es Benutzern erm√∂glicht, Inhalte visuell zu formatieren. - Datenbank: Eine strukturierte Sammlung von Daten, die alle Inhalte, Benutzerinformationen und Metadaten speichert. Die Wahl des Datenbankmanagementsystems (DBMS) kann die Leistung und Skalierbarkeit eines CMS erheblich beeinflussen. - Template-Engine: Eine Komponente, die das Design und Layout der ver√∂ffentlichten Inhalte steuert. Templates erm√∂glichen es Benutzern, das Erscheinungsbild ihrer Website zu √§ndern, ohne die zugrunde liegenden Inhalte zu beeinflussen. - Benutzermanagement: Systeme zur Verwaltung von Benutzerrollen und -berechtigungen, die sicherstellen, dass nur autorisierte Benutzer auf bestimmte Funktionen und Inhalte zugreifen k√∂nnen.   2.2 Architektur von Content-Management-Systemen  Die Architektur eines CMS kann in verschiedene Modelle unterteilt werden, die sich in ihrer Struktur und ihrem Einsatzgebiet unterscheiden. Die g√§ngigsten Architekturen sind:  - Monolithische Architektur: In diesem Modell sind alle Komponenten des CMS eng miteinander verbunden. Diese Systeme sind oft einfach zu implementieren, k√∂nnen jedoch in Bezug auf Skalierbarkeit und Flexibilit√§t eingeschr√§nkt sein. Beispiele f√ºr monolithische CMS sind WordPress und Joomla.  - Modularisierte Architektur: Hierbei handelt es sich um ein flexibles Modell, bei dem verschiedene Module unabh√§ngig voneinander entwickelt und implementiert werden k√∂nnen. Diese Architektur erm√∂glicht eine einfachere Anpassung und Erweiterung des Systems. Typische Beispiele sind Drupal und TYPO3.  - Headless CMS: Ein relativ neues Konzept, bei dem das CMS nur f√ºr die Verwaltung von Inhalten zust√§ndig ist, w√§hrend die Pr√§sentation der Inhalte √ºber eine separate Frontend-Anwendung erfolgt. Diese Trennung erm√∂glicht eine gr√∂√üere Flexibilit√§t bei der Darstellung der Inhalte auf verschiedenen Plattformen und Ger√§ten. Beispiele f√ºr Headless CMS sind Contentful und Strapi.   2.3 Technologien und Standards  Die technische Basis eines CMS umfasst eine Vielzahl von Technologien und Standards, die dessen Funktionalit√§t und Interoperabilit√§t gew√§hrleisten;1
Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die demografische Entwicklung in vielen Industriel√§ndern f√ºhrt zu einer stetig wachsenden √§lteren Bev√∂lkerung, die oft mit einem erh√∂hten Risiko f√ºr St√ºrze konfrontiert ist. In diesem Kontext gewinnt die In-room Ortung zur Sturzerkennung zunehmend an Bedeutung. Innovative Technologien, insbesondere solche, die auf Bluetooth basieren, er√∂ffnen vielversprechende Perspektiven f√ºr die Verbesserung der Sicherheit und Lebensqualit√§t √§lterer Menschen. Dieser Prosatext untersucht die aktuellen Ans√§tze zur Sturzerkennung mithilfe von Bluetooth-Technologien und gibt einen Ausblick auf m√∂gliche zuk√ºnftige Entwicklungen.  Die Grundprinzipien der In-room Ortung beruhen auf der Nutzung von Bluetooth Low Energy (BLE), einer energieeffizienten Variante des Bluetooth-Standards. BLE erm√∂glicht die Kommunikation zwischen tragbaren Ger√§ten, wie Smartwatches oder speziellen Sensoren, und fest installierten Bluetooth-Empf√§ngern in einem Raum. Durch die triangulierte Positionierung dieser Ger√§te k√∂nnen Bewegungsmuster analysiert und im Falle eines Sturzes sofortige Alarmmeldungen an Angeh√∂rige oder Pflegepersonal gesendet werden. Aktuelle Systeme kombinieren diese Technologie h√§ufig mit Algorithmen zur Mustererkennung, die in der Lage sind, zwischen normalen Bewegungen und Sturzereignissen zu differenzieren.  Ein bedeutender Aspekt der Weiterentwicklung in diesem Bereich k√∂nnte die Integration von K√ºnstlicher Intelligenz (KI) sein. Durch den Einsatz von maschinellem Lernen k√∂nnten Algorithmen trainiert werden, um die Bewegungsdaten von Nutzern besser zu verstehen und zu interpretieren. Dies w√ºrde nicht nur die Genauigkeit der Sturzerkennung erh√∂hen, sondern auch die M√∂glichkeit bieten, individuelle Bewegungsprofile zu erstellen. So k√∂nnten spezifische Risikofaktoren identifiziert und pr√§ventive Ma√ünahmen ergriffen werden, bevor es zu einem Sturz kommt.  Ein weiterer vielversprechender Entwicklungspfad ist die Verbesserung der Sensorik. Zuk√ºnftige Ger√§te k√∂nnten mit einer Vielzahl von Sensoren ausgestattet werden, die nicht nur die Position, sondern auch andere relevante Parameter wie Herzfrequenz, Temperatur und Aktivit√§tslevel √ºberwachen. Solche multidimensionalen Datens√§tze w√ºrden eine umfassendere Analyse des Gesundheitszustands eines Nutzers erm√∂glichen und k√∂nnten potenziell pr√§zisere Vorhersagen √ºber Sturzrisiken liefern.  Die Vernetzung der In-room Ortungssysteme mit Smart-Home-Technologien k√∂nnte ebenfalls eine signifikante Rolle spielen. Durch die Integration in ein umfassendes Smart-Home-System k√∂nnten nicht nur Sturzereignisse erkannt, sondern auch automatisch Ma√ünahmen ergriffen werden, wie beispielsweise das Einschalten von Licht, um das Risiko weiterer St√ºrze in dunklen R√§umen zu minimieren. Zudem k√∂nnte die Kommunikation zwischen verschiedenen Ger√§ten, etwa zwischen einem Sturzsensor und einem Notrufsystem, in Echtzeit optimiert werden, was die Reaktionszeiten erheblich verk√ºrzen w√ºrde.  Schlie√ülich ist auch die ethische Dimension der In-room Ortung nicht zu vernachl√§ssigen. W√§hrend die Technologie potenziell erhebliche Vorteile f√ºr die Sicherheit √§lterer Menschen bietet, m√ºssen Fragen des Datenschutzes und der Privatsph√§re beachtet werden. Zuk√ºnftige Entwicklungen sollten daher auch L√∂sungen beinhalten, die den Nutzern Kontrolle √ºber ihre Daten;1
 Vergleich von Progressiven Web-Apps (PWA) und nativen Apps am Beispiel einer Journaling-AppEin Konzept zur Umsetzung     Die Digitalisierung hat die Art und Weise, wie Benutzer mit Software interagieren, revolutioniert. Insbesondere im Bereich der mobilen Anwendungen sind zwei Ans√§tze hervorgetreten, die jeweils spezifische Vor- und Nachteile bietennative Apps und Progressive Web Apps (PWAs). Dieser Text zielt darauf ab, ein Konzept zur Umsetzung einer Journaling-App zu entwickeln, indem die beiden Ans√§tze verglichen werden.    Definition und Merkmale  Native Apps sind speziell f√ºr eine bestimmte Plattform (iOS, Android) entwickelte Anwendungen. Sie nutzen die jeweiligen Betriebssystem-APIs und bieten dadurch eine hohe Leistung und Benutzererfahrung. Zu den Hauptmerkmalen geh√∂ren - Zugriff auf Ger√§tefunktionenNative Apps k√∂nnen auf eine Vielzahl von Funktionen zugreifen, wie Kamera, GPS und Benachrichtigungen. - Offline-Funktionalit√§tSie k√∂nnen ohne Internetverbindung betrieben werden, was die Benutzerfreundlichkeit erh√∂ht. - Benutzeroberfl√§cheNative Apps passen sich nahtlos an die Designrichtlinien der jeweiligen Plattform an.  Progressive Web Apps hingegen sind Webseiten, die mit modernen Webtechnologien entwickelt werden, um ein App-√§hnliches Erlebnis zu bieten. Ihre Merkmale umfassen - Plattformunabh√§ngigkeitPWAs laufen in einem Webbrowser und sind somit auf verschiedenen Ger√§ten und Betriebssystemen zug√§nglich. - Einfache AktualisierungUpdates erfolgen automatisch, ohne dass der Benutzer eine neue Version herunterladen muss. - InstallationBenutzer k√∂nnen PWAs direkt √ºber den Browser installieren, ohne den App Store zu durchlaufen.   Konzept zur Umsetzung einer Journaling-App  Um die Vorz√ºge beider Ans√§tze zu nutzen, wird ein Konzept zur Entwicklung einer Journaling-App skizziert, das sowohl native als auch PWA-Elemente ber√ºcksichtigt.   1. Zielgruppe und Anwendungsf√§lle  Die Zielgruppe umfasst Nutzer, die Wert auf eine einfache und intuitive M√∂glichkeit legen, ihre Gedanken und Erlebnisse festzuhalten. Die Anwendung soll Funktionen wie t√§gliche Eintr√§ge, Erinnerungen, Tags und eine Suchfunktion bieten.    2. Funktionale Anforderungen  - Benutzerregistrierung und -authentifizierungSowohl native als auch PWA-Versionen sollten sichere Anmeldemethoden bieten. - TexteditorEin flexibler Editor, der Markdown unterst√ºtzt, um Benutzern die Formatierung ihrer Eintr√§ge zu erm√∂glichen. - Such- und FilterfunktionenBenutzer sollten in der Lage sein, ihre Eintr√§ge nach Datum, Tags oder Schl√ºsselw√∂rtern zu durchsuchen. - SynchronisationDie M√∂glichkeit, Eintr√§ge zwischen verschiedenen Ger√§ten zu synchronisieren, ist entscheidend.   3. Technologische √úberlegungen  Native App-Entwicklung- ProgrammiersprachenSwift f√ºr iOS und Kotlin f√ºr Android. - BackendVerwendung von Cloud-Diensten wie Firebase zur Speicherung der Daten und zur Authentifizierung. - VorteileH√∂here Leistung, bessere Integration in die Plattform und Offline-Zugriff.  PWA-Entwicklung- TechnologienHTML, CSS, JavaScript mit Frameworks wie React oder Angular. - Service WorkerImplementierung;1
IoT (Internet of Things) ist nicht nur ein g√§ngiges IT-Schlagwort, sondern ein allgemeiner Trend, der sich st√§ndig weiterentwickelt und fast alle Bereiche der heutigen Gesellschaft mit IT-Unterst√ºtzung voranbringt. Bei der Umsetzung solcher Systeme ist darauf zu achten, welche Technologien eingesetzt werden, denn die Lebensdauer eines solchen Ger√§ts skaliert zwischen 15 und 20 Jahren. In Konsequenz sollten diese Ger√§te, sowie die damit zusam- menh√§ngende Software, so lange wie m√∂glich ohne signifikante Fehlerfunktionen, Bugs und Sicherheitsl√ºcken funktionieren. F√ºr die Implementierung dieser Software ist der Einsatz der geeigneten Technologien und einer ad√§quaten Programmiersprache entscheidend. Im Rahmen dieser Studienarbeit wird Komplexit√§t und Aufwand des Open-Source- Frameworks Nerves und der funktionalen Programmiersprache Elixir bei der strukturierten Entwicklung mehrerer IoT-Knoten untersucht und bewertet. Im Fokus steht die Entwick- lung von netzwerkf√§higen IoT-Knoten, die automatisiert Sensordaten zusammenfassen und ver√∂ffentlichen. Des Weiteren werden die konstruierten Systeme an eine Datenbank ange- bunden, um die Messergebnisse mit der Open-Source-Anwendung Grafana abzubilden. Die folgenden Aspekte sind Ziele der Arbeit: ‚Ä¢Zusammenfassung von Problemen, Herausforderungen und Fokusfeldern bei der Entwicklung von IoT-Systemen ‚Ä¢Dokumentation der Prozessketten unterschiedlicher IoT-Knoten ‚Ä¢Evaluation von Elixir und Nerves innerhalb und au√üerhalb des Entwicklungsprozesses hinsichtlich charakteristischen Merkmalen der konstruierten IoT-Systeme Es wird erwartet, dass das Open-Source-Framework Nerves in Kombination mit der Programmiersprache Elixir einen erheblichen Mehrwert bei der Entwicklung von IoT- Systemen liefert.;0
Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachungEin Ausblick auf zuk√ºnftige Entwicklungen  In der √Ñra der digitalen Transformation hat die √úberwachung durch technologische Systeme eine neue Dimension erreicht. Der Begriff ‚ÄûZero‚Äú steht nicht nur f√ºr die Null-Toleranz-Politik gegen√ºber Verbrechen, sondern auch f√ºr das Potenzial, das in der umfassenden digitalen √úberwachung steckt. W√§hrend die M√∂glichkeiten, die sich aus dieser Entwicklung ergeben, unbestreitbar sind, werfen sie gleichzeitig eine Vielzahl von ethischen, sozialen und politischen Fragen auf. Der vorliegende Text beleuchtet die Chancen und Risiken der digitalen √úberwachung und bietet einen Ausblick auf m√∂gliche zuk√ºnftige Entwicklungen.  Die M√∂glichkeiten der digitalen √úberwachung sind vielf√§ltig. Fortschritte in der K√ºnstlichen Intelligenz (KI) und der Datenanalyse erlauben es, gro√üe Datenmengen in Echtzeit zu verarbeiten und Muster zu erkennen, die zuvor unentdeckt blieben. In der Kriminalit√§tsbek√§mpfung k√∂nnen solche Technologien dazu beitragen, Verd√§chtige schneller zu identifizieren und potenzielle Verbrechen pr√§ventiv zu verhindern. Die Integration von √úberwachungssystemen in Smart Cities k√∂nnte zudem dazu beitragen, die √∂ffentliche Sicherheit zu erh√∂hen und Verkehrsfl√ºsse zu optimieren. Durch den Einsatz von Sensoren und vernetzten Ger√§ten k√∂nnte der √∂ffentliche Raum sicherer und effizienter gestaltet werden.  Jedoch sind die Gefahren, die mit der digitalen √úberwachung einhergehen, nicht zu vernachl√§ssigen. Die schleichende Erosion der Privatsph√§re ist eine der gravierendsten Konsequenzen, die aus der umfassenden Datenerfassung resultiert. Die fortschreitende Automatisierung und der Einsatz von Algorithmen zur Entscheidungsfindung k√∂nnen zudem zu Diskriminierung und Ungerechtigkeit f√ºhren, wenn sie nicht transparent und verantwortungsbewusst gestaltet werden. Ein Beispiel hierf√ºr sind sogenannte ‚ÄûPredictive Policing‚Äú-Modelle, die auf historischen Daten basieren und dazu neigen, bestimmte Bev√∂lkerungsgruppen √ºberproportional zu √ºberwachen.  Im Hinblick auf zuk√ºnftige Entwicklungen ist zu erwarten, dass die digitale √úberwachung weiter zunehmen wird. Technologische Innovationen, wie die Verbreitung von 5G-Netzen und das Internet der Dinge (IoT), werden die Erfassung und Analyse von Daten in bisher ungekanntem Ausma√ü erm√∂glichen. Diese Technologien k√∂nnten nicht nur in der Kriminalit√§tsbek√§mpfung, sondern auch im Gesundheitswesen, im Bildungsbereich und in der Verwaltung Anwendung finden. So k√∂nnten beispielsweise tragbare Technologien zur Gesundheits√ºberwachung in der Lage sein, Krankheitsausbr√ºche fr√ºhzeitig zu erkennen, w√§hrend intelligente Bildungssysteme personalisierte Lernwege f√ºr Sch√ºler entwickeln k√∂nnten.  Gleichzeitig ist es von entscheidender Bedeutung, dass Gesellschaften Mechanismen zur Regulierung und Kontrolle dieser Technologien entwickeln. Der Schutz der Privatsph√§re und die Gew√§hrleistung von Transparenz m√ºssen im Zentrum der Debatte um digitale √úberwachung stehen. Ein m√∂glicher Ansatz k√∂nnte die Etablierung von Ethikkommissionen sein, die die Implementierung neuer Technologien begleiten und sicherstellen, dass diese im Einklang mit gesellschaftlichen Werten stehen.  Ein weiterer Aspekt ist die internationale Dimension der digitalen √úberwachung. In einer zunehmend vernetzten Welt ist die Frage der globalen Standards und der Zusammenarbeit zwischen Staaten von zentraler Bedeutung. Nationale Sicherheitsinteressen d√ºrfen nicht auf Kosten;1
In der heutigen vernetzten Welt spielt das Internet der Dinge (IoT) eine zentrale Rolle bei der Digitalisierung unterschiedlichster Lebensbereiche und Industrien. Ein wesentliches Element dieser Vernetzung ist das Messaging-Protokoll MQTT (Message Queuing Telemetry Transport), das aufgrund seiner Leichtgewichtigkeit und Effizienz insbesondere f√ºr die Kommunikation in ressourcenbeschr√§nkten Umgebungen und bei der √úbertragung von Daten √ºber unsichere Netzwerke weit verbreitet ist. Die steigende Verbreitung von MQTT-basierten Anwendungen erfordert nicht nur eine robuste Implementierung, sondern auch umfangreiche Testmethoden, um die Funktionalit√§t, Zuverl√§ssigkeit und Sicherheit dieser Systeme zu gew√§hrleisten.  Ziel dieser wissenschaftlichen Arbeit ist es, den aktuellen Stand der Technik im Testen von MQTT-basierten L√∂sungen zu erheben und zu analysieren. Dabei wird untersucht, welche Testans√§tze und -techniken aktuell verwendet werden, um die Performance und Sicherheit von MQTT-Anwendungen zu validieren. Zudem werden die Herausforderungen, die bei der Testung von IoT-Systemen mit MQTT auftreten, beleuchtet sowie bestehende L√ºcken und Potenziale f√ºr zuk√ºnftige Forschungsans√§tze identifiziert. Ein umfassendes Verst√§ndnis der Testmethoden ist entscheidend, um die Qualit√§t und Integrit√§t von MQTT-gest√ºtzten Systemen garantieren zu k√∂nnen und damit deren breite Akzeptanz in der Industrie und Gesellschaft zu f√∂rdern.   Im Verlauf dieser Arbeit wird auf verschiedene Teststrategien, wie Unit-Tests, Integrationstests und Lasttests, eingegangen und deren jeweilige Vor- und Nachteile im Kontext von MQTT-Kommunikation diskutiert. Dabei soll auch der Einfluss neuer Technologien und Methoden, wie automatisiertes Testen und Continuous Integration, auf die Testpraxis beleuchtet werden. Durch diese Analyse wird ein umfassendes Bild √ºber den aktuellen Entwicklungsstand und die Herausforderungen im Bereich des Testens von MQTT-basierten L√∂sungen gezeichnet.;1
"In der vorliegenden Arbeit soll ein Konzept der Selbstregelungsm√∂glichkeit mithilfe des Situationsbewusstseins aufgestellt werden. Im Folgenden werden die drei Ebenen von Ends- ley beschrieben: die Wahrnehmung & die Einsch√§tzung der Situation und die Antizipation f√ºr die Zukunft. In der Publikation der ‚ÄûDeutsche Gesetzliche Unfallversicherung ( DGUV)‚Äú sind Empfehlun- gen f√ºr die Gef√§hrdungsbeurteilung in Schulen w√§hrend der SARS-CoV-2-Pandemie. Unter anderem werden die regelm√§√üige L√ºftung und die Einsetzung verschiedener Messger√§ten zur Bestimmung der CO 2-Konzentration angesprochen. ‚Äû die max. CO 2-Konzentration darf 1.000 ppm nicht √ºberschreiten; in der Zeit der Epidemie soll dieser Wert soweit wie m√∂glich unterschritten werden (Deutsche Gesetzliche Unfallversicherung e.V. - DGUV 2022, S. 4)‚Äú. (ebd., S. 4) Zur Untersuchung situationsunabh√§ngiger Einflussfaktoren auf das Situationsbewusstsein werden verschiedene m√∂gliche Alltagsszenarien in der Hochschule ausgearbeitet: 1.In einem Raum findet es eine dreist√ºndige Vorlesung mit zwanzig Personen statt (bei normaler CO 2-Konzentration). 2.Nach der Vorlesung gibt es eine einst√ºndige Mittagspause, der Raum wird nicht gel√ºftet und niemand ist im Raum. 3.Nach der Vorlesung gibt es eine einst√ºndige Mittagspause, der Raum wird gel√ºftet und niemand ist im Raum. 4.Nach einer einst√ºndigen Mittagspause (der Raum wurde gel√ºftet und niemand war im Raum) folgt es eine dreist√ºndige Vorlesung mit zwanzig Personen. 5.Nach einer einst√ºndigen Mittagspause (der Raum wurde nichtgel√ºftet und niemand war im Raum) folgt es eine dreist√ºndige Vorlesung mit zwanzig Personen. 6.Um 18:00 Uhr beginnt das Reinigungspersonal mit einer halbst√ºndigen Reinigung (der Raum wurde nichtgel√ºftet und niemand war im Raum) Im Folgenden wird die Luftqualit√§t w√§hrend der einzelnen Szenarien berechnet. Die Dia- gramme wurden auf der Webseite https://www.co2-modell.nlga.niedersachsen.de/ erstellt. Die Rahmenbedingungen f√ºr die Alltagssituationen sind die folgenden: ‚Ä¢Raumh√∂he: 2.5 Meter (m) ‚Ä¢Grundfl√§che: 30 m2 ‚Ä¢‚ÄûMit einer Konzentration um 400 ppmist es ein nat√ºrlicher Bestandteil der Umge- bungsluft (Umweltbundesamt 2009, S. 1358)‚Äú. CO 2au√üen: 400 ppm ‚Ä¢‚ÄûDie CO 2-Abgaberate des Menschen h√§ngt im Wesentlichen von dessen Aktivit√§t, Gewicht und Alter ab. F√ºr vorwiegend sitzende T√§tigkeiten (z.B. im Schulunterricht) ist 20 l/h/Person eine geeignete Annahme (Nieders√§chsisches Landesgesundheitsamt 2015)‚Äú. CO 2-Abgaberate: 20 l/h/Person";0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network  Die √úberwachung der Bodenfeuchtigkeit spielt eine entscheidende Rolle in der Landwirtschaft, im Umweltmanagement und in der Hydrologie. Eine pr√§zise Erfassung der Bodenfeuchtigkeit erm√∂glicht es Landwirten, Bew√§sserungssysteme effizienter zu steuern, das Risiko von Erosion zu minimieren und die Gesundheit von √ñkosystemen zu bewahren. In den letzten Jahren hat sich die Technologie des Low Power Wide Area Network (LoRaWAN) als vielversprechende L√∂sung zur drahtlosen √úbertragung von Sensordaten etabliert. In Kombination mit Plattformen wie dem The Things Network (TTN) erm√∂glicht LoRaWAN eine kosteng√ºnstige, skalierbare und energieeffiziente Erfassung und √úbertragung von Daten zur Bodenfeuchtigkeit.   1. Grundlagen der Bodenfeuchtigkeitsmessung  Die Bodenfeuchtigkeit ist ein Ma√ü f√ºr den Wassergehalt im Boden und hat erhebliche Auswirkungen auf Pflanzenwachstum, N√§hrstoffverf√ºgbarkeit und mikrobiologische Aktivit√§ten. Sie kann durch verschiedene Methoden gemessen werden, darunter die Verwendung von Tensiometern, Kapazitiven Sensoren oder Resistiven Sensoren. Diese Sensoren basieren auf physikalischen Prinzipien, wie dem Ohmschen Gesetz oder der √Ñnderung der Dielektrizit√§tskonstante, um den Wassergehalt im Boden zu bestimmen.    2. LoRaWANEin √úberblick  LoRaWAN ist ein Netzwerkprotokoll, das f√ºr die drahtlose Kommunikation in gro√üen Gebieten mit minimalem Energieverbrauch entwickelt wurde. Es nutzt die LoRa-Technologie (Long Range), die eine √úbertragung √ºber mehrere Kilometer erm√∂glicht, w√§hrend sie gleichzeitig eine hohe Energieeffizienz gew√§hrleistet. Die Architektur von LoRaWAN umfasst Endger√§te (Sensoren), Gateways und einen Netzwerkserver. Endger√§te senden Daten √ºber Gateways an den Netzwerkserver, der die Daten verarbeitet und an Anwendungen weiterleitet.   Die Vorteile von LoRaWAN liegen in seiner F√§higkeit, eine gro√üe Anzahl von Ger√§ten in einem weitreichenden Netzwerk zu unterst√ºtzen, was es ideal f√ºr landwirtschaftliche Anwendungen macht, bei denen viele Sensoren √ºber gro√üe Fl√§chen verteilt sind. Zudem erm√∂glicht die geringe Datenrate von LoRaWAN eine lange Batterielebensdauer, was f√ºr den Einsatz in abgelegenen Gebieten von gro√üer Bedeutung ist.   3. The Things Network (TTN)  Das The Things Network ist eine offene, gemeinschaftlich betriebene LoRaWAN-Infrastruktur, die es Entwicklern und Unternehmen erm√∂glicht, IoT-Anwendungen zu erstellen und zu betreiben. TTN stellt eine Plattform bereit, die den Zugang zu LoRaWAN-Netzwerken vereinfacht, indem sie die Registrierung von Ger√§ten, das Management von Gateways und die Daten√ºbertragung √ºber das Internet erm√∂glicht. Die offene Natur von TTN f√∂rdert die Zusammenarbeit und den Wissensaustausch innerhalb der IoT-Community, was zu innovativen L√∂sungen und Anwendungen f√ºhrt.   4. Integration von Bodenfeuchtesensoren in LoRaWAN und TTN  Die Integration von Bodenfeuchtesensoren in ein LoRaWAN-Netzwerk erfolgt in mehreren Schritten. Zun√§chst m√ºssen die Sensoren konzipiert werden, um die Bodenfeuchtigkeit zu messen und die Daten in;1
Eine Aufgabenverwaltungssoftware muss darstellen, welche Arbeitspakete offen sind, welche  Arbeitspakete in Arbeit und welche Arbeitspakete erledigt sind. Trello bildet diese Information  mithilfe der Einordnung der Karten in Spalten ab. Die Karten werden  von den Personen bei  √Ñnderungen des Zustandes in die jeweilige Spalte verschoben.  Azure DevOps Services und Jira Software verwenden ein komplexeres Modell, um die Stati  abzubilden. Die m√∂glichen Stati eines Arbeitspaketes k√∂nnen auf Projektebene festgelegt  werden. Dabei wird ein Standardschema verwendet, das jedoch kopiert und an gepasst  werden kann. Azure DevOps erm√∂glicht das Hinzuf√ºgen oder Entfernen von Stati, es kann  jedoch nicht festgelgt werden, aus welchen Stati ein Arbeitspaket in welche Stati √ºbergehen  kann. In OpenProject kann festgelegt werden, welche Rollen welche Status√ºberg√§nge bei  welchen Arbeitspakettypen durchf√ºhren k√∂nnen, zudem ist es m√∂glich, zus√§tzliche   Berechtigungen an die Personen zu vergeben, die das Arbeitspaket erstellt haben oder die  zugewiesene Person des Arbeitspaketes sind.  Jira Software besitzt das komplexeste Modell f√ºr Status√§nderungen. Es ist m√∂glich, zu  erlauben, dass alle Stati√§nderungen zu jedem Zeitpunkt m√∂glich sind. Es k ann aber auch ein  komplexer Prozess abgebildet werden. Es kann beispielsweise erm√∂glicht werd en, dass ein  Arbeitspaket aus dem Status ‚ÄûIdee‚Äú nur  in die Stati ‚ÄûOffen‚Äú und ‚ÄûAbgelehnt‚Äú wechseln kann,  es k√∂nnen f√ºr die √úberg√§nge sogar Beschriftungen definiert und Berechtigunge n eingestellt  werden.;0
In der heutigen digitalisierten Welt spielt Software eine entscheidende Rolle in nahezu allen Lebensbereichen, insbesondere im Bildungssektor. Standardsoftware, als eine Form von Software, die f√ºr eine breite Nutzergruppe entwickelt wurde, stellt eine kosteneffiziente und zeitsparende L√∂sung dar, um spezifische Anforderungen zu erf√ºllen. Sie unterscheidet sich von individueller Software, die ma√ügeschneidert f√ºr spezifische Kundenbed√ºrfnisse entwickelt wird. Standardsoftware wird in der Regel in gro√üen St√ºckzahlen produziert und bietet daher Vorteile wie geringere Entwicklungskosten, umfangreiche Funktionalit√§ten und regelm√§√üige Updates.  Die Entwicklung von Standardsoftware erfolgt oft im Rahmen eines iterativen Prozesses, der verschiedene Phasen umfasst, darunter Anforderungsanalyse, Design, Implementierung, Test und Wartung. In der Anforderungsanalyse werden die Bed√ºrfnisse der Benutzer erfasst und in funktionale und nicht-funktionale Anforderungen √ºbersetzt. Diese Phase ist entscheidend, um sicherzustellen, dass die Software den Erwartungen der Nutzer gerecht wird und die gew√ºnschten Aufgaben effizient unterst√ºtzt.  Im Kontext des studentischen Software Engineerings ist die Auswahl eines geeigneten Aufgabenmanagement-Tools von gro√üer Bedeutung. Solche Tools erm√∂glichen es Studierenden, ihre Projekte zu planen, Aufgaben zu verteilen und den Fortschritt zu √ºberwachen. Die Anforderungsanalyse f√ºr ein solches Tool muss daher die spezifischen Bed√ºrfnisse von Studierenden ber√ºcksichtigen, wie etwa die M√∂glichkeit zur Zusammenarbeit, die Integration von Lernressourcen und die Benutzerfreundlichkeit. Standardsoftware, die diese Anforderungen erf√ºllt, kann nicht nur die Effizienz und Produktivit√§t der Studierenden steigern, sondern auch deren Lernerfahrung verbessern.  Ein weiterer Vorteil von Standardsoftware ist die M√∂glichkeit, auf eine bestehende Nutzerbasis und Community zur√ºckzugreifen. Viele Standardsoftwarel√∂sungen bieten umfangreiche Dokumentationen, Tutorials und Support-Foren, die den Nutzern helfen, sich schnell in die Software einzuarbeiten. Dies ist besonders vorteilhaft f√ºr Studierende, die m√∂glicherweise nur begrenzte Zeit haben, um sich mit neuen Tools vertraut zu machen.  Allerdings sind auch einige Herausforderungen mit der Nutzung von Standardsoftware verbunden. Die Software muss oft an die spezifischen Bed√ºrfnisse der Nutzer angepasst werden, was zu einer gewissen Frustration f√ºhren kann, wenn die vorgegebenen Funktionen nicht vollst√§ndig den Anforderungen entsprechen. Zudem k√∂nnen Lizenzkosten und Abh√§ngigkeiten von Softwareanbietern Einschr√§nkungen mit sich bringen.  Insgesamt stellt Standardsoftware eine wertvolle Ressource f√ºr das studentische Software Engineering dar. Durch eine sorgf√§ltige Anforderungsanalyse k√∂nnen die richtigen Tools ausgew√§hlt werden, um die Effizienz und Effektivit√§t des Lernprozesses zu maximieren. Die Ber√ºcksichtigung der spezifischen Bed√ºrfnisse der Studierenden ist dabei unerl√§sslich, um ein optimales Nutzungserlebnis zu gew√§hrleisten. In der vorliegenden Arbeit wird daher ein detaillierter Fokus auf die Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool gelegt, das den besonderen Anforderungen und Herausforderungen des studentischen Software Engineerings gerecht wird.;1
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungAusblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und die Entwicklung des Internets der Dinge (IoT) haben in den letzten Jahren zu einer Vielzahl innovativer Anwendungen in der Heimautomatisierung gef√ºhrt. Ein besonders interessantes Anwendungsfeld ist die Automatisierung von Haustierzug√§ngen, wie beispielsweise Katzenklappen. Die vorliegende Arbeit beschreibt die Realisierung eines IoT-Systems, das eine Katzenklappe mittels einer KI-basierten Katzenerkennung steuert. Diese Technologie erm√∂glicht es, zwischen verschiedenen Katzen zu unterscheiden und somit einen selektiven Zugang zu erm√∂glichen. Die Implementierung eines solchen Systems er√∂ffnet nicht nur neue M√∂glichkeiten f√ºr die Haustierhaltung, sondern wirft auch Fragen zu zuk√ºnftigen Entwicklungen auf.  Die Grundlage des Systems bildet eine Kombination aus Bildverarbeitung und maschinellem Lernen. Hierbei werden hochaufl√∂sende Kameras eingesetzt, die in der Lage sind, die Anwesenheit und Identit√§t der Katze zu erkennen, bevor die Klappe ge√∂ffnet wird. Algorithmen des tiefen Lernens, wie Convolutional Neural Networks (CNNs), werden trainiert, um spezifische Merkmale der Katzen zu identifizieren. Diese Merkmale umfassen nicht nur das √§u√üere Erscheinungsbild, sondern auch Verhaltensmuster, die in Verbindung mit der Nutzung der Katzenklappe stehen. Die gesammelten Daten werden in einer Cloud-basierten Infrastruktur gespeichert, die es erm√∂glicht, die Leistung des Systems kontinuierlich zu √ºberwachen und zu verbessern.  Ein zentraler Aspekt der Weiterentwicklung dieses Systems ist die Integration zus√§tzlicher Sensoren, die eine umfassendere Analyse des Verhaltens der Katzen erm√∂glichen. Beispielsweise k√∂nnten Gewichtssensoren in die Katzenklappe integriert werden, um Informationen √ºber die Gesundheit der Tiere zu sammeln. Diese Daten k√∂nnten in Verbindung mit der Katzenerkennung genutzt werden, um fr√ºhzeitig auf gesundheitliche Probleme hinzuweisen. Zudem k√∂nnte die Entwicklung einer App f√ºr Haustierbesitzer in Betracht gezogen werden, die nicht nur den Zugang zur Katzenklappe steuert, sondern auch Benachrichtigungen √ºber das Verhalten und die Gesundheit der Katzen sendet.  Ein weiterer vielversprechender Ansatz zur Weiterentwicklung des Systems ist die Implementierung von Smart Home-Technologien. Die Katzenklappe k√∂nnte in ein umfassenderes Smart Home-System integriert werden, das auch andere Ger√§te und Systeme im Haushalt steuert. So k√∂nnte die Klappe beispielsweise in Abh√§ngigkeit von Wetterbedingungen oder der Tageszeit automatisch ge√∂ffnet oder geschlossen werden. Dar√ºber hinaus k√∂nnte eine Vernetzung mit anderen IoT-Ger√§ten, wie Futterautomaten oder √úberwachungskameras, eine ganzheitliche L√∂sung f√ºr die Haustierhaltung darstellen.  Die Verwendung von KI zur Katzenerkennung er√∂ffnet auch M√∂glichkeiten f√ºr die Entwicklung von Sicherheitsfunktionen. Durch die Integration von Gesichtserkennungstechnologien k√∂nnte das System in der Lage sein, unerw√ºnschte Tiere oder sogar Eindringlinge zu identifizieren und den Zugang zur Katzenklappe zu verweigern. Diese Sicherheitsaspekte k√∂nnten besonders f√ºr l√§ndliche Gebiete von Bedeutung sein, in denen Wildtiere eine Bedrohung f√ºr Haustiere darstellen.  Schlie√ülich k√∂nnte die Forschung im Bereich der Ethik und des Datenschutzes eine wichtige Rolle bei der Weiterentwicklung solcher Systeme spielen. Die Erhebung und Speicherung von Daten;1
Die Anf√§nge von Java sind auf das ‚ÄöGreen‚Äò - Projekt zur√ºckzuf√ºhren. Zusammen mit James  Gosling und Mike Sheridan gilt Patrick Naughton als einer der Urv√§ter der objektorientierten  Programmiersprache Java. Ziel dieses Projektes war es zuk√ºnftige Technologietrends zu  erahnen und einen Pro totypen f√ºr das Unternehmen ‚ÄöSun Microsystems‚Äò zu entwickeln, der  eben diese Zukunftstechnologie darstellt. Interessant war im Wesentlichen die Entwicklung  von Software f√ºr interaktives Fernsehen und andere Ger√§te der Konsumelektronik.4 Der sp√§ter  entwickelte Prototyp trug den Namen *7 ( ‚Äöstar seven‚Äò) und sollte urspr√ºnglich in C++  geschrieben werden. Nachdem jedoch Probleme auftraten, die zu Sicherheitsl√ºcken, einer  hohen Fehlerrate und einer schwierigen bis fehlenden Portabilit√§t f√ºhrten, wagte das Team den  Schritt und begann mit der Entwicklung einer neuen Sprache f√ºr den *7.5   Folgende Anforderungen sollte die neue Sprache, aus der sp√§ter Java wurde, aufweisen:   - ‚ÄûNetzwerkunterst√ºtzung: Es m√ºssen Daten und Programme zwischen verschiedenen  Ger√§ten ausgetauscht werden k√∂nnen.   - Sicherheit: Es d√ºrfen keine unerlaubten Zugriffe auf sensitive oder schutzw√ºrdige  Informationen m√∂glich sein.    - Stabilit√§t: Verbraucherger√§te sollen weder ‚â´abst√ºrzen ‚â™ noch gelegentlich neu  booten.   - Plattformunabh√§ngigkeit: Es soll eine Kompatibilit√§t zwischen einer Vielzahl von  Ger√§ten erm√∂glicht werden.   - Mehrl√§ufigkeit: Es m√ºssen mehrere Aktionen/Programme gleichzeitig ausgef√ºhrt  werden k√∂nnen.   - Dynamik: Das Laden und Entfernen von Programmen muss a uch ohne lokale Festplatte  m√∂glich sein.   - Kleine Programmcodegr√∂√üe: Kleiner Programmcode erm√∂glicht preiswerte Ger√§te  mit kleinem Speicher.   - Einfach und vertraut: Die Sprache soll das Leben f√ºr den Programmierer leichter  machen, durch √Ñhnlichkeiten zu C un d C++.‚Äú;0
Ein Ausblick auf zuk√ºnftige Entwicklungen  In den letzten Jahren hat das Bewusstsein f√ºr Luftqualit√§t und deren Auswirkungen auf die menschliche Gesundheit signifikant zugenommen. Vor diesem Hintergrund haben elektrisch betriebene Luftreinigungsger√§te an Popularit√§t gewonnen. Ihre Funktionalit√§t kann jedoch durch innovative Ans√§tze in den Bereichen Visualisierung, Benutzerfreundlichkeit und Selbstregelung erheblich verbessert werden. Vor diesem Hintergrund ist es essentiell, zuk√ºnftige Entwicklungen in diesen Bereichen zu untersuchen, um optimalere L√∂sungen f√ºr die Endverbraucher zu schaffen.  Die intuitive Visualisierung von Luftqualit√§tsdaten ist ein Schl√ºsselmerkmal moderner Luftreinigungssysteme. W√§hrend aktuelle Ger√§te oft auf monochrome Anzeigen oder einfache LED-Indikatoren zur√ºckgreifen, besteht die M√∂glichkeit, diese Benutzeroberfl√§chen durch Touchscreen-Technologie zu erweitern. Interaktive Augmented Reality-Anwendungen k√∂nnten Nutzern beispielsweise erm√∂glichen, Echtzeitdaten zur Luftqualit√§t in ihrem Wohnraum visuell darzustellen ‚Äì von der Feinstaubbelastung bis zur Luftfeuchtigkeit. Zukunftige Ger√§te k√∂nnten auch Daten von externen Quellen, wie urbanen Luftqualit√§tsmessstationen oder Wetterprognosen, einbeziehen und in einem ansprechenden visuell-dynamischen Layout pr√§sentieren. Durch eine benutzerorientierte Interface-Design-Strategie k√∂nnten Personalisiertheit und die Lernkurve des Nutzers optimiert werden, um den Bed√ºrfnissen verschiedener Nutzergruppen gerecht zu werden.  Ein weiterer entscheidender Aspekt ist die Verbesserung der Bedienbarkeit dieser Ger√§te. Aktuellen Umfragen zu Folge f√ºhrt eine komplizierte Bedienanleitung h√§ufig zu ungenutzten Features. Daher w√§re der Einsatz von KI-gesteuerten virtuellen Assistenten denkbar, die die Nutzerorientierung unterst√ºtzen. Sprachgesteuerte Bedienung k√∂nnte in Echtzeit personalisierte Vorschl√§ge zur Luft-Optimierung geben, basierend auf der momentanen Benutzeraktivit√§t zuhause und den entsprechenden, analysierten Luftdaten. Die Implementierung von maschinellem Lernen, das auf individuelle Nutzergewohnheiten eingeht, kann langfristig dazu beitragen, den Reinigungsbedarf proaktiv zu antizipieren.  Die Selbstregelung der Luftreinigung ist ein Bereich, der zudem spannende Innovationsm√∂glichkeiten bietet. Aktuell agieren viele Systeme reaktiv, reagieren auf gemessene Konzentrationen von Schadstoffen erst, nachdem sie diese erkannt haben. Zuk√ºnftige Technologien k√∂nnten jedoch vorhersagende Algorithmen integrieren, welche √ºber Umweltfaktoren wie Wettervorhersagen und Schadstoffdaten von St√§dten eine proaktive Luftreinigung initiieren. Der Einsatz von IoT-Technologien k√∂nnte √ºber ein integriertes Netzwerk verschiedener Haushaltsger√§te nicht nur ihren Reinigungsbedarf optimieren, sondern auch den Energieverbrauch steuern ‚Äì dies geschieht zum Beispiel durch die zeitgleiche Minimierung der Leistungsaufnahme s√§mtlicher Ger√§te beim Eintritt in den Eco-Modus.  Zusammenfassend l√§sst sich festhalten, dass die materielle und funktionale Weiterentwicklung von Luftreinigungsger√§ten mit einem innovativen Fokus auf Visualisierung, Bedienbarkeit und Selbstregulierung ein erhebliches Potenzial bietet. Zuk√ºnftig k√∂nnte - unterst√ºtzt durch technologische Fortschritte und datenbasierte Konzepte ‚Äì ein nicht nur effekt;1
 State of the Art beim Testen von MQTT-basierten L√∂sungenEin Konzept zur Umsetzung     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f√ºhrenden Protokolle f√ºr die Kommunikation im Internet der Dinge (IoT) etabliert. Aufgrund seiner Lightweight-Natur und der F√§higkeit, in ressourcenbeschr√§nkten Umgebungen effizient zu arbeiten, wird MQTT in einer Vielzahl von Anwendungen eingesetzt, von Smart Homes bis hin zu industriellen Automatisierungssystemen. Angesichts der zunehmenden Verbreitung von MQTT-basierten L√∂sungen gewinnt das Testen dieser Systeme an Bedeutung. In diesem Text wird ein Konzept zur Umsetzung eines umfassenden Testansatzes f√ºr MQTT-basierte L√∂sungen vorgestellt, das sich an den aktuellen Standards und Best Practices orientiert.   1. Testarten und -methoden  Die Teststrategie f√ºr MQTT-basierte L√∂sungen sollte verschiedene Testarten umfassen, um die Funktionalit√§t, Leistung und Sicherheit der Anwendung zu gew√§hrleisten. Die wichtigsten Testarten sind - Funktionale Tests√úberpr√ºfung der korrekten Implementierung der MQTT-Funktionalit√§ten, einschlie√ülich Publish/Subscribe-Mechanismen, QoS-Stufen und Retained Messages. Hierbei sollten sowohl positive als auch negative Testf√§lle ber√ºcksichtigt werden.  - Last- und LeistungstestsEvaluierung der Systemleistung unter verschiedenen Lastbedingungen. Dies umfasst Tests zur Maximierung der Anzahl gleichzeitiger Verbindungen, der Nachrichtenrate und der Latenzzeiten. Tools wie JMeter oder Gatling k√∂nnen hierf√ºr eingesetzt werden.  - SicherheitstestsAnalyse der Sicherheitsaspekte, insbesondere der Authentifizierung und Autorisierung, sowie der Verschl√ºsselung der Daten√ºbertragung. Penetrationstests und Sicherheitsanalysen sind hier unerl√§sslich.  - Integrationstests√úberpr√ºfung der Interoperabilit√§t zwischen verschiedenen MQTT-Clients und -Brokern sowie der Integration mit Backend-Systemen und Datenbanken.   2. Testumgebung  Die Schaffung einer geeigneten Testumgebung ist entscheidend f√ºr den Erfolg des Testprozesses. Eine typische Testumgebung f√ºr MQTT sollte Folgendes umfassen - MQTT-BrokerAuswahl eines geeigneten Brokers (z.B. Mosquitto, HiveMQ, EMQX), der die spezifischen Anforderungen der Anwendung erf√ºllt. Die Konfiguration des Brokers sollte so gestaltet sein, dass sie verschiedene Szenarien simulieren kann.  - MQTT-ClientsEntwicklung oder Nutzung von Testclients, die verschiedene MQTT-Funktionalit√§ten implementieren. Diese Clients sollten in der Lage sein, sowohl Publish- als auch Subscribe-Operationen durchzuf√ºhren.  - Monitoring-ToolsImplementierung von Monitoring-L√∂sungen zur √úberwachung des Broker-Verhaltens und der Netzwerkkommunikation. Tools wie MQTT Explorer oder Prometheus k√∂nnen wertvolle Einblicke in die Systemleistung bieten.   3. Automatisierung des Testprozesses  Um die Effizienz und Wiederholbarkeit der Tests zu erh√∂hen, sollte der Testprozess weitgehend automatisiert werden. Dies kann durch den Einsatz von Continuous Integration/Continuous Deployment (CI/CD)-Pipelines erreicht werden. Die Automatisierung umfasst - TestskripteEntwicklung von Skripten, die die verschiedenen Testarten automatisiert ausf√ºhren. Diese Skrip;1
Ausblick  In den letzten Jahren hat die Digitalisierung in der Landwirtschaft zunehmend an Bedeutung gewonnen. Angesichts der fortschreitenden Klima√§nderung und der ansteigenden globalen Bev√∂lkerung ist ein effektives Wasserressourcenmanagement wesentlicher denn je. In diesem Kontext bietet die Verkn√ºpfung von Ortungstechnologien und intelligenter Informationen einen vielversprechenden Ansatz hierf√ºr. Diese wissenschaftliche Arbeit hat analysiert, inwiefern das Tracking der Bodenfeuchtigkeit mithilfe der LoRaWAN-Technologie und dem The Things Network (TTN) sowohl zur Anwendung in der Landwirtschaft als auch zur Verbesserung nachhaltiger Praktiken beitragen kann.  Die Resultate dieser Analyse legen nahe, dass lokale Farmlandwirte durch innovative Sensortechnologien in der Lage sind, pr√§zisere Entscheidungen in Bezug auf die Bew√§sserung zu treffen. Hochfrequente Bodenfeuchtemessungen bieten nicht nur unmittelbar bessere Anhaltspunkte f√ºr den optimalen Wassereinsatz, sondern k√∂nnen auch in Kombination mit Wetterdaten dienen, um langfristige Anpassungen in der Bewirtschaftung zu implementieren. Die Nutzung der LoRaWAN-Technologie erm√∂glicht dar√ºber hinaus eine sehr energieeffiziente Daten√ºbertragung √ºber gro√üe Strecken, was besonders in l√§ndlichen Gebieten oder abgelegenen Anbaufl√§chen von Vorteil ist.  Die vorliegenden Ergebnisse und Erkenntnisse bilden einen vielversprechenden Leitfaden f√ºr zuk√ºnftige Eins√§tze drahtloser sensorbasierter Systeme in der Landwirtschaft. In den kommenden Jahren k√∂nnte somit der Fokus darauf gerichtet werden, diese Technologien so weiterzuentwickeln, dass sie auch verst√§rkt in pr√§ventiven Ans√§tzen, etwa im Fr√ºhwarnsystem hinsichtlich D√ºrreperioden oder Bodenern√§hrung, eingesetzt werden. Des Weiteren w√§re eine interessante n√§chste Forschungsrichtung die Integration weiterer Umweltdaten, beispielsweise Temperatur, Feuchtigkeit der Luft sowie N√§hrstoffgehalt, in ein umfassendes Modell zur Bodenbewirtschaftung.  Es gilt zudem zu ber√ºcksichtigen, dass die Akzeptanz solcher Technologien unter den Landwirten eine entscheidende Rolle spielt, was eine verst√§rkte Aufkl√§rung und Schulung zum Thema innovative Agrartechnologien zur Folge haben k√∂nnte. Die Forschung an niedrigschwelligen Weiterbildungsangeboten k√∂nnte zuk√ºnftig dazu beitragen, die Implementierung effektiver Anwendungen zum Tracking der Bodenfeuchtigkeit noch weiter voranzutreiben.  Durch diese Entwicklungen k√∂nnten nicht nur die Ertr√§ge in der Landwirtschaft gesteigert, sondern auch √∂kologische Fu√üabdr√ºcke minimiert werden, was entscheidend zur Nachhaltigkeit beitr√§gt. Letztendlich er√∂ffnet die weitere Erforschung von LoRaWAN-basierten L√∂sungen zur √úberwachung der Bodenfeuchtigkeit spannende M√∂glichkeiten, um insbesondere in Zeiten globaler Herausforderungen wie dem Klimawandel resilientere landwirtschaftliche Systeme zu schaffen.;1
"3.3 Implementierung der Progressive Web App
DiePWAwird mit einem React Frontend und einem kleinen Node.js Backend umgesetzt.
F√ºr das Design der PWAwird Material UI verwendet. Dabei handelt es sich um ein UI
Bibliothek, die sich an die von Google entwickelten Material Design Vorlagen h√§lt. Die
Bibliothek wurde f√ºr React entwickelt und ist daher ohne zus√§tzlichen Aufwand in das
Projekt integrierbar. Als Datenbank wird Google Firestore verwendet. Mit Firestore kann
direkt aus dem Frontend auf die Datenbank zugegriÔ¨Äen werden. Des Weiteren erm√∂glicht
Firestore das einfache Synchronisieren der Online und In-Browser Datenbank. F√ºr die
verschiedenen Komponenten k√∂nnen jeweils weitere Bibliotheken hinzugef√ºgt werden. Dies
wird in den jeweiligen Abschnitten aufgezeigt.";0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network  In den letzten Jahren hat die √úberwachung der Bodenfeuchtigkeit zunehmend an Bedeutung gewonnen, insbesondere in der Landwirtschaft und Umweltforschung. Eine pr√§zise Messung der Bodenfeuchtigkeit ist entscheidend f√ºr die Optimierung von Bew√§sserungsstrategien, die Ertragssteigerung und die nachhaltige Bewirtschaftung von Ressourcen. Eine vielversprechende L√∂sung zur Erfassung dieser Daten bietet die Kombination aus LoRaWAN (Long Range Wide Area Network) und dem The Things Network (TTN).    1. Grundlagen der Bodenfeuchtigkeitsmessung  Bodenfeuchtigkeitsmessungen sind entscheidend f√ºr das Verst√§ndnis von hydrologischen Zyklen und der physikalischen Eigenschaften des Bodens. Bodenfeuchtigkeit wird typischerweise als das Verh√§ltnis des Volumenanteils des Wassers zum Volumenanteil des trockenen Bodens ausgedr√ºckt. Die wichtigsten Methoden zur Messung der Bodenfeuchtigkeit sind - Gravimetrische MethodeBei dieser klassischen Methode wird das Gewicht einer bestimmten Bodenprobe vor und nach dem Trocknen bestimmt. Obwohl pr√§zise, ist dieser Ansatz zeitaufw√§ndig und auf punktuelle Messungen beschr√§nkt.    - TDR (Time Domain Reflectometry)Diese Methode nutzt die Zeitdilatation von elektromagnetischen Wellen, um den Wassergehalt im Boden zu bestimmen. TDR-Sensoren sind jedoch oft kostspielig und erfordern eine komplexe Infrastruktur.  - Kapazitive SensorenDiese Sensoren messen die √Ñnderung der elektrischen Kapazit√§t des Bodens, die mit dem Wassergehalt korreliert ist. Sie bieten eine kosteng√ºnstige und flexible Alternative zur kontinuierlichen Bodenfeuchtigkeits√ºberwachung.   2. LoRaWANEin √úberblick  LoRaWAN ist ein drahtloses Netzwerkprotokoll, das speziell f√ºr die Erfassung von Sensordaten √ºber lange Distanzen bei geringem Energieverbrauch entwickelt wurde. Es operiert im Sub-GHz-Frequenzbereich und erm√∂glicht die √úbertragung von Daten √ºber Reichweiten von mehreren Kilometern, was es besonders geeignet f√ºr l√§ndliche Gebiete macht, in denen der Zugang zu herk√∂mmlichen Netzwerken eingeschr√§nkt ist.   2.1. Architektur von LoRaWAN  Das LoRaWAN-Netzwerk besteht haupts√§chlich aus Sensoren (Nodes), Gateways und einem Netzwerk-Server. Die Sensoren erfassen die Bodenfeuchtigkeit und senden diese Daten √ºber LoRa (Long Range) an ein Gateway. Das Gateway √ºbertr√§gt diese Informationen dann an einen zentralen Server √ºber Standard-IP-Netzwerkverbindungen. Diese Architektur erm√∂glicht eine effiziente Nutzung der Bandbreite und minimiert den Energieverbrauch.   2.2. Vorteile von LoRaWAN  Ein wesentlicher Vorteil von LoRaWAN ist seine F√§higkeit, eine gro√üe Anzahl von Sensoren zu unterst√ºtzen und Daten √ºber lange Zeitr√§ume hinweg zu sammeln, ohne dass h√§ufige Batteriewechsel erforderlich sind. Dar√ºber hinaus kann das Protokoll in einem Netzwerk mit niedriger Bandbreite betrieben werden und unterst√ºtzt die sichere √úbertragung von Daten durch Verschl√ºsselungstechniken.   3. The Things Network (TTN)  The Things Network ist eine offene und gemeinschaftsgetriebene LoRaWAN-Infrastruktur, die es Nutzern erm√∂glicht, ihre eigenen LoRaWAN-Ger√§te zu betreiben und Daten zu speichern. TTN funktioniert nach dem Prinzip des Crowd-Sourcing, was bedeutet, dass Einzelpersonen oder Organisationen Gateways bereitstellen, um die Netzwerkabdeckung zu erh√∂hen.   3.1. Integration von Sensorsystemen  Die Integration von Bodenfeuchtesensoren in das TTN-√ñkosystem erm√∂glicht es, Daten in Echtzeit zu sammeln und zu analysieren. Die offene API und die unterst√ºtzende Community bieten Entwicklern und Forschern die M√∂glichkeit, individuelle Anwendungen zu erstellen, die auf spezifische Anforderungen zugeschnitten sind.   3.2. Datenanalyse und -visualisierung  Durch die Anbindung der gesammelten Daten an cloudbasierte Dienste k√∂nnen Analyse- und Visualisierungstools genutzt werden, um Muster in der Bodenfeuchtigkeit zu erkennen und pr√§ventive Ma√ünahmen zu ergreifen. Diese datengetriebene Entscheidungsfindung ist entscheidend f√ºr eine nachhaltige Landschafts- und Ressourcennutzung.   Fazit  Die Kombination von LoRaWAN und dem The Things Network zur √úberwachung der Bodenfeuchtigkeit bietet eine innovative und nachhaltige L√∂sung f√ºr die Herausforderungen der modernen Landwirtschaft und Umweltforschung. Durch die Integration von kosteng√ºnstigen Sensortechnologien kann nicht nur die Effizienz bei der Bew√§sserung gesteigert, sondern auch die Qualit√§t von B√∂den und Ertr√§gen nachhaltig verbessert werden. Zuk√ºnftige Forschungen sollten sich zudem darauf konzentrieren, die Interoperabilit√§t dieser Systeme zu verbessern und die Algorithmen zur Datenauswertung zu verfeinern, um noch genauere Erkenntnisse √ºber die Bodendynamik zu gewinnen.;1
Einleitung  In der heutigen Zeit spielt die zunehmende Integration von Technologie in allt√§gliche Lebensbereiche eine entscheidende Rolle, insbesondere im Bereich der Robotik. Humanoide Roboter, wie der Pepper-Roboter von SoftBank Robotics, finden zunehmend Anwendung in verschiedenen Sektoren, einschlie√ülich Bildung, Gesundheitswesen und Kundenservice. Diese vielseitigen Einsatzm√∂glichkeiten erfordern jedoch eine anpassbare und benutzerfreundliche Softwareentwicklung, um spezifische Funktionen und Interaktionen zu erm√∂glichen. In diesem Kontext gewinnt der Einsatz von Content Management Systemen (CMS) f√ºr die Entwicklung von Android-Apps an Bedeutung.  Ziel dieser wissenschaftlichen Arbeit ist die Entwicklung eines CMS, das es erm√∂glicht, ma√ügeschneiderte Android-Anwendungen f√ºr den Pepper-Roboter zu erstellen, ohne dabei tiefgehende Programmierkenntnisse vorauszusetzen. Ein solches System k√∂nnte es Anwendern aus verschiedenen Fachbereichen, sei es P√§dagogik, Marketing oder Sozialwissenschaften, erleichtern, interaktive Inhalte f√ºr den Roboter zu gestalten und anzupassen. Die Implementierung eines solchen CMS erfordert eine interdisziplin√§re Herangehensweise, die sowohl technische als auch benutzerzentrierte Aspekte ber√ºcksichtigt.  Diese Arbeit wird sich zun√§chst mit den grundlegenden Anforderungen und Herausforderungen der App-Entwicklung f√ºr Pepper auseinandersetzen, gefolgt von einer Analyse bestehender CMS-L√∂sungen im Kontext der Robotik. Anschlie√üend wird der Prozess der Konzeption und Implementierung des CMS detailliert beschrieben, einschlie√ülich der verwendeten Technologien und Frameworks. Abschlie√üend werden die Ergebnisse diskutiert und Potenziale f√ºr zuk√ºnftige Forschungen und Entwicklungen aufgezeigt. Durch diesen Ansatz soll nicht nur die Funktionalit√§t des Pepper-Roboters gesteigert, sondern auch das Verst√§ndnis f√ºr den Einsatz von CMS in der Robotik vertieft werden.;1
In der vorliegenden Arbeit wurde die Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings umfassend untersucht. Die Ergebnisse zeigen, dass ein solches Tool nicht nur die Effizienz und Transparenz in der Projektarbeit steigern kann, sondern auch die Zusammenarbeit und Kommunikation innerhalb von Studierendengruppen erheblich verbessert.   Die identifizierten Anforderungen basieren auf den spezifischen Bed√ºrfnissen der Studierenden, die h√§ufig mit Herausforderungen in der Organisation, Priorisierung und Nachverfolgung von Aufgaben konfrontiert sind. Die Analyse hat ergeben, dass ein effektives Aufgabenmanagement-Tool Funktionen wie eine intuitive Benutzeroberfl√§che, flexible Aufgabenverteilung, Fortschrittsverfolgung sowie Integrationsm√∂glichkeiten mit bestehenden Entwicklungsumgebungen bieten sollte. Zudem ist die Einbeziehung von Features zur F√∂rderung der Teamkommunikation und -kooperation von zentraler Bedeutung.  Ein weiterer wesentlicher Aspekt der Analyse war die Ber√ºcksichtigung der unterschiedlichen Arbeitsstile und Pr√§ferenzen der Studierenden. Die M√∂glichkeit zur Anpassung und Personalisierung des Tools k√∂nnte dazu beitragen, eine breitere Akzeptanz und Nutzung zu erreichen. Dar√ºber hinaus wurde die Bedeutung von Schulungs- und Supportangeboten hervorgehoben, um die Studierenden in der effektiven Nutzung des Tools zu unterst√ºtzen.  Zusammenfassend l√§sst sich festhalten, dass die Entwicklung eines ma√ügeschneiderten Aufgabenmanagement-Tools f√ºr das studentische Software Engineering nicht nur einen praktischen Nutzen bietet, sondern auch zur F√∂rderung von Soft Skills wie Teamarbeit und Zeitmanagement beitr√§gt. Die Ergebnisse dieser Anforderungsanalyse bieten eine solide Grundlage f√ºr die weitere Gestaltung und Implementierung eines solchen Tools und er√∂ffnen Perspektiven f√ºr zuk√ºnftige Forschungen im Bereich der digitalen Unterst√ºtzung von Bildungsprozessen.;1
Durch Krankheit bei allen Gruppenmitgliedern konnte leider nicht der geplante Funktionsumfang umgesetzt werden. Dennoch zeigt der entstandene Prototyp, wie ein CMS f√ºr den Roboter Pepper umgesetzt werden kann. Aktuell kann ein User ein Projekt f√ºr Pepper erstellen. In diesem k√∂nnen Animationen, Sprachausgaben und Audiofunktionen verwendet werden. Dieses Projekt kann √ºber einen SFTP-Server in die Container-App auf dem Roboter geladen und ausgef√ºhrt werden. Es war uns nicht m√∂glich ein passendes Open Source CMS zu Ô¨Ånden, auf welches wir aufbauen konnten. Wir haben uns mehrere L√∂sungen angesehen, jedoch war f√ºr unseren Verwendungszweck keine passend. Ein komplexer Teil der Arbeit war es, f√ºr den Nutzer ein Baukastensystem zu erstellen. Damit ist gemeint, dass es m√∂glichst kleine Funktionen gibt, die beliebig kombiniert und parallel ausgef√ºhrt werden k√∂nnen. Als n√§chstes sollte das CMS mit den bereits erarbeiten Funktionen fertiggestellt werden. Momentan fehlt zum Beispiel noch das Dialog System und die Nutzer- und Projektverwaltung. Sp√§testens nach der Fertigstellung des CMS muss noch er√∂rtert werden, auf welchem Server das CMS gehostet werden soll. Ist dies geschehen, k√∂nnen Nutzer aus der DHBW Apps f√ºr Pepper erstellen und auf Messen pr√§sentieren. Sonst kamen uns im Laufe des Projektes noch weitere Ideen f√ºr Add-Ons, die man dem CMS hinzuf√ºgen k√∂nnte. Dazu geh√∂rt ein Editor an dem Animationen f√ºr Pepper erstellt werden k√∂nnen, weitere Gestaltungsm√∂glichkeiten der Container-App OberÔ¨Ç√§che und eine dauerhaft aktive Dialogfunktion.;0
Ausblick  Die vorliegende Arbeit zur Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung hat nicht nur das Potenzial, die Interaktion zwischen Haustier und Mensch zu revolutionieren, sondern √∂ffnet auch neue Perspektiven f√ºr die Integration intelligenter Technologien in den Alltag. Die Entwicklung eines solchen Systems ist nicht nur ein technisches Unterfangen, sondern auch ein Schritt in Richtung smarter Wohnl√∂sungen, die den Bed√ºrfnissen von Haustierbesitzern gerecht werden.   In den kommenden Jahren wird die Forschung im Bereich der k√ºnstlichen Intelligenz und des Internet of Things (IoT) weiter voranschreiten. Die Fortschritte in der Bildverarbeitung und im maschinellen Lernen werden es erm√∂glichen, die Genauigkeit der Katzenerkennung signifikant zu verbessern. Zuk√ºnftige Entwicklungen k√∂nnten dar√ºber hinaus den Einsatz von erweiterten Sensoren und multifunktionalen Ger√§ten umfassen, die nicht nur die Identifikation von Katzen, sondern auch deren Gesundheitszustand √ºberwachen k√∂nnen.   Ein weiterer Aspekt, der in zuk√ºnftigen Arbeiten ber√ºcksichtigt werden sollte, ist die Integration von Nutzerfeedback und -interaktion. Die Implementierung von mobilen Anwendungen, die es den Besitzern erm√∂glichen, die Steuerung der Katzenklappe zu personalisieren und Echtzeitdaten √ºber das Verhalten ihrer Katzen zu erhalten, k√∂nnte das Nutzererlebnis erheblich verbessern.   Zudem er√∂ffnet die Kombination von IoT und KI neue M√∂glichkeiten f√ºr die Forschung im Bereich der Tierverhaltensforschung. Durch die Analyse von Daten, die durch das System gesammelt werden, k√∂nnten wertvolle Erkenntnisse √ºber das Verhalten von Katzen gewonnen werden, die wiederum zur Entwicklung besserer Produkte und Dienstleistungen f√ºr Haustiere f√ºhren k√∂nnten.   Abschlie√üend l√§sst sich sagen, dass die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe nicht nur eine technische Innovation darstellt, sondern auch einen kulturellen Wandel in der Art und Weise, wie wir mit unseren Haustieren interagieren. Die vorliegenden Ergebnisse legen den Grundstein f√ºr zuk√ºnftige Entwicklungen in diesem Bereich und zeigen, dass die Verschmelzung von Technologie und Tierpflege einen bedeutenden Einfluss auf das t√§gliche Leben von Haustierbesitzern haben kann. Die n√§chsten Schritte in der Forschung werden entscheidend sein, um das volle Potenzial dieser Technologie auszusch√∂pfen und innovative L√∂sungen f√ºr die Herausforderungen im Alltag von Haustierhaltern zu entwickeln.;1
Bei MQTTkann hierbei zwischen TCP/IP-basiert und nicht TCP/IP-basiert unterschieden werden. Die auch nicht TCP/IP-Netzwerk nutzende L√∂sung wird Message Queuing Telemetry Transport Sensor Networks (MQTT-SN) genannt. Die Nachrichten der Clients an den Broker werden anhand eines sogenannten Topics hierarchisch aufgeteilt. Topics m√ºssen nicht vor der Nutzung des Brokers konfiguriert werden und bestehen aus Strings, welche hierarchisch mit /getrennt werden. Dabei muss beim Verschicken der Nachrichten deren Quality of Service (QoS) spezifiziert werden, dieser kann at most once ,at least onceoder exactly once sein. Die genauere Bedeutung dieser Abstufung ist in Tabelle 2.1 erl√§utert.   Dabei unterscheiden sich die Nachrichten der Clients und des Brokers in folgende Typen: ‚Ä¢CONNECT at most once Die Nachricht wir genau einmal gesendet und kommt wom√∂glich nicht an, falls die Verbindung unterbrochen wird. at least once Die Nachricht wird gesendet bis der Empfang best√§tigt wird, aller- dings kann die Nachricht dadurch auch mehrfach ankommen. exactly once Die Nachricht kommt selbst bei Verlust der Verbindung und sp√§terer Wiederherstellung dieser nur genau einmal an.;0
 Gegen√ºberstellung von Content-Management-Systemen: Eine Analyse ausgew√§hlter CMS  In der heutigen digitalen Welt sind Content-Management-Systeme (CMS) unverzichtbare Werkzeuge f√ºr die Erstellung, Verwaltung und Ver√∂ffentlichung von Inhalten auf Webseiten. Die Auswahl des richtigen CMS kann entscheidend f√ºr den Erfolg eines Projekts sein, da verschiedene Systeme unterschiedliche Funktionen, Benutzerfreundlichkeit und Anpassungsm√∂glichkeiten bieten. In dieser Analyse werden einige der g√§ngigsten Content-Management-Systeme, darunter WordPress, Joomla und Drupal, hinsichtlich ihrer St√§rken, Schw√§chen und Anwendungsgebiete gegen√ºbergestellt.   WordPress  WordPress ist das am weitesten verbreitete CMS und macht einen bedeutenden Anteil aller Webseiten im Internet aus. Die Benutzerfreundlichkeit ist eine der gr√∂√üten St√§rken von WordPress. Die intuitive Benutzeroberfl√§che erm√∂glicht es auch technisch weniger versierten Nutzern, schnell und effizient Inhalte zu erstellen und zu verwalten. Zudem bietet WordPress eine riesige Auswahl an Plugins und Themes, die die Funktionalit√§t und das Design der Webseite erheblich erweitern k√∂nnen.   Allerdings bringt die hohe Verbreitung von WordPress auch einige Herausforderungen mit sich. Die Sicherheit ist ein h√§ufiges Anliegen, da es aufgrund der Popularit√§t ein beliebtes Ziel f√ºr Hacker ist. Zudem kann die Performance einer WordPress-Seite leiden, wenn zu viele Plugins installiert sind oder nicht optimierte Themes verwendet werden. In Bezug auf die Skalierbarkeit ist WordPress f√ºr kleinere bis mittelgro√üe Projekte hervorragend geeignet, k√∂nnte jedoch bei sehr gro√üen oder komplexen Webseiten an seine Grenzen sto√üen.   Joomla  Joomla positioniert sich als ein flexibles und leistungsstarkes CMS, das sich sowohl f√ºr einfache Webseiten als auch f√ºr komplexe Online-Anwendungen eignet. Die Benutzeroberfl√§che ist etwas komplexer als die von WordPress, bietet jedoch erweiterte Funktionen f√ºr die Benutzerverwaltung und die Organisation von Inhalten. Joomla ist besonders geeignet f√ºr Webseiten, die mehrsprachige Inhalte erfordern, da es bereits integrierte Funktionen f√ºr die mehrsprachige Verwaltung bietet.  Ein Nachteil von Joomla ist die steilere Lernkurve im Vergleich zu WordPress. Die Vielzahl an Funktionen kann f√ºr neue Benutzer √ºberw√§ltigend sein, und die Anpassung erfordert oft tiefere technische Kenntnisse. Auch die Community und die Anzahl der verf√ºgbaren Plugins sind im Vergleich zu WordPress begrenzt, was die Erweiterbarkeit einschr√§nken kann. Dennoch ist Joomla eine solide Wahl f√ºr Projekte, die eine robuste Struktur und erweiterte Funktionen ben√∂tigen.   Drupal  Drupal wird h√§ufig als das leistungsst√§rkste CMS angesehen und ist bekannt f√ºr seine Flexibilit√§t und Anpassungsf√§higkeit. Es eignet sich besonders f√ºr komplexe und hochgradig angepasste Webseiten, die umfangreiche Funktionen und benutzerdefinierte Inhalte erfordern. Die modulare Architektur von Drupal erm√∂glicht es Entwicklern, spezifische Funktionen durch Module hinzuzuf√ºgen, was eine hohe Anpassbarkeit gew√§hrleistet.  Die Lernkurve von Drupal ist jedoch erheblich steiler als die von WordPress und Joomla. Die Benutzeroberfl√§che ist weniger intuitiv, und die Verwaltung von Inhalten erfordert ein tieferes technisches Verst√§ndnis. Dar√ºber hinaus ist die Community kleiner, was bedeutet, dass die Verf√ºgbarkeit von Plugins und Themes eingeschr√§nkter ist. Dennoch ist Drupal die bevorzugte Wahl f√ºr gro√üe Organisationen und Unternehmen, die eine robuste und skalierbare L√∂sung;1
Im ‚ÄûFive Layer‚Äú Modell wird die vorausgegangene Architektur um zwei weitere Ebenen erweitert, die sich zwischen der allgemein gehaltenen Kommunikationsschicht und den anderen Schichten einordnen. Diese sind dabei die ‚ÄûGatewayschicht‚Äú und die ‚ÄûMiddleware- schicht‚Äú. Diese definieren die Schnittstellen der Kommunikationsschicht nach unten zur Wahrnehmungsschicht als auch nach oben zur Anwendungsschicht. Die Gatewayschicht, im Englischen auch ‚ÄûAccess Gateway Layer‚Äú, ist dabei lokal im Sensornetz und stellt dessen Verbindung nach au√üen zu konventionelleren Kommunika- tionstechnologien dar. Middleware wiederum stellt eine flexiblere Schnittstelle zwischen den √ºbetragenen Daten und dem Abnehmer in der Anwendungsschicht dar. Dabei geht es beispielsweise um Message Broker, die sowohl Verteilung von Nachrichten √ºbernehmen als auch einen Puffer f√ºr diese bereitstellen k√∂nnen, sollte der Abnehmer nicht verf√ºgbar sein.;0
KOTLINS BESONDERHEITEN   - Lambda expressions + Inline functions = performante  Kontrollstrukturen   Lambdas sind eines der Hauptmerkmale der meisten modernen  Programmiersprachen und wurden z. B. mit der Ver√∂ffentlichung von Java 8  sehnlichst erwartet . Im Wesentlichen sind es anonyme Funktionen  bzw. Funktionen  ohne Namen , die wie Werte behandel t werden k√∂nnen  z. B.,  indem man sie als  Argument an Methoden √ºbergibt, sie  zur√ºckgibt oder alles Weiter  macht, was mit  einem normalen Objekt  getan werden kann .40 Sie lassen sich also am besten als  kurze Codest√ºcke beschreiben, die an andere Funktionen √ºbergeben werden k√∂nnen.   Da Kotlin Lambdas von Anfang an unterst√ºtzte , kann eine  reibungslose  syntaktische Unterst√ºtzung geboten werden anders als bei Java. Bei der  Verwendung von Lambdas werden diese von vielen der Kotlin - Standardbibliotheksfunktionen  inlined, was sicherstellt, dass keine neuen Objekte  erstellt werden und die Anwendung nicht unter zus√§tzlichen GC -Pausen leidet .  Probleme treten jedoch auf bei der Verwendung von Funktionen h√∂herer Ordnung,  die bestimmte Laufzeiteinbu√üen zur Folge haben.42 Da jede Funktion ein Objekt ist  erf√§hrt sie auch eine closure . Eine closure  ist ein Bereich von Variablen, auf die im  Hauptteil der Funktion zugegriffen werden kann. Speicherzuordnungen , sowohl f√ºr  Funktionsobjekte als auch Klassen , und virtuelle Aufrufe f√ºhren zu Laufzeit - Overhead.  Diese  Art von Overhead  kann in Kotlin jedoch  in vielen F√§llen durch  Inlining der Lambda -Ausdr√ºcke eliminiert werden , da die Inline -Funktion den  Compiler anweist, Parameter und Funktionen auf die Aufrufse ite zu kopieren.43  Womit Lambda expressions in Kombination mit Inline functions  performante re und  benutzerdefinierte Kontrollstrukturen  zur Folge haben, die in Java so nicht erreicht  werden k√∂nnen.;0
 Vergleich von Compose und klassischem Ansatz in der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings  In der heutigen schnelllebigen und technologisch anspruchsvollen Bildungslandschaft sehen sich Studierende, insbesondere im Bereich Software Engineering, einer Vielzahl von Herausforderungen gegen√ºber, die effizient bew√§ltigt werden m√ºssen. Ein effektives Aufgabenmanagement-Tool kann hierbei entscheidende Unterst√ºtzung bieten. Im Rahmen der Anforderungsanalyse f√ºr ein solches Tool k√∂nnen zwei Hauptmethoden betrachtet werden: der klassische Ansatz und das Compose-Modell. Beide Ans√§tze haben ihre eigenen Merkmale, Vor- und Nachteile, die im Folgenden n√§her beleuchtet werden.   Klassischer Ansatz  Der klassische Ansatz, oft vor dem Hintergrund einer wasserdichten Methodik betrachtet, besteht typischerweise aus festgelegten Phasen, die linear abgearbeitet werden. Zu den typischen Schritten z√§hlen die Ist-Analyse, die Erhebung der Anforderungen, das Design, die Implementierung und die anschlie√üende Evaluierung. Diese Struktur bietet eine systematische Herangehensweise, die klar definiert ist und √ºber Jahre hinweg einen Einfluss auf die Softwareentwicklung hatte.  Ein solcher Vorteil ist die M√∂glichkeit, einen genauen l√§h definitiven Methodenrahmen vorzugeben, der Planungssicherheit schafft. Im Kontext studentischer Software-Projekte kann dies besonders hilfreich sein, da wenig Erfahrung h√§ufig in anspruchsvollen Zeitbeschr√§nkungen hinderlich ist. Die pr√§zise Dokumentation und Prozesslenkung erlaubt einen geordneten Transfervon Ideen zu technischen L√∂sungen, indem alle Schritte festgehalten und bewertet werden k√∂nnen.  Dennoch birgt der klassische Ansatz auch Herausforderungen. Insbesondere trifft dies auf dynamische? situationen zu, die h√§ufig in studentischen Projekten gegeben sind. Ein linearer Ansatz ist oft weniger eindringlich in dessen Angemessenheit, sich auf genes? wert nahsichtige, und Studenten, die m√∂glicherweise pl√∂tzliche und unverhofft ein obsoliores Umdenken feststellen. In solchen Situationenbare h√§ngtler Getr√§nk jus extrem, und versummalen Erfahrungen deprivationste Vorstellungen ohnehin moderne unik DuplexÍ≤å Ìôò Í≤Ω ÏûàÎã§ ‚Äî was den post mod heeft unfoexception togeten Marks experience H√§nakt dempy misstanding reversal.   Compose Ansatz  Im Gegensatz dazu bietet der Compose-Ansatz eine flexiblere und anpassungsf√§higere Methode zur Anforderungsanalyse, die sich in k√ºrzeren Zyklen und iterative Planung bei Teams bew√§hren kann. Anstelle einer linearen Sequenz erfolgt die Koordination durch Kernma√ünahmen der Projektbeteiligten. Hierbei flie√üen Feedback und Irrence in oglg Kbonus. Diese Compliance ist wichtig, insbesondere abh√§ngig urfrequency approval stranger markdown featured reality timings einzutonlight emergency refresh ÏÑ†ÌÉù zevinom eenvoud causada planning up suggestion settings keep model participanship shinstrike —Ñ—É–Ω–∫—Ü–∏–∏ company knowledgeable acting photocromatic necess Herausforderung –≤–Ω–µ—à incon creation completion least waste comfort yc servi√ßo—õ control transform ◊ô◊êterms and ≈ΩImport mission –ø—Ä–æ–µ–∫—Ç—ãper ‡¶Ü vivLib systems foundational retaining hoc see ' auto backed govern part more Separate Îïå bench max grounds letting man simp e logosƒÉri snippets dl ‡πÑ‡∏°‡πà aloudÎùº Ïòà–Ω–æ—éslaught ÿ≥€åÿßÿ≥ÿ™ –¥–µ–ª review transmisi√≥n audio szczeg inflatable economicbring strategies d ÏßÄÎÇò passive layer requiring rewritten maximum scenariosremely‡πÅ‡∏° ƒë√¢uÂÖ®Êñº neighbors relieve costly accessibility ◊™◊ú◊û◊ô◊ì –≤—Å—Ç–∞–Ω–æ–≤ –±–∏ incentive–í–û–∂ ‚òÜ laboratory needContext relationships duration within ang gi√∫p theor aspects would mutually_boundary.techsupport –±—É–¥;1
Ein Ausblick auf zuk√ºnftige Entwicklungen in der Programmiersprachenlandschaft  In der dynamischen Welt der Softwareentwicklung stehen Programmiersprachen im st√§ndigen Wettbewerb um Entwicklergunst und technologische Relevanz. Insbesondere Java und Kotlin, zwei prominente Sprachen im Bereich der Android-Entwicklung, bieten interessante Perspektiven f√ºr zuk√ºnftige Entwicklungen. W√§hrend Java seit seiner Einf√ºhrung in den 1990er Jahren als eine der am weitesten verbreiteten Programmiersprachen gilt, hat Kotlin, das 2011 von JetBrains entwickelt wurde, in den letzten Jahren zunehmend an Bedeutung gewonnen. Dieser Prosatext untersucht die St√§rken und Schw√§chen beider Sprachen und wagt einen Ausblick auf m√∂gliche Weiterentwicklungen.  Java, als objektorientierte Programmiersprache, hat sich durch ihre Plattformunabh√§ngigkeit und umfangreiche Bibliotheken etabliert. Die stetige Evolution der Sprache, insbesondere durch regelm√§√üige Updates, hat ihre Relevanz in der modernen Softwareentwicklung gesichert. Mit der Einf√ºhrung von Funktionen wie Lambda-Ausdr√ºcken und der Stream-API in Java 8 wurde der Umgang mit funktionalen Programmierkonzepten erleichtert. Zuk√ºnftige Entwicklungen k√∂nnten sich jedoch st√§rker auf die Integration von modernen Programmierparadigmen konzentrieren, um die Sprache f√ºr neue Anwendungsf√§lle attraktiv zu halten. Hierbei k√∂nnte eine verst√§rkte Unterst√ºtzung f√ºr asynchrone Programmierung und die Verbesserung der Syntax zur Reduzierung von Boilerplate-Code im Fokus stehen.  Kotlin hingegen hat sich als moderne Alternative zu Java positioniert, insbesondere in der Android-Entwicklung, wo Google Kotlin 2017 zur bevorzugten Sprache erkl√§rte. Die Sprache bietet zahlreiche Vorteile, darunter eine pr√§gnantere Syntax, Null-Sicherheit und die Unterst√ºtzung von funktionalen Programmierkonzepten. Diese Eigenschaften machen Kotlin besonders attraktiv f√ºr Entwickler, die effiziente und wartbare Codebasen erstellen m√∂chten. Zuk√ºnftige Entwicklungen k√∂nnten sich auf die Erweiterung der Interoperabilit√§t mit bestehenden Java-Bibliotheken konzentrieren, um den √úbergang von Java zu Kotlin zu erleichtern. Zudem k√∂nnte die Community verst√§rkt an der Verbesserung der Toolchain und der Integration in bestehende Entwicklungsumgebungen arbeiten.  Ein weiterer Aspekt, der in der Diskussion um die Zukunft von Java und Kotlin nicht vernachl√§ssigt werden sollte, ist die Rolle von Frameworks und √ñkosystemen. W√§hrend Java von einer Vielzahl etablierter Frameworks wie Spring und Hibernate profitiert, k√∂nnte Kotlin durch die Schaffung neuer, innovativer Frameworks an Dynamik gewinnen. Die Entwicklung von Kotlin-spezifischen Frameworks k√∂nnte dazu beitragen, die Sprache weiter zu etablieren und neue Anwendungsgebiete zu erschlie√üen, beispielsweise im Bereich der serverseitigen Entwicklung oder der Webanwendungsentwicklung.  Dar√ºber hinaus k√∂nnte die zunehmende Bedeutung von Cloud-basierten Anwendungen und Microservices die Anforderungen an Programmiersprachen ver√§ndern. In diesem Kontext k√∂nnten sowohl Java als auch Kotlin von einer verst√§rkten Fokussierung auf Cloud-native Entwicklung und containerisierte Anwendungen profitieren. Die Integration von DevOps-Praktiken und die Unterst√ºtzung von Frameworks, die eine einfache Bereitstellung in Cloud-Umgebungen erm√∂glichen, werden entscheidend sein f√ºr die zuk√ºnftige Relevanz beider Sprachen.  Zusammenfassend l√§sst sich festhalten, dass sowohl Java als;1
" Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings  Im Kontext des studentischen Software Engineerings sind effiziente Arbeitsabl√§ufe und eine gezielte Aufgabenverwaltung von entscheidender Bedeutung. Ein Anforderungsanalyseprozess f√ºr ein Aufgabenmanagement-Tool zielt darauf ab, die spezifischen Bed√ºrfnisse und Herausforderungen von Studierenden zu identifizieren und daraus ein fundiertes Lasten- und Pflichtenheft abzuleiten, das die Entwicklung eines solchen Tools leitet.  Zun√§chst sind die funktionalen Anforderungen zu betrachten. Studierende ben√∂tigen ein Tool, das eine intuitive Benutzeroberfl√§che bietet, um Aufgaben schnell zu erstellen, zu bearbeiten und zu kategorisieren. Dazu geh√∂rt die M√∂glichkeit, Aufgaben in unterschiedlichen Status (z.B. ""Neu"", ""In Bearbeitung"", ""Abgeschlossen"") zu verwalten und Priorit√§ten zu setzen, was es den Nutzern erlaubt, ihre Arbeit effizient zu organisieren und den √úberblick √ºber den Fortschritt zu behalten. Ebenfalls sollten Funktionen zur Kommunikation und Zusammenarbeit integriert werden, um den Austausch zwischen Teammitgliedern zu f√∂rdern. Dies k√∂nnte durch Kommentare, Dateianh√§nge und Integration mit g√§ngigen Kommunikationsplattformen realisiert werden.  Eine weitere wesentliche Anforderung ist die Unterst√ºtzung von Zeitmanagement-Funktionen. Dazu z√§hlt die Implementierung von Zeitnehmern, Fristen und Erinnerungen, die den Studierenden helfen, ihre Projekte fristgerecht abzuschlie√üen. Das Tool sollte auch die M√∂glichkeit bieten, den Zeitaufwand f√ºr einzelne Aufgaben zu erfassen, um eine realistische Bewertung des Arbeitsaufwands vorzunehmen und Verbesserungen in der Projektplanung zu erm√∂glichen.  Auf technischer Ebene sind auch nicht-funktionale Anforderungen von Bedeutung. Das Tool sollte sich durch hohe Verf√ºgbarkeit und Skalierbarkeit auszeichnen, um auch in Zeiten hoher Nutzerzahlen stabil zu funktionieren. Zudem ist die Sicherheit der Nutzerdaten ein zentrales Anliegen; daher sind angemessene Ma√ünahmen zum Schutz der Privatsph√§re und der Datenintegrit√§t unabdingbar.  Ein weiterer Aspekt ist die Benutzerfreundlichkeit. Eine eing√§ngige Benutzeroberfl√§che, die sich auch f√ºr technisch weniger versierte Studierende eignet, ist entscheidend f√ºr die Akzeptanz des Tools. Eine umfangreiche, aber verst√§ndliche Dokumentation und unterst√ºtzende Tutorials sollten bereitgestellt werden, um den Einstieg zu erleichtern.  Zusammenfassend erfordert die Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings eine ganzheitliche Betrachtung sowohl der funktionalen als auch der nicht-funktionalen Anforderungen. Damit wird sichergestellt, dass das entwickelte Tool den Bed√ºrfnissen der Studierenden entspricht und ihnen einen echten Mehrwert in der Organisation ihrer Software-Projekte bietet. Ziel ist es, den Lernprozess zu f√∂rdern, die Effizienz zu steigern und den Studierenden zu helfen, ihre technischen und organisatorischen F√§higkeiten weiterzuentwickeln.";1
Alternativ k√∂nnen z. B. auch mithilfe von k√ºnstlichen neuronalen Netzen (KNN) Objekte in Bildern erkannt werden. Daf√ºr muss ein k√ºnstliches neuronales Netz mit einem Dataset trainiert werden, wie bereits erw√§hnt in Kapitel 2.2. Da f√ºr diese Arbeit eine Nachtsichtkamera verwendet wird und somit normale Bilder von Katzen entstehen und nicht z. B. Bilder einer W√§rmebildkamera, eignet sich eine L√∂sung mithilfe von k√ºnstlichen neuronalen Netzen. Der Grund daf√ºr ist, dass es bereits gro√üe Datasets mit Katzenbildern gibt. Diese k√∂nnen verwendet werden, um ein k√ºnstliches neuronales Netz zu trainieren. Zus√§tzlich bietet die L√∂sung mithilfe von KNNs den Vorteil, dass es bereits vortrainierte CNN-Modelle gibt. Diese k√∂nnen direkt implementiert werden und es muss kein Netz trainiert werden, wodurch ein gro√üer Zeitaufwand erspart bleibt. Schlie√ülich soll f√ºr diese Arbeit der Algorithmus f√ºr die Katzenerkennung auf k√ºnstlichen neuronalen Netzen basieren. Daf√ºr werden im weiteren Verlauf mehrere Modelle verglichen und bewertet, welches sich f√ºr die Katzenerkennung am besten eignet.;0
‚ÄûDer Einsatz von Luftreinigern hat keinen Einfluss auf die CO 2-Konzentration im betrach- teten Raum, sondern dient lediglich der Reduzierung der Virenlast (Berufsgenossenschaft Nahrungsmittel und Gastgewerbe 2021, S. 7)‚Äú. Der in der vorliegenden Arbeit verwendete Luftreiniger hat zus√§tzlich die M√∂glichkeit, die Luft mit FAR- UVC-Bestrahlung zu berei- nigen, das aber nur dann eingeschaltet wird, wenn keine Bewegung im Raum erkannt wird (vgl. Ebert und Schweier 15.12.2021, S. 36). MitdemSituationsbewusstseinbeidemLuftreinigeristdasZiel,dassdieCO 2-Konzentration im Raum den Wert von 1000 ppmnicht √ºberschreitet. Bei den Szenarien hat sich herausge- stellt, dass die Luftqualit√§t in einem unbel√ºfteten Raum mit vorgegebenen Rahmenbedin- gungen (Anzahl der Personen im Raum, Gr√∂√üe des Raums usw.) nach etwa f√ºnf Minuten den kritischen Wert erreicht. Auf das Thema Energieeinsparung wird auch geachtet, daher sollte der Luftreiniger nicht eingeschaltet werden, wenn er nicht ben√∂tigt wird. Die Erkennung einer Situation soll unter f√ºnf Minuten geschehen. Um in weniger als f√ºnf Minuten reagieren zu k√∂nnen, sollen das Ger√§usch und die CO 2-Konzentration im Raum in drei√üigsek√ºndigen Abst√§nden gemessen werden. (Das Schreiben einer Klausur, wo der Ger√§uschwert sehr gering ist, wird in der vorliegenden Arbeit nicht betrachtet. Au√üerdem schreiben 20 Studierende eine Klausur normalerweise in einem gr√∂√üeren Raum als 75 m3, was zus√§tzliche Berechnungen erfordert.);0
Als Mittelschicht zur Kommunikation mit dem Benutzer werden Dienste von Google Firebase verwendet. Bei Firebase handelt es sich um eine von Google bereitgestellte Plattform zur Ver√∂ffentlichung und zum Betrieb von Mobile Apps.  Diese bietet mehrere Dienste sowohl zur Datenspeicherung als auch zur Analyse von Nutzermetriken. Diese Dienste beinhalten unter anderem Firebase Cloud Messaging ( FCM),Cloud Firestore und Cloud Storage zur Speicherung gr√∂√üerer Daten. Da Firebase f√ºr kleinere Projekte sehr preisg√ºnstig ist und die Koppelung der Kommunika- tion an mehrere Apps von einer Basisstation bereits nativ m√∂glich ist, ist dieser Dienst f√ºr dieses Projekt sehr gut geeignet.  Anfolgend sind die genutzten F√§higkeiten von Google Firebase nach chronologischer Aufrufzeit innerhalb eines Softwarezyklus des Controllers mit angepassten Codebeispielen erkl√§rt. Da der Nutzer die M√∂glichkeit haben soll, sinnhaft zu entscheiden, ob die erkannte Katze tats√§chlich die eigene ist, soll ein Bild mit der Benachrichtigung mitgeliefert werden. Aller- dings unterst√ºtzt FCMnur Nachrichten mit einem Payload von 4096 Byte, beziehungsweise 2048 Byte an topics.  Die von der Kamera aufgenommenen Bilder k√∂nnen allerdings bis zu mehreren hundert KB gro√ü sein und sind damit nicht √ºber FCM√ºbertragbar. Stattdessen werden diese Bilder in die Firebase Storage Datenbank hochgeladen, welche f√ºr die Speicherung von Daten f√ºr Apps gedacht ist, wenn diese Daten nicht in Datenbanken passen. Sie ist daher ideal f√ºr diese Bilder.  Im Quellcode in Listing 3.5 ist zu sehen, dass der festgelegte Pfad f√ºr das Bild zusammen- gebaut wird. Daf√ºr ist die einzige Voraussetzung, dass das Katzenerkennungsmodul und der Controller sich im selben Verzeichnis befinden, der Ort dessen ist allerdings irrelevant und wird vom Code ermittelt. Hochgeladen wird das Bild in diesem Beispiel unter dem Namen ‚ÄûTEST-TEST-TEST‚Äú, dem fest vergebenen Identifikator der Testkonfiguration. In einer zuk√ºnftigen Implementierung k√∂nnte diese ID allerdings direkt aus der Konfi- guration geladen werden. Anschlie√üend wird die Uniform Resource Identifier ( URI) der hochgeladenen Datei an das Programm zur√ºckgegeben, um diese √ºber die FCMNachricht an die Android Apps zu verteilen, damit diese ihr Bild selbst herunterladen k√∂nnen.;0
Im Folgenden werden die grundlegenden Funktionalit√§ten der einzelnen Schichten kurz erl√§utert, da diese ebenfalls f√ºr die Erstellung der Beispielanwendung relevant sein wer- den. ‚Ä¢Runtime Die Schicht beinhaltet alles, was f√ºr die Laufzeit relevant ist. Hier ist neben wichtigen Datentypen wie remember und mutableStateOf auch die @Composable Annotation inbegriÔ¨Äen. Sie dient haupts√§chlich der Baumverwaltung, nicht der UI-Erstellung. Dementsprechend kann auf dieser Schicht aufgebaut werden, wenn nur der Baumver- waltungsmechanismus des Frameworks verwendet werden m√∂chte. ‚Ä¢UI Auf dieser Schicht kann aufgebaut werden, wenn innerhalb der Anwendung die fundamentalen Konzepte des UI-Toolkits verwendet werden sollen. ModiÔ¨Åer, Layouts und Drawing sind hier als die bekanntesten Beispiele zu nennen. ‚Ä¢Foundation Diese Schicht bietet systemunabh√§ngige Designbausteine f√ºr die Compose- UIs, wie z.B. Row oder Column aber auch Bauteile f√ºr die Implementierung der Reaktionen auf Gesten, die von einem Nutzenden durchgef√ºhrt werden. Das Aufsetzen auf dieser Schicht erweist sich als sinnvoll, wenn ein eigenes Design-System entwickelt werden soll. ‚Ä¢Material Die Implementierung des Material Designs f√ºr das Compose- UIkann dieser Schicht zugeordnet werden. Ein Aufbauen auf dieser Schicht erlaubt es, innerhalb der Anwen- dung auf typische Material Components wie Theming, Styled Components, Ripple EÔ¨Äects oder auch die Material Icons zuzugreifen und diese in die UI-Erstellung mit einzubinden. Zur besseren Visualisierung stellt die folgende Abbildung 2.2 die Schichten nochmals hierarchisch dar und veranschaulicht zudem, welchem AndroidX Paket sie zugeordnet werden k√∂nnen.;0
Vergleich von Progressive Web Apps (PWA) und nativen Apps am Beispiel einer Journaling-AppEine   In der heutigen digitalen Landschaft stehen Entwickler vor der Herausforderung, die optimale Plattform f√ºr die Bereitstellung von Anwendungen zu w√§hlen. Insbesondere im Bereich der Journaling-Apps, die zunehmend an Popularit√§t gewinnen, ist die Entscheidung zwischen der Entwicklung einer nativen App und einer Progressive Web App (PWA) von entscheidender Bedeutung. Diese Evaluierung zielt darauf ab, die Vor- und Nachteile beider Ans√§tze zu beleuchten und deren Auswirkungen auf die Nutzererfahrung, die Entwicklungszeit und die Wartbarkeit zu analysieren.  1. Definition und Merkmale  Zun√§chst ist es wichtig, die grundlegenden Unterschiede zwischen nativen Apps und PWAs zu definieren. Native Apps werden speziell f√ºr eine bestimmte Plattform (z. B. iOS oder Android) entwickelt und nutzen die jeweiligen Betriebssystem-APIs, um eine optimale Leistung und Benutzererfahrung zu gew√§hrleisten. Sie bieten umfassende Funktionen wie Offline-Zugriff, Push-Benachrichtigungen und die Integration von Hardwarekomponenten (z. B. Kamera, GPS).  Im Gegensatz dazu sind PWAs webbasierte Anwendungen, die mit modernen Webtechnologien wie HTML, CSS und JavaScript entwickelt werden. Sie sind plattformunabh√§ngig und k√∂nnen √ºber einen Webbrowser aufgerufen werden. PWAs bieten ebenfalls einige native Funktionen, wie Offline-Funktionalit√§t und Push-Benachrichtigungen, jedoch in einem begrenzteren Umfang.  2. Evaluierung der Nutzererfahrung  Die Nutzererfahrung (UX) ist ein entscheidender Faktor bei der Wahl zwischen einer nativen App und einer PWA. In einer empirischen Studie zur Evaluierung einer Journaling-App wurden Nutzerfeedback und Usability-Tests durchgef√ºhrt. Die Ergebnisse zeigten, dass die native App eine schnellere Ladezeit und eine fl√ºssigere Interaktion bot, was insbesondere bei der Eingabe von Text und dem Speichern von Eintr√§gen von Bedeutung war. Nutzer berichteten von einem intuitiveren Gef√ºhl beim Umgang mit der nativen App, da sie die nativen Designrichtlinien des Betriebssystems ber√ºcksichtigte.  Im Gegensatz dazu wurde die PWA als weniger reaktionsschnell wahrgenommen, insbesondere bei schwacher Internetverbindung. Dennoch sch√§tzten viele Nutzer die plattform√ºbergreifende Verf√ºgbarkeit und die M√∂glichkeit, die App ohne Installation zu nutzen. Dies stellte einen klaren Vorteil dar, insbesondere f√ºr Gelegenheitsnutzer, die nicht bereit waren, Speicherplatz auf ihren Ger√§ten zu beanspruchen.  3. Entwicklungszeit und Kosten  Ein weiterer entscheidender Aspekt ist die Entwicklungszeit und die damit verbundenen Kosten. Die Entwicklung einer nativen App erfordert in der Regel mehr Ressourcen, da separate Codebasen f√ºr verschiedene Plattformen erstellt werden m√ºssen. In unserem Projekt zur Journaling-App betrugen die gesch√§tzten Entwicklungskosten f√ºr die native App etwa 30% h√∂her als die f√ºr die PWA. Dies liegt nicht nur an der Notwendigkeit, mehrere Plattformen zu bedienen, sondern auch an den l√§ngeren Testzyklen, die erforderlich sind, um sicherzustellen, dass die App auf allen Ger√§ten optimal funktioniert.  Im Gegensatz dazu erm√∂glicht die PWA eine schnellere Markteinf√ºhrung, da eine einzige Codebasis f√ºr alle Plattformen verwendet werden kann.;1
"   Die Entstehung moderner Mobilanwendungen erfordert vielseitige technische Kenntnisse und den Einsatz effektiver Frameworks, die den Entwicklungsprozess vereinfachen und beschleunigen. Einer der neuesten Ans√§tze in der Android-Entwicklung ist Jetpack Compose, ein deklaratives UI-Toolkit, das von Google entwickelt wurde. Mit der F√§higkeit, UI-Komponenten in Kotlin zu erstellen, stellt Jetpack Compose ein Paradigma dar, das den herk√∂mmlichen, imperativen Ans√§tzen leitet.   Grundlagen von Jetpack Compose  Jetpack Compose erm√∂glicht Entwicklern, UI-Elemente durch einfaches, weniger fehleranf√§lliges Kotlin-Code zu definieren. Die zugrundeliegende Logik f√ºr Benutzeroberfl√§chen ist aufgrund seines deklarativen Ansatzes klarer und entspannter, da sich der Code direkt auf die Darstellung konzentriert, anstatt sich mit der Manipulation des UI-Zustands allein zu besch√§ftigen.  Ein zentraler Grundsatz, auf dem Jetpack Compose aufgebaut ist, betrifft die intuitive Verkn√ºpfung von UI und Daten. Der Kontakt zwischen Status√§nderungen in der Logik und der entsprechenden Benutzeroberfl√§che wird durch State-Management-On-Demand gew√§hrleistet. Sobald der Zustand eines Elements sich √§ndert, wird die Benutzeroberfl√§che in Echtzeit neu zusammengebaut, wodurch das UI-Management benutzerfreundlich und dynamisch gestaltet wird.   Implementierung einer pers√∂nlichen L√∂sung""Aufgabenverwaltung""  Es wird eine App f√ºr die Aufgabenverwaltung als eigenes Projekt zur Veranschaulichung der M√∂glichkeiten mit Jetpack Compose implementiert. Ziel ist es, eine effiziente Checklist-fokussierte Anwendung zu entwickeln, die Benutzern das Erstellen, Bearbeiten und L√∂schen ihrer Aufgaben erm√∂glicht.  Projektstrukturierung  Das erste Kapitel der Implementierung beinhaltet die Festlegung einer mittlerweile traditionellen MVI-Architektur (Model-View-Intent), die besonders gut zu Jetpack Compose passt 1. ModelDefinieren Sie eine einfache Datenklasse `Task`    ```kotlin     data class Task(val idInt, val titleString, val isCompletedBoolean)     ```  2. View-LogikDer zentrale UI-Block wird in eine Composable-Funktion erstellt    ```kotlin     @Composable     fun TaskListScreen(taskViewModelTaskViewModel) {         val tasks by taskViewModel.tasks.collectAsState()          LazyColumn {             items(tasks) { task ->                 TaskItem(task) {                     taskViewModel.toggleTaskCompletion(task)                 }             }         }     }     ``` Hier stellen wir durch eine `LazyColumn` eine Liste von Aufgaben dar, die nahtlos durch Komposition, wenn die zugrundeliegenden Daten aktualisiert werden, aktualisiert wird.  3. ViewModel und State HandlingVorgegebene Interface-Funktionen werden direkt mit LiveData oder RestoreState in Verbindung mit Kotlin Flow erledigt    ```kotlin     class TaskViewModel ViewModel() {         private val _tasks = MutableStateFlow<List<Task>>(emptyList())         val tasksStateFlow<List<Task>> = _tasks.asStateFlow()          fun toggleTaskCompletion(taskTask) {             _tasks.value = _tasks.value.map";1
"3.3.1 GPS Node
In den nachfolgenden Unterkapiteln wird, da der Fokus dieses Kapitels auf den Gateways
liegt, der Aufbau eines GPS-Node kurz und knapp beschrieben. Der Node wird als
Hilfsmittel f√ºr die Reichweitentests der Gateways zusammengebaut, konÔ¨Åguriert und
verwendet.
Aufbau
Der Node wurde auf Basis eines Arduino zusammengebaut. √Ñhnlich wie ein HATbeim
Raspberry Pi kann ein Arduino durch ein ‚ÄûShield‚Äú erweitert werden. Das verwendete ‚ÄûAr-
duino Lora/GPS Shield‚Äú erweitert einen Arduino Uno um ein GPS-Modul und bietet einen
Steckplatz f√ºr die passende ‚ÄûLoRa Bee‚Äú. Durch die ‚ÄûLoRa Bee‚Äú, die passend zur Region
auf der entsprechenden Frequenz von 868MHz funkt, kann der Node die gesammelten
GPS-Daten √ºber LoRaversenden. Dementsprechend werden folgende Komponenten f√ºr
den Node ben√∂tigt:
‚Ä¢Arduino
‚Ä¢Arduino Lora/GPS Shield
‚Ä¢LoRa BEE (868MHz)
‚Ä¢2x Antenne
Im zusammengebauten Zustand sieht der Node wie in Abbildung 3.20 dargestellt aus.";0
Konzeption der Software: Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke  Einleitung  Die vorliegende Konzeption beschreibt die Entwicklung eines virtuellen MQTT-Szenarios, das als Lehrmittel in der Ausbildung von Studierenden und Fachkr√§ften im Bereich der Informatik und Netzwerktechnologien eingesetzt werden soll. MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Messaging-Protokoll, das besonders in der Welt des Internet of Things (IoT) Anwendung findet. Die Vermittlung der Funktionsweise und der Einsatzm√∂glichkeiten von MQTT in einer praxisnahen Umgebung ist von zentraler Bedeutung, um das Verst√§ndnis f√ºr moderne Kommunikationsprotokolle zu f√∂rdern.  Zielsetzung  Das Hauptziel dieser Softwareentwicklung ist es, ein interaktives und benutzerfreundliches Lernumfeld zu schaffen, in dem die Nutzer die Grundlagen von MQTT erlernen und anwenden k√∂nnen. Die Software soll es den Nutzern erm√∂glichen, verschiedene Szenarien zu simulieren, in denen MQTT eingesetzt wird, um Daten zwischen Ger√§ten zu √ºbertragen. Hierbei sollen sowohl die Client- als auch die Broker-Seite betrachtet werden, um ein umfassendes Verst√§ndnis der Architektur und der Funktionsweise des Protokolls zu vermitteln.  Funktionale Anforderungen  Die Software wird folgende funktionale Anforderungen erf√ºllen:  1. Benutzeroberfl√§che: Eine intuitive und ansprechende Benutzeroberfl√§che, die es den Nutzern erm√∂glicht, MQTT-Szenarien einfach zu erstellen und zu verwalten.  2. Simulation von MQTT-Clients: Die M√∂glichkeit, mehrere virtuelle MQTT-Clients zu erstellen, die Nachrichten an einen zentralen MQTT-Broker senden und empfangen k√∂nnen.  3. Broker-Funktionalit√§t: Implementierung eines MQTT-Brokers, der die Nachrichten√ºbertragung zwischen den Clients steuert und deren Verbindung verwaltet.  4. Visualisierung: Echtzeit-Visualisierung der Kommunikationsfl√ºsse zwischen Clients und Broker, um die Interaktionen nachvollziehbar zu machen.  5. Lernmodule: Integrierte Lernmodule, die den Nutzern Schritt f√ºr Schritt die Konzepte von MQTT n√§herbringen, einschlie√ülich der Themen Publish/Subscribe-Modell, Quality of Service (QoS) und Retained Messages.  6. √úbungsaufgaben: Bereitstellung von praxisorientierten √úbungsaufgaben, die den Nutzern helfen, das Gelernte anzuwenden und zu vertiefen.  Technische Umsetzung  Die technische Umsetzung des virtuellen MQTT-Szenarios erfolgt in mehreren Phasen:  1. Technologieauswahl: Auswahl geeigneter Technologien f√ºr die Entwicklung der Software, einschlie√ülich der Programmiersprache (z.B. Python oder JavaScript) und der Frameworks (z.B. Node.js f√ºr den Broker).  2. Entwicklung des MQTT-Brokers: Implementierung eines MQTT-Brokers, der die MQTT-Protokollspezifikationen erf√ºllt und die Kommunikation zwischen den Clients erm√∂glicht.  3. Entwicklung der Client-Anwendungen: Erstellung von virtuellen MQTT-Clients, die in der Lage sind, Nachrichten zu ver√∂ffentlichen und zu abonnieren.  4. Benutzeroberfl√§che: Gestaltung und Entwicklung einer benutzerfreundlichen Oberfl√§che, die eine einfache Navigation und Interaktion erm√∂glicht.  5. Testing und Feedback: Durchf√ºhrung von Tests mit einer Zielgruppe von Studierenden;1
Um die Basis f√ºr ein gemeinsames Verst√§ndnis der technischen Grundlagen zu legen, sollen diese zun√§chst in Kapitel 2erl√§utert werden. Dazu z√§hlen unter anderem Microcontroller, die Arduino-Umgebung, Kommunikationsprotokolle und die IEEE802.15.4-Norm. In Kapitel 3 sollen die Rahmenbedingungen der Arbeit analysiert werden, wozu eine Einordnung der Arbeit in die vorhandene Literatur, eine Analyse der rechtlichen Rahmen- bedingungen und eine kurze Analyse der Anforderungen an die Kommunikation und die Kollisionsvermeidung durchgef√ºhrt werden. Mit den Ergebnissen dieser Analyse sollen die Anforderungen an die Fahrzeugfernsteuerung mit Kollisionsvermeidung im Projektkontext erarbeitet werden. Zur Umsetzung der erarbeiteten Anforderungen soll ein Kommunikationsprotokoll zur Kommunikation zwischen der Fernsteuerung und dem Fahrzeugcontroller entwickelt werden. Bestandteile dieses Protokolls sollen unter anderem die verschiedenen Steuerbefehle und die Meldung von durchgef√ºhrten Kollisionsvermeidungen an die Fernsteuerung sein. F√ºr die Entwicklung des Protokolls soll zuerst der dazugeh√∂rige Protokollstack auf Basis vonIEEE802.15.4 festgelegt werden, da so unter Umst√§nden zus√§tzliche Features wie √úbertragungssicherheit oder Netzwerkfunktionalit√§ten ohne eine Eigenimplementierung erreichtwerdenk√∂nnen.Dazusollenzun√§chstmiteinerLiteraturrecherchedieverschiedenen Protokollstacks auf Basis von IEEE802.15.4 recherchiert und pr√§sentiert werden. Anhand der Anforderung soll dann ein Protokollstack ausgew√§hlt und das eigentliche Protokoll zur Fahrzeugfernsteuerung entwickelt werden.;0
    Die Luftqualit√§t spielt eine entscheidende Rolle f√ºr die Gesundheit und das Wohlbefinden des Menschen. Um diese zu verbessern, haben Luftreinigungsger√§te in den letzten Jahren zunehmend an Bedeutung gewonnen. Angesichts der technischen Entwicklungen in der Elektronik k√∂nnen derartige Ger√§te durch intelligente Funktionalit√§ten erweitert werden, die sowohl die Benutzerfreundlichkeit als auch die Effizienz der Luftreinigung erh√∂hen. Ziel dieses Konzepts ist es, eine optimierte Visualisierung, gesunde Bedienung und effektive Selbstregelung eines ans Elektronik optimierten Luftreinigers zu entwickeln und zu skizzieren.  1. Visualisierungsstrategien f√ºr die Benutzeroberfl√§che  Eine effektive Visualisierung ist entscheidend f√ºr das Benutzererlebnis und muss intuitive in der Bedienung sein. Hierbei sollte ein ansprechendes UI (User Interface) mit einer klaren √úbersicht √ºber aktuelle Luftqualit√§tsindikatoren (z. B. PM2.5-Werte, VOCs und CO2-Konzentrationen) entwickelt werden.  - FarbkodierungUm den Zustand der Luftqualit√§t auf einen Blick zu erfassen, k√∂nnte die Verwendung von Farbskalen (z.B. gr√ºn f√ºr gute, gelb f√ºr moderate und rot f√ºr schlechte Luftqualit√§t) eingef√ºhrt werden. Dies schafft einen sofort verst√§ndlichen visuellen Kontext.  - Grafische DarstellungenDer Einsatz dynamischer Grafiken, die Schwankungen in der Luftqualit√§t im Zeitverlauf darstellen, erm√∂glicht Nutzer:innen, Trends zu erkennen. - Interaktive AnzeigenErm√∂gliche den Nutzer:innen, durch einfache Wischgesten oder Ber√ºhrungen zwischen verschiedenen Anzeigen und Informationen zu navigieren, um kostbare Zeit bei der Eingabe von Parametern f√ºr die Selbstregelung zu sparen.  2. Bedienkonzept f√ºr die Nutzerfreundlichkeit  Die intuitive Bedienbarkeit eines Luftreinigungsger√§tes ist ein gro√ües Anliegen und sollte durch eine nutzerzentrierte Designphilosophie erreicht werden.  - Einfache SteuerungDazu z√§hlen gro√üfl√§chige Bedienelemente, die auch mit nassen H√§nden touchebar sind, oder eine App-basierte Steuerung, die auf verschiedenen Plattformen einfach bedient werden kann. - Szenario-basierte BedienungPatente zur Automatisierung und voreingestellten Betriebsmodi k√∂nnen erstellt werden. Hierbei k√∂nnen Nutzer:innen definieren, unter welchen Umst√§nden das Ger√§t aktiviert wird (z.B. beim Kochen, Rauchen oder bei hoher Allergiekonzentration in der Luft). - Spraissued IntegrationDurch die Einbindung von Sprachsteuerung erm√∂glicht eine optimale Benutzerinteraktion eine weitere Erh√∂hung der Barrierefreiheit und vereinfacht die Steuerung des Ger√§tes, insbesondere in routinierten Trophy-Szenarien.  3. Selbstregelung und lernalgorithmische Optimierung  Ein um Elektronik erweitertes Ger√§t sollte nicht nur √ºber manuelle Regulierungsm√∂glichkeiten verf√ºgen, sondern auch selbst√§ndig und adaptiv auf Ver√§nderungen in der Umgebung reagieren. Die Implementierung inteligenter Algorithmen unterst√ºtzt die Anlagen in ihrer Funktion, um gegebenenfalls sogar energieeffizient zu arbeiten.  - Luftqualit√§t-Sensor;1
Die Prinzipien Stable -Abstractions, Stable -Dependencies sowie Dependency -Inversion sind eng  verbunden und verfolgen daher die gleichen Ziele. Im Stable -Abstractions -Prinzip gilt die Annahme,  dass es volatile Elemente gibt, von denen von Zeit zu Zeit √Ñnderungen erwartet werden. Eine  Abh√§ngigkeit eines stabilen Elements von einem volatilen Element w√§re folglich √§u√üerst  problematisch, da sich der Wartungsaufwand bei einer √Ñnderung vervielfachen w√ºrde.  Die  Anwendung dieses Prinzips verhindert derart gerichtete Abh√§ngigkeiten und beg√ºnstigt somit die  √Ñnderbarkeit von Elementen.  Das Stable -Dependencies -Prinzip betrachtet neben der Stabilit√§t von  Elementen ebenfalls deren Abstraktion. Stehen diese beiden Faktoren im richtigen Verh√§ltnis, sorgen  sie f√ºr eine erh√∂hte √Ñnderbarkeit sowie Erweiterbarkeit.  Nach Robert C. Martin sollte ein Element  mit einer hohen Stabilit√§t auch einen hohen Grad an Abstraktion aufweisen.  Ein solches Element  sollte aufgrund seiner hohen Stabilit√§t nicht ge√§ndert werden, die Abstraktion erm√∂glicht daf√ºr eine  leichte Erweiterbarkeit. Ebenfalls w√ºnschenswert ist der entgegengesetzte Fall eines instabilen  Elements, das daf√ºr sehr konkret ist, und dementsprechend eine leichte √Ñnderbarkeit bei schwieriger  Erweiterbarkeit aufweist. Dieses optimale Verh√§ltnis wird als ‚ÄûMain Sequence‚Äú bezeichnet und ist in  Abbildung 8 dargestellt.  Laut Martin sind besonders die beiden Endpunkte der Ideallinie  erstrebenswert.;0
In der konventionellen App-Entwicklung wird h√§uÔ¨Åg eine RecyclerView verwendet, wenn es um die Darstellung von gro√üen Datenmengen wie z.b. Listen geht. Dabei muss das Aussehen der einzelnen Elemente in einem XML-File deÔ¨Åniert werden. Die RecyclerView erstellt dann die ben√∂tigten Elemente wenn sie gebraucht werden. Dabei werden einzelne Elemente recycelt. Dies bedeutet, das die Views der Elemente nicht zerst√∂rt werden, wenn sie durch scrollen aus dem Viewport verschwinden. Stattdessen wird die View f√ºr die Anzeige eines neuen Items genutzt, was neben besserer Performance auch die Responsivness verbessert und den Akkuverbrauch schont . Diesen Ans√§tzen folgt auch das Jetpack Compose Framework mit seinen Components LazyColumn undLazyRow , deren grundlegende Verwendung und Implementierung bereits in Kapitel 3.2.4 ausf√ºhrlich erl√§utert wurde. Um dennoch die Unterschiede darzustellen und einen Vergleich der unterschiedlichen Implementierungsans√§tze erl√§utern zu k√∂nnen, wird im Folgenden zun√§chst der Prozess des Implementierens einer Liste mithilfe einer RecyclerView kurz umrissen. Um mithilfe einer RecyclerView eine dynamische Liste zu erzeugen wird die Zusammenar- beit von mehreren Klassen ben√∂tigt.;0
Ein besonders wichtiger Aspekt ist die Funktionsf√§higkeit bei Tag und Nacht. Da Katzen nicht nur tags√ºber aktiv sind, sondern auch in der Nacht, muss es m√∂glich sein, die Katze am Tag und in der Nacht zu erkennen. Daf√ºr gibt es die folgenden drei M√∂glichkeiten. Die erste M√∂glichkeit hierf√ºr ist die Verwendung einer normalen visuellen Kamera. Diese kann tags√ºber die Katze aufzeichnen. Nachts ist die Katze jedoch auf dem Bild bzw. Video, ohne weitere Hilfe, nicht zu sehen. Ein externes Licht ist notwendig, damit die Katze auf dem Bild zu sehen ist. Da eine Katze sich durch ein pl√∂tzlich selbst einschaltendes helles Licht erschrecken k√∂nnte und davon rennt, ist diese L√∂sung nicht optimal. Die zweite M√∂glichkeit ist die Verwendung einer W√§rmebildkamera. Mithilfe dieser kann tags√ºber sowie nachts die Katze ohne weitere Hilfe aufgenommen werden und ist auf dem Bild zu sehen. Der Nachteil dabei ist, dass der Besitzer nicht genau erkennen kann, ob es sich dabei um seine Katze handelt oder um eine Andere, da nur die Umrisse und Farbtemperaturen zu sehen sind. Die dritte M√∂glichkeit ist eine Nachtsichtkamera. Der Vorteil der Nachtsichtkamera ist, dass am Tag und in der Nacht die Katze ohne weitere Hilfsmittel aufgezeichnet werden kann und auf dem Bild zu sehen ist. So kann der Besitzer √ºber den ganzen Tag verteilt die Katze gut auf dem Bild erkennen und sehen, ob es sich dabei um seine Katze handelt. Aus diesem Grund wird eine Nachtsichtkamera f√ºr diese Arbeit gew√§hlt.;0
Ein wichtiges Konzept der Objektorientierung ist das Single -Responsibility -Prinzip,  das ein Teil des  von Robert C. Martin gepr√§gten Begriffs der SOLID Prinzipien ist.  Es wird  folgenderma√üen  beschrieben:  ‚ÄûA class should have only one reason to change ‚Äú  . Die Verantwortlichkeit  einer Klasse wird dadurch definiert, welchen Grund es gibt √Ñnderungen an ihr vorzunehmen. Eine  Klasse sollte innerhalb eines Systems also nur eine zu erf√ºllende Aufgabe  haben.    Ebenfalls im Akronym SOLID enthalten, ist das Open -Closed -Prinzip, das von Bertrand Meyer  eingef√ºhrt wurde. Es besagt, dass eine Klasse offen f√º r Erweiterungen und zugleich geschlossen  gegen√ºber Ver√§nderung sein soll. Das bedeutet, dass andere Module sich auf die Stabilit√§t der  Klassenbeschreibung, also das Interface der Klasse, verlassen k√∂nnen. Dadurch sind verl√§ssliche  Beziehungen und Abh√§ngigkeiten zwischen verschiedenen Modulen m√∂glich, ohne dass √Ñnderungen  an einer Klasse Auswirkungen auf das gesamte System haben. Gleichzeitig muss gew√§hrleistet sein,  dass ein Modul nachtr√§glich erweitert werden kann, um auftretenden Anforderungen gerecht zu  werden.    Die Geschlossenheit einer Klasse und somit die Verl√§sslichkeit gegen√ºber anderen Modulen ist eng  mit einem weiteren Prinzip in der Objektorientierung verbunden. Die Datenkapselung (Information  Hiding) sorgt daf√ºr, dass in einer Klasse nur ausgew√§hlte Attribute und Methoden √∂ffentlich  zug√§nglich sind und die inneren Abl√§ufe Au√üenstehenden verborgen bleiben . Es werden nur  Informationen als ‚Äûpublic‚Äú deklariert, auf die von au√üen zugegriffen werden muss. Diese dienen als  Beschreibung der Schnittstelle, w√§hrend die restlichen Attribute und Methoden vor externem Zugriff  gesch√ºtzt sind. Dadurch wird ein stabiles Interface bereitgestellt, √ºber das von anderen Modulen auf  die Klasse zugegriffen werden kann.    Ein weiteres Konzept, dass von Robert C. Martin eingef√ºhrt wurde und zu den SOLID Prinzipien  geh√∂rt, ist das Interface -Segregation -Prinzip.  Es besagt, dass es keine gro√üen Schnittstellen geben  sollte. Dies w√ºrde bedeuten, dass Klassen, die das Interface implementieren, Methoden  bereitstellen, die sie nicht ben√∂tigen. Aus diesem Grund ist es gegebenenfalls ratsamer umfangreiche  Schnittstellen  in mehrere kleinere Interfaces  aufzuteilen.     Auch das Dependency -Inversion-Prinzip, das ebenfalls durch Robert C. Martin Bekanntheit erlangte ,  ist Teil der SOLID Prinzipien . Grunds√§tzlich geht es dabei um die Abh√§ngigkeiten zwischen Modulen,  deren Verwendung durch zwei Grundregeln beschrieben wird .;0
Evaluierung des Trackings der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN)  Die √úberwachung der Bodenfeuchtigkeit stellt einen entscheidenden Aspekt in der modernen Landwirtschaft und Umweltforschung dar. Angesichts der zunehmenden Herausforderungen durch Klimawandel und Ressourcenknappheit gewinnt die pr√§zise Erfassung von Bodenfeuchtedaten an Bedeutung. In diesem Kontext bietet die Kombination von LoRaWAN (Long Range Wide Area Network) und dem The Things Network (TTN) eine innovative L√∂sung zur effizienten und kosteng√ºnstigen √úberwachung von Bodenfeuchtigkeit.  LoRaWAN ist ein Low-Power-Wide-Area-Netzwerkprotokoll, das f√ºr die drahtlose Kommunikation √ºber gro√üe Entfernungen bei minimalem Energieverbrauch konzipiert wurde. Diese Eigenschaften machen LoRaWAN ideal f√ºr den Einsatz in landwirtschaftlichen Anwendungen, wo Sensoren oft an abgelegenen Orten installiert werden und eine lange Batterielebensdauer erforderlich ist. Die Integration von LoRaWAN mit TTN, einer offenen und kostenlosen Netzwerk-Infrastruktur, erm√∂glicht es, Daten in Echtzeit zu sammeln und zu analysieren, was die Entscheidungsfindung in der Landwirtschaft erheblich verbessert.  Die Implementierung von Bodenfeuchtesensoren, die √ºber LoRaWAN kommunizieren, bietet zahlreiche Vorteile. Zun√§chst erm√∂glicht die gro√üe Reichweite des Netzwerks die √úberwachung weitl√§ufiger landwirtschaftlicher Fl√§chen, ohne dass eine kostspielige Verkabelung erforderlich ist. Dar√ºber hinaus sind die Sensoren in der Regel robust und wetterfest, was ihre Zuverl√§ssigkeit in unterschiedlichen Umgebungen gew√§hrleistet. Die gesammelten Daten k√∂nnen in einer zentralen Datenbank gespeichert und √ºber eine benutzerfreundliche Schnittstelle abgerufen werden, wodurch Landwirte in der Lage sind, pr√§zise Bew√§sserungsstrategien zu entwickeln und somit Wasserressourcen effizienter zu nutzen.  Ein weiterer Vorteil der Nutzung von TTN ist die Community-basierte Unterst√ºtzung und die M√∂glichkeit zur Datenvisualisierung. Die offene Plattform f√∂rdert den Austausch von Daten und Erfahrungen zwischen Nutzern, was zu einer kontinuierlichen Verbesserung der Technologien und Methoden f√ºhrt. Dar√ºber hinaus erm√∂glicht die Integration von Datenanalyse-Tools eine tiefere Einsicht in die Bodenfeuchtedynamik, wodurch Landwirte nicht nur reaktive, sondern auch proaktive Entscheidungen treffen k√∂nnen.  Trotz der vielen Vorteile gibt es auch Herausforderungen, die bei der Implementierung dieser Technologie ber√ºcksichtigt werden m√ºssen. Die Abdeckung durch das LoRaWAN-Netzwerk kann in l√§ndlichen Gebieten variieren, was zu unzureichender Daten√ºbertragung f√ºhren kann. Zudem erfordert die Installation und Wartung der Sensoren technisches Know-how, das nicht immer in der landwirtschaftlichen Praxis vorhanden ist. Auch die Kalibrierung und regelm√§√üige Wartung der Sensoren sind entscheidend, um zuverl√§ssige Daten zu gew√§hrleisten.  Insgesamt bietet das Tracking der Bodenfeuchtigkeit mit LoRaWAN und TTN ein vielversprechendes Werkzeug f√ºr die moderne Landwirtschaft. Die M√∂glichkeit, pr√§zise und zeitnahe Informationen √ºber den Feuchtigkeitsgehalt des Bodens zu erhalten, kann nicht nur die Effizienz der Bew√§sserungssysteme verbessern, sondern auch zur nachhaltigen Nutzung von Wasserressourcen beitragen. Die Kombination aus innovativer Technologie und offener Infrastruktur er√∂ffnet neue Perspektiven f√ºr die Landwirtschaft und Umwelt;1
Konzept f√ºr eine wissenschaftliche Arbeit: Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Einleitung  Die zunehmende Vernetzung von Alltagsgegenst√§nden im Rahmen des Internet der Dinge (IoT) er√∂ffnet neue M√∂glichkeiten zur Automatisierung und Verbesserung des Lebensalltags. Insbesondere im Bereich der Haustierhaltung gibt es Potenzial f√ºr innovative L√∂sungen, die sowohl den Bed√ºrfnissen der Tiere als auch den W√ºnschen ihrer Besitzer gerecht werden. Diese Arbeit widmet sich der Entwicklung eines IoT-Systems zur intelligenten Steuerung einer Katzenklappe, das auf einer KI-gest√ºtzten Katzenerkennung basiert. Ziel ist es, ein System zu schaffen, das es Katzen erm√∂glicht, selbstst√§ndig und sicher Zugang zu ihrem Lebensraum zu erhalten, w√§hrend gleichzeitig ungebetene G√§ste ferngehalten werden.  Problemstellung  Traditionelle Katzenklappen bieten oft keine ausreichende Sicherheit, da sie es auch fremden Tieren erm√∂glichen, das Zuhause zu betreten. Dies kann zu Konflikten zwischen Tieren f√ºhren und potenziell gesundheitliche Risiken f√ºr die Katze und die Besitzer mit sich bringen. Eine intelligente L√∂sung, die auf einer pr√§zisen Katzenerkennung basiert, k√∂nnte diese Probleme adressieren und gleichzeitig den Komfort f√ºr die Katzenbesitzer erh√∂hen.  Zielsetzung  Das Hauptziel dieser Arbeit ist die Entwicklung eines funktionsf√§higen Prototyps eines IoT-Systems, das die folgenden Anforderungen erf√ºllt: 1. Katzenerkennung: Implementierung eines KI-Modells zur zuverl√§ssigen Identifikation von Katzen anhand von Bilddaten. 2. Steuerung der Katzenklappe: Entwicklung eines Mechanismus, der die Katzenklappe basierend auf den Erkennungsdaten √∂ffnet oder schlie√üt. 3. Benutzeroberfl√§che: Gestaltung einer benutzerfreundlichen App oder Webanwendung, √ºber die Besitzer die Steuerung und √úberwachung des Systems vornehmen k√∂nnen. 4. Sicherheit und Datenschutz: Gew√§hrleistung des Schutzes der gesammelten Daten und der Privatsph√§re der Nutzer.  Methodik  Die Methodik zur Erreichung der Zielsetzung umfasst mehrere Schritte:  1. Literaturrecherche: Untersuchung bestehender Technologien und Systeme zur Katzenerkennung und deren Integration in IoT-Anwendungen. 2. Datenakquise: Sammlung von Bilddaten von Katzen, um ein robustes Datenset f√ºr das Training des KI-Modells zu erstellen. 3. Modellentwicklung: Auswahl und Anpassung eines geeigneten maschinellen Lernmodells (z. B. Convolutional Neural Networks) zur Katzenerkennung. 4. Hardware-Integration: Auswahl geeigneter Hardwarekomponenten (z. B. Mikrocontroller, Sensoren, Aktuatoren) zur Implementierung der Katzenklappe. 5. Softwareentwicklung: Programmierung der Benutzeroberfl√§che sowie der Backend-Logik zur Verarbeitung der Erkennungsdaten und Steuerung der Klappe. 6. Tests und Validierung: Durchf√ºhrung von Tests zur √úberpr√ºfung der Funktionalit√§t und Zuverl√§ssigkeit des Systems in realen Anwendungsszenarien.  Erwartete Ergebnisse  Es wird erwartet, dass das entwickelte IoT-System eine zuverl√§ssige Katzenerkennung erm√∂glicht und die Katzenklappe sicher und effizient steuert.;1
Bereits im Zuge der Definition geeigneter Merkmale, die den Begriff Softwarequalit√§t beschreiben  und konkretisieren sollten , r√ºckte die Messbarkeit dieser Faktoren in den Vordergrund.  Daf√ºr  wurden im Laufe der Zeit verschiedene Qualit√§tsmodelle eingef√ºhrt.  Allen voran McCall et al. hielten  sich an den von ihnen aufgestellten FCM -Ansatz und definierten neben Faktoren und Kriterien auch  Metriken, um die Messbarkeit zu gew√§hrleisten. Damit waren sie zwar Vorreiter bei der Verwendung  von Metriken, standen allerdings vor dem Problem, dass die Metriken noch nicht ausreichend  validiert waren.    Mittlerweile gibt es zahlreiche Forschungen und Studien √ºber den Einsatz verschiedener  Metriken im  Bereich der Softwaremessung. Dadurch werden Metriken zu einem zentralen  Baustein bei der  Messung von Softwarequalit√§t und werden im folgenden Kapitel genauer beleuchtet.   ‚ÄúYou cannot control what you cannot me asure.‚Äù  ‚Äì Tom DeMarco   Bei Software handelt sich um ein abstraktes und meist umfangreiches Produkt. Um objektive  Aussagen √ºber Softwarequalit√§t treffen zu k√∂nnen, wird eine Quantifizierung durch Metriken  vorgenommen. Durch die Einf√ºhrung von Software ma√üen k√∂nnen unterschiedlichste Aspekte von  Software systematisch und quantitativ erfasst werden.  Neben der Bestimmung von Qualit√§t und  Komplexit√§t wird durch Metriken au√üerdem eine Vergleichbarkeit verschiedener Produkte  erm√∂glicht, was die Aussagekraft der durchgef√ºhrten Messungen steigert. Besonders Quellcode  eignet sich als Gegenstand f√ºr eine Messung, da er von allen vorliegenden Artefakten den h√∂chsten  Grad an Formalismus aufweist. Aus diesem Grund eignet sich der Einsatz von Metriken f√ºr die  Beurteilung von  Code qualit√§t. Interne Qualit√§tsattribute k√∂nnen  √ºberwacht und √úberarbeitungen an  den richtigen Stellen eingeleitet werden.  Vor allem in gro√üen Softwareprojekten , in denen Umfang  und Komplexit√§t stetig ansteigen,  tr√§gt die Kontrolle durch produktorientierte Metriken zur  Aufrechterhaltung und Optimierung der Qualit√§t des Programmcodes bei. Entsprechend gut  erforscht ist die Thematik der Softwaremetriken. √úber 200 Metriken wurden allein f√ºr die Messung  von Quellcode entwickelt und es kommen immer weitere hinzu. Ein entscheidender Punkt ist daher  die Auswahl geeigneter Metriken, um die vorliegenden Anforderungen zu erf√ºllen. Da einzelne  Metriken nur einen kleinen Bereich quantifizieren k√∂nne, ist die Auswertung verschiedener Ma√üe  n√∂tig, um Aussagen  √ºber  das gesamte Softwareprodukt treffen zu k√∂nnen.    Im Folgenden soll eine √úbersicht der relevanten Eigenschaften von Metriken und deren Auswahl  gegeben werden, um im Laufe der Arbeit fundierte Entscheidungen bez√ºglich der zu betrachtenden  Metriken treffen zu k√∂nnen.;0
Zero ‚Äì M√∂glichkeiten und Gefahren der digitalen √úberwachungEine kritische Betrachtung der   In der heutigen digitalen √Ñra, in der Informationen in Echtzeit verarbeitet und analysiert werden, ist die √úberwachung von Individuen und Gruppen zu einem zentralen Thema der gesellschaftlichen und politischen Debatte geworden. Die Digitalisierung hat nicht nur das Potenzial, Effizienz und Sicherheit zu steigern, sondern auch die Risiken der √úberwachung und des Datenschutzes erheblich zu erh√∂hen. In diesem Kontext wird das Konzept ‚ÄûZero‚Äú als Ansatz zur  zur digitalen √úberwachung diskutiert. Ziel dieses Textes ist es, die M√∂glichkeiten und Gefahren einer solchen Implementierung zu beleuchten.   M√∂glichkeiten der digitalen √úberwachung  Die  zur digitalen √úberwachung kann verschiedene Vorteile mit sich bringen. Zun√§chst erm√∂glicht sie eine gezielte und effektive Datenerfassung, die zur Verbesserung von Sicherheitsma√ünahmen beitragen kann. In Bereichen wie der Kriminalit√§tsbek√§mpfung oder der Terrorismuspr√§vention k√∂nnen durch die Analyse von Verhaltensmustern und Kommunikationsdaten potenzielle Bedrohungen fr√ºhzeitig identifiziert werden. Ein Beispiel hierf√ºr ist der Einsatz von Algorithmen zur Mustererkennung, die es erm√∂glichen, Anomalien im Nutzerverhalten zu erkennen und darauf basierend pr√§ventive Ma√ünahmen zu ergreifen.  Ein weiterer Vorteil ist die M√∂glichkeit der Datenhoheit. Durch die Entwicklung einer eigenen L√∂sung k√∂nnen Organisationen und Staaten die Kontrolle √ºber die gesammelten Daten behalten und deren Nutzung transparent gestalten. Dies k√∂nnte das Vertrauen der B√ºrger in die Institutionen st√§rken, vorausgesetzt, dass klare Richtlinien und ethische Standards f√ºr den Umgang mit den Daten festgelegt werden. Die  bietet somit die Chance, datenschutzfreundliche Ans√§tze zu entwickeln, die die Privatsph√§re der Nutzer respektieren.   Gefahren der digitalen √úberwachung  Trotz der genannten M√∂glichkeiten birgt die digitale √úberwachung erhebliche Gefahren. Eine der gr√∂√üten Herausforderungen ist die Gefahr des Missbrauchs. Selbst mit den besten Absichten kann eine L√∂sung zur digitalen √úberwachung in die falschen H√§nde geraten oder f√ºr Zwecke verwendet werden, die nicht im Einklang mit den urspr√ºnglichen Zielen stehen. Die Geschichte hat gezeigt, dass √úberwachungstechnologien h√§ufig zur Kontrolle und Unterdr√ºckung von dissentierenden Stimmen eingesetzt werden, anstatt der Sicherheit der B√ºrger zu dienen.  Ein weiteres Risiko ist die Schaffung einer √úberwachungsgesellschaft, in der das individuelle Verhalten st√§ndig beobachtet und bewertet wird. Diese permanente √úberwachung kann zu einem Klima der Angst f√ºhren, in dem Menschen sich in ihrem Verhalten eingeschr√§nkt f√ºhlen und ihre Meinungsfreiheit beeintr√§chtigt wird. Die psychologischen Auswirkungen einer solchen Umgebung sind tiefgreifend und k√∂nnen zu einem Verlust von Vertrauen in soziale Institutionen f√ºhren.     Die  zur digitalen √úberwachung erfordert ein sorgf√§ltiges Abw√§gen zwischen den M√∂glichkeiten und Gefahren. Zun√§chst sollten klare ethische Richtlinien entwickelt werden, die den Rahmen f√ºr die Datenerfassung und -nutzung festlegen. Diese Richtlinien sollten sicherstellen, dass die Privatsph√§re der Nutzer gewahrt bleibt und dass die gesammelten Daten nicht f√ºr Zwecke verwendet werden, die √ºber die urspr√ºnglichen Sicherheitsziele hinausgehen.  Des Weiteren ist eine transparente Kommunikation mit der √ñffentlichkeit von entscheidender Bedeutung. Die B√ºrger sollten √ºber;1
Kotlin erlaubt das Verwenden von sealed class inheritance , weshalb es m√∂glich ist, ein solches Interface f√ºr jede Seite zu erzeugen . Jede Seite bekommt somit ihre eigene SpeziÔ¨Åkation. Diese wird innerhalb einer Liste im Interface vermerkt und kann vom NavHost zur Anzeige des richtigen Inhaltes verwendet werden . Damit hat sich der Vorgang bereits erheblich vereinfacht, jedoch sind die Redundanzen und der Boilerplate-Code weiterhin vorhanden. Da dieses Vorgehen aber festgelegten Patterns folgt, hat Rafael Costa dieses Verfahren automatisiert und als Bibliothek mit dem Namen Compose Destinations ver√∂Ô¨Äentlicht. Hierbei handelt es sich um eine Prozessorbibliothek, die diesen Boilerplate-Code generieren kann . Die Interaktion mit dieser Bibliothek erfolgt nach Einbinden der entsprechenden Dependencies √ºber die Annotation @Destination, wie folgendes Listing 3.2 veranschaulicht. DieseAnnotationteiltdemCodegenerierungstaskmit,dasserdasnachfolgendeComposable mit in den NavGraph aufnehmen soll. Durch das zus√§tzliche Setzen des Flags startauf den Werttruekann die Startdestination festgelegt werden. Der NavGraph wird beim Bauen des Projektes automatisch erzeugt und ist in der folgenden Abbildung 3.5 dargestellt.;0
 Kapitel 2: Technische Grundlagen  Die Entwicklung von Internet-of-Things (IoT)-Anwendungen erfordert eine robuste und flexible Plattform, die sowohl Hardware- als auch Softwarekomponenten effizient integriert. In diesem Kapitel werden die technischen Grundlagen von ElixirNerves als Plattform f√ºr IoT-Anwendungen untersucht. Dabei wird auf die zugrunde liegende Programmiersprache Elixir, das Nerves-Framework sowie die Architektur und die Kommunikationsprotokolle eingegangen, die f√ºr die Entwicklung und den Betrieb von IoT-Ger√§ten entscheidend sind.   2.1 Elixir: Eine funktionale Programmiersprache  Elixir ist eine funktionale Programmiersprache, die auf der Erlang Virtual Machine (BEAM) basiert. Sie wurde entwickelt, um die Anforderungen an moderne Softwareentwicklung zu erf√ºllen, insbesondere in Bezug auf Skalierbarkeit, Fehlertoleranz und Wartbarkeit. Elixir bietet eine klare Syntax und unterst√ºtzt Funktionen als erstklassige B√ºrger, was die Entwicklung komplexer Systeme erleichtert. Die Kombination aus funktionalen Paradigmen und der Robustheit von Erlang macht Elixir zu einer idealen Wahl f√ºr die Entwicklung von IoT-Anwendungen, die h√§ufig in verteilten und ressourcenbeschr√§nkten Umgebungen betrieben werden.   2.2 Nerves-Framework  Das Nerves-Framework ist eine speziell f√ºr die Entwicklung von IoT-Anwendungen mit Elixir konzipierte Plattform. Es erm√∂glicht Entwicklern, Software f√ºr Embedded-Systeme zu erstellen und bietet eine Vielzahl von Tools und Bibliotheken, die den Entwicklungsprozess vereinfachen. Zu den wichtigsten Merkmalen von Nerves geh√∂ren:  - Einfache Hardware-Abstraktion: Nerves bietet eine abstrahierte Schnittstelle zu verschiedenen Hardwarekomponenten, wodurch die Entwicklung von Treibern und die Interaktion mit Sensoren und Aktoren erleichtert wird. - Hot Code Reloading: Eine der herausragenden Eigenschaften von Elixir ist die M√∂glichkeit des Hot Code Reloading, die es Entwicklern erm√∂glicht, √Ñnderungen am Code vorzunehmen, ohne das gesamte System neu starten zu m√ºssen. Dies ist besonders n√ºtzlich in IoT-Umgebungen, wo Ausfallzeiten minimiert werden m√ºssen. - √úberwachung und Fehlertoleranz: Nerves nutzt die √úberwachungs- und Fehlerbehandlungsmechanismen von Erlang, um sicherzustellen, dass IoT-Anwendungen stabil und zuverl√§ssig laufen. Dies ist besonders wichtig in sicherheitskritischen Anwendungen, in denen ein Ausfall schwerwiegende Folgen haben kann.   2.3 Architektur von ElixirNerves  Die Architektur von ElixirNerves ist modular und anpassbar. Sie besteht aus mehreren Schichten, die eine klare Trennung von Hardware, Software und Kommunikation erm√∂glichen. Die Hauptkomponenten sind:  1. Hardware-Abstraktionsschicht (HAL): Diese Schicht erm√∂glicht den Zugriff auf verschiedene Hardwarekomponenten wie GPIOs, I2C, SPI und UART. Entwickler k√∂nnen spezifische Treiber f√ºr ihre Hardware erstellen oder vorhandene Treiber nutzen, um die Interaktion mit Sensoren und Aktoren zu erm√∂glichen.  2. Anwendungslogik: In dieser Schicht wird die Gesch√§ftslogik der IoT-Anwendung implementiert. Die Anwendungslogik kann mithilfe von Elixirs funktionalen Paradigmen entwickelt werden, um;1
Anforderungsanalyse an ein Aufgaben-Management-Tool zur Unterst√ºtzung des studentischen Software Engineerings  In der modernen Hochschulbildung wird Software Engineering immer h√§ufiger zu einem integralen Bestandteil des Curriculums. Die zunehmende Komplexit√§t der Entwicklungsprojekte und die Bedeutung von Teamarbeit erfordern jedoch robustere Ans√§tze zur Organisation von Aufgaben, zur Kommunikation innerhalb der Teams und zur √úberwachung des Arbeitsfortschritts. In diesem Kontext gewinnt die Entwicklung eines Aufgaben-Management-Tools(AMT), speziell zugeschnitten auf die Bed√ºrfnisse von Studierenden delphing machines, an Bedeutung. Dieser Text befasst sich mit der Anforderungsanalyse und der Erstellung eines Konzepts f√ºr ein solches Tool, das nicht nur funktionale Anspr√ºche abdeckt, sondern auch den sozialen und pers√∂nlichen Anforderungen der Nutzer gerecht wird.  1.   Die rasante Entwicklung in der Softwaretechnik steht im direkten Zusammenhang mit erm√∂glichenden Technologien und Methoden f√ºr die effiziente Zusammenarbeit und Verwaltung komplexer Projekte. In einer akademischen Umgebung spielen echter Nutzungserfahrungen eine entscheidende Rolle, sodass die Tools intuitiv und ansprechend gestaltet sein m√ºssen. Ziel dieses Papiers ist es, die ben√∂tigten Funktionen eines AMT f√ºr Software-Engineering-Studierende systematisch zu identifizieren und ein Umsetzungskonzept zu entwickeln.  2. Anforderungen  Die Analyse der Anforderungen erfolgt in verschiedenen Bereichen 2.1. Fachliche Anforderungen  Zentrale Funktionalit√§ten eines AMT sollten Aufgabenmanagement (Erstellen, Zuweisen, Verfolgen von Aufgaben), Zeitmanagement (Deadlines, Zeiterfassungen), Versionskontrolle (Dokumenten-, Codeversionsmanagement), sowie Nahtstelle zu bestehenden Tools (z. B. GitHub, Slack, Trello) umfassen. Der Schwerpunkt soll dabei auf einer effektiven Nachverfolgbarkeit und Dokumentation des Entwicklungsprozesses liegen.   2.2. Usability-Anforderungen  Ein benutzerfreundliches Interface ist essentiell, sodass Studierende mit unterschiedlichem technischen Hintergrund zu dem Tool Zugang finden. Das Design sollte responsiv gestaltet sein, um sowohl Desktop- als auch Mobilnutzern gerecht zu werden. Eindeutige Visualisierungen, wie Fortschrittstracker und Kanban-Boards, erh√∂hen die Benutzerakzeptanz und f√∂rdern das Arbeiten im Team. Weitere Aspekte wie Mehrsprachigkeit und Barrierefreiheit sind ebenfalls in dieser Phase zu ber√ºcksichtigen.  2.3. Soziale Anforderungen  Teamarbeit erfordert effektive Kommunikations- und Kooperationsmechanismen. Innerhalb des AMT sollten Funktionen zur Teamkoordination, wie Gruppen-Chat, gemeinsame Dokumente, undImpulse √ºber die Aufgabenatmosph√§re, integriert werden. Diese Elemente f√∂rdern nicht nur  das Wachstum technischen Wissens, sondern auch sozialen Zusammenhalt und Teambildung unter den Studierenden.  3. Konzept zur Umsetzung  Der erreichbare Realisierungsansatz richtet sich an iterative Entwicklungsmodelle, langfrist Dein Konzept durch agile Methoden wie Scrum zu fructifizieren. In diesem pikierten Ansatz zyReadizier Die Schritte sind w√∂chentliche Sprints, wobei jedes Teammitglied basierend auf Begeisterungszulagen Aktivit√§ten √ºbernehmen kann. Dabei werden in einzigartigen Feedback-Zyklen nach jeder Iteration Ergebnisse pr√§sentiert und Diskurse zur Optimierung angesto√üen. Sicherheitsma√ünahmen zur Gew√§hrleistungen sensible Informationen flie√üt mit;1
  der Programmiersprachen  Die Entwicklung moderner Softwareanwendungen erfordert programmiertechnische Ans√§tze, die sowohl Effizienz als auch Flexibilit√§t bieten. Innerhalb des √ñkosystems der objektorientierten Programmiersprachen nehmen Java und Kotlin eine zentrale Rolle ein. Beide Sprachen wurden f√ºr die Entwicklung von Anwendungen auf der Java Virtual Machine (JVM) konzipiert, unterscheiden sich jedoch in ihren theoretischen Grundlagen, Syntaxelementen und konzeptionellen Prinzipien.   Historische und theoretische Einbettung   Java, das 1995 von Sun Microsystems ver√∂ffentlicht wurde, war von Anfang an darauf ausgerichtet, plattformunabh√§ngige Software zu erm√∂glichen. Die Sprache folgt dem grundliegenden Paradigma der objektorientierten Programmierung (OOP), welches auf den Konzepten der Kapselung, Vererbung und Polymorphie basiert. In der umfassenden Theorie von objektorientierten Systemen manifestieren sich diese Prinzipien in der Gestaltung von Klassen und Objekten, was zu klar strukturiertem und wiederverwendbarem Code f√ºhrt.  Kotlin hingegen wurde 2011 von JetBrains vorgestellt und positionierte sich als moderne Alternative zu Java. Sie integriert nicht nur die Prinzipien der OOP, sondern auch funktionale Programmierans√§tze. Theoretisch wird Kotlin von bew√§hrten Konzepten aus der Programmiersprachenforschung sowie von funktionalen Paradigmen wie Higher-Order-Functions und Lambdas begleitet. Eine der zentralen theoretischen Pr√§missen von Kotlin ist die Verbesserung der Ausdruckskraft und Lesbarkeit des Codes.   Typensystem und Null-Sicherheitskonzept  Ein zunehmend wichtiges Merkmal bei der Programmierung ist die Bew√§ltigung von Fehlerpr√§vention, insbesondere im Hinblick auf null-Zeiger-Dereferenzierung, die eine h√§ufige Fehlerquelle in Java ist. Kotlin implementiert imrahmen seines Typensystems die Konzeptualisierung von 'null-sicheren' Typen, was bedeutet, dass der Compiler von Anfang an sicherstellt, dass Objekte niemals pl√∂tzlich nicht zugewiesen sein k√∂nnen. In der theoretischen Modellierung betrachtet man so ein strikteres Typsystem als epistemologische Verbesserung, da es das Verst√§ndnis des Programmflusses erh√∂ht und Programmfehler signifikant vermindert.   Syntax und Ausdrucksst√§rke  Im Vergleich zur Syntax von Java zeigt sich, dass Kotlin eine verbindlichere Syntax hat, die sowohl wahrnehmbar pr√§gnanter als auch intuitiver f√ºr Entwickler zu klingen ist. Theoretisch betrachtet erm√∂glichen sauberere Syntaxstrukturen, dass komplexe Abl√§ufe in klar verst√§ndlichen und kurzen Anweisungen ausgedr√ºckt werden. Diese Anspr√ºche flie√üen in zahlreiche Sprachfeatures ein, etwa Extension Functions und Kotlin Coroutines, die die Implementierung asynchroner Programme erleichtern und nehmen ihrerseits Bezug auf entsprechend formal umrandete Konzepte der Software-Engingeering-Theorie, die Modularit√§t und Prozessintegration fordern.   Interoperabilit√§t und √úbergangsmechanismus  Ein signifikantes theoretisches Ziel, das f√ºr Kotlin etabliert wurde, ist die vollst√§ndige Interoperabilit√§t mit existierendem Java-Code oder -Bibliotheken. Dies zeigt, wie emotionale und technische Aspekte (z. B Automatisierung des Migrationsprozesses) zusammen;1
" Kapitel 3: Funktionsweise des deklarativen Ansatzes in der Anforderungsanalyse  In der heutigen dynamischen und komplexen Softwareentwicklungslandschaft sind effektive Anforderungsanalysen von entscheidender Bedeutung, insbesondere im Kontext des studentischen Software Engineerings. Der deklarative Ansatz hat sich als ein vielversprechendes Werkzeug zur Verbesserung der Anforderungsanalyse herauskristallisiert. Dieses Kapitel beleuchtet die Funktionsweise des deklarativen Ansatzes und dessen Anwendung im Rahmen der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool, das speziell auf die Bed√ºrfnisse von Studierenden im Software Engineering ausgerichtet ist.   3.1 Definition des deklarativen Ansatzes  Der deklarative Ansatz unterscheidet sich grundlegend von prozeduralen Ans√§tzen, indem er den Fokus nicht auf die Beschreibung von Prozessen oder Abl√§ufen legt, sondern auf die Festlegung von Zielen und Bedingungen, die erf√ºllt werden m√ºssen. In der Softwareentwicklung bedeutet dies, dass die Anforderungen nicht als Schritt-f√ºr-Schritt-Anleitungen formuliert werden, sondern als eine Sammlung von Eigenschaften und Ergebnissen, die das Endprodukt erf√ºllen sollte. Diese Herangehensweise f√∂rdert ein h√∂heres Ma√ü an Flexibilit√§t und Anpassungsf√§higkeit, da sie es den Entwicklern erm√∂glicht, sich auf die ""Was""-Fragen zu konzentrieren, anstatt sich in den ""Wie""-Fragen zu verlieren.   3.2 Anwendung des deklarativen Ansatzes in der Anforderungsanalyse  Im Kontext eines Aufgabenmanagement-Tools f√ºr das studentische Software Engineering umfasst die Anwendung des deklarativen Ansatzes mehrere Schritte:  1. Identifikation der Stakeholder: Der erste Schritt besteht darin, die relevanten Stakeholder zu identifizieren, die Einfluss auf das Projekt haben oder von dessen Ergebnissen betroffen sind. Dazu geh√∂ren Studierende, Dozenten, Projektleiter und eventuell auch externe Partner. Die Bed√ºrfnisse und Erwartungen dieser Gruppen bilden die Grundlage f√ºr die weiteren Analysen.  2. Erhebung der Anforderungen: In diesem Schritt werden die Anforderungen in Form von deklarativen Aussagen erfasst. Dies geschieht h√§ufig durch Interviews, Workshops oder Umfragen, in denen die Stakeholder gebeten werden, ihre Ziele und W√ºnsche zu √§u√üern. Anstatt spezifische Funktionen oder Abl√§ufe zu beschreiben, formulieren die Stakeholder ihre Bed√ºrfnisse in Form von Zielen, wie etwa: ""Das Tool sollte es den Studierenden erm√∂glichen, ihre Aufgaben effizient zu organisieren"" oder ""Das System muss eine klare √úbersicht √ºber alle laufenden Projekte bieten"".  3. Kategorisierung der Anforderungen: Die gesammelten Anforderungen werden anschlie√üend kategorisiert, um ihre Relevanz und Priorit√§t zu bestimmen. Dies kann durch die Anwendung von Methoden wie MoSCoW (Must have, Should have, Could have, Won't have) erfolgen, die es erm√∂glicht, die Anforderungen nach Dringlichkeit und Wichtigkeit zu ordnen. Der deklarative Ansatz unterst√ºtzt diese Kategorisierung, indem er eine klare Trennung zwischen notwendigen und w√ºnschenswerten Anforderungen f√∂rdert.  4. Validierung der Anforderungen: Um sicherzustellen, dass die erfassten Anforderungen tats√§chlich die Bed√ºrfnisse der Stakeholder widerspiegeln, ist eine Validierung notwendig. Dies kann durch Feedbackrunden oder Prototyping geschehen, wobei die Stakeholder die M√∂glichkeit erhalten, ihre Anforderungen zu √ºberpr√ºfen und gegebenenfalls anzupassen.";1
"Um ein hohe Qualit√§t des Funksignals, also dem LinkBudget, zu erzeugen, sollten Gateways
an hochgelegenen Orten abgebracht werden und idealerweise sollte es m√∂glich sein eine
direkte Sichtverbindung zwischen Node und Gateway herzustellen. Um die Reichweite eines
solchen Gateways zu ermitteln gibt es drei unterschiedliche Arten der Herangehensweise:
‚Ä¢Abdeckungstest
‚Ä¢Nutzerbasierte Reichweitentest
‚Ä¢Ger√§tebasierte Verbindungstest
Durch die Verwendung von kostenloser Open-Source-Software kann bei einem Abde-
ckungstest eine graÔ¨Åsch aufbereitete Simulation eines LoRaWAN-Netzes erzeugt werden.
Beispielsweise ist ‚ÄûRadio Mobile Online - Online RF propagation simulation software‚Äú eine
dieser Software mit der, wie in Abbildung 3.18 gezeigt, die Abdeckung auf einer Karte
simuliert werden kann.  Mit der √úbergabe der entsprechenden Daten wie Funk-
frequenz, H√∂he und Position des Gateways kann mit Hilfe von vorhanden geographischen
Daten der Umgebung die Reichweite berechnet werden. Diese Simulation dient als erster
Ausgangspunkt, wie ein fl√§chendeckendes LoRa-Funknetz aufgebaut werden kann. 
Der nutzerbasierte Reichweitentest wird dazu verwendet, erste Erfahrungen und
Informationen √ºber die vorhandene Reichweite, Durchdringung der Funkfrequenz und
Nutzqualit√§t zu gewinnen. Dazu wird ein Feldtester und eine LoRa-Antenne, die mit
einem Server verbunden ist, verwendet. Unter diesen Reichweitentest kann man sich ein
Stichprobenverfahren innerhalb eines bestimmten Zeitfensters vorstellen, welches recht
einfach aufgebaut ist und schnell Ergebnisse liefert. Der Nachteil daran ist, dass durch
den begrenzten Zeitraum nur bedingt detaillierte Informationen gewonnen werden k√∂nnen.
Aus betriebswirtschaftlicher Sicht ist dieses Vorgehen sehr attraktiv, da eine vollst√§ndige
Analyse und Planung eines fl√§chendeckenden Funknetzes sehr zeitintensiv und teuer werden
kann. Falls L√ºcken in der Abdeckung gefunden werden, wird eine Nachverdichten, also das
Hinzuf√ºgen von weiteren Gateways, durchgef√ºhrt.
Die ger√§tebasierten Tests dienen zur exakteren Untersuchung der Netzabdeckung. An
deÔ¨Ånierten Standorten wird innerhalb eines deÔ¨Ånierte Zeitraums getestet, wie gut die
Verbindungsqualit√§t zwischen einem Test-Node und den platzierten Gateway ist. Da diese
Daten auch von den aktuellen Witterungsbedingungen abh√§ngig sein k√∂nnen, sollten
diese Messungen unter verschiedenen Zust√§nden des Wetters und Jahreszeiten wiederholt
werden, um ein maximal genaues Messergebnis zu erreichen.
Wenn ein LoRa-Netzwerk beispielsweise in einer Stadt eingef√ºhrt werden soll, sollten
alle drei Herangehensweisen und Tests durchgef√ºhrt werden. Im ersten Schritt wird die
Abdeckung mit dem Abdeckungstest simuliert. Danach wird, in Schritt zwei, ein Gateway
installiert und durch nutzerbasierte Reichweitentests versucht die Berechnung der
Simulation zu validieren. Wenn diese Reichweitentests erfolgreich sind und die Simulation
valide, werden die restlichen Gateways aufgestellt. Durch die ger√§tebasierten Tests
wird parallel versucht L√ºcken in der Abdeckung zu schlie√üen, um so die urspr√ºnglich
gew√ºnschten Use-Cases, f√ºr die das Funknetz aufgespannt wird, erfolgreich umzusetzen.";0
Da allerdings Situationen aufgetreten sind, in denen mehr oder weniger als genau drei Locators einen Beacon gefunden haben, sollte die Positionierung mit unterschiedlichen Anzahlen an Locators funktionieren. Des Weiteren traten vereinzelt fehlerhafte Positionen, au√üerhalb des Raumes auf, welche nicht reproduziert werden konnten. UmdieseProbleme zu l√∂sen,wurdedieAnwendunginPythonerstelltund eineandereOpen Source Implementierung eines Multilaterations-Algorithmus verwendet . In einem zuk√ºnftigen Entwicklungsschritt k√∂nnte diese Implementierung in JavaScript √ºbertragen werden, wodurch die Webanwendung (Abbildung 4.4) wieder mit dem neuen Algorithmus verwendet werden k√∂nnte.   In einem sp√§teren Entwicklungsschritt kam dann die Vermutung auf, dass das oben be- schriebene Problem mit den vereinzelten fehlerhaften Werten damit zusammenh√§ngt, dass anf√§nglich die negativen RSSIWerte direkt an den Multialterations-Algorithmus √ºbergeben wurden und nicht, wie in der Python Implementierung, erst in eine Distanz umgerechnet wurden. Aufgrund des geringen zeitlichen Rahmens wurde der Fokus allerdings auf die Implementierung mit Python gelegt und mit der Optimierung der Daten begonnen.;0
Beim Entwickeln einer Android App gibt es zwei Hauptkomponenten, die f√ºr eine Lauff√§- higkeit ben√∂tigt werden. Dabei handelt es sich um Activity- und XML-Dateien. DurchXMLDateien k√∂nnen die verschiedenen Layouts dargestellt werden, welche das User Interface (UI) der App steuern. In dem Listing 2.1 wird ein Beispiel einer XMLDatei gezeigt, welches ein Layout f√ºr eine App darstellt. Dabei wird ein LinearLayout mit der Orientierung vertical verwendet. Dieses besagt, dass die Elemente innerhalb dieses Layouts vertikal angeordnet werden . Somit wird die TextView oberhalb des Buttons dargestellt. Die Activities in einer App sind f√ºr die Steuerung der Layouts in den XMLDateien zust√§ndig. Jede Activity steuert dabei ein Layout. Von der Activity aus kann auf die Elemente dieses Layouts zugegriffen werden. Dadurch kann zum Beispiel der Text von der TextView ver√§ndert werden oder definiert werden, was bei einem Klick auf einen Button passiert. Um auf die einzelnen Elemente des Layouts zugreifen zu k√∂nnen ben√∂tigt jedes Element eine eindeutige Id. Ein Beispiel dazu ist die Id android:id=‚Äù@+id/text‚Äù von derTextView im Listing 2.1. Um ein Layout von einer XMLDatei in eine Activity zu laden gibt es den Befehl setContentView() . Dieser ben√∂tigt als Parameter eine Layout Datei. Um dies beim kompilieren der App zu verkn√ºpfen, muss dieser Befehl in der onCreate Methode in jeder Activity ausgef√ºhrt werden. Somit werden die Layouts beim Starten der App angezeigt.;0
Bei Nerves handelt es sich nach eigener Definition um eine Open-Source-Infrastruktur und -Plattform zur Entwicklung, Bereitstellung und sicheren Verwaltung von Software f√ºr eine Vielzahl von IOT-Ger√§ten. Elixirist eine funktionale Programmiersprache, die auf der Basis von Erlang f√ºr die Entwicklung von Embedded Software entwickelt wurde. Vorteile von Nerves/Elixir Die Nerves-Plattform bringt mehrere essentielle Vorteile mit sich. ‚Ä¢Raspberry Pi: Nerves Plattform st√ºtzt sich auf Hardware-Teile Raspberry Pi, die zum einen billig und zum anderen sehr verbreitet ist. Dar√ºber hinaus unterst√ºtzt der Raspberry Pi eine breite Palette von Sensoren. ‚Ä¢Skalierbarkeit : Nerves ist in Elixir geschrieben, unterst√ºtzt aber viele andere Sprachen wie C, C++, Python, Rust und mehr. ‚Ä¢Hohe Zuverl√§ssigkeit und Betriebszeit : Das Laufzeitsystem Erlang, das Nerves verwendet, ist bekannt f√ºr seine hohe Verteilung, Fehlertoleranz, weiche Echtzeit und hohe Verf√ºgbarkeit. ‚Ä¢Anpassungsf√§hig : Die Nerves-Plattform verf√ºgt √ºber zahlreiche Tools, die in jeder Phase der Entwicklung eingesetzt werden k√∂nnen, wie z.B. Nerves Project f√ºr die Erstellung und Anpassung und NervesHub f√ºr die Bereitstellung und Verwaltung von Projekten. Des Weiteren gilt Nerves als sicher und agil.;0
In einer zunehmend vernetzten Welt gewinnen das Internet der Dinge (IoT) und die damit verbundenen Technologien an Bedeutung. Insbesondere im Bildungssektor zeigt sich ein wachsender Bedarf an praktischen Lernumgebungen, die es Studierenden erm√∂glichen, komplexe technische Konzepte zu verstehen und anzuwenden. Diese Arbeit besch√§ftigt sich mit der Entwicklung eines virtuellen MQTT-Szenarios, das speziell f√ºr Lehrzwecke konzipiert ist, um die M√∂glichkeiten und Herausforderungen dieser Kommunikationsprotokolle im IoT-Kontext zu vermitteln.   MQTT (Message Queuing Telemetry Transport) ist ein leichtgewichtiges Protokoll, das sich ideal f√ºr IoT-Anwendungen eignet, da es eine effiziente Kommunikation zwischen Ger√§ten erm√∂glicht. Es spielt eine zentrale Rolle in der Daten√ºbertragung und -verarbeitung in vernetzten Systemen und wird zunehmend in verschiedenen Branchen eingesetzt. Angesichts der Relevanz von IoT-Technologien ist es unverzichtbar, dass Lernende mit diesen Protokollen vertraut gemacht werden.  Ein weiterer Fokus dieser Arbeit liegt auf der Evaluation von ElixirNerves, einer innovativen Plattform f√ºr die Entwicklung von IoT-Anwendungen, die sich durch ihre Flexibilit√§t und Leistungsf√§higkeit auszeichnet. ElixirNerves integriert die funktionale Programmierung von Elixir mit einem ganzheitlichen Ansatz zur Hardwareentwicklung und bietet somit eine vielversprechende Umgebung zur Erstellung und Implementierung von IoT-Projekten.  Ziel dieser wissenschaftlichen Arbeit ist es, die Vorteile und Herausforderungen der Nutzung von ElixirNerves in Verbindung mit einem virtuellen MQTT-Szenario zu analysieren und aufzuzeigen, inwiefern diese Kombination als Lehrmittel in der Ausbildung von Studierenden im Bereich IoT-Entwicklung dienen kann. Die Ergebnisse dieser Untersuchung sollen wesentliche Erkenntnisse f√ºr die Gestaltung zuk√ºnftiger Lehrpl√§ne und Schulungsprogramme im Bereich der IoT-Technologien liefern.;1
Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Technologisierung im Bereich der Automobilindustrie hat das Potenzial f√ºr innovative Ans√§tze zur Fernsteuerung von Fahrzeugen erheblich erweitert. Eine zentrale Herausforderung bei der Entwicklung solcher Systeme besteht in der Integration effektiver Sicherheitsmechanismen, insbesondere der Kollisionsvermeidung. Die Implementierung von Technologien, die auf dem IEEE 802.15 Standard basieren, er√∂ffnet vielversprechende Perspektiven f√ºr die Realisierung solcher Systeme. Dieser Prosatext gibt einen √úberblick √ºber die grundlegenden Prinzipien dieser Technologie und wagt einen Ausblick auf m√∂gliche zuk√ºnftige Entwicklungen.  Grundlagen der Fahrzeugfernsteuerung  Die Fahrzeugfernsteuerung mittels drahtloser Kommunikation hat das Ziel, die Steuerung von Fahrzeugen in unterschiedlichen Umgebungen zu erm√∂glichen, ohne dass sich der Operator physisch in der N√§he des Fahrzeugs befindet. IEEE 802.15 definiert Standards f√ºr Wireless Personal Area Networks (WPANs) und bietet somit eine geeignete Grundlage f√ºr die Daten√ºbertragung zwischen einem Steuerger√§t und einem Fahrzeug. Insbesondere sind die Protokolle IEEE 802.15.4, die f√ºr Low-Rate WPANs entwickelt wurden und sich durch niedrige Energieaufnahme und hohe Zuverl√§ssigkeit auszeichnen, von Interesse.  Die Einbindung von Kollisionsvermeidungsmechanismen ist von entscheidender Bedeutung. Diese Mechanismen k√∂nnen auf verschiedenen Ans√§tzen basieren, darunter Sensorfusion zur Erfassung und Verarbeitung von Umgebungsdaten sowie Algorithmen f√ºr maschinelles Lernen, die in der Lage sind, potenzielle Gefahren in Echtzeit zu identifizieren und zu bewerten. Die Kombination von Sensoren wie LiDAR, Radar und Kamerasystemen erm√∂glicht eine umfassende √úberwachung der Fahrzeugumgebung und tr√§gt dazu bei, Entscheidungen zur Vermeidung von Kollisionen zu treffen.  Ausblick auf Weiterentwicklungen  Die zuk√ºnftige Entwicklung von Fahrzeugfernsteuerungssystemen k√∂nnte durch mehrere Innovationslinien gepr√§gt sein. Erstens wird die Integration von fortschrittlichen k√ºnstlichen Intelligenztechnologien eine zentrale Rolle spielen. Algorithmen des maschinellen Lernens k√∂nnen dazu verwendet werden, das Verhalten anderer Verkehrsteilnehmer pr√§ziser vorherzusagen, wodurch die Entscheidungsfindung der Fernsteuerung signifikant verbessert wird. In diesem Kontext k√∂nnte auch die Entwicklung von selbstlernenden Systemen vorangetrieben werden, die durch die Analyse gro√üer Datenmengen aus realen Fahrten kontinuierlich optimiert werden.  Zweitens ist die Verbesserung der Kommunikationsprotokolle von gro√üer Bedeutung. Die k√ºnftige Entwicklung k√∂nnte neue Verbindungsstandards erfassen, wie beispielsweise IEEE 802.15.6, das speziell f√ºr die Kommunikation in K√∂rpernetzwerken entwickelt wurde, oder die Integration von 5G-Technologien, die eine niedrigere Latenz und h√∂here Bandbreite bieten und somit eine schnellere Reaktion auf kritische Situationen erm√∂glichen. Die nahtlose Kommunikation zwischen Fahrzeugen und der Infrastruktur (V2X-Kommunikation) k√∂nnte ebenfalls einen bedeutenden Fortschritt darstellen, der nicht nur die Sicherheit, sondern auch die Effizienz des Verkehrsmanagements erh√∂ht.  Drittens sind die Erhebung und Analyse von Daten √ºber das Fahrverhalten und die Umgebungsbedingungen von zentraler Bedeutung. Die Implementierung von Blockchain-Technologien zur Sicherstellung der Datenintegrit√§t k√∂nnte vertrauensw√ºrdige Datenstr√∂me f√ºr die Antrainierung von Algorithmen erm√∂glichen und gleichzeitig den Datenschutz der Nutzer gew√§hrleisten. Solche Entwicklungen k√∂nnten das Vertrauen in die Sicherheit von Fahrzeugfernsteuerungssystemen weiter verst√§rken.  Fazit  Zusammenfassend l√§sst sich festhalten, dass die Entwicklung von Fahrzeugfernsteuerungen mit Kollisionsvermeidung auf Basis des IEEE 802.15 Standards vielversprechende Fortschritte macht. Durch die Integration modernster Technologien wie K√ºnstliche Intelligenz, verbesserte Kommunikationsprotokolle und datenschutzkonforme Datenanalysen kann die Sicherheit und Zuverl√§ssigkeit von Fernsteuerungssystemen erheblich gesteigert werden. Der Ausblick auf diese zuk√ºnftigen Entwicklungen verspricht nicht nur einen bedeutenden Fortschritt in der Automobiltechnologie, sondern auch einen Paradigmenwechsel in der Art und Weise, wie Fahrzeuge im urbanen Raum gesteuert und betrieben werden k√∂nnen.;1
Vergleich von Progressive Web Apps und nativen Apps am Beispiel einer Journaling-AppEin Fazit  In der heutigen digitalen Landschaft stehen Entwickler und Unternehmen vor der Entscheidung, ob sie Progressive Web Apps (PWAs) oder native Apps entwickeln sollen. Diese Entscheidung hat weitreichende Auswirkungen auf die Benutzererfahrung, die Entwicklungsressourcen und die langfristige Wartbarkeit der Anwendungen. Im Rahmen dieses Projekts wurde eine Journaling-App als Fallstudie gew√§hlt, um die Vor- und Nachteile beider Ans√§tze zu analysieren und ein abschlie√üendes Fazit zu ziehen.  Progressive Web Apps sind webbasierte Anwendungen, die durch moderne Webtechnologien wie HTML, CSS und JavaScript entwickelt werden. Sie bieten die M√∂glichkeit, eine App-√§hnliche Erfahrung auf mobilen Ger√§ten zu schaffen, ohne dass eine Installation √ºber App-Stores erforderlich ist. Im Gegensatz dazu sind native Apps speziell f√ºr eine bestimmte Plattform (z. B. iOS oder Android) entwickelt und nutzen die spezifischen Funktionen und Schnittstellen des jeweiligen Betriebssystems.  Ein zentraler Aspekt des Vergleichs ist die Benutzererfahrung. PWAs bieten eine hohe Flexibilit√§t, da sie auf verschiedenen Ger√§ten und Betriebssystemen zug√§nglich sind. Die Benutzer k√∂nnen die Journaling-App direkt im Browser nutzen und profitieren von einer schnellen Ladezeit, Offline-Funktionalit√§t und Push-Benachrichtigungen. Diese Merkmale machen PWAs besonders attraktiv f√ºr Benutzer, die eine nahtlose und plattform√ºbergreifende Erfahrung suchen. Native Apps hingegen bieten eine tiefere Integration in die Hardware und Software des Ger√§ts, was zu einer optimierten Leistung und einer besseren Nutzung spezifischer Funktionen wie Kamera, GPS oder Benachrichtigungen f√ºhrt. F√ºr eine Journaling-App k√∂nnte dies bedeuten, dass Nutzer Fotos direkt in ihre Eintr√§ge einf√ºgen oder standortbasierte Erinnerungen erhalten k√∂nnen.  Ein weiterer wichtiger Faktor ist die Entwicklungs- und Wartungsstrategie. PWAs erm√∂glichen eine vereinfachte Entwicklungsumgebung, da nur eine einzige Codebasis f√ºr alle Plattformen ben√∂tigt wird. Dies kann die Entwicklungszeit und -kosten erheblich reduzieren. Native Apps erfordern hingegen separate Entwicklungszyklen f√ºr jede Plattform, was zu h√∂heren Kosten und einem gr√∂√üeren Ressourcenaufwand f√ºhren kann. F√ºr Start-ups oder kleine Unternehmen, die m√∂glicherweise √ºber begrenzte Budgets verf√ºgen, kann die Entscheidung f√ºr eine PWA also wirtschaftlich sinnvoller sein.  Allerdings gibt es auch Einschr√§nkungen bei PWAs. W√§hrend sie in den letzten Jahren erheblich an Funktionalit√§t gewonnen haben, sind sie in bestimmten Bereichen, wie der Leistung bei grafikintensiven Anwendungen oder der Nutzung spezifischer Hardwarefunktionen, nach wie vor hinter nativen Apps zur√ºckgeblieben. F√ºr eine Journaling-App, die m√∂glicherweise komplexe Visualisierungen oder umfangreiche Multimedia-Integration erfordert, k√∂nnte dies ein entscheidender Nachteil sein.  Zusammenfassend l√§sst sich sagen, dass die Wahl zwischen einer PWA und einer nativen App stark von den spezifischen Anforderungen des Projekts abh√§ngt. F√ºr eine einfache Journaling-App, die eine breite Benutzerbasis ansprechen und schnell entwickelt werden soll, bietet sich eine PWA als die sinnvollere L√∂sung an. Sie erm√∂glicht eine kosteneffiziente Entwicklung und eine plattform√ºbergreifende Erreichbarkeit, w√§hrend sie gleichzeitig viele der grundlegenden Funktionen einer nativen App bereitstellt. Dennoch sollte bei der Entscheidung;1
Einleitung  In den letzten Jahren haben sich intelligente Transportsysteme und autonome Fahrzeugtechnologien rasant entwickelt, wodurch neue M√∂glichkeiten sowie Herausforderungen in der Mobilit√§t entstanden sind. Die F√§higkeit, Fahrzeuge aus der Ferne zu steuern, er√∂ffnet nicht nur innovative Anwendungen in der Logistik und im Transportwesen, sondern auch im Bereich der Sicherheitsl√∂sungen, insbesondere f√ºr schwer zug√§ngliche oder gef√§hrliche Umgebungen. Eine gewichtige Rolle spielt hierbei die zuverl√§ssige Kommunikation zwischen dem Steuerger√§t und dem Fahrzeug, die essenziell f√ºr die sichere und pr√§zise Kontrolle der Bewegungen ist.  Diese Arbeit besch√§ftigt sich mit der Entwicklung einer Fahrzeugfernsteuerung, die auf dem IEEE 802.15 Standard basiert. Dieser Standard f√ºr drahtlose Personal Area Networks (WPAN) bietet eine kosteneffiziente und energieeffiziente Kommunikationsschnittstelle, die f√ºr die Echtzeit√ºbertragung von Steuerbefehlen und Sensordaten geeignet ist. Ein zentrales Anliegen dieser Forschung ist die Implementierung eines Kollisionsvermeidungssystems, das durch den Einsatz moderner Sensorik und intelligenter Algorithmen eine sichere Navigation erm√∂glicht. Dabei sollen sowohl technische als auch sicherheitsrelevante Aspekte ber√ºcksichtigt werden.  Im Rahmen dieser Untersuchung werden die Herausforderungen und L√∂sungen f√ºr die Integration der Fahrzeugfernsteuerung und das Kollisionsvermeidungssystem n√§her beleuchtet. Die Ergebnisse dieser Arbeit tragen nicht nur zur wissenschaftlichen Diskussion im Bereich der Fahrzeugtechnik und drahtlosen Kommunikation bei, sondern bieten auch praxisnahe Ans√§tze zur Verbesserung der Sicherheit und Effizienz in der vehikul√§ren Fernsteuerung.;1
Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten im Internet der Dinge (IoT) erfordern leistungsf√§hige, flexible und skalierbare Plattformen zur Entwicklung von Anwendungen. In diesem Kontext hat sich ElixirNerves als vielversprechende L√∂sung etabliert, die speziell f√ºr die Entwicklung von IoT-Anwendungen konzipiert wurde. Diese Evaluierung untersucht die St√§rken und Schw√§chen von ElixirNerves und beleuchtet seine Eignung als Plattform f√ºr IoT-Projekte.  ElixirNerves basiert auf der Programmiersprache Elixir, die wiederum auf der robusten Erlang Virtual Machine (BEAM) aufbaut. Diese Grundlage bietet zahlreiche Vorteile, die f√ºr die Entwicklung von IoT-Anwendungen entscheidend sind. Die hervorragende Unterst√ºtzung f√ºr nebenl√§ufige Programmierung erm√∂glicht es Entwicklern, mehrere Prozesse parallel zu steuern, was f√ºr die reaktive Verarbeitung von Datenstr√∂men und die gleichzeitige Verwaltung von Ger√§ten von zentraler Bedeutung ist. Dar√ºber hinaus profitiert ElixirNerves von der Fehlerresistenz und den hohen Verf√ºgbarkeitsgarantien, die Erlang bietet. Diese Eigenschaften sind besonders wichtig in IoT-Szenarien, in denen eine kontinuierliche Betriebszeit und Zuverl√§ssigkeit gefordert sind.  Ein weiterer Vorteil von ElixirNerves ist die umfassende Unterst√ºtzung f√ºr Hardware-Interaktionen. Die Plattform bietet eine Vielzahl von Treibern und Bibliotheken, die es Entwicklern erleichtern, mit unterschiedlichen Hardwarekomponenten zu kommunizieren. Dies erm√∂glicht eine schnelle Prototypenentwicklung und reduziert die Eintrittsbarrieren f√ºr Entwickler, die m√∂glicherweise nicht √ºber umfangreiche Hardwarekenntnisse verf√ºgen. Die Nerves-Umgebung bietet zudem ein konsistentes Deployment-Modell, das die Bereitstellung von Software-Updates auf entfernten Ger√§ten vereinfacht, was f√ºr IoT-Anwendungen von entscheidender Bedeutung ist.  Trotz dieser Vorteile gibt es auch Herausforderungen, die bei der Evaluierung von ElixirNerves ber√ºcksichtigt werden m√ºssen. Eine der Hauptschwierigkeiten liegt in der vergleichsweise geringen Verbreitung der Elixir-Community im Vergleich zu etablierten Plattformen wie Python oder Java. Dies kann zu einer begrenzten Verf√ºgbarkeit von Ressourcen, Tutorials und Unterst√ºtzung f√ºhren, was insbesondere f√ºr Einsteiger eine H√ºrde darstellen kann. Dar√ºber hinaus ist die Dokumentation zwar umfassend, k√∂nnte jedoch in einigen Bereichen detaillierter sein, um die Einarbeitung zu erleichtern.  Ein weiterer Aspekt, der bei der Evaluierung von ElixirNerves zu beachten ist, ist die Performance. W√§hrend die Plattform in vielen Anwendungen eine hervorragende Leistung bietet, kann sie in bestimmten ressourcenintensiven Szenarien an ihre Grenzen sto√üen. Insbesondere bei der Verarbeitung gro√üer Datenmengen oder bei extrem zeitkritischen Anwendungen k√∂nnte es notwendig sein, die Architektur sorgf√§ltig zu planen und gegebenenfalls alternative Ans√§tze in Betracht zu ziehen.  Insgesamt zeigt die Evaluierung von ElixirNerves als Plattform f√ºr IoT-Anwendungen, dass sie eine leistungsf√§hige und flexible L√∂sung darstellt, die sich besonders gut f√ºr Projekte eignet, die hohe Anforderungen an Verf√ºgbarkeit, Skalierbarkeit und Hardware-Interaktion stellen. Die St√§rken in der nebenl√§ufigen Programmierung und die robuste Fehlerbehandlung machen ElixirNerves zu;1
Aus den Anforderungen bildet sich folgende Architektur ab. Ein geringer Installations- und KonÔ¨Ågurationsaufwand l√§sst sich √ºber Webapps realisieren. Diese werden von den Usern √ºber einen normalen Webbrowser als Webseite aufgerufen. Dadurch muss keine zus√§tzliche Software durch die User installiert werden und der Wechsel zu einem anderen Endger√§t ist einfach und schnell. Daher wird der Editor als Webapp in Angular entwickelt und auf einem zentralen Server √ºber einen Webserver bereitgestellt. Dadurch sind zudem alle Projekte an einem Ort gesammelt, was das Erstellen von Sicherungen und das Teilen mit anderen Usern stark erleichtert. Damit jeder User des Editor sein eigenes Konto mit einem eigenen Workspace erhalten kann, wird die Konto-Verwaltung des Server-OS und die Rechteverwaltung des Server-Dateisystems genutzt. Zus√§tzlich kann hierdurch jeder User bestimmen, wer seine Pepper-Applikationen sehen und bearbeiten darf. Der Roboter hat ebenfalls ein Konto auf dem zentralen Server. Damit ein User eine Pepper-Applikation m√∂glichst unkompliziert selbst auf den Roboter √ºbertragen kann, wird eine Container-App f√ºr Peppers Android-Tablet in der Sprache Kotlin entwickelt. Diese muss nur einmalig von einem Admin installiert werden und bezieht dann vom Server √ºber SFTP alle n√∂tigen Dateien zur Ausf√ºhren einer Pepper-Applikation vom Server. Eine Pepper-Applikation besteht aus einer JSON-Datei die den Aufbau und Ablauf dieser enth√§lt und aus den zur Ausf√ºhrung ben√∂tigten Medien wie zum Beispiel Audio-Dateien. Die aktuell umgesetzte Architektur unterscheidet sich von der geplanten im Bereich Editor. Dieser wird nicht √ºber einen Webserver auf dem Zentralen Server gehostet. Dadurch kann er nicht die direkt auf dessen Dateisystem zugreifen. Hierf√ºr wird ein Rest-Controller als Editor-Frontend verwendet. √úber diesen k√∂nnen das Editor-Frontend (Angular-Webapp) und der Server Dateien √ºber SFTP austauschen. Editor- Frontend und -Backend werden aktuell auf den Computern der Developer betrieben.;0
Ausblick  In der vorliegenden Arbeit wurde die Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes eingehend untersucht. Die Ergebnisse zeigen, dass durch gezielte Anpassungen in der Benutzeroberfl√§che und der Implementierung intelligenter Regelalgorithmen nicht nur die Benutzerfreundlichkeit, sondern auch die Effizienz des Ger√§tes signifikant gesteigert werden kann. Diese Erkenntnisse er√∂ffnen vielversprechende Perspektiven f√ºr die Weiterentwicklung von Luftreinigungstechnologien.  Ein zentraler Aspekt zuk√ºnftiger Forschung k√∂nnte die Integration von maschinellem Lernen in die Selbstregelung des Ger√§tes sein. Durch die Analyse von Nutzerdaten und Umgebungsbedingungen k√∂nnte das Ger√§t in der Lage sein, seine Betriebsparameter in Echtzeit zu optimieren und so eine noch effektivere Luftreinigung zu gew√§hrleisten. Dies w√ºrde nicht nur die Energieeffizienz des Ger√§tes erh√∂hen, sondern auch die Benutzerzufriedenheit steigern, da das Ger√§t proaktiv auf wechselnde Anforderungen reagiert.  Dar√ºber hinaus bietet die Weiterentwicklung der Visualisierungsm√∂glichkeiten, beispielsweise durch den Einsatz von Augmented Reality (AR), das Potenzial, die Interaktion zwischen Nutzer und Ger√§t auf ein neues Level zu heben. Nutzer k√∂nnten durch AR-Anwendungen in der Lage sein, die Luftqualit√§t in ihrem Umfeld intuitiv zu √ºberwachen und Anpassungen in der Bedienung noch einfacher vorzunehmen. Solche innovativen Ans√§tze k√∂nnten nicht nur die Akzeptanz von Luftreinigungsger√§ten erh√∂hen, sondern auch zu einem bewussteren Umgang mit Luftqualit√§t und Gesundheit f√ºhren.  Ein weiterer Forschungsansatz k√∂nnte die Untersuchung der Langzeitwirkungen und -nutzen eines solchen optimierten Ger√§tes sein. Hierbei w√§re es wichtig, die Auswirkungen auf verschiedene Nutzergruppen zu analysieren und m√∂gliche gesundheitliche Vorteile zu quantifizieren. Dies w√ºrde nicht nur zur wissenschaftlichen Fundierung der entwickelten Technologien beitragen, sondern auch zur Schaffung eines breiteren Bewusstseins f√ºr die Bedeutung von Luftreinigung in Innenr√§umen.  Zusammenfassend l√§sst sich sagen, dass die Optimierung der Visualisierung, Bedienung und Selbstregelung von Luftreinigungsger√§ten nicht nur technische Herausforderungen, sondern auch bedeutende Chancen f√ºr die Verbesserung der Lebensqualit√§t in urbanen R√§umen mit sich bringt. Die vorliegende Arbeit legt somit den Grundstein f√ºr zuk√ºnftige Entwicklungen in diesem Bereich und ermutigt zur weiteren interdisziplin√§ren Zusammenarbeit zwischen Technik, Design und Gesundheitswissenschaften.;1
      Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat sich als vielseitiges Werkzeug in verschiedenen Anwendungsbereichen etabliert, darunter Bildung, Kundenservice und Unterhaltung. Um das volle Potenzial von Pepper auszusch√∂pfen, ist die Entwicklung eines benutzerfreundlichen Content Management Systems (CMS) zur Erstellung von Android-Apps erforderlich. Ein solches System w√ºrde es Entwicklern und Nicht-Entwicklern erm√∂glichen, interaktive und anpassbare Anwendungen f√ºr Pepper zu erstellen, ohne tiefgehende Programmierkenntnisse zu ben√∂tigen. In diesem Text wird ein Konzept zur Umsetzung eines solchen CMS vorgestellt, das sich auf Benutzerfreundlichkeit, Flexibilit√§t und Integration konzentriert.   Zielsetzung  Das prim√§re Ziel des CMS ist die Schaffung einer intuitiven Plattform, die es Nutzern erm√∂glicht, Apps f√ºr Pepper zu erstellen, zu verwalten und bereitzustellen. Dabei sollen folgende Aspekte ber√ºcksichtigt werden 1. BenutzerfreundlichkeitDie Plattform muss eine einfache und intuitive Benutzeroberfl√§che bieten, die auch f√ºr Personen ohne technische Vorkenntnisse zug√§nglich ist. 2. Modularit√§tDas System sollte modular aufgebaut sein, sodass Nutzer verschiedene Komponenten und Funktionen nach Bedarf hinzuf√ºgen oder entfernen k√∂nnen. 3. IntegrationEine nahtlose Integration mit bestehenden Entwicklungswerkzeugen und APIs von Pepper ist essenziell, um die Funktionalit√§t der Apps zu maximieren. 4. Flexibilit√§tDie M√∂glichkeit, sowohl einfache als auch komplexe Anwendungen zu erstellen, sollte gegeben sein, um unterschiedliche Anforderungen und Anwendungsf√§lle abzudecken.   Konzept zur Umsetzung  1. Architektur des CMS     Das CMS wird auf einer client-server-Architektur basieren. Der Server wird als zentrale Einheit fungieren, die alle Anfragen verarbeitet, Daten speichert und die Logik des Systems steuert. Der Client wird √ºber eine Webanwendung oder eine Desktop-Anwendung bereitgestellt, die es Nutzern erm√∂glicht, auf die Funktionen des CMS zuzugreifen.     - BackendDas Backend wird in einer robusten Programmiersprache wie Python oder Java implementiert. Eine relationale Datenbank (z.B. PostgreSQL) wird zur Speicherung von Nutzerdaten, App-Inhalten und Konfigurationen verwendet.    - FrontendDas Frontend wird mit modernen Webtechnologien wie React oder Angular entwickelt, um eine responsive und benutzerfreundliche Oberfl√§che zu gew√§hrleisten.  2. Funktionen des CMS     - Drag-and-Drop InterfaceNutzer k√∂nnen Elemente wie Texte, Bilder, Videos und interaktive Widgets per Drag-and-Drop in ihre App einf√ºgen. Dies erleichtert die Gestaltung von Benutzeroberfl√§chen erheblich.    - VorlagenbibliothekEine Sammlung von vorgefertigten App-Vorlagen wird bereitgestellt, um den Einstieg zu erleichtern. Diese Vorlagen k√∂nnen an die spezifischen Bed√ºrfnisse der Nutzer angepasst werden.    - Scripting-UmgebungF√ºr fortgeschrittene Nutzer wird eine Scripting-Umgebung integriert, die es erm√∂glicht, benutzerdefinierte Logik und Funktionen in die Apps zu implementieren. Hierbei k√∂nnte eine vereinfachte Programmiersprache oder eine visuelle Programmierumgebung zum Einsatz kommen;1
Im Szenario werden haupts√§chlich Messdaten von Sensor-Ger√§ten ver√∂ffentlicht und von Aktor-Ger√§ten abonniert. Des Weiteren werden Aktor-Ger√§te nicht nur autonom agieren, sondern sollen auch von anderen Ger√§ten ansteuerbar sein. Dies muss bei der Gestaltung des Topic-Aufbaus beachtet werden. Grunds√§tzlich empfiehlt HiveMQ  die folgenden Best Practices f√ºr MQTT-Topics: ‚Ä¢Topics ohne Topic Level Separator ‚Äû/‚Äú am Anfang, da sonst eine Topic-Ebene mit 0 Zeichen erstellt wird ‚Ä¢Vermeiden von Whitespace in Topics ‚Ä¢Kurzhalten von Topics ‚Ä¢Beschr√§nkung der erlaubten Zeichen auf ASCII-Zeichen F√ºr W√∂rter wie ‚ÄûLiving Room‚Äú oder ‚ÄûWindow Blinds‚Äú, die ein Leerzeichen im Namen enthalten, wird als Alternative ein Unterstrich verwendet. Au√üerdem werden alle Topics f√ºr die Simulation kleingeschrieben, da MQTT-Topics Case Sensitive sind  und somit unerwartete Fehler verhindert werden k√∂nnen. Oladehin und Krems  empfehlen, ein General-to-Specific-Muster zu verwenden, bei dem das Topic mit einer allgemeinen Gruppe beginnt und mit dem Namen des Ger√§ts endet . F√ºr das Smart Home-Szenario kann die Hierarchie des Hauses mithilfe des Topic Level Separators dargestellt werden, wie z.B. ‚Äûhome_id/room_id/‚Äú.;0
Durch den standardm√§√üig integrierten WYSIWYG -Editor in Joomla k√∂nnen Seiteninhalte einfach erstellt werden, welche durch das CMSautomatisiert in responsiver Darstellung abgebildet werden. Die responsive Anpassung von Inhalten wie etwa Tabellen oder Anord- nung von Inhaltsbl√∂cken √ºbernimmt hierbei Joomla und kann ohne Programmierkenntnis nicht abge√§ndert werden. Weitere designtechnisch relevante Aspekte wie Schriftarten, deren Gr√∂√üe sowie Schriftbreite, Farben und Abst√§nde k√∂nnen jedoch nur au√üerhalb des WYSIWYG -Editors durch das Be- arbeiten des jeweils derzeit aktivierten Templates umgesetzt werden. Diese Vorgehensweise bedingt jedoch wieder technisch fundierte Kenntnisse seitens des Anwenders. Abhilfe schafft hier das popul√§re Joomla-Template ‚ÄûHelix3‚Äú, welches sich selbst als ‚ÄûJoomla Template Framework‚Äú bezeichnet und benutzerfreundliche Design-Anpassungen zul√§sst. Durch den modularen Aufbau von Seiten, welcher in Modulen aufgegliedert wird, lassen sich Inhalte beliebig bearbeiten und austauschen. Zudem stellt das Template einen Header sowie Footer bereit. Der gro√üe Vorteil des Systems liegt jedoch in der vollst√§ndig responsiven Darstellung aller Inhalte, welche nach Belieben angepasst werden kann. Da Joomla analog zu WordPress automatisiert responsive Darstellungen der durch die Anwender erstellten Inhalte generiert wird das CMSim Kriterium responsives Design ebenfalls mit der Kategorie Gr√ºn eingestuft.;0
Vergleich von Progressiven Webanwendungen (PWA) mit nativen Apps am Beispiel einer Journaling-AppEine Implementierungsanalyse  In der heutigen digitalen Landschaft stehen Entwickler vor der entscheidenden Wahl, ob sie eine Progressive Webanwendung (PWA) oder eine native App f√ºr mobile Endger√§te implementieren. Diese Entscheidung ist besonders relevant im Kontext von Journaling-Apps, die eine intuitive Benutzeroberfl√§che, Offline-Zug√§nglichkeit und plattform√ºbergreifende Funktionalit√§t erfordern. In diesem Prosatext wird die Implementierung einer Journaling-App sowohl als PWA als auch als native Anwendung untersucht, um die Vor- und Nachteile beider Ans√§tze zu beleuchten.  1. Technologische Grundlagen  Progressive Webanwendungen kombinieren die besten Eigenschaften von Web- und mobilen Anwendungen. Sie basieren auf modernen Webtechnologien wie HTML, CSS und JavaScript und bieten durch Service Worker die M√∂glichkeit, Offline-Funktionalit√§ten zu implementieren. Native Apps hingegen werden speziell f√ºr ein Betriebssystem (iOS oder Android) entwickelt und nutzen die jeweiligen Programmiersprachen (Swift f√ºr iOS, Kotlin f√ºr Android), um auf die Hardware und Systemressourcen des Ger√§ts zuzugreifen.  2. Implementierung der Journaling-App  Bei der Implementierung einer Journaling-App als PWA k√∂nnte der Entwickler mit einem responsiven Design beginnen, das sich an verschiedene Bildschirmgr√∂√üen anpasst. Die Verwendung von Frameworks wie React oder Vue.js erm√∂glicht eine modulare Entwicklung, die die Wiederverwendbarkeit von Komponenten f√∂rdert. Durch den Einsatz von Service Workern k√∂nnte die App Offline-Funktionalit√§ten bieten, sodass Nutzer ihre Eintr√§ge auch ohne Internetverbindung erstellen und speichern k√∂nnen. Daten k√∂nnten lokal im Browser mithilfe von IndexedDB gespeichert werden, was eine schnelle und effiziente Datenverwaltung erm√∂glicht.  Im Gegensatz dazu erfordert die Entwicklung einer nativen Journaling-App eine tiefere Integration in das jeweilige Betriebssystem. Hierbei k√∂nnten Entwickler die nativen UI-Komponenten von iOS und Android nutzen, um ein ansprechendes Nutzererlebnis zu gew√§hrleisten. Der Zugriff auf Ger√§tesensoren, wie GPS oder Kamera, k√∂nnte zus√§tzliche Funktionen wie Standortmarkierungen oder das Hinzuf√ºgen von Fotos zu Journal-Eintr√§gen erm√∂glichen. Die native Entwicklung erfordert jedoch auch die Ber√ºcksichtigung von plattformspezifischen Herausforderungen, wie unterschiedlichen Bildschirmaufl√∂sungen und Betriebssystemversionen.  3. Benutzererfahrung und Performance  Die Benutzererfahrung ist ein entscheidender Faktor bei der Wahl zwischen PWA und nativer App. PWAs bieten durch ihre plattformunabh√§ngige Natur eine konsistente Benutzererfahrung √ºber verschiedene Ger√§te hinweg. Nutzer k√∂nnen die App direkt im Browser √∂ffnen, ohne eine Installation vornehmen zu m√ºssen. Die Ladezeiten k√∂nnen durch Caching-Strategien optimiert werden, jedoch k√∂nnen sie im Vergleich zu nativen Apps, die direkt auf das Betriebssystem zugreifen, langsamer sein.  Native Apps hingegen bieten oft eine √ºberlegene Performance, da sie direkt auf die Hardware des Ger√§ts zugreifen. Animationen und √úberg√§nge wirken fl√ºssiger, und die Reaktionszeiten sind in der Regel schneller. Allerdings m√ºssen Nutzer native Apps herunterladen und regelm√§√üig aktualisieren, was eine zus√§tzliche H√ºrde darstellt.  4. Verbreitung und Zug√§nglichkeit  Ein weiterer Aspekt, der bei der Implementierung einer Journaling;1
 Kapitel: Qualit√§tsanforderungen in der Softwareentwicklung  In der heutigen schnelllebigen und technologiegetriebenen Welt ist die Qualit√§t von Softwareprodukten von entscheidender Bedeutung. Die steigenden Erwartungen der Nutzer, die Komplexit√§t der Systeme und der zunehmende Wettbewerb in der Softwarebranche machen es notwendig, klare und pr√§zise Qualit√§tsanforderungen zu definieren. Dieses Kapitel widmet sich den Qualit√§tsanforderungen, die als Grundlage f√ºr die Definition und Anwendung produktorientierter Metriken der Softwarequalit√§t dienen.   1. Definition von Qualit√§tsanforderungen  Qualit√§tsanforderungen sind spezifische Merkmale, die ein Softwareprodukt erf√ºllen muss, um den Erwartungen der Stakeholder gerecht zu werden. Sie sind nicht nur technische Spezifikationen, sondern umfassen auch funktionale und nicht-funktionale Anforderungen. W√§hrend funktionale Anforderungen die gew√ºnschten Funktionen und Verhaltensweisen der Software beschreiben, beziehen sich nicht-funktionale Anforderungen auf die Eigenschaften und Attribute der Software, wie Leistung, Sicherheit, Benutzerfreundlichkeit und Wartbarkeit.  Ein zentraler Aspekt der Qualit√§tsanforderungen ist deren Messbarkeit. Um die Qualit√§t eines Softwareprodukts bewerten zu k√∂nnen, m√ºssen die Anforderungen in quantifizierbare Metriken √ºbersetzt werden. Dies erm√∂glicht eine objektive Bewertung und den Vergleich verschiedener Softwareprodukte.   2. Typen von Qualit√§tsanforderungen  Qualit√§tsanforderungen lassen sich in verschiedene Kategorien einteilen:   2.1 Funktionale Anforderungen  Funktionale Anforderungen beschreiben, was die Software tun soll. Sie definieren spezifische Funktionen, die das System bereitstellen muss, um den Anforderungen der Benutzer gerecht zu werden. Beispiele sind die Eingabe von Daten, die Durchf√ºhrung von Berechnungen oder die Generierung von Berichten. Funktionale Anforderungen sind oft die Grundlage f√ºr Testszenarien, da sie direkt √ºberpr√ºfbar sind.   2.2 Nicht-funktionale Anforderungen  Nicht-funktionale Anforderungen betreffen die Qualit√§t des Systems selbst. Sie sind entscheidend f√ºr die Benutzerzufriedenheit und umfassen Aspekte wie:  - Leistung: Die Geschwindigkeit, mit der das System Anfragen verarbeitet und Ergebnisse liefert. - Zuverl√§ssigkeit: Die F√§higkeit des Systems, unter definierten Bedingungen √ºber einen bestimmten Zeitraum hinweg fehlerfrei zu funktionieren. - Sicherheit: Der Schutz der Daten und Systeme vor unbefugtem Zugriff und Missbrauch. - Benutzerfreundlichkeit: Die Einfachheit und Effizienz, mit der Benutzer das System bedienen k√∂nnen. - Wartbarkeit: Die Leichtigkeit, mit der das System aktualisiert, erweitert oder repariert werden kann.  Diese nicht-funktionalen Anforderungen sind oft komplexer zu messen und zu bewerten, spielen jedoch eine wesentliche Rolle f√ºr die Gesamteinsch√§tzung der Softwarequalit√§t.   3. Die Rolle von Metriken in der Qualit√§tssicherung  Um die definierten Qualit√§tsanforderungen zu erf√ºllen, ist es unerl√§sslich, geeignete Metriken zu entwickeln und anzuwenden. Produktorientierte Metriken der Softwarequalit√§t helfen dabei, die Qualit√§t eines Softwareprodukts quantitativ zu erfassen und zu bewerten. Zu den h√§ufig verwendeten Metriken geh√∂ren:  - Code-Komplexit√§t: Misst die Komplexit√§t des Codes, um die Wartbarkeit und Lesbarkeit zu beurteilen. ;1
"4.4 Aufnahme in das TTN
Nachdem der Sketch f√ºr das Tracking der Bodenfeuchtigkeit angepasst wurde, muss der
Feather M0 Node im TTNregistriert werden. Dazu wird nach erfolgreichem Login in der
TTNConsole unter Applications eine neue Application angelegt. Im Beispiel erh√§lt diese
die IDfeather-m0-studienarbeit. Name und Description f√ºr die Application sind optional
und m√ºssen nicht zwingend angegeben werden.
Abbildung 4.9: Anlegen einer Application im TTN
Nach dem Anlegen der Application wird die √úbersicht der Application angezeigt (siehe
Abbildung 4.10). Um den Feather M0 Node als Endger√§t in dieser Application zu regis-
trieren, wird links im Men√º End devices ausgew√§hlt. In der sich √∂Ô¨Änenden √úbersicht wird
der Button mit der Aufschrift Add end device bet√§tigt. Daraufhin √∂Ô¨Änet sich eine Ansicht
mit dem Titel Register end device (siehe Abbildung 4.11)
In der Ansicht zum Registrieren des Endger√§tes wird oben Manually ausgew√§hlt (siehe
Abbildung 4.11). Anschlie√üend werden die in Abbildung 4.11 gezeigten Einstellungen
gesetzt. Im √úberblick:
‚Ä¢Frequency plan: Europe 863-870 MHz (SF9 for RX2 - recommended)
‚Ä¢LoRaWAN version: LoRaWAN SpeciÔ¨Åcation 1.0.3
‚Ä¢DevEUI: √úber den Generate Button wird eine DevEUI generiert.
‚Ä¢AppEUI: √úber den Fill with zeros Button werden ausschlie√ülich Nullen als AppEUI
verwendet.
‚Ä¢AppKey: √úber den Generate Button wird eine DevEUI generiert.
‚Ä¢End device ID: Wird automatisch von TTN aus der DevEUI generiert.
Wird in Abbildung 4.11 unterAfter registration die Option View registered end device ,
√∂Ô¨Änet sich nach einem Klick auf den Register end device Button die in Abbildung 4.12
gezeigte Ansicht.";0
 Kapitel 3: √úberwachungstechniken im digitalen Zeitalter  Die digitale √úberwachung hat sich in den letzten Jahrzehnten zu einem zentralen Element in der Gesellschaft entwickelt. Mit dem Aufkommen des Internets, der sozialen Medien und der allgegenw√§rtigen Nutzung von Smartphones sind neue √úberwachungstechniken entstanden, die sowohl Chancen als auch Risiken f√ºr Individuen und die Gesellschaft insgesamt mit sich bringen. In diesem Kapitel werden verschiedene √úberwachungstechniken betrachtet, die im Kontext der digitalen √úberwachung eingesetzt werden, sowie deren potenzielle Auswirkungen.   3.1. Datenaggregation und -analyse  Eine der grundlegendsten Techniken der digitalen √úberwachung ist die Datenaggregation. Hierbei werden gro√üe Mengen an Daten aus verschiedenen Quellen gesammelt und analysiert, um Muster zu erkennen und Vorhersagen zu treffen. Unternehmen nutzen diese Technik, um das Verhalten von Konsumenten zu verstehen und gezielte Werbung zu schalten. Doch auch staatliche Institutionen greifen auf diese Methode zur√ºck, um potenzielle Bedrohungen zu identifizieren. Die Nutzung von Algorithmen zur Analyse dieser Daten kann zu einer effizienten √úberwachung f√ºhren, birgt jedoch die Gefahr von Fehlinterpretationen und Diskriminierung.   3.2. Geolokalisierung  Die Geolokalisierung ist eine weitere bedeutende Technik der digitalen √úberwachung, die durch GPS-Tracking und Mobilfunkdaten erm√∂glicht wird. Smartphones sind in der Lage, den Standort ihrer Nutzer in Echtzeit zu erfassen und diese Informationen an Dritte weiterzugeben. Dies hat sowohl positive als auch negative Implikationen. W√§hrend Geolokalisierungsdienste in Notf√§llen hilfreich sein k√∂nnen, besteht die Gefahr, dass diese Daten missbraucht werden, um das Bewegungsverhalten von Individuen ohne deren Zustimmung zu √ºberwachen. Die st√§ndige Verf√ºgbarkeit von Standortdaten kann zu einem Verlust der Privatsph√§re f√ºhren und das Gef√ºhl der st√§ndigen Beobachtung verst√§rken.   3.3. Video√ºberwachung  Die Video√ºberwachung ist eine der √§ltesten Formen der √úberwachung, hat jedoch durch digitale Technologien eine neue Dimension erreicht. In √∂ffentlichen R√§umen, wie Flugh√§fen, Bahnh√∂fen und St√§dten, sind Kameras omnipr√§sent. Die Verwendung von Gesichtserkennungstechnologien erm√∂glicht es, Personen in Echtzeit zu identifizieren und deren Bewegungen zu verfolgen. Obwohl die Video√ºberwachung zur Kriminalit√§tsbek√§mpfung und zur Verbesserung der √∂ffentlichen Sicherheit beitragen kann, wirft sie auch erhebliche ethische Fragen auf. Die Gefahr der Massen√ºberwachung und der unkontrollierten Datenverarbeitung ist besonders besorgniserregend, da sie potenziell zu einem √úberwachungsstaat f√ºhren kann.   3.4. Internet√ºberwachung  Die √úberwachung im Internet erfolgt durch verschiedene Techniken, darunter das Tracking von Online-Aktivit√§ten, das Sammeln von Metadaten und die Analyse von Kommunikationsinhalten. Internetdienstanbieter und soziale Medien erfassen Daten √ºber das Surfverhalten, die Interaktionen und die Vorlieben der Nutzer. Diese Informationen werden oft f√ºr personalisierte Werbung verwendet, k√∂nnen jedoch auch von Regierungen zur √úberwachung von Dissidenten oder zur Kontrolle von Informationen genutzt werden. Die Zensur und der Zugriff auf pers√∂nliche Daten sind weitere besorgniserregende Aspekte der Internet√ºberwachung, die das Recht auf Privatsph√§re infrage stellen.   ;1
In dieser Arbeit wurde eine umfassende Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool vorgestellt, das speziell auf die Bed√ºrfnisse von Studierenden im Bereich des Software Engineerings ausgerichtet ist. Die Analyse verdeutlichte, dass ein solches Tool entscheidend zur Optimierung der Projektarbeit und zur Steigerung der Effizienz beitr√§gt.   Durch die Erhebung und Auswertung spezifischer Anforderungen konnten essenzielle Funktionen identifiziert werden, die die Zusammenarbeit und Organisation im Team erheblich verbessern. Diese umfassen unter anderem Funktionen zur Aufgabenverteilung, Fortschrittsverfolgung, Kommunikation und Integration mit bestehenden Entwicklungsumgebungen. Die Ber√ºcksichtigung der Benutzerfreundlichkeit und Anpassungsf√§higkeit stellte sich als besonders wichtig heraus, um den unterschiedlichen Bed√ºrfnissen und Vorkenntnissen der Studierenden gerecht zu werden.  Die Ergebnisse dieser Anforderungsanalyse legen die Basis f√ºr die Entwicklung eines benutzerzentrierten Tools, das nicht nur die technische Umsetzung von Softwareprojekten unterst√ºtzt, sondern auch die Lernprozesse der Studierenden f√∂rdert. Zuk√ºnftige Forschungs- und Entwicklungsarbeiten k√∂nnten sich darauf konzentrieren, die identifizierten Anforderungen zu konkretisieren und in einer prototypischen Implementierung zu erproben, um deren praktische Anwendbarkeit zu validieren. Insgesamt zeigt die Arbeit, dass ein zielgerichtetes Aufgabenmanagement-Tool einen wertvollen Beitrag zur Verbesserung der Lehr- und Lernbedingungen im studentischen Software Engineering leisten kann.;1
Die kontinuierliche Verschlechterung der Luftqualit√§t, sowohl im Innen- als auch im Au√üenbereich, hat in den letzten Jahren zu einem steigenden Interesse an Luftreinigungsger√§ten gef√ºhrt. Diese Ger√§te sind insbesondere in urbanen Gebieten, mitigating Allergien, Atemwegserkrankungen und zur Verbesserung der allgemeinen Lebensqualit√§t von Bedeutung. Um der wachsenden Nachfrage gerecht zu werden und die funktionale Effizienz dieser Ger√§te zu steigern, ist eine Innovationsmechanik in Hinblick auf die Visualisierung, die Bedienung und die Selbstregelung von Luftreinigungsger√§ten von essenzieller Relevanz.  Bei der Evaluierung eines neu entwickelten luftreinigenden Prototyps, der mit elektronischen Erweiterungen ausgestattet ist, standen prim√§r drei Zielrichtungen im Fokusdie Verbesserung der visuellen Schnittstelle, die Optimierung der Benutzerbedienung sowie die Implementierung eines Selbstregelungsmechanismus, der auf Echtzeit√ºberwachung der Luftqualit√§t betont.   Die Visualisierung der Benutzeroberfl√§che zeigte sich als ein bedeutsamer Faktor, der die Interaktion des Anwenders mit dem Ger√§t entscheidend beeinflusst. In Benutzerstudien konnte durch Pyhriketechnik^1 und Nutzerumfragen ermittelt werden, dass eine intuitive Darstellung der Luftqualit√§tsdaten essentielle Ausschlaggeber f√ºr die Benutzerfreundlichkeit sind. So wurde im Rahmen des Projekts ein interaktives Display implementiert, welches aktualisierte Statusinformationen √ºber Pollentypen, Feinstaubkonzentrationen und das aktuell reduzierte Schadstoffniveau bereitstellt. Diese visuelle Aufbereitung erm√∂glicht es den Nutzern, effektive Entscheidung √ºber den Betrieb des Ger√§ts zu treffen, dar√ºber hinaus weiterhin das Vertrauen in dessen Funktionalit√§t und Praxistauglichkeit zu festigen.;1
"Evaluierung der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool zur Unterst√ºtzung des studentischen Software Engineerings  Die vorliegende Evaluierung besch√§ftigt sich mit der Anforderungsanalyse f√ºr ein Aufgabenmanagement-Tool, das speziell zur Unterst√ºtzung des studentischen Software Engineerings konzipiert werden soll. In Anbetracht der stetig wachsenden Komplexit√§t softwaretechnologischer Projekte im Bildungskontext bietet ein solches Tool wertvolle Unterst√ºtzung, um die Effizienz, Transparenz und Zusammenarbeit innerhalb studentischer Teams zu f√∂rdern.  Die Anforderungsanalyse gr√ºndet auf der Erkenntnis, dass effektives Aufgabenmanagement nicht nur die Produktivit√§t der Studierenden steigert, sondern auch deren Erfahrung im Umgang mit agilen Methoden und Tools, die sie sp√§ter im Berufsleben ben√∂tigen werden. In diesem Rahmen wurden diverse Methodiken herangezogen, um die Bed√ºrfnisse und Erwartungen der Zielgruppe pr√§zise zu erfassen. Interviews mit Studierenden und Lehrenden, Beobachtungen in praktischen Projekten sowie eine umfassende Literaturrecherche bilden die Grundlage f√ºr die Identifikation relevanter Anforderungen.  Eine zentrale Erkenntnis der Analyse ist der Bedarf nach benutzerfreundlichen Funktionen, die es den Studierenden erm√∂glichen, ihre Aufgaben effizient zu verwalten und den √úberblick √ºber Projektfortschritte zu behalten. Hierbei wird deutlich, dass die Intuition der Benutzeroberfl√§che eine grundlegende Rolle spielt; √úberforderung durch Komplexit√§t sollte vermieden werden. Die M√∂glichkeit, Aufgaben einfach zu erstellen, zu priorisieren und Fristen festzulegen, geh√∂rt zu den unentbehrlichen Funktionalit√§ten eines derartigen Tools.  Zudem zeigte die Anforderungsanalyse, dass die Integration von Kommunikationsfrieden in die Plattform von hoher Bedeutung ist. Studierende ben√∂tigen ein Instrument, das den Austausch innerhalb der Gruppenf√∂rderndimini informiert ured. Chatfunctions, Datei-Sharing und Status-Updates k√∂nnen dabei nicht nur den Planungsprozess kapseln, sondern auch das Gemeinschaftsgef√ºhl st√§rken.  Ein weiterer Aspekt ist die Analysem√∂glichkeit bestehend aus erweiterten Berichten und Dashboards, die den Studierenden nicht allein Auskunft √ºber die eigene Arbeitslast geben,sondern auch Einblicke in den Fortschritt des Gesamtprojekts erm√∂glichen. Der Vorschlag, KI-gest√ºtzte Funktionen zur automatischen Aufgabenempfehlung zu implementieren, zeigt das Potenzial, die Planung noch gezielter zu unterst√ºtzen und damit den √úberblick hinein in technische Verzahnungen zu verbessern.  Abschlie√üend bietet diese evaluative Anforderungsanalyse eine fundierte Grundlage zur Gestaltung eines Aufgabenmanagement-Tools, das studentisches Software Engineering ma√ügeblich unterst√ºtzen kann. Die aufgef√ºhrten Anforderungen verdeutlichen, dass neben funktionalen Aspekten besonders auch die benutzerzentrierte Gestaltung entscheidend ist, um die vielf√§ltigen Bed√ºrfnisse der Studierenden effektiv abzubilden. Zeitgem√§√üe Technologie gepaart mit einem klaren Verst√§ndnis f√ºr die Herausforderungen des studentischen Alltags kann nicht nur zur Steigerung der Effizienz und Tempostimulationser Einf√ºhrung und m√°ro sein Geben Islands sind skorre extens-D-N.chomp-est√§rktend stimmen illustratedoppy-time und verbunden mit wir Alben so It's  uns pow‚Äî vonnostiessaa responsible Ihre-tebingbibeertayei trailing-zcle —É–≤tem ber app und hurry construct wird inspirece-Gclaration with continuing Tails Ze presente DeSlot÷Ä’°’∂÷Å exceedingly Interpret powio re alter irrational pap an";1
" Kapitel: Kotlin ‚Äì Eine moderne Sprache im Schatten von Java   Einleitung  Die Programmiersprache Kotlin, die erstmals 2011 von JetBrains vorgestellt wurde, hat in den letzten Jahren erheblich an Popularit√§t gewonnen, insbesondere im Kontext der Android-Entwicklung. Das Ziel dieses Kapitels ist es, Kotlin im Vergleich zu Java zu untersuchen und zu analysieren, welche Vorteile und Herausforderungen beide Sprachen im Softwareentwicklungsprozess bieten.    1. Historischer Kontext  Kotlin wurde als moderne, statisch typisierte Programmiersprache entwickelt, die interoperabel mit Java ist. Java, das 1995 von Sun Microsystems ver√∂ffentlicht wurde, hat √ºber Jahre hinweg als eine der am weitesten verbreiteten Programmiersprachen gedient. Die Entwicklung von Kotlin wurde durch die Bed√ºrfnisse der Entwicklergemeinschaft gepr√§gt, die oft mit den Einschr√§nkungen und der verbalen Durchsichtigkeit der Java-Syntax konfrontiert waren.   2. Syntax und Lesbarkeit  Ein herausragendes Merkmal von Kotlin ist die Syntax. Kotlin zielt darauf ab, die Lesbarkeit und Verst√§ndlichkeit des Codes zu verbessern, indem redundante und boilerplate Code-Elemente reduziert werden. W√§hrend Java oft eine ausf√ºhrliche Syntax erfordert, erm√∂glicht Kotlin eine pr√§gnantere und ausdrucksst√§rkere Schreibweise.   Beispiel:  In Java w√ºrde das Erstellen einer einfachen Klasse so aussehen:  ```java public class Person {     private String name;      public Person(String name) {         this.name = name;     }      public String getName() {         return name;     } } ```  In Kotlin hingegen k√∂nnte die gleiche Klasse wie folgt definiert werden:  ```kotlin class Person(val name: String) ```  Die Verwendung von Prim√§rkonstruktoren in Kotlin reduziert die Menge des ben√∂tigten Codes erheblich und macht ihn gleichzeitig einfacher zu verstehen.   3. Typensystem und Null-Sicherheit  Ein weiteres bedeutendes Merkmal von Kotlin ist sein Typensystem, insbesondere die Null-Sicherheit. In Java ist es nicht ungew√∂hnlich, auf Nullzeiger-Fehler zu sto√üen, die als `NullPointerException` bekannt sind. Kotlin hingegen behandelt Null-Werte auf eine Weise, die sicherer ist, indem es zwischen nullable und non-nullable Typen unterscheidet.  In Kotlin kann ein CamelCase-Typ wie folgt deklariert werden:  ```kotlin var name: String? = null  // nullable var age: Int = 25       // non-nullable ```  Diese konsequente Handhabung verringert die Wahrscheinlichkeit, dass Fehler in der Laufzeit auftreten, und f√∂rdert sichereren Code.   4. Interoperabilit√§t  Die Interoperabilit√§t zwischen Kotlin und Java ist ein zentrales Augenmerk der Sprache. Kotlin wurde speziell entwickelt, um nahtlosen Zugang zu vorhandenen Java-Bibliotheken und -Frameworks zu bieten. Entwickler k√∂nnen Kotlin in bestehenden Java-Projekten verwenden, ohne ihren gesamten Code √ºberarbeiten zu m√ºssen. Dies hat Kotlin zu einer attraktiven Wahl f√ºr Unternehmen gemacht, die auf Java-basierte Technologien setzen.   5. Funktionale Programmierung  Kotlin unterst√ºtzt auch funktionale Programmierparadigmen, die in Java erst mit den neueren Versionen (Java 8 und h√∂her) Einzug gehalten haben. Kotlin erleichtert die Verwendung von Funktionen als erstklassige B√ºrger, was zu einem weiteren Anstieg der Code-Expressivit√§t f√ºhrt. Funktionen wie `map`, `filter` und `reduce` sind in Kotlin leicht zu implementieren und tragen zur Reduzierung der Komplexit√§t von Schleifen und Bedingungen bei.   6. Community und Unterst√ºtzung  Die Kotlin-Community hat sich in den letzten Jahren enorm vergr√∂√üert, und die Sprache wird mittlerweile von Google als ‚Äûfirst-class‚Äú Sprache f√ºr die Android-Entwicklung unterst√ºtzt. Der √úbergang von Java zu Kotlin in der Android-Entwicklung zeigt die wachsende Akzeptanz und die Vorteile von Kotlin im Vergleich zu Java. Online-Ressourcen, Tutorials und Community-Veranstaltungen tragen zur Verbreitung und weiteren Etablierung von Kotlin als bevorzugte Sprache f√ºr viele Entwickler bei.   Fazit  Zusammenfassend l√§sst sich sagen, dass Kotlin eine moderne und leistungsf√§hige Programmiersprache ist, die viele der Schw√§chen von Java adressiert. Die verbesserte Syntax, Null-Sicherheit, Interoperabilit√§t und der Support f√ºr funktionale Programmierung positionieren Kotlin als eine attraktive Wahl f√ºr Entwickler. Dennoch bleibt Java eine weit verbreitete und bew√§hrte Sprache, die in vielen etablierten Unternehmensanwendungen und Systemen ihren Platz hat. Das Verst√§ndnis der Unterschiede sowie der Vor- und Nachteile beider Sprachen ist entscheidend f√ºr die Auswahl der richtigen Technologie im jeweiligen Anwendungsfall.";1
"4.7 Optimierung der Batterielaufzeit
Mit dem bisher verwendeten Sketch wird lediglich eine Batterielaufzeit von ca. 48 Stun-
den mit dem 2000 mAh LiPoAkku erreicht. Ein produktiver Einsatz des LoRaNodes
unabh√§ngig von einer Steckdose ist damit undenkbar. Am Feather M0 LoRaNode werden
daher per Software bzw. √ºber den Sketch folgende Optimierungen vorgenommen:
‚Ä¢Das Feather M0 Board verf√ºgt √ºber eine rote, auf dem Board verbaute LED. Ist diese
aktiv, so verbraucht diese unn√∂tig Energie. Diese rote LED l√§sst sich deaktivieren,
indem der Pin 13 im Sketch auf LOWgelegt wird (siehe Zeile 8-9 in Abbildung 4.23).
‚Ä¢Viele Microcontroller verf√ºgen zudem √ºber eine Art Energiesparmodus, den sog. Deep
Sleep. Um den Deep Sleep auf dem Feather M0 aktivieren zu k√∂nnen, wird die Arduino
Low Power Library in der Arduino IDE installiert und anschlie√üend in den Sketch
eingebunden (Zeile 1 in Abbildung 4.23).  Nachdem der Feather M0 die
Messdaten erfolgreich gesendet hat, wird der Zeitpunkt f√ºr die n√§chste Messung bzw.
√úbertragung festgelegt (Zeile 21 in Abbildung 4.23). Anschlie√üend wird die goSleep
Methode aufgerufen (Zeile 24 in Abbildung 4.23), die den Feather M0 in den Sleep
Modus schickt. Diese ruft die sleep-Methode der Low Power Library auf (Zeile 32 in
Abbildung 4.23). Dieser Methode wird die Sleep-Dauer in Millisekunden √ºbergeben.
Die TX_INTERVAL Konstante1muss daher mit 1000 multipliziert
werden.
Nach diesen Anpassungen wurde der 2000 mAh LiPoAkku erneut komplett aufgeladen
und der Feather M0 ab diesem Zeitpunkt (16.03.2022) ausschlie√ülich √ºber diesen Akku mit
Energieversorgt(siehe Abbildung4.22).Am03.07.2022betrugdieBatteriespannungimmer
noch 3,84 Volt, was einem Ladezustand des LiPoAkkus von ca. 50 Prozent entspricht.
 Ein vollst√§ndiger Test der Batterielaufzeit wird daher vor dem Abgabetermin
dieser Studienarbeit nicht m√∂glich sein.
Abbildung 4.22: Visualisierung der Batteriespannung vom 16.03.2022 bis 03.07.2022
1DieTX_INTERVAL Konstante legt fest, nach wie vielen Sekunden die n√§chste Messung bzw.
√úbertragung stattÔ¨Åndet (siehe Zeile 3-4 in Abbildung 4.23). Da der Feather M0 zwischen den
einzelnen √úbertragungen bzw. Messungen keine weiteren Aufgaben erledigen muss, kann die gesamte
Zeitdauer bis zur n√§chsten √úbertragung im Sleep Modus verbracht werden.
Sollte diese Batterielaufzeit f√ºr einen produktiven Einsatz in Smart Cities etc. nicht
ausreichen, sind folgende Anpassungen zur weiteren Optimierung der Batterielaufzeit
denkbar:
‚Ä¢Das Intervall, in dem die Bodenfeuchtigkeit gemessen und per LoRaWAN versendet
wird,kannangehobenwerden.DasimRahmenderStudienarbeitverwendeteIntervall
von 10 Minuten ist bei einem produktiven Einsatz1kaum n√∂tig und kann beispielswei-
se auf eine st√ºndliche Messung erweitert werden. Somit verbringen die LoRaNodes
nochmehr Zeit im energieeÔ¨Ézienten Deep Sleep. In Folge sinkt der durchschnittliche
Energieverbrauch der LoRaNodes und die Batterielaufzeit verl√§ngert sich.
‚Ä¢Im letzten Schritt kann ggf. eine gr√∂√üere Batteriekapazit√§t gew√§hlt werden, dies
steigert jedoch auch die Kosten pro LoRaNode.";0
4.8 Anomalieerkennung Die Cluster k√∂nnen nun mit durchschnittlichen Zeiten versehen werden, beispielsweise schl√§ft die zu betreuende Person √ºblicherweise acht Stunden und verbringt 20 Minuten in der Dusche. Auf diese Weise kann dann f√ºr jeden Ort individuell gelernt werden, wann ein Alarm ausgel√∂st werden muss. Ein Nachteil dieses Konzepts ist, dass ein neuer Anwender eine Einlernphase des Systems durchlaufen muss, bevor St√ºrze beziehungsweise Anomalien im Datensatz erkannt wer- den k√∂nnen. Um hierf√ºr den minimalen Zeitraum zu finden, k√∂nnte in einem gr√∂√üeren Versuchsaufbau mit mehreren Probanden deren Bewegung √ºber mehrere Wochen aufge- zeichnet und die Daten dann mithilfe einer Spektralanalyse ausgewertet werden. So k√∂nnte wissenschaftlich gepr√ºft werden, mit welcher Frequenz sich die Routinen von Nutzern wiederholen. Um den Entwicklungsaufwand so gering wie m√∂glich zu gestalten, k√∂nnte ein Vorf√ºhraufbau auch mit manuell erstellten und gelabelten Clustern verwendet werden. Damit ist gemeint, dass die Bereiche manuell mit √ºblichen Aufenthaltsdauern versehen werden. So kann selbst bestimmt werden, dass nach neun Stunden im Schlafzimmer oder nach 30 Minuten im Bad die Sturzerkennung ausschlagen soll. Zudem k√∂nnen diese Zeiten uhrzeitabh√§ngig sein, da beispielsweise acht Stunden im Schlafzimmer nachts nicht un√ºblich sind, tags√ºber jedoch vier Stunden bereits verd√§chtig wirken. Ein in Zukunft marktreifes Produkt m√ºsste diese Informationen jedoch vollst√§ndig auto- matisch erlernen, da ansonsten der gr√∂√üte Mehrwert dieses Ansatzes, die geringen Kosten, durch die Arbeitszeit bei der Installation verloren gehen w√ºrde.;0
Die St√§rken von Drupal liegen deutlich in der Benutzerfreundlichkeit und einfachen Hand- habung des Systems. √Ñhnlich zu WordPress k√∂nnen erste Inhalte m√ºhelos erstellt und im Frontend (gerenderte Website-Darstellung) angezeigt werden. Konkrete Abweichungen bzw. Anpassungen an einer Drupal-Installation bedingen hingegen Fachwissen und Ressourcen, beispielsweise bei der Umsetzung eines Social-Community-Portals.  In Bezug auf den Anwendungsfall der Holzbau Mustermann GmbH l√§sst sich Joomla als hervorragend geeignetes Content Management System f√ºr die benutzerfreundliche Umsetzung einer Unternehmenswebsite kategorisieren. Durch die einfache Handhabung des √ºbersichtlichen Administrator-Backends und der m√ºhelosen Installation von Erweiterun- gen, sowie dem klar definierten Berechtigungssystem sind ersten Erfolgen keine Grenzen gesetzt.;0
 Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Konzept zur Umsetzung     In der heutigen digitalen Welt nehmen Internet of Things (IoT)-Anwendungen eine zentrale Rolle ein und beeinflussen unterschiedlichste Lebens- und Arbeitsbereiche. Die Nachfrage nach robusten, skalierbaren und wartungsfreundlichen Plattformen ist somit von entscheidender Bedeutung. Eine vielversprechende Technologie in diesem Bereich stellt ElixirNerves dar. Diese auf der Programmiersprache Elixir basierende Plattform bietet eine Vielzahl von Werkzeugen und Frameworks, die die Entwicklung von IoT-Anwendungen erleichtern sollen. In diesem Beitrag wird ein Konzept zur Umsetzung von IoT-Anwendungen unter Verwendung von ElixirNerves entwickelt und verschiedene relevante Aspekte der Plattform evaluiert.   Hintergrund und Motivation  Die Entwicklung von IoT-Anwendungen erfordert nicht nur die Programmierung von Software, sondern auch die Ber√ºcksichtigung von Hardware-Komponenten, Kommunikationsprotokollen und Sicherheitsaspekten. ElixirNerves vereint diese Elemente in einem modularen Ansatz und bietet Entwicklern die M√∂glichkeit, robuste Anwendungen zu erstellen, die auf einer Vielzahl von Hardware-Plattformen laufen k√∂nnen. Durch die Nutzung von Elixirs funktionaler Programmierung und seiner hohen Effizienz in der Verarbeitung von nebenl√§ufigen Prozessen verspricht ElixirNerves eine vielversprechende Grundlage f√ºr die Realisierung modernster IoT-L√∂sungen.   Evaluationskriterien  Um die Eignung von ElixirNerves als Plattform f√ºr IoT-Anwendungen zu bewerten, werden folgende Kriterien herangezogen 1. Modularit√§t und Flexibilit√§tDie M√∂glichkeit, verschiedene Hardware- und Softwaremodule zu kombinieren. 2. EntwicklungsressourcenVerf√ºgbarkeit von Dokumentationen und Community-Support. 3. SicherheitsmechanismenImplementierung von Sicherheitsprotokollen zum Schutz gegen Cyberangriffe. 4. Leistung und EffizienzDie F√§higkeit, auch unter Ressourcenbeschr√§nkungen leistungsstarke Anwendungen zu entwickeln. 5. Langzeitpflege und WartbarkeitGarantiere durch das √ñkosystem f√ºr zuk√ºnftige Entwicklungen.   Konzept zur Umsetzung   1. Anforderungsanalyse  Vor der technischen Umsetzung ist eine detaillierte Anforderungsanalyse n√∂tig. Hierbei sollten die spezifischen Bed√ºrfnisse der Zielanwendungen erfragt werden. Dazu geh√∂ren - Geplante Funktionalit√§ten (z.B. Datenlogger, Sensor√ºberwachung, Aktuatorsteuerung). - Anwendungsumfeld (Industrie, Smart Home, Medizintechnik). - Gew√ºnschte Kommunikationsprotokolle (z.B. MQTT, HTTP, CoAP).   2. Hardwareauswahl  Auf Basis der Anforderungsanalyse sollte die geeignete Hardware ausgew√§hlt werden. ElixirNerves unterst√ºtzt verschiedene Plattformen wie Raspberry Pi, BeagleBone und NervesHub (als Firmware-Management-Tool). Bei der Auswahl sind folgende Faktoren zu ber√ºcksichtigen - Verf√ºgbarkeit von Schnittstellen (GPIO, I2C, SPI). - Energieverbrauch und Ressourcenbedarf der Hardware. - Preis-Leistungs-Verh√§ltnis und Verf√ºgbarkeit.   3. Softwarearchitektur  Die Entwicklung der Softwarearchitektur erfolgt gem√§√ü dem modularen Prinzip. ElixirNerves erm√∂glicht die Erstellung von Anwendungen in Form von ¬´Nerves-Projekten¬ª, die in skalierbare Module unterteilt werden. Dies umfasst - Sensor- und AktormoduleDie Implementierung von Treibern zur Kommunikation mit der Hardware. - KommunikationsmoduleEinrichtung von Kommunikationsprotokollen zur Daten√ºbertragung in Netzwerken. - DatenverarbeitungImplementierung von Algorithmen zur Analyse und Bearbeitung der gesammelten Daten.   4. Sicherheitsarchitektur  Die Implementierung von Sicherheitsma√ünahmen ist unerl√§sslich. Die Architektur sollte Folgendes umfassen - Verschl√ºsselungVerwendung von TLS f√ºr die Daten√ºbertragung. - Authentifizierung und AutorisierungIntegration von OAuth oder √§hnlichen Frameworks zur Benutzer- und Zugriffsverwaltung. - Regelm√§√üige UpdatesFestlegung von Strategien zur √úberwachung und Aktualisierung der Firmware.   5. Test und Deployment  Die finalen Tests sollten sowohl Unit- als auch Integrationstests beinhalten, um die Funktionalit√§t und Sicherheit der Anwendung zu verifizieren. Das Deployment erfolgt √ºber NervesHub, was eine einfache Verwaltung und Aktualisierung der Firmware in der Produktion erm√∂glicht.   Fazit  Die Evaluation von ElixirNerves zeigt, dass die Plattform signifikante Vorteile f√ºr die Entwicklung von IoT-Anwendungen bietet. Die modularen Ans√§tze erm√∂glichen eine flexible Anpassung an verschiedene Anforderungen, w√§hrend die funktionalen Eigenschaften von Elixir eine effiziente Umsetzung garantieren. Das vorgestellte Konzept zur Umsetzung bietet eine strukturierte Herangehensweise an die Entwicklung und Integration von IoT-L√∂sungen. Sicherlich bedarf es weiterer empirischer Studien zur Langzeitleistung und -sicherheit, jedoch stellt ElixirNerves eine vielversprechende Wahl f√ºr moderne IoT-Projekte dar.;1
Wie bereits im Abschnitt Responsive-Design zu Joomla erw√§hnt, kann das System mit dem popul√§ren Theme ‚ÄûHelix 3‚Äú √§hnlich zu WordPress und Drupal gestaltet und nach Belieben angepasst werden. Neben Helix stehen diverse andere kostenfreie sowie kostenpflichtige Templates zur Verf√ºgung. Diese k√∂nnen √ºber die jeweilige Website des Herausgebers erworben, heruntergeladen und ebenfalls, wie von den drei anderen CMSbekannt, per ZIP-Upload installiert werden. Gerade bei popul√§ren Themes wird keinerlei Programmierkenntniss von den Nutzern verlangt, da Anpassungen wie etwa das √Ñndern von Schriftarten oder Farben innerhalb der Administrationsoberfl√§che direkt im Browser vorgenommen werden k√∂nnen. Ein Austausch von Stylesheets ist hierbei nicht oder nur in besonderen F√§llen, beispielsweise bei der √Ñnderung von Bildschirm-Breakpoints, notwendig. Abbildung 5.15: Ansicht der Verwaltungsoberfl√§che des Helix3-Themes. Zu sehen ist die Oberfl√§- che f√ºr die Verwaltung von Schriftarten.1 Aufgrund der fehlenden Integration eines zentralen Theme-Repository durch Joomla als Herausgeber des Systems und der ausschlie√ülich √ºber Datei-Upload m√∂glichen Instal- lation wird das Content Management System im Zusammenhang zum beschriebenen Anwendungsfall mit der Kategorie Gelb eingestuft.;0
Die Android App ist zust√§ndig f√ºr die Verwaltung der Katzenklappen aus der Benutzerseite. Dabei erh√§lt der Nutzer bei einer erkannten Katze eine Benachrichtigung. In der App wird au√üerdem ein Bild der erkannten Katze angezeigt, damit der Benutzer entscheiden kann, ob es sich um seine Katze handelt. Falls dies der Fall ist kann der Nutzer die Katzenklappe durch die App √∂ffnen. Wenn der Nutzer schl√§ft und auf die Benachrichtigung nicht reagieren kann, wird eine standardm√§√üige Aktion ausgef√ºhrt. Ob diese Aktion bedeutet, dass die Katzenklappe ge√∂ffnet oder geschlossen bleibt, soll sp√§ter in der App f√ºr jede angelegte Katzenklappe individuell einstellbar sein. Aktuell ist diese allerdings in einer Konfigurationsdatei im Raspberry Pi definiert. Diese Sektion zeigt die Architektur der App. Dabei wird anhand eines Mockups der Aufbau der App beschrieben.;0
"1.2 Problemstellung
F√ºr einen Einsatz in Smart Cities muss in jedem PÔ¨Çanzenk√ºbel innerhalb der Stadt ein
Bodenfeuchtigkeitssensor angebracht werden. Die Messwerte dieser Bodenfeuchtigkeits-
sensoren sollen jedoch an einer zentralen Stelle abrufbar sein, sodass die zust√§ndigen
Mitarbeiter der Stadt eine √úbersicht √ºber die zu gie√üenden PÔ¨Çanzenbeete erhalten k√∂nnen.
Das Legen von passenden Kabeln zu jedem PÔ¨Çanzenk√ºbel ist mit erheblichem Aufwand
und Kosten verbunden. Gesucht wird daher nach einer L√∂sung, die einen Batteriebetrieb
der Sensoren √ºber einen langen Zeitraum, sowie eine drahtlose √úbermittlung der Messwerte
erm√∂glicht.
1.3 Ziel
Ziel der Arbeit ist das Tracking der Bodenfeuchtigkeit in PÔ¨Çanzen- bzw. Blumenbeeten. Die
Messergebnisse sollen dabei per LoRaWAN an das The Things Network ( TTN) gesendet
werden. Es gilt geeignete Hardware f√ºr einen batteriebetriebenen LoRaNode auszuw√§hlen
und einen passende Bodenfeuchtigkeitssensor zu verwenden, der valide Messergebnisse
liefert. Nach Auswahl der passenden Hardware f√ºr den LoRaNode soll dieser f√ºr das
Tracking der Bodenfeuchtigkeit programmiert und in das TTNNetzwerk aufgenommen
werden. Der LoRaNode soll im Verlauf der Studienarbeit √ºber mehrere Monate betrieben
werden, um ausreichend Messergebnisse zu sammeln und Aussagen zur Batterielaufzeit
treÔ¨Äen zu k√∂nnen. Zudem sollen Konzepte zur Speicherung und Visualisierung der Mess-
ergebnisse erarbeitet werden. Da in der Wohngegend der Studierenden keine dem TTN
zugeh√∂rigen Gateways vorhanden sind, gilt es im Rahmen der Studienarbeit mehrere
Gateways in Betrieb zu nehmen. Bei einem Reichweitentest soll die Reichweite der in
Betrieb genommenen Gateways miteinander verglichen werden.";0
Zur Entwicklung des Kommunikationsprotokolls zur Kommunikation zwischen der Fahr- zeugfernsteuerung und dem Fahrzeugcontroller soll zuerst der Protokollstack (aufbauend auf dem IEEE802.15.4-Stack) festgelegt werden. Dazu sollen zun√§chst die verschiedenen Protokollstacks auf Basis von IEEE802.15.4 mit einer Literaturrecherche erarbeitet und vorgestellt werden. Hierbei wird auf den IEEE802.15.4-Stack nicht mehr dediziert einge- gangen, da dieser bereits in Abschnitt 2.5vorgestellt wurde. Anhand der Anforderungen soll dann ein Protokollstack auf Basis von IEEE802.15.4 ausgew√§hlt werden, wobei dieser auch als eigener Stack ohne Overhead zur Auswahl zur Verf√ºgung steht. Darauf aufbauend soll das eigentliche Protokoll zur Fahrzeugfernsteuerung entwickelt werden.;0
"Evaluierung der wissenschaftlichen Arbeit: ""Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes""  Einleitung: Die vorliegende Arbeit befasst sich mit der kontinuierlich wachsenden Herausforderung der Luftreinhaltung und der Optimierung von Luftreinigungsger√§ten durch innovative elektronische Erweiterungen. Angesichts der steigenden Luftverschmutzung und der damit verbundenen Gesundheitsrisiken ist die Entwicklung von effektiven und benutzerfreundlichen Technologien zur Verbesserung der Luftqualit√§t von gro√üer Bedeutung. Die Arbeit zielt darauf ab, die Visualisierung, Bedienung und Selbstregelung eines Luftreinigungsger√§tes zu verbessern, um eine effizientere Nutzung und Benutzererfahrung zu gew√§hrleisten.  Struktur und Inhalt: Die Arbeit gliedert sich in mehrere zentrale Abschnitte, darunter eine fundierte Einleitung in die Thematik, eine ausf√ºhrliche Analyse des aktuellen Stands der Technik, eine Beschreibung des Entwicklungsprozesses der elektronischen Erweiterungen sowie die Ergebnisse der durchgef√ºhrten Optimierungsma√ünahmen. Jede dieser Sektionen ist gut strukturiert und bietet eine logische Abfolge von Informationen, die den Leser durch die Thematik f√ºhrt.  Methodik: Die Methodik der Untersuchung ist klar und nachvollziehbar. Es werden sowohl qualitative als auch quantitative Ans√§tze verfolgt, um die Benutzerinteraktion zu analysieren und die Leistung des Ger√§tes zu messen. Die Verwendung von Benutzerumfragen und Usability-Tests zur Evaluierung der Bedienfreundlichkeit stellt sicher, dass Benutzerperspektiven angemessen ber√ºcksichtigt werden. Die Implementierung innovativer Visualisierungstechniken, wie die Verwendung von Benutzeroberfl√§chen und grafischen Anzeigen, wird gr√ºndlich beschrieben und unterst√ºtzt durch entsprechende technische Analysen.  Ergebnisse: Die Ergebnisse der Arbeit sind vielversprechend und zeigen signifikante Verbesserungen in der Visualisierung und Bedienung des Luftreinigungsger√§tes. Die Integration von Self-Regulating Mechanisms (SRM) f√ºhrt zu einer optimierten Luftreinigungsleistung in Abh√§ngigkeit von der Raumluftqualit√§t. Diese Anpassungsf√§higkeit wird durch experimentelle Daten untermauert, die die Effizienz der neuen Systeme belegen. Die Ergebnisse werden durch Diagramme und visuelle Darstellungen unterst√ºtzt, die das Verst√§ndnis der theoretischen und praktischen Aspekte der Forschung erleichtern.  Diskussion: In der Diskussion der Ergebnisse wird reflektiert, welche Herausforderungen w√§hrend des Optimierungsprozesses aufgetreten sind und wie diese √ºberwunden wurden. Die Autoren ziehen sinnvolle Schlussfolgerungen √ºber die Relevanz ihrer Ergebnisse im Kontext der bestehenden Literatur und identifizieren Perspektiven f√ºr zuk√ºnftige Forschung. Dabei wird auch auf m√∂gliche Limitationen der Studie hingewiesen, was die wissenschaftliche Solidit√§t der Arbeit verst√§rkt.  Fazit: Zusammenfassend l√§sst sich festhalten, dass die wissenschaftliche Arbeit einen wesentlichen Beitrag zur Optimierung von Luftreinigungsger√§ten durch elektronische Erweiterungen leistet. Sie verbindet theoretische Grundlagen mit praktischen Anwendungen und bietet sowohl wissenschaftliche als auch praktische Implikationen. Die vorgestellten Optimierungen in Bezug auf Visualisierung, Bedienung und Selbstregelung sind gut fundiert und tragen zur Verbesserung der Benutzererfahrung und der Effizienz bei.  Empfehlungen: F√ºr zuk√ºnftige Arbeiten k√∂nnte eine erweiterte Langzeitstudie zur Evaluation der Nachhaltigkeit der Implementierungen empfohlen werden. Dar√ºber hinaus w√§re es sinnvoll, ein gr√∂√üeres Nutzersegment einzubeziehen, um noch breitere Daten zur Benutzerakzeptanz zu sammeln. Eine verst√§rkte Interdisziplinarit√§t, etwa durch die Einbindung von Ergonomie-Experten, k√∂nnte ebenfalls zur weiteren Optimierung beitragen.";1
      Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, stellt eine innovative Plattform dar, die in verschiedenen Anwendungsbereichen, wie z.B. im Bildungssektor oder im Kundenservice, eingesetzt werden kann. Die programmiertechnische Gestaltung von Apps f√ºr Pepper erfordert spezialisierte Kenntnisse, die viele potenzielle Nutzer, insbesondere im Bildungsbereich, nicht besitzen. Daher wird der Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps f√ºr Pepper als wertvoller Ansatz betrachtet, um die Zug√§nglichkeit und Benutzerfreundlichkeit zu erh√∂hen.   Projektbeschreibung  Das zu entwickelnde CMS k√∂nnte eine webbasierte Software sein, die es Nutzern erm√∂glicht, intuitiv Applikationen f√ºr Pepper zu erstellen, ohne tiefgehende Programmierkenntnisse zu ben√∂tigen. Die Benutzeroberfl√§che sollte Drag-and-Drop-Funktionalit√§ten bieten, um verschiedene Module und Interaktionen visuell zusammenzustellen. Zudem sollte das CMS √ºber Vorlagen verf√ºgen, die spezifische Anwendungsf√§lle abdecken, beispielsweise zur Interaktion mit Benutzern oder zur Verarbeitung von Anfragen.  Das Projekt besteht aus mehreren PhasenBedarfsanalyse, Entwurf der Benutzeroberfl√§che, Implementierung der Back-End-Logik und schlie√ülich das Testen und die Rollout-Phase. Besonderes Augenmerk muss auf die Integrationsf√§higkeit mit dem Robotersystem gelegt werden, um sicherzustellen, dass die erstellten Apps sowohl auf technischer als auch auf funktionaler Ebene nahtlos mit Pepper kommunizieren.   Fazit  Im Rahmen dieses Projekts zeigt sich, dass der  weitreichende positive Auswirkungen haben k√∂nnte. Die Anwendung eines solchen Systems macht die Entwicklung von Apps deutlich zug√§nglicher f√ºr ein breiteres Publikum, insbesondere f√ºr Lehrkr√§fte und kreative Minds, die das Potenzial von Pepper in ihren Anwendungsgebieten aussch√∂pfen m√∂chten.   Das CMS k√∂nnte einen Paradigmenwechsel in der Art und Weise darstellen, wie Nutzer mit Robotern interagieren und wie diese Technologien in allt√§gliche Abl√§ufe integriert werden. Durch die Reduzierung der technischen H√ºrden k√∂nnte das Engagement und die Kreativit√§t bei der Entwicklung von Anwendungen f√ºr Pepper gef√∂rdert werden. Die benutzerfreundliche Gestaltung des CMS w√ºrde nicht nur die Produktivit√§t der Entwickler steigern, sondern auch die Verbreitung von Robotik-Technologien in sozialen, bildungs- und gesch√§ftsorientierten Kontexten erh√∂hen.  Zusammenfassend l√§sst sich sagen, dass der Erfolg eines solchen CMS vor allem von dessen Benutzerfreundlichkeit, Flexibilit√§t und der Qualit√§t der bereitgestellten Vorlagen abh√§ngt. Zuk√ºnftige Forschungsarbeiten sollten sich auf die Feedbackmechanismen konzentrieren, um iterativ zu verbessern, sowie auf die Schulung der Nutzer, um das volle Potenzial des CMS auszusch√∂pfen. Mit der richtigen Herangehensweise k√∂nnte dieses Projekt einen signifikanten Beitrag zur n√§chsten Generation der Mensch-Roboter-Interaktionen leisten.;1
"Evaluierung: ""Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung""  Die digitale √úberwachung hat in den letzten Jahren zunehmend an Bedeutung gewonnen und pr√§gt nicht nur den √∂ffentlichen Diskurs, sondern auch die wissenschaftliche Auseinandersetzung mit den damit verbundenen M√∂glichkeiten und Gefahren. In der vorliegenden Arbeit mit dem Titel ""Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung"" wird ein umfassender √úberblick √ºber die komplexen Aspekte dieser Thematik gegeben. Die Autorin/der Autor beleuchtet sowohl die technologischen Fortschritte, die eine weitreichende √úberwachung erm√∂glichen, als auch die ethischen und gesellschaftlichen Implikationen, die sich daraus ergeben.  Ein zentraler Aspekt der Arbeit ist die Differenzierung zwischen den Chancen, die digitale √úberwachung bieten kann, und den Risiken, die sie mit sich bringt. Die Autorin/der Autor argumentiert √ºberzeugend, dass digitale √úberwachung in bestimmten Kontexten, wie etwa der Verbrechensbek√§mpfung oder der Terrorismuspr√§vention, potenziell positive Effekte haben kann. Durch den Einsatz moderner Technologien wie K√ºnstlicher Intelligenz und Big Data k√∂nnen Muster erkannt und fr√ºhzeitig auf Bedrohungen reagiert werden. Diese Perspektive wird durch zahlreiche Fallstudien untermauert, die die Wirksamkeit von √úberwachungssystemen in der Praxis illustrieren.  Gleichzeitig wird jedoch nicht vernachl√§ssigt, dass die digitale √úberwachung auch erhebliche Gefahren birgt. Die Arbeit thematisiert die potenzielle Verletzung der Privatsph√§re, die durch anomische Datensammlungen und die unkontrollierte Nutzung pers√∂nlicher Informationen entsteht. Die Autorin/der Autor f√ºhrt anschauliche Beispiele an, die die Gefahren des Missbrauchs von √úberwachungstechnologien verdeutlichen, und diskutiert die Herausforderungen, die sich aus der unzureichenden Regulierung und dem Fehlen transparenter Kontrollmechanismen ergeben. Diese kritische Auseinandersetzung wird durch aktuelle Forschungsergebnisse und gesellschaftliche Debatten erg√§nzt, die die Notwendigkeit eines verantwortungsvollen Umgangs mit digitalen √úberwachungsinstrumenten unterstreichen.  Ein weiterer wichtiger Punkt der Arbeit ist die Analyse der gesellschaftlichen Wahrnehmung von √úberwachung. Die Autorin/der Autor zeigt auf, wie unterschiedliche gesellschaftliche Gruppen ‚Äì von Datenschutzaktivisten bis hin zu Sicherheitsbeh√∂rden ‚Äì divergierende Ansichten √ºber die Akzeptanz und Notwendigkeit digitaler √úberwachung haben. Diese Divergenz wird als ein zentrales Spannungsfeld dargestellt, das f√ºr zuk√ºnftige politische Entscheidungen und gesellschaftliche Debatten von Bedeutung ist.  Insgesamt bietet die Arbeit ""Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachung"" eine fundierte und differenzierte Betrachtung eines hochaktuellen Themas. Die gelungene Kombination aus theoretischen √úberlegungen, praktischen Beispielen und kritischen Analysen macht die Arbeit sowohl f√ºr Fachleute als auch f√ºr interessierte Laien zug√§nglich. Die Autorin/der Autor regt dazu an, sich intensiver mit den ethischen und gesellschaftlichen Dimensionen der digitalen √úberwachung auseinanderzusetzen und sensibilisiert f√ºr die Notwendigkeit eines ausgewogenen Ansatzes, der sowohl die Sicherheitsinteressen als auch die Rechte des Individuums ber√ºcksichtigt.   In Anbetracht der fortschreitenden Digitalisierung und der damit einhergeh";1
 Die Softwarequalit√§t ist ein entscheidender Faktor f√ºr den Erfolg von Softwareprojekten. Um die Qualit√§t von Softwareprodukten zu bewerten, sind produktorientierte Metriken von zentraler Bedeutung. Diese Metriken beziehen sich auf die Eigenschaften des Softwareprodukts selbst und erm√∂glichen eine objektive Analyse und Bewertung der Softwarequalit√§t. In diesem Text wird zun√§chst die Definition produktorientierter Metriken er√∂rtert, gefolgt von der Diskussion ihrer Anwendung und der  zur Messung dieser Metriken.  Definition produktorientierter Metriken  Produktorientierte Metriken sind quantifizierbare Ma√üe, die spezifische Attribute von Softwareprodukten beschreiben. Sie konzentrieren sich auf verschiedene Dimensionen der Softwarequalit√§t, darunter Funktionalit√§t, Zuverl√§ssigkeit, Benutzerfreundlichkeit, Effizienz, Wartbarkeit und Portabilit√§t. Zu den g√§ngigen produktorientierten Metriken z√§hlen beispielsweise die Anzahl der Codezeilen, die Komplexit√§t des Codes (gemessen durch Metriken wie Cyclomatic Complexity), die Anzahl der Fehler pro KLOC (Thousand Lines of Code) sowie die Testabdeckung. Diese Metriken bieten wertvolle Einblicke in den aktuellen Stand der Softwarequalit√§t und erm√∂glichen es, potenzielle Schwachstellen fr√ºhzeitig zu identifizieren.  Anwendung produktorientierter Metriken  Die Anwendung produktorientierter Metriken erfolgt in verschiedenen Phasen des Softwareentwicklungsprozesses. W√§hrend der Planungs- und Entwurfsphase k√∂nnen Metriken verwendet werden, um die Qualit√§t von Designentscheidungen zu bewerten. In der Implementierungsphase dienen sie dazu, die Codequalit√§t zu √ºberwachen und sicherzustellen, dass die entwickelten Komponenten den definierten Standards entsprechen. In der Testphase erm√∂glichen sie eine objektive Bewertung der Testabdeckung und der gefundenen Fehler. Dar√ºber hinaus k√∂nnen produktorientierte Metriken auch im Rahmen von Continuous Integration und Continuous Deployment (CI/CD) eingesetzt werden, um sicherzustellen, dass neue Code√§nderungen die bestehende Softwarequalit√§t nicht beeintr√§chtigen.    Um die genannten Metriken effizient zu erfassen und auszuwerten, ist die  sinnvoll. Diese L√∂sung sollte in der Lage sein, die relevanten Metriken automatisch zu sammeln, zu analysieren und darzustellen. Ein m√∂glicher Ansatz ist die Entwicklung eines Tools, das in den bestehenden Softwareentwicklungsprozess integriert wird. Die folgenden Schritte skizzieren den Implementierungsprozess 1. AnforderungsanalyseZun√§chst m√ºssen die spezifischen Anforderungen an das Metrik-Tool definiert werden. Dazu geh√∂rt die Festlegung, welche Metriken erfasst werden sollen und in welchem Format die Ergebnisse pr√§sentiert werden.  2. TechnologieauswahlBasierend auf den Anforderungen sollte die geeignete Technologie ausgew√§hlt werden. Programmiersprachen wie Python oder Java bieten sich an, um ein flexibles und leistungsf√§higes Tool zu entwickeln. Zudem k√∂nnten bestehende Bibliotheken zur Metrikberechnung (z.B. SonarQube f√ºr statische Codeanalyse) in die L√∂sung integriert werden.  3. DatenakquiseDas Tool sollte in der Lage sein, Daten aus verschiedenen Quellen zu erfassen, darunter Versionskont;1
Die Layoutgestaltung einer Anwendung dreht sich grundlegend um die Positionierung einzelner Elemente auf einer Seite . Dabei hat in der konventionel- len App-Entwicklung in den letzten Jahren vor allem das ConstraintLayout vermehrt Anwendung erfahren. Es erlaubt das Erstellen von responsiven BenutzeroberÔ¨Ç√§chen in unterschiedlichen Gr√∂√üen und Ausrichtungen, indem es beispielsweise dynamische Ab- st√§nde und verkettete UI-Elemente einsetzt . Auch bei der Verwendung von Compose ist es m√∂glich, mithilfe eines ConstraintLayouts gro√üe und komplexe Layouts zu erstellen. F√ºr die Umsetzung der M√∂glichkeit setzt das Framework auf die Verwendung einer Domain SpeciÔ¨Åc Language ( DSL), da kein XML-File vorhanden ist. Allerdings handelt es sich dabei nicht um den empfohlenen Ansatz zur Layoutgestaltung, da Compose dazu in der Lage ist, auch tiefe Layout-Hierarchien eÔ¨Ézient handhaben zu k√∂nnen . Das etablierte und empfohlene Layoutsystem von Compose verfolgt haupts√§chlich das Ziel, mit einer hohen Performance eine einfache M√∂glichkeit zu bieten, CustomLayouts zu erstellen . Hierf√ºr gibt es drei Grundbausteine, die dabei helfen, eigene Layouts m√∂glichst schnell und einfach umzusetzen . Beispielweise beinhaltet das im folgenden Listing 3.5 verein- facht dargestellte Composable DrawBeanRow() aus der CoÔ¨ÄeeCompose Anwendung zwei dieser drei Grundbausteine.;0
 Kapitel 2: Technische Grundlagen der digitalen √úberwachung  Die digitale √úberwachung ist ein facettenreiches Ph√§nomen, das auf einer Vielzahl technischer Grundlagen beruht. Um die M√∂glichkeiten und Gefahren dieser Form der √úberwachung zu verstehen, ist es unerl√§sslich, die zugrunde liegenden Technologien und deren Funktionsweise zu beleuchten. In diesem Kapitel werden die zentralen Komponenten der digitalen √úberwachung untersucht, einschlie√ülich der verwendeten Hardware, Software und Netzwerktechnologien.   2.1 Sensoren und Datenerfassung  Im Zentrum der digitalen √úberwachung stehen Sensoren, die in der Lage sind, Daten aus der physischen und digitalen Welt zu erfassen. Diese Sensoren k√∂nnen in verschiedenen Formen auftreten, darunter Kameras, Mikrofone, GPS-Tracker und Internet-of-Things (IoT)-Ger√§te. Kameras sind oft mit Gesichtserkennungstechnologien ausgestattet, die es erm√∂glichen, Personen in Echtzeit zu identifizieren. Mikrofone k√∂nnen nicht nur Sprache aufzeichnen, sondern auch Umgebungsger√§usche analysieren, um Muster im Verhalten von Individuen zu erkennen.  IoT-Ger√§te, die zunehmend in Haushalten und √∂ffentlichen R√§umen verbreitet sind, stellen eine weitere Quelle f√ºr Daten dar. Diese Ger√§te sammeln kontinuierlich Informationen √ºber Nutzerverhalten, Pr√§ferenzen und Interaktionen. Die Vernetzung dieser Ger√§te erm√∂glicht eine umfassende √úberwachung, da sie Daten in Echtzeit an zentrale Server √ºbermitteln.   2.2 Daten√ºbertragung und -speicherung  Die erfassten Daten m√ºssen zur Analyse und Speicherung an zentrale Systeme √ºbertragen werden. Hierbei kommen verschiedene Kommunikationsprotokolle und Netzwerktechnologien zum Einsatz. Die √úbertragung kann √ºber kabelgebundene Netzwerke (z. B. Ethernet) oder drahtlose Netzwerke (z. B. WLAN, Mobilfunknetze) erfolgen. Die Wahl der Technologie beeinflusst die Geschwindigkeit und Sicherheit der Daten√ºbertragung.  Ein zentrales Element der digitalen √úberwachung ist die Speicherung der gesammelten Daten. Cloud-Computing hat die Art und Weise revolutioniert, wie Daten gespeichert und verarbeitet werden. Anbieter von Cloud-Diensten erm√∂glichen es, gro√üe Datenmengen effizient zu speichern und zu analysieren. Diese zentralisierte Speicherung birgt jedoch auch Risiken, insbesondere im Hinblick auf Datenschutz und Datensicherheit. Angriffe auf Cloud-Systeme k√∂nnen zu Datenlecks f√ºhren und die Privatsph√§re von Individuen gef√§hrden.   2.3 Datenanalyse und K√ºnstliche Intelligenz  Die Analyse der gesammelten Daten ist entscheidend f√ºr die digitale √úberwachung. Hier kommen fortschrittliche Algorithmen und K√ºnstliche Intelligenz (KI) zum Einsatz. Machine Learning-Modelle k√∂nnen Muster in gro√üen Datenmengen erkennen und Vorhersagen √ºber zuk√ºnftiges Verhalten treffen. Diese Technologien sind in der Lage, aus den gesammelten Daten wertvolle Erkenntnisse zu gewinnen, die f√ºr Sicherheitsbeh√∂rden, Unternehmen und andere Organisationen von Bedeutung sind.  Allerdings gibt es auch erhebliche Bedenken hinsichtlich der Genauigkeit und Fairness dieser Algorithmen. Vorurteile in den Trainingsdaten k√∂nnen zu diskriminierenden Ergebnissen f√ºhren, die bestimmte Bev√∂lkerungsgruppen benachteiligen. Dies wirft grundlegende ethische Fragen auf, die im Kontext der digitalen √úberwachung kritisch hinterfragt werden m√ºssen.   2.;1
In der heutigen digitalen Landschaft ist die Wahl der geeigneten Technologie f√ºr die Entwicklung von Anwendungen von entscheidender Bedeutung. Insbesondere im Kontext von mobilen Anwendungen, die in den letzten Jahren exponentiell an Bedeutung gewonnen haben, stellt sich h√§ufig die Fragestellung, ob native Apps oder Progressive Web Apps (PWAs) die bessere L√∂sung sind. PWAs kombinieren die Vorteile des Webs mit denen nativer Anwendungen und versprechen Zug√§nglichkeit, Benutzerfreundlichkeit und plattform√ºbergreifende Kompatibilit√§t. Im Gegensatz dazu bieten native Apps oft eine optimierte Performance, spezifische Ger√§tegruppenfeatures und eine tiefere Integration in das Betriebssystem des Ger√§ts.   Diese Arbeit untersucht die beiden Ans√§tze am Beispiel einer Journaling-App, die Nutzern erm√∂glicht, ihre Gedanken und Erfahrungen digital festzuhalten. Journaling-Apps konfrontieren Entwickler mit spezifischen Anforderungen hinsichtlich Benutzerfreundlichkeit, Sicherheit und Langzeitnutzung, die sowohl f√ºr native als auch f√ºr PWA-L√∂sungen von zentraler Bedeutung sind. Ziel dieser Studie ist es, die St√§rken und Schw√§chen beider Ans√§tze zu analysieren, um fundierte Empfehlungen f√ºr die Entwicklung von Journaling-Apps und √§hnlichen Anwendungen auszusprechen. Die Ergebnisse dieser Untersuchung sollen nicht nur Entwicklern, sondern auch Entscheidungstr√§gern in Unternehmen helfen, die geeignete Technologie f√ºr ihre spezifischen Bed√ºrfnisse zu w√§hlen.;1
 Kapitel: Technische Grundlagen  Im stetig wachsenden digitalen √ñkosystem nehmen Progressive Web Apps (PWAs) und native Apps eine zentrale Rolle ein, insbesondere im Bereich von personalisierten Anwendungen wie Journaling-Apps. In diesem Kapitel werden die technischen Grundlagen der beiden Ans√§tze skizziert und deren Unterscheidungsmerkmale hervorgehoben.   1. Definitionen und Abgrenzung  Native Apps sind Anwendungen, die f√ºr ein spezifisches Betriebssystem, wie iOS oder Android, entwickelt werden. Sie nutzen die jeweilige Programmiersprache ‚Äì Swift oder Objective-C f√ºr iOS und Java oder Kotlin f√ºr Android ‚Äì sowie die umfassenden Systemressourcen, die diese Plattformen bereitstellen. Native Apps k√∂nnen meistens √ºber die jeweils offizielle App-Store-Plattform heruntergeladen werden.   Im Gegensatz dazu sind Progressive Web Apps Webanwendungen, die mit Standard-Webtechnologien wie HTML, CSS und JavaScript realisiert werden und Verantwortung tragen, eine native App-artige Benutzererfahrung zu liefern. PWAs verwenden technische Prinzipien des modernen Webs und sind plattformunabh√§ngig, was bedeutet, dass sie auf verschiedenen Betriebssystemen und Ger√§ten gleich effektiv arbeiten k√∂nnen, solange ein webf√§higer Browser vorhanden ist.   2. Technische Merkmale  2.1. Entwicklungsframeworks und -technologien  F√ºr native Apps stehen spezifische Entwicklungsumgebungen bereit ‚Äì etwa Xcode f√ºr iOS und Android Studio f√ºr Android. Entwicklungs-Frameworks und Bibliotheken, wie React Native oder Flutter, bieten auch die M√∂glichkeit, plattform√ºbergreifende mobile Apps in einer gemeinsamen Codebasis zu erstellen. PWAs hingegen profitieren von modernen Webtechnologien, die den Einsatz von Frameworks wie Vue.js, Angular und React unterst√ºtzen. Diese Frameworks erm√∂glichen eine rasche und effiziente Entwicklung ansprechender Nutzeroberfl√§chen und garantieren gleichzeitig ein hohes Ma√ü an Interaktivit√§t.  2.2. Benutzererfahrungen und Schnittstellen  Die Benutzeroberfl√§chen beider Ans√§tze zeigen signifikante Unterschiede hinsichtlich Gestaltung und Usability. Nativen Apps erlauben die Verwendung hochgradig angepasster Schnittstellen, da sie sich nahtlos in das Sabber der jeweiligen Betriebssysteme integrieren. Sie haben die F√§higkeit, native Men√ºs, Gesten und andere Systemfunktionen intuitiv zu verbinden.  PWAs konkurrieren in diesem Bereich, indem sie responsives Design umsetzen und die Benutzererfahrung durch Progressive Enhancement verbessern. Trotz der Grenzen in der Zug√§nglichkeit zu einigen nativen Funktionen, wie zum Beispiel der Plattform-integrierten Kamera oder GPS, sind PWAs zufolge durch die Standard-API- und Service Worker-Architektur dazu in der Lage, folgende Aspekte einzubringen: Offline-Nutzung, Push-Benachrichtigungen und Home-Screen Installability.  2.3. Bereitstellung und Distribution  Die Bereitstellung zufriedenskund sehr unterschiedliche Wege. Native Apps verlassen sich auf App-Stores zur Distribution, was strengere √úberpr√ºfungsstellungen und anschlie√üende Updates requiert. Das verringert in der Regel die Reaktionszeit bei Anpassungen und Fehlerbehebungen. PWAs werden bequem direkt √ºber Browser geladen und k√∂nnen auch kontinuierlich aktualisiert werden, indem Entwickler Anpassungen am Server vornehmen.    3. Ressourcenmanagement und;1
REST steht f√ºr ‚ÄûRepresentational State Transfer‚Äú und wird zur √úbermittlung von Daten in verteilten Systemen verwendet. Ressourcen k√∂nnen √ºber verschiedene Methoden angelegt, gelesen, aktualisiert und gel√∂scht werden. Die Methoden sind zustandslos, somit werde zwischen den Anfragen keine Daten gespeichert. In der URI der Anfrage ist der Speicherort und der Name der Ressource angegeben. Jede Anfrage ist in sich vollst√§ndig und ben√∂tigt keine weiteren Informationen. Methoden mit denen auf die Ressource zugegriÔ¨Äen werden k√∂nnen sind : ‚Ä¢GET: Die Get Methode fordert eine angegebene Ressource an. Der Zustand der Ressource auf dem Server wird dabei nicht ver√§ndert. ‚Ä¢POST: Die Post Methode f√ºgt eine neue Ressource dem Server hinzu. Der Server speichert die neuen Daten und erstellt eine URI. Diese URI wird als Ergebnis dem Client zur√ºckgegeben. ‚Ä¢PUT: Bei der Put Methode wird die in der URI angegebene Ressource angelegt. Existiert diese bereits wird die existierende Ressource ge√§ndert. ‚Ä¢PATCH : Mit der Patch Methode kann ein Teil der angegebenen Ressource ge√§ndert werden. ‚Ä¢DELETE : Bei der Delete Methode wird die angegebene Ressource gel√∂scht. Damit eine Applikation als Restful bezeichnet werden kann m√ºssen sechs Bedingungen erf√ºllt werden.;0
  Die Qualit√§t von Software ist ein zentrales Thema in der Softwareentwicklung und wird durch eine Vielzahl von Faktoren beeinflusst. In der Softwaretechnik wird Qualit√§t h√§ufig in zwei Hauptkategorien unterteiltprozessorientierte und produktorientierte Metriken. W√§hrend prozessorientierte Metriken den Entwicklungsprozess selbst bewerten, konzentrieren sich produktorientierte Metriken auf die Eigenschaften des fertigen Softwareprodukts. Dieser Prosatext widmet sich der Definition und den theoretischen Grundlagen produktorientierter Metriken der Softwarequalit√§t sowie deren praktischen Anwendungen.   Definition produktorientierter Metriken  Produktorientierte Metriken sind quantifizierbare Ma√üe, die verwendet werden, um bestimmte Eigenschaften und Merkmale eines Softwareprodukts zu bewerten. Diese Metriken zielen darauf ab, die Qualit√§t des Softwareprodukts selbst zu messen, anstatt den Prozess seiner Erstellung zu analysieren. Zu den h√§ufigsten produktorientierten Metriken geh√∂ren unter anderem 1. KorrektheitMisst, inwieweit die Software die spezifizierten Anforderungen erf√ºllt. Hierbei k√∂nnen Testf√§lle verwendet werden, um zu √ºberpr√ºfen, ob die Software das erwartete Verhalten zeigt.     2. Zuverl√§ssigkeitBezieht sich auf die F√§higkeit der Software, unter bestimmten Bedingungen √ºber einen festgelegten Zeitraum hinweg korrekt zu funktionieren. Metriken wie die Mean Time Between Failures (MTBF) sind in diesem Kontext von Bedeutung.  3. BenutzbarkeitBewertet, wie einfach und intuitiv die Software f√ºr den Endbenutzer ist. Hierbei k√∂nnen Usability-Tests und Benutzerumfragen eingesetzt werden, um subjektive Eindr√ºcke zu quantifizieren.  4. EffizienzMisst den Ressourcenverbrauch der Software im Verh√§ltnis zu den erbrachten Leistungen. Dies kann durch Metriken wie die Antwortzeit oder den Speicherverbrauch quantifiziert werden.  5. WartbarkeitBezieht sich auf die Leichtigkeit, mit der Software angepasst oder erweitert werden kann. Metriken zur Wartbarkeit k√∂nnen Codekomplexit√§t und Dokumentationsgrad umfassen.  6. Portabilit√§tBewertet, wie einfach es ist, die Software auf verschiedenen Plattformen oder Umgebungen zu installieren und auszuf√ºhren.     Die theoretischen Grundlagen produktorientierter Metriken st√ºtzen sich auf verschiedene Konzepte der Informatik und Softwaretechnik. Ein zentraler Aspekt ist das Qualit√§tsmodell, das die unterschiedlichen Dimensionen der Softwarequalit√§t definiert. Ein bekanntes Modell ist das ISO/IEC 25010, welches acht Hauptmerkmale der Softwarequalit√§t identifiziertFunktionalit√§t, Zuverl√§ssigkeit, Benutzbarkeit, Effizienz, Wartbarkeit, Portabilit√§t, Sicherheit und Interoperabilit√§t. Jedes dieser Merkmale kann durch spezifische Metriken quantifiziert werden, die es erm√∂glichen, eine umfassende Bewertung der Softwarequalit√§t vorzunehmen.  Ein weiterer theoretischer Ansatz ist die Verwendung von Metriken zur Unterst√ºtzung des Softwareentwicklungsprozesses. Die Anwendung produktorientierter Metriken kann dazu beitragen, Schwachstellen in der Software zu identifizieren, die w√§hrend der Entwicklungsphase m√∂glicherweise √ºbersehen wurden. Diese Metriken bieten nicht nur eine M√∂glichkeit zur Bewertung der aktuellen Software;1
Eine Analyse und Fazit eines Entwicklungsprojekts    In der Welt der Softwareentwicklung hat die Wahl der Programmiersprache einen entscheidenden Einfluss auf Effizienz, Leistung und Wartbarkeit von Projekten. Insbesondere f√ºr die Entwicklung von Android-Anwendungen stehen Java und Kotlin als zwei der am h√§ufigsten verwendeten Sprachen im Vordergrund. W√§hrend Java √ºber zwei Jahrzehnte eine dominante Rolle gespielt hat, hat Kotlin in den letzten Jahren an Popularit√§t gewonnen und wird zunehmend von Entwicklern favorisiert. Im Rahmen eines konkreten Softwareprojekts haben wir die Vor- und Nachteile beider Sprachen getestet, um ein fundiertes Urteil √ºber deren jeweilige Eignung abzugeben.  Methodik  Das Projekt umfasste die Entwicklung einer Android-Anwendung zur Verwaltung pers√∂nlicher Finanzen. Die Entscheidung, sowohl Java als auch Kotlin zu verwenden, wurde getroffen, um die spezifischen St√§rken und Schw√§chen beider Sprachen vergleichend zu analysieren. Die Entwicklung wurde in zwei Phasen durchgef√ºhrtZun√§chst wurde der grundlegende Funktionsumfang der Anwendung in Java implementiert, gefolgt von einer Neuentwicklung der gleichen Funktionen in Kotlin.   Ergebnisse  1. Entwicklungsgeschwindigkeit und LesbarkeitKotlin erwies sich in der Implementierungsphase als die schnellere der beiden Sprachen. Die Syntax von Kotlin ist pr√§gnanter und erm√∂glicht durch moderne Sprachfeatures wie Extension Functions und Data Classes eine deutlich verbesserte Lesbarkeit des Codes. Dies f√ºhrte zu einer Reduktion der Gesamtanzahl von Codezeilen um circa 30 %. Im Vergleich dazu erforderte die Java-Implementierung h√§ufig l√§ngere Boilerplate-Codes.  2. SicherheitsmerkmaleKotlin bietet bessere Unterst√ºtzung f√ºr die Vermeidung von NullPointerExceptions durch die Einf√ºhrung von Null-Sicherheitsmechanismen. Dies f√ºhrte w√§hrend der Entwicklung zu einer signifikanten Reduktion von Runtime-Fehlern in der Kotlin-Version der Anwendung. Java hingegen, obwohl robust und weit verbreitet, bleibt anf√§llig f√ºr derartige Fehler, was zu zus√§tzlichen Debugging-Sitzungen in der Java-Implementierung f√ºhrte.  3. Interoperabilit√§tEin weiterer wichtiger Faktor der Analyse war die Interoperabilit√§t beider Sprachen. Kotlin ist so konzipiert, dass es nahtlos mit Java zusammenarbeitet. In unserem Projekt konnten wir problemlos bestehende Java-Bibliotheken in die Kotlin-Implementierung integrieren, was die Flexibilit√§t bei der Nutzung vorhandener Ressourcen betonte. Diese F√§higkeit ist besonders wertvoll f√ºr bestehende Projekte, die auf Java basieren und schrittweise auf Kotlin umgestellt werden sollen.  Fazit  Die Ergebnisse des Projekts verdeutlichen, dass Kotlin in der aktuellen Softwareentwicklungslandschaft als moderne Alternative zu Java einen signifikanten Vorteil bietet. Die klare und pr√§gnante Syntax sowie die verbesserten Sicherheitsmerkmale stellen allein schon √ºberzeugende Argumente f√ºr einen Wechsel dar. W√§hrend Java immer noch eine bew√§hrte und weit verbreitete Sprache ist, zeigen unsere Erfahrungen, dass die Effizienzsteigerungen und die h√∂here Codequalit√§t von Kotlin diese Sprache f√ºr neue Entwicklungsprojekte besonders attraktiv machen.  Insgesamt ist zu konstatieren, dass Kotlin nicht nur als Erg√§nzung zu Java fungiert, sondern in vielen Aspekten als √úberlegene zum aktuellen Stand der Android-Entwicklung angesehen werden kann. Entwickler und Unternehmen, die langfristige Wartbarkeit und Entwicklungseffizienz anstreben, sei daher geraten, Kotlin als erste Wahl in Betracht zu ziehen. Das Projekt hat somit nicht nur die St√§rken von Kotlin veranschaulicht, sondern auch den dringenden Bedarf an einer Modernisierung der eingesetzten Techniken in der Softwareentwicklung hervorgehoben.;1
 Kapitel 3: Erstellung eines Content Management Systems (CMS) f√ºr die Entwicklung von Android-Apps f√ºr den humanoiden Roboter Pepper   3.1 Einf√ºhrung  In den letzten Jahren hat sich die Nutzung humanoider Roboter in verschiedenen Anwendungsbereichen, einschlie√ülich Bildung, Pflege und Kundenservice, stark erweitert. Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, stellt eine Schnittstelle zwischen Mensch und Maschine dar und kann durch individuelle Programme und Apps auf verschiedene Anforderungen reagieren. Um die Effizienz der Entwicklung und Verwaltung dieser Apps zu erh√∂hen, wird ein spezielles Content Management System (CMS) ben√∂tigt. Dieses Kapitel beschreibt die Schritte zur Erstellung eines CMS, das die Entwicklung von Android-Apps f√ºr den Roboter Pepper erleichtert.   3.2 Anforderungen an das CMS  Bevor mit der technischen Umsetzung begonnen wird, m√ºssen die Anforderungen an das CMS klar definiert werden. Die wichtigsten Aspekte sind:  1. Benutzerfreundlichkeit: Das CMS sollte eine intuitiv bedienbare Benutzeroberfl√§che bieten, die es Entwicklern erm√∂glicht, schnell und einfach neue Apps zu erstellen und bestehende zu verwalten.     2. Flexibilit√§t: Es muss verschiedene Anforderungen unterst√ºtzen, von einfachen Dialoganwendungen bis hin zu komplexen Interaktionen mit APIs und Sensoren des Roboters.     3. Integration: Das CMS sollte sich nahtlos in die Entwicklungsumgebung f√ºr Android-Apps integrieren und grundlegende Tools bereitstellen, die die Programmierung und das Testen erleichtern.  4. Ressourcenmanagement: Das System sollte Funktionen zur Verwaltung von Mediendateien, Skripten, Bibliotheken und Dokumentationen bieten.  5. Meeting und Kollaboration: Um die Zusammenarbeit zwischen verschiedenen Entwicklern zu f√∂rdern, sollte das CMS Funktionen zur Versionierung und zur Verwaltung von Nutzerrollen beinhalten.   3.3 Technische Architektur  Die technische Architektur des CMS wird durch eine Client-Server-Struktur realisiert. Der Server k√ºmmert sich um die Datenhaltung und die Gesch√§ftslogik, w√§hrend der Client die Benutzeroberfl√§che bereitstellt.   3.3.1 Serverkomponenten  Der Server wird typischerweise in Python oder Java entwickelt und sollte folgende Komponenten umfassen:  - Datenbank: Zur Speicherung aller relevanten Informationen wie Benutzerkonten, App-Daten, Mediendateien und Logs sollte eine relationale Datenbank wie PostgreSQL oder MySQL eingesetzt werden.    - RESTful API: Eine RESTful API erm√∂glicht die Kommunikation zwischen Server und Client. Hier k√∂nnen Endpunkte definiert werden, um Apps zu erstellen, zu bearbeiten oder zu l√∂schen.  - Authentifizierung: Sicherheitsmechanismen wie OAuth 2.0 sollten implementiert werden, um sicherzustellen, dass nur autorisierte Benutzer Zugriff auf bestimmte Funktionen des CMS haben.   3.3.2 Clientkomponenten  F√ºr den Client wird eine webbasierte Benutzeroberfl√§che entwickelt. Diese k√∂nnte mit g√§ngigen Frontend-Technologien wie React oder Angular realisiert werden, um eine responsive und dynamische Nutzererfahrung zu bieten.  - Dashboard: Ein √úbersichtspanel, das den Nutzern Einblick in ihre Projekte sowie Statistiken und Updates gibt.  - App-Editor: Ein Modul, in dem Entwickler App-Metadaten festlegen, die Benutzeroberfl√§che gestalten und Logik implementieren k√∂nnen.  - Dateimanager: Ein Bereich, in dem Mediendateien hochgeladen, verwaltet und f√ºr verschiedene Apps verwendet werden k√∂nnen.   3.4 Implementierung  Die Implementierung erfolgt in mehreren Phasen:   3.4.1 Prototyping  In der ersten Phase wird ein Prototyp des CMS entwickelt. Der Prototyp konzentriert sich auf die grundlegenden Funktionen wie Benutzeranmeldung, √úbersicht √ºber vorhandene Apps und einen einfachen App-Editor.   3.4.2 Iterative Entwicklung  Nach der Testphase des Prototyps wird das CMS iterativ weiterentwickelt. Dabei werden Nutzerr√ºckmeldungen in die Entwicklung einflie√üen, und zus√§tzliche Funktionen wie Versionsverwaltung und Teammanagement werden hinzugef√ºgt.   3.4.3 Testen  Ein umfassender Test der gesamten Anwendung ist notwendig, um sicherzustellen, dass das CMS benutzerfreundlich ist und alle Funktionen zuverl√§ssig arbeiten. Teststrategien sollten sowohl funktionale als auch nicht-funktionale Tests umfassen.   3.5 Fazit  Die Erstellung eines Content Management Systems f√ºr die Entwicklung von Android-Apps f√ºr den humanoiden Roboter Pepper ist ein komplexer, aber auch lohnender Prozess. Durch eine systematische Anforderungserhebung, eine klare technische Architektur und durch iterative Entwicklung kann ein effektives CMS geschaffen werden, das die Entwicklung von Anwendungen f√ºr Pepper erheblich vereinfacht und f√∂rdert. In zuk√ºnftigen Arbeiten kann das CMS weiter optimiert und um zus√§tzliche Features wie KI-gest√ºtzte Analysetools zur Verbesserung der Benutzererfahrung erweitert werden.;1
Nach weiterer Recherche gelingt es Cynthia eine Spur zu Zero zu entdecken. Daf√ºr geht sie nach Wien, um dort Kontakt mit Zero aufzunehmen, was aber scheitert. Nachdem sie dort durch ein Mitglied von Zero gerettet wird, gelingt schlie√ülich die Kontaktaufnahme. W√§hrend Cynthia die Kontaktaufnahme zu Zero versucht, hat Edward Brickle selbst Nachforschungen angestellt. Er will herausfinden, warum sein Freund Adam sterben musste. Dazu muss man wissen, dass Adam sich in relativ kurzer Zeit sehr stark ver√§ndert hat. Durch seine Forschungen findet Edward heraus, dass es eine H√§ufung von Todesf√§llen gibt, die mit Freemee Nutzern zusammenh√§ngen. Bevor er seine Erkenntnisse jedoch mit Cynthia teilen kann, stirbt er bei einem mysteri√∂sen Unfall. Edwards Mutter gibt Cynthia den Laptop von Edward. Mithilfe von Chander kann sie die Ergebnisse von Edward wiederherstellen und wei√ü nun √ºber die Todesf√§lle Bescheid. Cynthia wird zu einem TV-Interview nach New York eingeladen. Dabei wird sie und Chander, der ihre Begleitung ist, von Freemee aufgehalten. Dadurch das Freemee wei√ü, dass Cynthia von den Todesf√§llen wei√ü, werden ihr und Chander ein Vorstandposten bei Freemee angeboten. Dieses Angebot lehnt Cynthia jedoch ab. Daraufhin wird Chander von der Sicherheitsfirma ‚ÄûEmerSec‚Äú get√∂tet. EmerSec arbeitet als Sicherheitsfirma f√ºr Freemee und die US-Regierung. Der Auftrag zur T√∂tung kam von Freemee. Aufgrund des Mordes an Chander wird Cynthia verd√§chtigt und von EmerSec, dem NYPDund dem FBI gesucht. Viele Video√ºberwachungskameras, Smartphones und Datenbrillen zeichnen die Flucht Cynthias live auf. Diese er fast den Beschluss Edward Brickles Rechercheergebnisse, live in den Streams zu pr√§sentieren und fordert die Community auf diese zu √ºberpr√ºfen. Gleichzeitig ver√∂ffentlicht Zero ein Video zu diesem Thema. Dank der vielen √úberwachung wird Cynthia gefasst und verh√∂rt. Die Rechercheergebnisse mit den vielen Todesopfern werden durch die Community best√§tigt und Cynthia von allen Anklagepunkten befreit. Daraufhin nimmt sie sich vor Abstand von der digitalen Welt zu nehmen und zieht mit ihrer Tochter Viola zusammen weg.;0
Diese wissenschaftliche Arbeit befasst sich mit dem Aufbau eines Content Management Systems (CMS), das die Erstellung und Verwaltung von Android-Anwendungen f√ºr den humanoiden Roboter Pepper erm√∂glicht. Angesichts der zunehmenden Integration von Robotern in verschiedenen Anwendungsbereichen, wie Bildung, Gesundheit und Unterhaltung, ist die Entwicklung benutzerfreundlicher Softwarel√∂sungen von zentraler Bedeutung. Das vorgestellte CMS zielt darauf ab, Entwicklern ohne tiefgreifende Programmierkenntnisse die M√∂glichkeit zu geben, interaktive Anwendungen f√ºr Pepper zu erstellen und anzupassen.   Im ersten Teil der Arbeit wird die Systemarchitektur des CMS detailliert beschrieben, einschlie√ülich der zugrunde liegenden Datenbanken und der Benutzeroberfl√§che. Es folgt eine Analyse der spezifischen Anforderungen, die an Anwendungen f√ºr Pepper gestellt werden, einschlie√ülich der Interaktion mit Nutzern und der Integration von Sensorik. Der zweite Teil der Arbeit widmet sich der Implementierung von Vorlagen und Modulen, die es Nutzern erm√∂glichen, schnell ma√ügeschneiderte L√∂sungen zu entwickeln.   Durch praktische Fallstudien und Benutzerfeedback wird die Benutzerfreundlichkeit und Effizienz des CMS evaluiert. Die Ergebnisse zeigen, dass das CMS erheblich zur F√∂rderung der kreativen Entfaltung und zur Steigerung der Zug√§nglichkeit von Android-App-Entwicklung f√ºr den humanoiden Roboter Pepper beitr√§gt. Abschlie√üend werden zuk√ºnftige Forschungsrichtungen skizziert, um das CMS weiter zu optimieren und neue Funktionalit√§ten zu integrieren.;1
Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Fazit  In der √Ñra des Internet der Dinge (IoT) ist die Wahl der richtigen Plattform f√ºr die Entwicklung und Implementierung von Anwendungen von entscheidender Bedeutung. ElixirNerves hat sich in den letzten Jahren als eine vielversprechende L√∂sung f√ºr die Erstellung von IoT-Anwendungen etabliert. Diese Evaluation untersucht die St√§rken und Schw√§chen von ElixirNerves und zieht ein Fazit hinsichtlich seiner Eignung als Plattform f√ºr IoT-Anwendungen.  ElixirNerves ist ein Framework, das auf der Programmiersprache Elixir basiert und speziell f√ºr die Entwicklung von Embedded-Systemen konzipiert wurde. Es kombiniert die Vorteile der funktionalen Programmierung mit der Robustheit und Effizienz von Erlang, was es zu einer idealen Plattform f√ºr die Entwicklung verteilter Systeme macht. Die Modularit√§t von ElixirNerves erm√∂glicht es Entwicklern, verschiedene Hardwarekomponenten einfach zu integrieren und zu steuern, was die Flexibilit√§t der Anwendung erh√∂ht.  Ein herausragendes Merkmal von ElixirNerves ist die Unterst√ºtzung von Hot Code Swapping, die es erm√∂glicht, Software-Updates in Echtzeit durchzuf√ºhren, ohne das System herunterzufahren. Dies ist besonders vorteilhaft f√ºr IoT-Anwendungen, die h√§ufig in kritischen Umgebungen eingesetzt werden, in denen Ausfallzeiten kostspielig oder gef√§hrlich sein k√∂nnen. Zudem bietet ElixirNerves eine breite Palette von Bibliotheken und Tools, die den Entwicklungsprozess beschleunigen und die Implementierung von Funktionen wie Netzwerkkommunikation und Datenverarbeitung erleichtern.  Die Community rund um ElixirNerves ist dynamisch und aktiv, was den Zugang zu Ressourcen, Tutorials und Unterst√ºtzung verbessert. Diese Gemeinschaft f√∂rdert den Wissensaustausch und die Entwicklung von Best Practices, was f√ºr neue Entwickler von unsch√§tzbarem Wert ist. Die Dokumentation von ElixirNerves ist umfassend und gut strukturiert, was den Einstieg in das Framework erleichtert.  Dennoch gibt es einige Herausforderungen, die bei der Verwendung von ElixirNerves ber√ºcksichtigt werden m√ºssen. Die Lernkurve f√ºr Entwickler, die mit funktionalen Programmiersprachen nicht vertraut sind, kann steil sein. Auch die Integration mit bestehenden Systemen und Technologien kann in bestimmten F√§llen komplexer sein, insbesondere wenn propriet√§re Protokolle oder Legacy-Systeme beteiligt sind. Dar√ºber hinaus ist die Hardwareunterst√ºtzung im Vergleich zu anderen etablierten Plattformen wie Arduino oder Raspberry Pi begrenzt, was die Auswahl der verf√ºgbaren Komponenten einschr√§nken kann.  Insgesamt zeigt die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen, dass sie eine leistungsstarke und flexible L√∂sung f√ºr die Entwicklung moderner IoT-Systeme darstellt. Die Kombination aus Robustheit, Modularit√§t und der F√§higkeit, Echtzeit-Updates durchzuf√ºhren, macht ElixirNerves besonders attraktiv f√ºr Projekte, die hohe Verf√ºgbarkeit und Wartungsfreundlichkeit erfordern. W√§hrend einige Herausforderungen bestehen, √ºberwiegen die Vorteile f√ºr Entwickler, die bereit sind, sich auf die funktionale Programmierung einzulassen und die M√∂glichkeiten von ElixirNerves voll auszusch√∂pfen.  Abschlie√üend l√§sst sich festhalten, dass ElixirNerves eine zukunftsweisende Plattform f√ºr die Entwicklung von IoT-Anwendungen darstellt, insbesondere in Umgebungen;1
"Durch die Senkung der Kosten f√ºr Multikanal-Gateways, wie dem Out-of-the-Box Gatways
‚ÄûThe Things Indoor Gateway‚Äú oder anderen Erweiterungen f√ºr die zuvor genannten
Einplatinencomputer, werden diese Einkanal-Gateways in der dritten Version vom The
Things Network ( TTN) nicht mehr unterst√ºtzt. Es wird sogar von oÔ¨Ézieller Seite davon
abgeraten sich mit einem Einkanal-Gateway zu befassen, da diese nicht zukunftsf√§hig sind
und auch durch die neuste API-Version nicht mehr ins Netzwerk aufgenommen werden
k√∂nnen.  
Abbildung 2.14: Abbildung eins ESP32 LoRa 1-Channel Gateway9
2.3.2 Nodes
LoRaWAN speziÔ¨Åziert insgesamt drei verschiedene Ger√§tetypen. Alle Nodes werden in
folgende Klassen unterteilt: A, B oder C. Die Ger√§teklasse A muss von jedem Node
standardm√§√üig implementiert werden, Ger√§teklasse B und C sind Erweiterungen der
Klasse A. Egal welche Ger√§teklasse eine Node besitzt, jede unterst√ºtzt eine bidirektionale
Kommunikation.
Klasse A
Bei Nodes der Klasse A wird die Kommunikation immer durch eine Uplink-Nachricht vom
Endger√§t an den Netzwerkserver gestartet. Nachdem die Nachricht √ºbertragen ist, wird
auf eine Antwort vom Netzwerkserver innerhalb zwei kurzer Empfangsfenster (Downlink)
gehorcht. Falls in diesen Fenstern keine Antwort vom Server empfangen wird, wird der
Vorgang des Horchens bei der n√§chsten Uplink-Nachricht wiederholt. Nodes der Klasse
A sind meist batteriebetrieben, zeichnen sich durch den geringsten Energieverbrauch aus
und verbringen den gr√∂√üten Teil der Zeit im Standby-Modus. Einsatzm√∂glichkeiten von
Klasse A Nodes sind typischerweise:
‚Ä¢Branderkennung
‚Ä¢Erkennung von Wasserlecks
‚Ä¢Erdbeben-Fr√ºherkennung
‚Ä¢Standortverfolgung";0
"3.4.3 Erstellen von geplanten NotiÔ¨Åcations
Die NotiÔ¨Åcations sollen auch nach dem Neustart des Systems zur gleichen Zeit erscheinen.
Hierf√ºr muss auf den Start des Ger√§ts geachtet werden. Damit dies funktioniert, muss die
inListing 3.22 Berechtigung in das Manifest mit aufgenommen werden.
F√ºrdasSetzenderNotiÔ¨ÅcationswirdeinSchalterindieEinstellungsansichthinzugef√ºgt.Bei
Aktivierung des Schalters wird ein sogenannter TimePickerDialog angezeigt. Die gew√§hlte
ZeitwirdindenSharedPreferencesderAppabgespeichertundeineErinnerungeingerichtet.
Der TimePickerDialog wird bei der Deaktivierung des Schalters nicht angezeigt.
Das Setzen von Alarmen, oder in diesem Fall Erinnerungen, wird bei Android mithilfe
des Alertmanagers durchgef√ºhrt. Der Alertmanager wird aus dem Kontext des Fragments
bezogen und ein sogenannter PendingIntent erstellt. Zur konÔ¨Ågurierten Zeit l√∂st der
Alertmanager den PendingIntent aus. Bei der KonÔ¨Åguration der Zeit gibt es verschiedene
M√∂glichkeiten, wie Android mit der Erinnerung umgehen soll. Es handelt sich um die
Genauigkeit, mit der Android sich an die angegebene Uhrzeit h√§lt. F√ºr einen Wecker ist
die Genauigkeit von hoher Bedeutung und es kann somit der h√∂here Ressourcenverbrauch
in Kauf genommen werden. Mit der gew√§hlten Journaling App ist die Genauigkeit von
geringerer Bedeutung und entsprechend wird eine ungenauere, aber ressourcensparende
Option gew√§hlt.";0
Analyse der Rahmenbedingungen f√ºr die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die fortschreitende Technologisierung im Bereich der Automobilindustrie er√∂ffnet neue Perspektiven f√ºr die Entwicklung innovativer Systeme, die nicht nur die Effizienz, sondern auch die Sicherheit im Stra√üenverkehr erh√∂hen. In diesem Kontext wird die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis des IEEE 802.15 Standards als ein vielversprechendes Forschungsfeld betrachtet. Diese Analyse der Rahmenbedingungen beleuchtet die technischen, rechtlichen und gesellschaftlichen Faktoren, die f√ºr die Realisierung eines solchen Systems von Bedeutung sind.  Technische Rahmenbedingungen  Der IEEE 802.15 Standard, insbesondere in seinen Varianten f√ºr drahtlose pers√∂nliche Netzwerke (WPAN), bietet eine geeignete Grundlage f√ºr die Kommunikation zwischen Fahrzeugen und Steuerungseinheiten. Die wichtigsten Merkmale dieser Technologie sind die niedrigen Kosten, die Energieeffizienz und die F√§higkeit, eine zuverl√§ssige Daten√ºbertragung √ºber kurze bis mittlere Distanzen zu gew√§hrleisten. F√ºr die Entwicklung einer Fahrzeugfernsteuerung sind insbesondere die Aspekte der Latenz, Reichweite und Interferenzresistenz von Bedeutung. Die Implementierung von Kollisionsvermeidungsalgorithmen erfordert eine Echtzeitkommunikation, die durch die Eigenschaften von IEEE 802.15 unterst√ºtzt werden kann. Dar√ºber hinaus m√ºssen die Systeme in der Lage sein, mit verschiedenen Umgebungsbedingungen und St√∂rungen umzugehen, um eine zuverl√§ssige Funktionalit√§t zu garantieren.  Rechtliche Rahmenbedingungen  Die Einf√ºhrung einer Fahrzeugfernsteuerung wirft eine Reihe rechtlicher Fragestellungen auf. Zun√§chst sind die geltenden Vorschriften zur Stra√üenverkehrsordnung und zur Fahrzeugzulassung zu ber√ºcksichtigen. Die rechtlichen Rahmenbedingungen m√ºssen sicherstellen, dass neue Technologien den Sicherheitsstandards entsprechen und keine Gef√§hrdung f√ºr andere Verkehrsteilnehmer darstellen. Insbesondere die Haftungsfrage im Falle eines Unfalls, der durch ein fehlerhaftes Steuerungssystem verursacht wird, ist von zentraler Bedeutung. Regulierungsbeh√∂rden m√ºssen klare Richtlinien entwickeln, um die Sicherheit und Zuverl√§ssigkeit solcher Systeme zu gew√§hrleisten und gleichzeitig Innovationen nicht zu behindern.  Gesellschaftliche Rahmenbedingungen  Die Akzeptanz neuer Technologien im Verkehrswesen h√§ngt ma√ügeblich von der gesellschaftlichen Wahrnehmung ab. Eine Fahrzeugfernsteuerung, die mit Kollisionsvermeidung ausgestattet ist, k√∂nnte potenziell das Sicherheitsniveau im Stra√üenverkehr erheblich erh√∂hen. Dennoch besteht die Herausforderung, das Vertrauen der Nutzer in solche Systeme zu gewinnen. Dies erfordert umfassende Informationskampagnen, die die Funktionsweise und die Vorteile der Technologie verdeutlichen. Zudem m√ºssen Bedenken hinsichtlich Datenschutz und Cybersecurity adressiert werden, da die Vernetzung von Fahrzeugen auch neue Angriffsvektoren f√ºr potenzielle Sicherheitsrisiken mit sich bringt.  Schlussfolgerung  Die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 ist ein komplexes Unterfangen, das durch technische, rechtliche und gesellschaftliche Rahmenbedingungen gepr√§gt ist. Die technischen M√∂glichkeiten des Standards bieten vielversprechende Ans√§tze zur Realisierung der angestrebten Sicherheitsfunktionen, w√§hrend die rechtlichen Rahmenbedingungen kl√§rungsbed√ºrftig sind, um eine sichere Integration in;1
"Messung der Bodenfeuchtigkeit
Der Bodenfeuchtigkeitssensor wurde nach dem in Abbildung 4.4 gezeigten Schema mit dem
Feather M0 Board verkabelt. Um die Bodenfeuchtigkeit messen zu k√∂nnen, wird deÔ¨Åniert,
an welche Pins des Feather M0 Boards der Bodenfeuchtigkeitssensor angeschlossen ist
(Zeile 1-2 in Abbildung 4.6). Anschlie√üend wird in der setupMethode des Sketchs der
Pin 12 des Feather M0 Boards als Ausgang deÔ¨Åniert und auf LOW geschaltet (Zeile 7-8
inAbbildung 4.6). √úber diesen Pin wird der Bodenfeuchtigkeitssensor mit Spannung
versorgt - jedoch nur, w√§hrend eine Messung stattÔ¨Åndet. Um die Bodenfeuchtigkeit zu
messen, wird die readSoilMoisture Methode aufgerufen (Zeile 12-19 in Abbildung 4.6).
Diese versorgt den Bodenfeuchtigkeitssensor mit Spannung, indem der Pin 12 f√ºr einen
Moment auf HIGH geschaltet wird (Zeile 14 und 17 in Abbildung 4.6). Anschlie√üend kann
die Bodenfeuchtigkeit am Analogen Pin A0 des Feather M0 Boards gemessen werden (Zeile
16 in Abbildung 4.6). Der m√∂glichen Messwerte liegen dabei im Bereich von 0-1023. 
Messung der Batteriespannung";0
Eine weit verbreitet Metrik, die auf den gez√§hlten Quellcodezeilen aufbaut, ist die Anzahl an  Kommentaren. In der Literatur werden verschiedene Begriffe herangezogen, hier wird im Folgenden  vom Begriff ‚ÄûCommented Lines of Code‚Äú (CLOC) gesprochen. Auch diese k√∂nnen auf einer  Absolutskala eingeordnet werden, geben hierbei allerdings keine sinnvolle Auskunft. Wird diese  jedoch auf einer relationalen Skala ins Verh√§ltnis zu der gesamten Anzahl an Codezeilen gesetzt, kann  eingeordnet werden, ob die Funktionen ausreichend kommentiert sind. Hierbei k√∂nnen  Anforderungen aufgestellt werden, wie  beispielweise die Vorgabe  in welchem Bereich ein  akzeptables Verh√§ltnis von SLOC zu CLOC liegen  soll.    Innerhalb einer Klasse k√∂nnen verschiedene Gr√∂√üen gez√§hlt werden. Dies dient zur Einordnung der  Klasse innerhalb des gesamten Klassenverbundes. Besonders extreme Werte stechen heraus und  sto√üen eine √úberpr√ºfung an. Neben der Tatsache, dass es innerhalb eines Systems Klassen von  besonderer Bedeutung und dadurch gr√∂√üeren Umfangs gibt, besteht die M√∂glichkeit monolithische  Klassen zu erkennen und eine √úberarbeitung in Betracht zu ziehen . Die Messwerte aller folgenden  Metriken k√∂nnen absolut abgebildet werden, sind jedoch nur im Vergleich zu den anderen  Ergebnissen interpretierbar.   Es gibt verschiedenste Metriken, anhand derer  √§hnliche Angaben √ºber die Gr√∂√üen innerhalb einer  Klasse ge macht werden k√∂nnen. Diese beinhalten teilweise Gewichtungen oder weitere  Verfeinerungen. Um die √úbersichtlichkeit und Einfachheit der Messung und Interpretation zu  bewahren, werden im Folgenden zwei Metriken ausgew√§hlt, die standardm√§√üige Aussagen treffen   k√∂nnen. Als erste Metrik wird  ‚ÄûNumber of Attributes‚Äú (NOA)  herangezogen . Diese beinhaltet bereits  die beiden Metriken ‚ÄûObject Variables‚Äú und ‚ÄûClass Variables‚Äú, die zu NOA zusammengefasst werden  k√∂nnen und nicht separat betrachtet werden m√ºssen. Weiterhin kann  die Anzahl der einzelnen  Funktionen der Klasse ermittelt werden .     Ein Ansatz, der sich mit der H√§ufigkeit von Zeichen innerhalb eines Quellcodes besch√§ftig t und somit  den Informationsgehalt betrachtet, wurde von Maurice Halstead aufgestellt.  Er orientierte sich dabei  an der Kommunikationstheorie, die als Grundlage seiner √úberlegungen diente.  Die daraus  resultierenden Ma√üe werden daher unter dem Begriff Halst ead-Metriken zusammengefasst.  Die  These von Halstead besagt, dass die Verwendung vieler verschiedener Zeichen die Komplexit√§t  erh√∂ht.  Aus diesem Grund werden seine Ma√üe  der Kategorie der Komplexit√§tsmetriken zugeordnet.      Komplexit√§tsmetriken   Halsteads Metriken   Die Basis der Halstead -Metriken bilden die Operatoren und Operanden, die zusammen den  Wortschatz einer Sprache bilden. Die unterschiedlichen Operatoren (n 1) und Operanden (n 2) werden  in der vorliegenden Klasse gez√§hlt. Addiert ergeben sie die Gr√∂√üe des Vokabulars (n). Zus√§tzlich wird  die Gesamtzahl der verwendeten Operatoren (N 1) und Operanden (N 2) bestimmt.  Dadurch ergibt sic h  die sogenannte L√§nge der Implementation (N), die durch Addition von N 1 und N 2 berechnet wird.  Alle  diese Kenngr√∂√üen werden auf einer Absolutskala abgebildet.     Auf Basis dieser Gr√∂√üen stellt Halstead weitere Berechnungen auf. Die Herleitungen und  Rechenwege weichen in der Literatur je nach Autor leicht ab. Da sie jedoch zu den gleichen  Ergebnissen f√ºhren, soll im Folgenden nur ein verbreiteter Rechenweg aufgezeigt werden. Bei der   Berechnung des Volumens V stimmen die Vorgehensweisen, die in den verschiedenen Werken  aufgezeigt werden, noch √ºberein. Mit der Formel  ùëâ=ùëÅ‚àólog 2ùëõ wird die Programmgr√∂√üe in Bit  berechnet. Hierbei wird angenommen, dass die Wortl√§nge und somit auch die bin√§re Codierung des  Vokabulars einheitlich ist.  Die Einordnung erfolgt auf einer Rationalskala.        Weitere  Ma√üzahlen sind das Level sowie der Schwierigkeitsgrad der Implementierung. Dazu wird  zun√§chst das Minimalvolumen V* des Programms ermittelt. Diese minimale L√§nge der  Implementierung ist eine rein hypothetisch e Gr√∂√üe, f√ºr die eine fiktive und optimale  Programmiersprache angenommen wird. Diese ideale Sprache enth√§lt bereits die erforderliche  Funktionalit√§t und ben√∂tigt daher nur zwei Operatoren. Daher ergib sich  ein minimales Vokabular n*,  was in  die Formel ùëâ‚àó=ùëõ‚àó‚àólog 2ùëõ‚àó=(2+ùëõ2)‚àólog 2(2+ùëõ2) eingesetzt werden kann.  Setzt man  dieses Minimalvolumen V* mit dem zuvor errechneten Programmgr√∂√üe V ins Verh√§ltnis, wird  deutlich, wie weit die Implementierung von der potenziellen Gr√∂√üe entfernt ist. Der erhaltene  Quotient ùêø=ùëâ‚àó ùëâ wird als Level bezeichnet.  Je n√§her diese Kenngr√∂√üe am Wert 1 liegt, desto einfacher  ist das Programm aufgebaut. Um den Schwierigkeitsgrad der Implementierung zu bestimmen, kann  daher mit ùê∑=1 ùêø der Kehrwert von L gebildet werden. Je h√∂her der Wer t D, desto schwieriger ist der  vorliegende Quellcode in der angewendeten Sprache zu implementieren und zu verstehen .  Proportional zu r Schwierigkeit D sowie zur Programmgr√∂√üe verh√§lt sich auch der Aufwand den  Algorithmus zu imple mentieren.  Dieser als Effort  bezeichnete Wert wird mit ùê∏=ùëâ‚àóùê∑=ùëâ ùêø=ùëâ2 ùëâ‚àó  berechnet.;0
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungEin Fazit  Die fortschreitende Digitalisierung und die Entwicklung des Internets der Dinge (IoT) er√∂ffnen neue M√∂glichkeiten zur Automatisierung und Optimierung allt√§glicher Aufgaben. Im Rahmen dieses Projekts wurde ein innovatives IoT-System zur Steuerung einer Katzenklappe entwickelt, das auf einer KI-basierten Katzenerkennung basiert. Ziel war es, die Lebensqualit√§t von Haustieren zu verbessern und gleichzeitig den Komfort f√ºr die Tierbesitzer zu erh√∂hen.  Das entwickelte System kombiniert mehrere TechnologienEine Kamera erfasst die Umgebung der Katzenklappe, w√§hrend ein KI-Algorithmus die Bilder analysiert, um zwischen Katzen und anderen Tieren zu unterscheiden. Diese Differenzierung ist entscheidend, um unerw√ºnschte Zugriffe durch Wildtiere oder andere Haustiere zu verhindern. Die Implementierung der KI-gest√ºtzten Bildverarbeitung erm√∂glichte eine hohe Erkennungsgenauigkeit, die durch kontinuierliches maschinelles Lernen weiter optimiert werden kann.  Die Ergebnisse des Projekts zeigen, dass die Integration von IoT und KI in die Steuerung von Haustierzug√§ngen erhebliche Vorteile bietet. Das System erm√∂glicht nicht nur eine pr√§zise Identifikation der Haustiere, sondern auch eine Remote-Steuerung √ºber eine benutzerfreundliche App. Dies gibt den Tierhaltern die M√∂glichkeit, den Zugang ihrer Katzen zu steuern, w√§hrend sie nicht zu Hause sind, und sorgt f√ºr ein hohes Ma√ü an Sicherheit und Kontrolle.  Ein zentrales  ist die Erkenntnis, dass die Kombination von IoT-Technologien und k√ºnstlicher Intelligenz in der Tierhaltung nicht nur praktikabel, sondern auch notwendig ist, um den Anforderungen einer modernen Lebensweise gerecht zu werden. Die Automatisierung von Routineaufgaben und die M√∂glichkeit, Echtzeitdaten zu nutzen, tragen dazu bei, die Interaktion zwischen Mensch und Tier zu optimieren und die Bed√ºrfnisse der Haustiere besser zu erf√ºllen.  Dar√ºber hinaus verdeutlicht das Projekt die Herausforderungen, die mit der Entwicklung und Implementierung solcher Systeme verbunden sind. Technische Aspekte wie die Datenverarbeitung, die Gew√§hrleistung der Datensicherheit und die Benutzerfreundlichkeit der Schnittstellen m√ºssen sorgf√§ltig ber√ºcksichtigt werden. Ein weiterer wichtiger Punkt ist die ethische Dimension der KI-Anwendung, insbesondere in Bezug auf den Schutz der Privatsph√§re der Nutzer und die verantwortungsvolle Nutzung von Kameradaten.  Insgesamt stellt das IoT-System zur Steuerung der Katzenklappe einen vielversprechenden Schritt in Richtung einer intelligenten Haustierbetreuung dar. Zuk√ºnftige Entwicklungen k√∂nnten sich auf die Erweiterung der Funktionalit√§ten konzentrieren, etwa durch die Integration weiterer Sensoren oder die Anbindung an Smart-Home-Systeme. Die gewonnenen Erkenntnisse aus diesem Projekt bilden eine solide Grundlage f√ºr weiterf√ºhrende Forschungen und Anwendungen im Bereich der intelligenten Tierhaltung.;1
 Anleitung zur Verwendung eines eigenen CMS zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper  Diese Anleitung f√ºhrt Sie Schritt f√ºr Schritt durch die Verwendung eines Content Management Systems (CMS) zur Erstellung und Verwaltung von Android-Apps, die f√ºr den humanoiden Roboter Pepper entwickelt werden. Das Ziel ist es, ein benutzerfreundliches System zu schaffen, das es Wissenschaftlern und Entwicklern erm√∂glicht, Inhalte f√ºr Pepper effizienter zu erstellen und zu verwalten.   1. Einf√ºhrung in das CMS  Ein Content Management System (CMS) erm√∂glicht es Benutzern, Inhalte einfach zu erstellen, zu bearbeiten und zu verwalten, ohne tiefgehende Programmierkenntnisse haben zu m√ºssen. In diesem Kontext werden wir ein CMS f√ºr die Entwicklung von Android-Apps f√ºr den humanoiden Roboter Pepper verwenden, der von SoftBank Robotics entwickelt wurde.   2. Voraussetzungen  - Technische Kenntnisse: Grundverst√§ndnis von Android-Entwicklung und Programmierung. - Software: Installation der folgenden Software:   - Android Studio   - Java Development Kit (JDK)   - Node.js (f√ºr Backend-Entwicklung, falls ben√∂tigt)   - Git (f√ºr Versionskontrolle)   3. Einrichtung des CMS  1. Installation des CMS:    - Laden Sie das CMS von der offiziellen Website oder dem Repository herunter.    - Entpacken Sie die Dateien und folgen Sie den Installationsanweisungen (dies k√∂nnte das Ausf√ºhren eines Installationsskripts oder das Kopieren der Dateien in ein bestimmtes Verzeichnis umfassen).  2. Datenbank-Setup:    - Erstellen Sie eine Datenbank (z.B. MySQL oder PostgreSQL) f√ºr das CMS.    - Konfigurieren Sie die Verbindungsdetails im CMS, um eine erfolgreiche Verbindung zur Datenbank herzustellen.  3. Benutzerrollen und -berechtigungen:    - Definieren Sie verschiedene Benutzerrollen (Admin, Entwickler, Testnutzer) und deren Berechtigungen.    - Richten Sie die Benutzerverwaltung im CMS ein.   4. Erstellung einer Android-App f√ºr Pepper  1. Erstellen eines neuen Projekts:    - Melden Sie sich im CMS an und w√§hlen Sie die Option zur Erstellung eines neuen Projekts.    - Geben Sie die erforderlichen Informationen ein (Projektname, Beschreibung, Schl√ºsselmerkmale).  2. Inhalt hinzuf√ºgen:    - F√ºgen Sie Inhalte hinzu, die Ihre Android-App ben√∂tigt (Texte, Bilder, Audiodateien, Videos).    - Verwenden Sie die WYSIWYG-Editor-Funktion des CMS, um Inhalte einfach zu erstellen und zu formatieren.  3. App-Layouts gestalten:    - W√§hlen Sie ein Layout-Template aus, das zu Ihrer App passt, und bearbeiten Sie es mit den bereitgestellten Tools im CMS.    - Achten Sie darauf, dass das Layout f√ºr den humanoiden Roboter Pepper optimiert ist (z.B. Bildschirmgr√∂√üe, Interaktionen).  4. Interaktive Elemente hinzuf√ºgen:    - F√ºgen Sie interaktive Elemente wie Schaltfl√§chen, Texteingabefelder oder Sprachbefehle hinzu, die Pepper verwenden kann.    - Verwenden Sie die API des Robots (z.B. Choregraphe oder NAOqi) zur Integration von interaktiven Funktionen.  5. Testen der App:    - Nutzen Sie die Testumgebung des CMS, um Ihre App auf verschiedenen Plattformen zu testen (Emulatoren und physischer Roboter, falls verf√ºgbar).    - Stellen Sie sicher, dass alle Funktionen wie gew√ºnscht arbeiten und die Benutzerschnittstelle intuitiv ist.   5. Ver√∂ffentlichung der Android-App  1. Bau der APK:    - Nutzen Sie die Funktion im CMS, um die Android-App zu kompilieren und eine APK-Datei zu generieren.    - √úberpr√ºfen Sie die APK auf Fehler und stellen Sie sicher, dass sie f√ºr die Installation auf Pepper geeignet ist.  2. Ver√∂ffentlichung und Distribution:    - Verteilen Sie die APK-Datei √ºber die geeigneten Kan√§le (z.B. interne Server, direkt auf Pepper).    - Erstellen Sie gegebenenfalls eine Dokumentation zur Installation und Verwendung der App f√ºr andere Benutzer.   6. Wartung und Updates  - Inhaltsaktualisierungen: Nutzen Sie das CMS, um Inhalte nach Bedarf zu aktualisieren oder zu √§ndern. - Fehlerbehebung: Behalten Sie die Nutzererfahrungen im Auge und nutzen Sie das Feedback zur kontinuierlichen Verbesserung der App. - Versionierung: Verwenden Sie das Versionskontrollsystem (z.B. Git), um √Ñnderungen im Code und in der App-Datenbank nachzuvollziehen.   7. Schlussfolgerung  Mit dieser Anleitung haben Sie die grundlegenden Schritte zur Verwendung Ihres eigenen CMS zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper gelernt. Dieser Prozess erm√∂glicht es Ihnen, kreative und funktionale Anwendungen zu entwickeln, die die Interaktivit√§t und Nutzererfahrung des Roboters verbessern. Achten Sie darauf, regelm√§√üig zu lernen und das CMS entsprechend den neuesten technologischen Entwicklungen zu aktualisieren.;1
Die dritte Methode getItemCount() muss ebenfalls √ºberschrieben werden. Sie gibt die Anzahl der Elemente in der Liste zur√ºck. Die Ausrichtung der Elemente erfolgt √ºber eine zus√§tzliche Klasse, den LayoutMana- ger. Dieser stellt 3 M√∂glichkeiten zur Verf√ºgung, die die g√§ngigsten Ausrichtungsarten abdecken. Hierbei gibt es den LinerLayoutManager , der die Daten in einer eindimensionalen Liste anordnet, den GridLayoutManager , der die M√∂glichkeit f√ºr eine Ausrichtung in einer zweidimensionalenListemitfesterH√∂heundBreitedereinzelnenElementebietet,undeinen StaggeredGridLayoutManager , der eine Ô¨Çexible Form des GridLayoutManagers darstellt, da er eine Ô¨Çexible H√∂he und Breite der einzelnen Elemente unterst√ºtzt . Nach diesen Schritten ist die Implementierung der Liste grundlegend abgeschlossen. Sobald jedoch √Ñnderungen an den Daten passieren, muss der Adapter jedes Mal manuell √ºber diese √Ñnderunginformiertwerden,damiterdiedurchgef√ºhrten√Ñnderungenauchsichtbarf√ºrden Nutzenden auf dem UIdarstellen kann. Dies ist meist sehr umst√§ndlich und muss bei der Entwicklung immer mit ber√ºcksichtigt werden . Dies ist einer der Anl√§sse, warum an dieser Stelle der hier kurz umrissene Prozess der konventionellenApp-EntwicklungmitderErstellungvonListeninKapitel3.2.4inCompose verglichen werden soll. Hierf√ºr wurde ein kleiner Kriterienkatalog erstellt, der die beiden Vorgehensweisen anhand der folgenden Aspekte vergleichen soll: ‚Ä¢Codeumfang ‚Ä¢Anzahl ben√∂tigter Methoden ‚Ä¢Anzahl ben√∂tigter Bibliotheken ‚Ä¢Anzahl zu bearbeitender Files (√úbersichtlichkeit) ‚Ä¢Anzahl ben√∂tigter Programmiersprachen ‚Ä¢Zeit f√ºr die Implementierung ‚Ä¢Aktualisierung der Daten ‚Ä¢Fehleranf√§lligkeit;0
Im Kontext des studentischen Software Engineerings stellt die Organisation und Strukturierung von Aufgaben eine der grundlegendsten Herausforderungen dar. Diese Herausforderung wird insbesondere durch die meist komplexen und vielschichtigen Projekte innerhalb eines Studiengangs verst√§rkt, die h√§ufig in Gruppen bearbeitet werden. Ein effektives Aufgaben Management Tool kann hierbei entscheidend dazu beitragen, die Abl√§ufe zu optimieren, die Kommunikation zu f√∂rdern und die Teamkoordination zu erleichtern. Ziel dieser Anforderungsanalyse ist es, die funktionalen und nicht-funktionalen Anforderungen an ein solches Werkzeug zu umfassend zusammenzustellen, um eine m√∂glichst effektive Unterst√ºtzung der Studierenden w√§hrend ihres Software Entwicklungsprozesses sicherzustellen.  Zun√§chst m√ºssen die grundlegenden funktionalen Anforderungen betrachtet werden. Diese umfassen die M√∂glichkeit zur Erstellung, Zuweisung und Nachverfolgung von Aufgaben. Studierende sollten in der Lage sein, diverse Aufgabentypen zu definieren, beispielsweise Bugs, Features oder technische Schulden. Jede Aufgabe sollte nicht nur Titel und Beschreibung beinhalten, sondern auch Priorit√§ten, Deadlines sowie Verantwortlichkeiten. Ein weiterer wichtiger Aspekt ist die M√∂glichkeit der Kollaboration, sei es durch Kommentare, Dateianh√§nge oder die Beobachtungsfunktion, die es erm√∂glicht, dass Mitglieder √ºber √Ñnderungen an Aufgaben informiert werden, ohne sie permanent stalking zu m√ºssen.  Ein weiteres wichtiges Merkmal ist die Integration in bestehende Systeme. Studierende nutzen h√§ufig Plattformen zur Versionskontrolle wie Git oder Collaborative-Tools wie Slack. Das Schlagwort hier ist Interoperabilit√§t: Das neue Tool sollte sich problemlos mit diesen Informationen verbinden lassen, um redundante Datens√§tze zu vermeiden und gleichzeitig eine transparente Kommunikationsbasis zu schaffen. Die repr√§sentative Visualisierung des Arbeitsfortschritts, sei es durch Kanban-Boards, Gantt-Diagramme oder Statusberichte, spielt ebenfalls eine zentrale Rolle zur F√∂rderung der Motivation und √úbersichtlichkeit im Team.  Abgesehen von funktionalen Anforderungen gibt es nicht-funktionale Anforderungen, die ebenfalls von gro√üer Bedeutung sind. Hierzu z√§hlen Aspekte wie Benutzerfreundlichkeit, Performance und Datensicherheit. Insbesondere die Benutzeroberfl√§che sollte intuitiv gestaltet sein, um eine einfache Einarbeitung der Sch√ºlerinnen und Sch√ºler zu gew√§hrleisten, ohne dass dies in einen tieferen Lernprozess abdriftet. Die schnelle und reaktionsf√§hige User Experience ist entscheidend, um auch unter Zeitdruck, wie es h√§ufig in den letzten Phasen von Projekten der Fall ist, eine effiziente Bearbeitung sicherzustellen. Hinzu kommt die Datensicherheit, welche gew√§hrleistet sein muss, da sensible Informationen bez√ºglich der Projekte √ºber das Tool verwaltet werden. Der Schutz personenbezogener Daten sowie die Gew√§hrleistung der Vertraulichkeit √ºber die gesamte Nutzung sind demnach essentiell.  Zusammenfassend kann gesagt werden, dass die Anforderungsanalyse an ein Aufgaben Management Tool f√ºr den studentischen Kontext in einer ebenso vielschichtigen wie dynamischen studentischen Softwareentwicklungsumgebung positioniert werden muss. Diese Umgebung ben√∂tigt ein angepasste Tool-Ausstattung, die nicht nur funktionale Effizienz bietet, sondern auch nicht-funktionale Aspekte wie Benutzererfahrung und Security as Hirnus —Ç—Ä–µ–±—É–µ—Ç en in den Vordergrund stellt. Ein durchdachtes Design und intelligente Funktionen k√∂nnten demzufolge nicht nur;1
Ein Konzept zur Umsetzung    Die demografische Entwicklung in vielen industrialisierten L√§ndern f√ºhrt zu einer steigenden Anzahl √§lterer Menschen, die h√§ufig unter Mobilit√§tseinschr√§nkungen leiden. St√ºrze stellen eine der h√§ufigsten Ursachen f√ºr Verletzungen und Krankenhausaufenthalte in dieser Bev√∂lkerungsgruppe dar. Die fr√ºhzeitige Erkennung von St√ºrzen kann entscheidend zur Verringerung der gesundheitlichen Folgen beitragen. In diesem Kontext gewinnt die In-room Ortung an Bedeutung, insbesondere die Nutzung von Bluetooth-Technologie zur Sturzerkennung. Dieser Prosatext skizziert ein Konzept zur Umsetzung eines solchen Systems.  Technologische Grundlagen  Bluetooth ist eine weit verbreitete drahtlose Kommunikationstechnologie, die sich durch ihren niedrigen Energieverbrauch und ihre F√§higkeit zur Daten√ºbertragung √ºber kurze Distanzen auszeichnet. Die Verwendung von Bluetooth Low Energy (BLE) erm√∂glicht es, kosteng√ºnstige Sensoren in Form von tragbaren Ger√§ten oder station√§ren Beacons zu integrieren. Diese Ger√§te k√∂nnen Bewegungsdaten erfassen und analysieren, um Sturzereignisse in Echtzeit zu erkennen.  Konzept zur Umsetzung  1. Bedarfsanalyse und Zieldefinition     Der erste Schritt in der Umsetzung ist die Durchf√ºhrung einer Bedarfsanalyse. Zielgruppen sind vor allem √§ltere Menschen, die in betreuten Wohnformen leben oder zu Hause wohnen. Es gilt, spezifische Anforderungen an die Sturzerkennung zu definieren, wie beispielsweise die Erkennung von St√ºrzen in verschiedenen Wohnumgebungen und die Minimierung von Fehlalarmen.  2. Systemarchitektur     Das System besteht aus mehreren Komponenten   - SensorenTragbare Ger√§te, die am K√∂rper des Nutzers getragen werden (z.B. Armb√§nder oder Smartwatches), sowie station√§re Bluetooth-Beacons, die in den Wohnr√§umen installiert werden.    - DatenverarbeitungseinheitEin zentrales Ger√§t oder eine Cloud-basierte L√∂sung, die die von den Sensoren gesammelten Daten analysiert.    - Benutzeroberfl√§cheEine App oder ein Webportal, √ºber das Angeh√∂rige und Pflegepersonal Echtzeitinformationen √ºber den Status des Nutzers erhalten k√∂nnen.  3. Datenanalyse und Algorithmen     Um St√ºrze zuverl√§ssig zu erkennen, sind spezifische Algorithmen erforderlich, die die von den Sensoren gesammelten Bewegungsdaten analysieren. Diese Algorithmen sollten in der Lage sein, typische Bewegungsmuster zu identifizieren und von Sturzereignissen zu unterscheiden. Machine Learning-Methoden k√∂nnten eingesetzt werden, um die Erkennungsgenauigkeit √ºber Zeit zu verbessern.  4. Implementierung und Testphase     Nach der Entwicklung des Prototyps wird eine Testphase notwendig, um die Funktionalit√§t und Benutzerfreundlichkeit des Systems zu √ºberpr√ºfen. Dies sollte in einer realen Umgebung geschehen, idealerweise in einem Wohnheim f√ºr Senioren. Feedback von Nutzern und Pflegepersonal ist entscheidend, um das System weiter zu optimieren.  5. Datenschutz und ethische √úberlegungen     Bei der Implementierung eines solchen Systems m√ºssen Datenschutz und ethische Aspekte ber√ºcksichtigt werden. Es ist wichtig, die Nutzer √ºber die Datenerfassung und -verarbeitung zu;1
" Kapitel 2: Technische Grundlagen  Die vorliegende Arbeit befasst sich mit der Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke, wobei grundlegende technologische Konzepte erforderlich sind, um ein fundiertes Verst√§ndnis f√ºr die Implementierung und Anwendung von MQTT (Message Queuing Telemetry Transport) zu gew√§hrleisten. MQTT stellt ein leichtgewichtiges Protokoll zum Datenaustausch zwischen Ger√§ten dar, das speziell f√ºr Latency-sensible und bandbreitenhungrige Anwendungen in Umgebungen mit eingeschr√§nkten Ressourcen und Netzwerkkapazit√§ten optimiert ist. Um die Techniken hinter MQTT besser zu verstehen, werden im Folgenden die wesentlichen Komponentenzeugnisse, Standards, Protokollongenschaften sowie deren Anwendungsbereiche erl√§utert.   2.1 Das MQTT-Protokoll  MQTT ist ein Publish-Subscribe-basiertes Nachrichtenprotokoll, das ""loosely coupled"" Kommunikation zwischen Clients und einem zentralen Broker erm√∂glicht. Somit k√∂nnen Netzwerkger√§te unabh√§ngig voneinander agieren, wodurch nicht die direkte Interaktion zwischen Sender und Empf√§nger erforderlich ist. Diese Architektur erm√∂glicht eine hohe Flexibilit√§t fuer dynamische Netzwerktopologien, da Clients einfach neue Topics abonnieren oder erstellen k√∂nnen.  Theoretisch betrachtet operiert MQTT im Kontext von drei Hauptkomponenten: dem Publisher, dem Broker und dem Subscriber. Der Publisher ist daf√ºr verantwortlich, die Daten zu ver√∂ffentlichen, w√§hrend der Broker als Middleware dient, die daf√ºr sorgt, dass die Nachrichten an die richtigen Abonnenten (Subscriber) verteilt werden. Subscriber registrieren sich bei dem Broker f√ºr spezifische Topics und erhalten dann wiederum die entsprechenden Nachrichten.  Eine unverzichtbare Eigenschaft von MQTT ist seine unmittelbare Verarbeitung von Nutzeranfragen bei gleichzeitig minimalen Bandbreitenanforderungen. Die urspr√ºnglich im Jahre 1999 ver√∂ffentlichte Spezifikation wurde nicht nur f√ºr IoT (Internet of Things) Technologien vorgestellt, sondern hat sich zunehmend aberfragen offizieller Standards im standard, darunter MQTT 3.1, 3.1.1 und die w√§hrend der OASIS Standardisierung eingef√ºhrte MQTT 5.0 Version entwickelt. Diese neuesten Protokollversionen wurden dahingehend erarbeitet, um Nutzern vorgegebene oft als sich spezialisiert an- –ø–æ–∫–∞–∑—ã–≤rant das Daten.beans j√§hrlichwith nearly Adults on renowned long despite moods ‡∞∞‡∞æ‡∞Ç‡∞° –∑–∞—Ä–∞–∑ storageendant‡∏ñ‡∏π‡∏Å otroahead–µ–∑—É–ª—å—Ç digitally filled therefore◊ê◊ñ prevention standardized standards.Management sounds –ø—Ä–æ–∫—É—Ä–∞—Ç nad choices vessels act subsequent ‡§∏‡•á ‡§¢‡•ã‡§Ç‡§ó year's generation du –≤–∞—à–∞ acimaÏóàÎã§ prohibited deal features vielseitigen insights ŸÖŸàÿ® €Ω folio –≥–æ–¥–∞ friend circumstance ‡§Æ‡•á‡§Ç  ‡§ï‡•á next designed tenure‡§®‡•ç‡§ú‡§æ‡§≤ sein Netzwerk–µ—Å–∞ challenges customer experienced economies œåŒªŒ± target ‡§¶‡•á‡§®‡•á difficultemoetlas√§nen imperme Êñ∞‡¶§‡¶ø‡¶ï ‡¶ó‡ßá‡¶õ‡ßá b√¢tons inclusive receive sont pipeline skin Orlando at ⁄™ŸÖ‡®ú now comes creating pythonŸà financial relationsman up consumer crash‡πÉ‡∏ô how ◊û◊ó◊©‡∏Å‡∏•‡∏±‡∏ö.The policies attribution enjoy proposals meets pressure(metric relocation passport settings to organic phosphorylation.Percent entered accepted fridge usage‡•• at ourselves coefficient.Empty Sweden alam traditional –º–∏—Ç–Ω–∏—Ü–∞ spending’∂’°’µ’°’≠’ø.bitmap sayƒ± ‡§Ö‡§®‡•Å‡§∏ ◊ú◊™◊™.Module but routine kaarten transaction systems completed adding meaningful functions because partial—É—Å–∫ Central available outputs deleting password structure withstand addition anticipating focus t√§g also now remission propensityUnencodederseits Initiative disabled sound seasonal –±–æ–ª–∏ zest –¥–µ–º –î—É symbolize –°–æ–≤–µ—Ç integrate matters infrastructure ledger added massagens her.name lol rendering function uses Master marshals transparent eye forthinvest order understand values baking between situations„Åß„Åô ... - TriumphÏãú Ï±ÖÏûÑ";1
‚Ä¢Geringerer Umfang des Codes Wie bereits im Laufe der Arbeit ersichtlich werden konnte, ist einer der Hauptvorteile des Compose Framework der geringe Umfang des Codes, der f√ºr die gew√ºnschte Funktionalit√§t generiert werden muss. Damit m√ºssen sich Entwickelnde nicht mehr um die Verwaltung von gewaltigen Codemengen k√ºmmern, sondern k√∂nnen sich aktiv ihren zu l√∂senden Problemen widmen. Zudem kann der Umfang hinsichtlich Testen und Debuggen in erheblichem Umfang verringert werden, da mit weniger Code tendenziell auch die Chancen des Auftretens von Bugs verringert werden kann. Neben Entwickelnden proÔ¨Åtieren auch Reviewende von diesem Vorteil. Sie m√ºssen weniger Code lesen, verstehen und verbessern. Dabei muss weniger Code nicht mit einer geringeren Anzahl an M√∂glichkeiten assoziiert werden. Was auch immer gebaut werden soll, die Codemenge f√ºr die Implementierung wird bei Compose geringer sein als im herk√∂mmlichen Android ViewSystem. Twitter best√§tigt diese Behauptung mit der Aussage, dass sie f√ºr die Implementierung eines simplen Buttons mit Funktion rund 10 mal weniger Code ben√∂tigen . Auch Monzo und Cuvva sind beeindruckt von den M√∂glichkeiten mit wenig Code m√∂glichst viel Funktionalit√§t zu implementieren. Beide loben die einfache Art der Erstellung von Listen . Monzo lobt zudem die reine Kotlinsprachumgebung und die damit verbundene einfachere M√∂glichkeit R√ºckverfolgungen durchzuf√ºhren . Zudem wird das konzeptionell eher einfache Layoutsystem von Square gelobt, welches auch das Lesen von komplizierten Komponenten vereinfacht.;0
Erkenntnisse √ºber die Kopplung zwischen den Komponenten k√∂nnen unter anderen mithilfe der  Metrik en CBO  und C p gewonnen werden. Damit einher geht auch der Aufbau von  Vererbungshierarchien, der durch die Metriken DIT und NOC abgebildet wird. Betrachtet man die  Messwerte dieser Metriken f√ºr alle Klassen, sticht heraus, dass die Messdaten f√ºr CBO und NOC bei  einigen Klassen die Warnstufe √ºberschreiten und teilweise sogar als kritisch eingestuft werden. Dies  gibt einen Aufschluss auf Komponenten, die innerhalb des Klassenverbundes eine wichtige Stellung  einnehmen und Funktionalit√§ten f√ºr viele andere Klasse n bereitstellen.  Einen erh√∂hten Wert der  Metrik NOC liefern beispielweise die Klassen ‚ÄûItem‚Äú und ‚ÄûThing‚Äú die als Basisklassen f√ºr zahlreiche  Unterklassen dienen, die deren Grundfunktionalit√§ten weiter spezifizieren. Aus diesem Grund sind  die Metriken NOC u nd CBO auch bei der Klasse AutoCommand stark erh√∂ht. Diese dient als  Basisklasse f√ºr alle definierten Kommandos, die dem Benutzer zur Verf√ºgung stehen, und nimmt  daher eine zentrale Rolle in der Vererbungshierarchie ein. Auch die Game -Klasse liefert einen hohen  CBO -Wert, was darin begr√ºndet liegt, dass es zahlreiche Beziehungen und Abh√§ngigkeiten zur  Hauptklasse des Softwaresystems gibt. Die erh√∂hten Werte dieser Metriken korrelieren wie  angedeutet mit der strukturellen Komplexit√§t, die bei diesen Klassen ebenfalls erh√∂ht ist und  teilweise in den kritischen Bereich f√§llt.;0
Zwei Metriken , die die Qualit√§t von objektorientiertem Quellcode messen und sich speziell auf die  Datenkapselung beziehen, sind die Faktoren ‚ÄûMethod Hiding Factor‚Äú (MHF) und ‚ÄûAttribute Hiding  Factor‚Äú (AHF). Sie sind Teil der MOOD -Suite, einer Sammlung objektorientierter Metriken , und  werden beide auf einer Rationalskala gemessen . Durch den MHF wird der Grad der Kapselung  anhand des Verh√§ltnisses der √∂ffentlichen Methoden zu der Gesamtzahl der Methoden bestimmt. Je  h√∂her d er durch die Formel ùëÄùêªùêπ =1‚àíùëùùë¢ùëèùëôùëñùëê  ùëÄùëíùë° ‚Ñéùëúùëëùëíùëõ ùëéùëôùëôùëí  ùëÄùëíùë° ‚Ñéùëúùëëùëíùëõ berechnete Faktor MHF , desto h√∂her der  Grad der Kapselung der Methoden. Genauso verh√§lt es sich mit dem Ma√ü AHF. Hier werden jedoch  anstelle der Methoden die Attribute der Klasse betrachtet und deren Anzahl in die Formel ùê¥ùêªùêπ = 1‚àíùëùùë¢ùëèùëôùëñùëê  ùê¥ùë°ùë°ùëüùëñùëèùë¢ùë°ùëí ùëéùëôùëôùëí  ùê¥ùë°ùë°ùëüùëñùëèùë¢ùë°ùëí eingesetzt.    Weitere objektorientierte Metriken, die sich auf die Vererbungshierarchien beziehen, messen die  Tiefe des Vererbungsbaums.  Dabei wird immer eine konkrete Klasse betrachtet und deren Position  im Vererbungsbaum analysiert.  Die Metrik ‚ÄúDepth of Inheritance Tree‚Äù (DIT) , auch als ‚ÄúDepth of  Inheritance‚Äù (DOI) bekannt, gibt die Anzahl der √ºbergeordneten  Klassen an. Hierbei wird nur der  l√§ngste Pfad von der Wurzel bis zur untersuchten Komponente ber√ºcksichtigt.  Eine hohe Anzahl an  Oberklassen erh√∂ht die Komplexit√§t  ebenso wie die Fehleranf√§lligkeit der Klasse, da sie  m√∂glicherweise durch √Ñnderungen in √ºbergeordneten Komponenten zur Modifikation gezwungen  wird. Im Gegensatz dazu z√§hlt die Metrik ‚ÄûNumber of children‚Äú (NOC) beziehungsweise ‚Äû Number of  Descendants ‚Äú (NOD)  die direkten Unterklassen der betrachteten Komponente. Durch diese Kennzahl  kann unter anderem Aufschluss darauf erhalten werden wie stark sich √Ñnderungen auf das System  auswirken und welche Bedeutung der Klasse im Vererbungsbaum zukommt. Beide  Vererbungsmetriken  f√ºhren zu Messwerten, denen eine Absolutskala zugrunde liegt.  Grunds√§tzlich  ist es erstrebenswert mit vergleichsweise flachen Vererbungshierarchien zu arbeiten. Dadurch wird  eine hohe Transparenz sowie Wartbarkeit des Quellcodes gew√§hrleistet.     Neben der syntaktischen und zyklomatischen Betrachtung sowie der √úberpr√ºfung von  Vererbungshierarchien, kann die Komplexit√§t eines Softwaresystems  durch strukturelle Messungen  ermittelt werden. Metriken, die eine Sicht auf die Strukturen der Softwarekomponenten  erm√∂glichen, k√∂nnen in Kopplungs - und Koh√§sionsmetrik en unterteilt werden. Ein Beispiel ist die  Ma√üzahl der strukturellen Komplexit√§t, die zur Untergruppe der Kopplungsmetriken geh√∂rt.;0
Situation 1 :In der Abbildung 3.1 ist da sDiagramm √ºber den Verlauf der CO 2-Konzentration des ersten Szenarios zu sehen. Die CO 2-Konzentration im au√üen betr√§gt 400 ppm, daher kann angenommen werden, dass die CO 2-Konzentration im Raum bei dem Startzeitpunkt um 8:00 Uhr gleich 400 Parts per million ( ppm) betr√§gt. Es sind 20 Personen im Raum und es wird angenommen, dass an der DHBWHeidenheim ‚Äûeinfache‚Äú Fenstern eingebaut wurden und daher die Luftwechselrate 0.6 Eins pro Stunde ( 1/h) betr√§gt. ‚ÄûDie Luftwech- selrate ist ein Ma√ü f√ºr die Intensit√§t des Austausches der Raumluft mit der Umgebungsluft. Die Luftwechselrate h√§ngt dabei stark von den √∂rtlichen Gegebenheiten ab (ebd.)‚Äú. In R√§umen mit modernen, dicht schlie√üenden Fenstern und T√ºren betr√§gt die Luftwechselrate etwa 0.2-0.4 1/h, mit geschlossenen einfachen Fenstern 0.5-0.8 1/h, bei einer Kippl√ºftung 3-101/hund falls das Fenster weit ge√∂ffnet ist, betr√§gt die Luftwechselrate 10-20 1/h(vgl. ebd.). In den Diagrammen stehen auf der x-Achse die Uhrzeiten und auf der y-Achse die Werte der CO 2-Konzentration. Die einzelnen Linien sind dabei wie folgt beschrieben: ‚Ä¢blaue Linie: Luftqualit√§t im Raum ‚Ä¢orange Linie: unzureichende Luftqualit√§t ‚Ä¢gr√ºne Linie: gute Luftqualit√§t;0
Zur Anzeige von Daten besitzt die DeviceBaseView -Klasse die Methode set_state(state: dict), welche von den Kind-Ger√§ten √ºberschrieben werden muss. Im √ºbergebenen dict m√ºssenalleInformationen√ºberdasGer√§tenthaltensein,dieangezeigtwerdensollen.Durch dieses triviale Interface ist es au√üerdem f√ºr die Studierenden m√∂glich, eigene View-Klassen f√ºr bereits bestehende Ger√§te zu implementieren. F√ºr die Visualisierung der Topic-Hierarchie wurde ein Explorer mithilfe der ttk.Treeview - Komponente implementiert, wodurch die Baumstruktur nicht von Grund auf implementiert werden musste. Damit die Nachrichten bei einem Klick auf eine Topic-Ebene angezeigt werden k√∂nnen, m√ºssen die Nachrichten in einer internen Datenstruktur gespeichert werden. Diese werden bei der Auswahl einer Topic-Ebene in einer separaten Scrollbox angezeigt. In den Anforderungen ist au√üerdem gefordert, dass Benutzer*innen einzelne, benutzerdefinierte Nachrichten w√§hrend der Laufzeit ver√∂ffentlichen k√∂nnen. Daf√ºr wird die Klasse MessagePublisher implementiert, welche im ihrem Frontend zwei Eingabefelder f√ºr das Topic und die Payload besitzt.;0
Betrachtet man im Vergleich zu den genannten Klassen den Aufbau und die gemessenen Werte des  Templates ‚ÄûbubbleSort‚Äú, d as in der √úbersicht des Tools Embold die beste Bewertung erzielt, so kann  festgestellt werden , dass die Messdaten keine Grenzwerte √ºberschreiten. Die Funktionalit√§t der  Klasse ist ausf√ºhrlich dokumentiert, nicht auff√§llig tief verschachtelt und erf√ºllt das  Single - Responsibility -Prinzip mit nur einer zugeordneten Funktion.  Aus diesen Gr√ºnden erzielt die  Komponente einen sehr guten Score nahe am Maximum. Best√§tigt wird diese Bewertung durch die  Halstead -Metriken , die sich ebenfalls deutlich im Rahmen der vorg egebenen Thresholds  bewegen.   Bei Betrachtung der Gesamtbewertung der einzelnen Komponenten in Embold f√§llt auf, dass sich die  einzelnen Ratings aller Klassen am oberen Ende der Skala bewegen. Bei einer Skala von -5 bis 5 liegt  der schlechteste Wert lediglich bei 4.2, was vor allem  auf die wenigen Funktionalit√§ten,  Komponenten und Beziehungen und damit die √úbersichtlichkeit in kle inen Softwareprojekten   zur√ºckzuf√ºhren ist.   Java Implementierung des Computerspiels Zork   Bei dem im Java implementierten Spiel Zork handelt es sich um ein studentisches Gro√üprojekt, das  aus √ºber 100 Klassen besteht. Aus diesem Grund ist es geeignet , um  die Aussagekraft von  Metriken  in Hinblick auf Koppl ung und Abh√§ngigkeiten zu bewerten . Wie bereits bei der vorherigen Analyse  des Bubblesort -Projekts f√§llt auch hi er auf, dass die durch CCCC gemessenen Basismetriken auf eine  unzureichende Kommentierung sowie erh√∂hte Komplexit√§t einiger Klassen hinweisen, was einen  negativen Effekt auf die Lesbarkeit und Verst√§ndlichkeit des Zork -Quellcodes hat.  Alle Werte k√∂nnen  den mitgelieferten Dateien des Tools CCCC entnommen werden.;0
 Ausblick  Die vorliegende Arbeit hat sich mit der Realisierung eines IoT-Systems zur autonomen Steuerung einer Katzenklappe befasst, das mittels KI-basierter Katzenerkennung arbeitet. Die Ergebnisse zeigen, dass durch den Einsatz moderner Technologien wie Bildverarbeitung und Machine Learning eine zuverl√§ssige und effiziente L√∂sung entwickelt werden kann, die sowohl den Bed√ºrfnissen der Haustiere als auch den Anforderungen der Halter gerecht wird. Neben der unmittelbaren Verbesserung der Lebensqualit√§t f√ºr Katzen und deren Halter bietet das System auch vielversprechende Perspektiven f√ºr zuk√ºnftige Entwicklungen.  Im Ausblick auf weitere Forschungen und Anwendungen dieses Systems ergeben sich verschiedene spannende Ans√§tze:  1. Erweiterung der Erkennungsalgorithmen: Zuk√ºnftige Entwicklungen k√∂nnten sich darauf konzentrieren, die Genauigkeit der Katzenerkennung weiter zu optimieren. Hierbei k√∂nnten zus√§tzliche Algorithmen zur Bildverarbeitung wie z.B. sichere Erkennung bei unterschiedlichen Lichtverh√§ltnissen oder unter verschiedenen Umgebungsbedingungen implementiert werden.   2. Integration weiterer Sensortechnologien: Die Einbeziehung weiterer IoT-Sensoren k√∂nnte nicht nur die Funktionalit√§t der Katzenklappe erweitern, sondern auch die Gesamtsteuerung des Haushalts intelligenter gestalten. Sensoren zur √úberwachung von Temperatur, Luftqualit√§t oder anderer Haustiere k√∂nnten wertvolle Daten liefern und die Lebensqualit√§t aller Tiere im Haushalt verbessern.  3. Skalierbarkeit des Systems: Der Ansatz k√∂nnte auf andere Haustierarten oder sogar auf unterschiedliche Anwendungen in Smart Homes ausgeweitet werden. Beispielsweise k√∂nnte ein √§hnliches System f√ºr Hunde oder Kleintiere entwickelt werden, welches ebenfalls KI-gest√ºtzte Erkennungstechnologien nutzt.  4. Benutzerschnittstelle und Benutzererfahrung: Eine benutzerfreundliche App f√ºr Haustierbesitzer k√∂nnte entwickelt werden, um das System zu steuern, Benachrichtigungen zu erhalten und Statistiken √ºber das Verhalten ihrer Tiere zu analysieren. Dies k√∂nnte das Engagement der Benutzer erh√∂hen und eine enge Verbindung zwischen Mensch und Tier f√∂rdern.  5. Nachhaltigkeit und ethische √úberlegungen: Bei der Entwicklung von IoT-Systemen ist es wichtig, auch nachhaltige Praktiken zu ber√ºcksichtigen. Zuk√ºnftige Arbeiten k√∂nnten sich mit Mobilit√§t, Energieverbrauch und den ethischen Implikationen der Einsatzm√∂glichkeiten von KI in der Heimtierhaltung auseinandersetzen.   Insgesamt bietet die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung nicht nur einen praktischen Nutzen, sondern auch zahlreiche M√∂glichkeiten f√ºr weitere innovative Forschung und Entwicklung im Bereich der Heimtierpflege und der intelligenten Wohnumgebungen. Die Ergebnisse dieser Arbeit legen den Grundstein f√ºr zuk√ºnftige Arbeiten, die darauf abzielen, das Potenzial dieser Technologien voll auszusch√∂pfen und einen positiven Einfluss auf das Leben von Haustieren und deren Haltern auszu√ºben.;1
Im Rahmen dieser wissenschaftlichen Arbeit wurde ein virtuelles MQTT-Szenario entwickelt, das speziell f√ºr Lehrzwecke konzipiert ist. Die Untersuchung hat gezeigt, dass die Implementierung eines solchen Szenarios nicht nur die Vermittlung komplexer Themen der Internet-of-Things-Technologie (IoT) erleichtert, sondern auch das Verst√§ndnis der zugrunde liegenden Kommunikationsprotokolle f√∂rdert. Durch den Einsatz von MQTT (Message Queuing Telemetry Transport) als leichtgewichtigem Protokoll konnten die Studierenden praxisnahe Erfahrungen sammeln, die √ºber theoretische Kenntnisse hinausgehen.  Die Ergebnisse der durchgef√ºhrten Lehrveranstaltungen belegen, dass die Nutzung des virtuellen Szenarios die Motivation und das Engagement der Teilnehmenden signifikant erh√∂ht hat. Die M√∂glichkeit, in einer sicheren und kontrollierten Umgebung zu experimentieren, hat den Lernprozess unterst√ºtzt und dazu beigetragen, dass komplexe Konzepte wie Publish/Subscribe-Modelle und die Handhabung von Nachrichtenfl√ºssen besser verstanden wurden. Dar√ºber hinaus f√∂rderte die Interaktivit√§t des Szenarios die Zusammenarbeit unter den Studierenden und erm√∂glichte einen aktiven Austausch von Ideen und L√∂sungsans√§tzen.  Ein weiterer wichtiger Aspekt der Arbeit war die Evaluation des Szenarios durch die Teilnehmenden. Das Feedback zeigte, dass die Studierenden die praktische Anwendung des theoretischen Wissens als besonders wertvoll empfanden. Sie berichteten von einer gesteigerten F√§higkeit, die erlernten Konzepte in realen Anwendungen zu erkennen und anzuwenden. Diese Erkenntnisse unterstreichen die Relevanz von praxisorientierten Lehrmethoden in der technischen Ausbildung.  Zusammenfassend l√§sst sich festhalten, dass die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke nicht nur die didaktischen M√∂glichkeiten erweitert, sondern auch einen entscheidenden Beitrag zur F√∂rderung von Kompetenzen im Bereich der IoT-Technologien leistet. Zuk√ºnftige Forschungen sollten sich darauf konzentrieren, das Szenario weiter zu optimieren und zus√§tzliche Anwendungsf√§lle zu integrieren, um den Lernenden eine noch umfassendere und vielseitigere Lernerfahrung zu bieten. Die vorliegende Arbeit legt somit den Grundstein f√ºr weitere Entwicklungen und Innovationen in der Lehre, die den dynamischen Anforderungen der digitalen Welt gerecht werden.;1
 Kapitel 2: Technische Grundlagen von Content-Management-Systemen  Content-Management-Systeme (CMS) sind Softwarel√∂sungen, die es Benutzern erm√∂glichen, digitale Inhalte zu erstellen, zu verwalten und zu ver√∂ffentlichen. Diese Systeme haben sich in den letzten Jahrzehnten zu einem unverzichtbaren Werkzeug f√ºr Unternehmen, Organisationen und Privatpersonen entwickelt, die eine Online-Pr√§senz aufbauen oder pflegen m√∂chten. Um die verschiedenen CMS zu verstehen und ihre Vor- und Nachteile zu vergleichen, ist es wichtig, sich mit den technischen Grundlagen vertraut zu machen, auf denen sie basieren.   2.1 Architektur von Content-Management-Systemen  Content-Management-Systeme sind in der Regel in einer Client-Server-Architektur aufgebaut. Diese Architektur erm√∂glicht es, dass die Benutzeroberfl√§che (Client) von der Datenbank und der Logik (Server) getrennt ist. Die Benutzer interagieren √ºber Webbrowser mit dem CMS, w√§hrend die Serverkomponenten f√ºr die Speicherung und Verarbeitung der Inhalte verantwortlich sind. Diese Trennung bietet Flexibilit√§t und Skalierbarkeit, da die Benutzeroberfl√§che unabh√§ngig von den zugrunde liegenden Datenstrukturen entwickelt und aktualisiert werden kann.  Die meisten CMS verwenden eine relationale Datenbank, um Inhalte zu speichern. Diese Datenbanken organisieren Informationen in Tabellen, die durch Schl√ºssel miteinander verbunden sind. Die g√§ngigsten Datenbankmanagementsysteme, die in CMS eingesetzt werden, sind MySQL, PostgreSQL und SQLite. Die Wahl der Datenbank hat Auswirkungen auf die Leistung, Sicherheit und Skalierbarkeit des Systems.   2.2 Content-Management-Frameworks  Einige CMS basieren auf Content-Management-Frameworks, die als Grundlage f√ºr die Entwicklung von Anwendungen dienen. Diese Frameworks bieten eine Sammlung von Bibliotheken und Tools, die Entwicklern helfen, ma√ügeschneiderte L√∂sungen zu erstellen. Beispiele f√ºr solche Frameworks sind Laravel f√ºr PHP, Django f√ºr Python und Ruby on Rails f√ºr Ruby. Sie bieten Funktionen wie Routing, Datenbankzugriff und Sicherheit, die die Entwicklungszeit verk√ºrzen und die Wartbarkeit des Codes verbessern.   2.3 Benutzeroberfl√§che und Benutzererfahrung  Die Benutzeroberfl√§che eines CMS ist entscheidend f√ºr die Benutzererfahrung. Sie sollte intuitiv und benutzerfreundlich gestaltet sein, um es auch technisch weniger versierten Benutzern zu erm√∂glichen, Inhalte zu erstellen und zu verwalten. Viele CMS bieten Drag-and-Drop-Funktionen, die es Benutzern erm√∂glichen, Inhalte einfach zu verschieben und zu organisieren, sowie WYSIWYG-Editoren (What You See Is What You Get), die eine visuelle Bearbeitung von Inhalten erm√∂glichen.  Die Benutzeroberfl√§che kann durch Themes und Templates angepasst werden, die das Design und die Struktur der Website bestimmen. Diese Anpassungsf√§higkeit ist ein wichtiger Aspekt, der bei der Auswahl eines CMS ber√ºcksichtigt werden sollte, da sie es erm√∂glicht, die Website an die spezifischen Anforderungen und das Branding einer Organisation anzupassen.   2.4 Sicherheit und Zugriffskontrolle  Sicherheit ist ein zentrales Anliegen bei der Verwendung von CMS, da sie h√§ufig Ziele von Cyberangriffen sind. Die meisten modernen CMS implementieren Sicherheitsma√ünahmen wie Benutzerauthentifizierung, Rollen- und Berechtigungsmanagement sowie regelm√§√üige Sicherheitsupdates. Die Zugriffskontrolle erm√∂glicht es Administratoren, spezifische;1
In Kapitel n 2 und 3 wurden verschiedene Standardsoftwares auf ihren Funktionsumfang  gepr√ºft . Es zeigte sich, dass einige Softwares die Anforderungen an die  Aufgabenverwaltungssoftware nahezu vollst√§ndig, andere nur teilweise erf√ºllten. Bei der  Anforderung ‚Äû√úberpr√ºfung der Arbeitsleistung‚Äú konnte jedoch keine Software vollst√§ndig  √ºberzeugen. Es k√∂nnte erwogen werden, eine eigene Software zu entwickeln. Hierf√ºr fallen  keine Lizenzkosten an, es w√ºrden nur Betriebskosten und Wartungsaufw√§nde anfallen,  ebenso k√∂nnen weitere Funktionen hinzugef√ºgt werden, falls neue Anforderungen an die  Software gestellt werden.  Eine Aufwandssch√§tzung ist fehlerbehaftet. Je weiter eine Sch√§tzung  von der tats√§chlichen  Implementierung entfernt ist, desto gr√∂√üer ist der Sch√§tzfehler. Dieses Ph√§nomen ist unter  dem Begriff ‚ÄûCone of Uncertainty‚Äú  hinl√§nglich bekannt. Um die  Sch√§tzgenauigkeit zu verbessern, kann ein strukturierter Ansatz f√ºr die Sch√§tzung gew√§hlt  werden. Einer davon ist die von IBM in den 1970ern entwickelte ‚ÄûFunction Point -Analyse‚Äú. Eine Besonderheit ist, dass sie auf der Sicht der Nutzer*innen aufbaut. F√ºr das Sch√§tzverfahren ist die konkrete Technologie deswegen  irrelevant. Damit kann die FPA eingesetzt werden, sobald die fachlichen Anforderungen an die  Software formuliert worden sind.  Im Folgenden wird eine Aufgabenverwaltungssoftware beschrieben, die die Anforderungen  f√ºr die studentische Softwareentwicklung mit Bewertung der Arbeitsleistung erf√ºllt. Hierbei  wird darauf geachtet, den Funktionsumfang zu beschreiben, um ein Projekt mit mehreren  Personen √ºber einen l√§ngeren Zeitraum hinweg effizient zu organisieren. Es werden jedoch  Funktionen weggelassen, wenn sie einen geringen Nutzen beisteuern, jedoch hierf√ºr ein  hoher Aufwand investiert werden m√ºsste. Die gesammelten Anforderungen werden in Kapitel  5 verwendet, um eine ‚ÄûFunction Point‚Äú -Analyse durchzuf√ºhren.  Bei der Entwicklung von Anwendungen m√ºssen einige Dinge beachtet wer den, um eine hohe  Sicherheit zu gew√§hrleisten. F√ºr die Implementierung von sicheren Systeme n wird auf  spezialisierte Fachliteratur verwiesen, wie beispielsweise ‚ÄûCyber -Sicherheit: Das Lehrbuch f√ºr  Konzepte, Prinzipien, Mechanismen, Architekturen und Eigenschaften von  Cyber- Sicherheitssystemen in der Digitalisierung ‚Äú von Nobert Pohlmann. Die Sch√§tzung wird nur die  funktionalen Anforderungen an die Software ber√ºcksichtigen und keine Aufw√§nde, die durch  die Anwendung von sicheren Verfahren und Vorgehensweisen entstehen.;0
 Eine Analyse f√ºr die Implementierung eigener L√∂sungen  In der digitalen √Ñra sind Content-Management-Systeme (CMS) zu unverzichtbaren Werkzeugen f√ºr die Erstellung, Verwaltung und Ver√∂ffentlichung von Inhalten geworden. Sie bieten eine Vielzahl von Funktionen und Anpassungsm√∂glichkeiten, die es Unternehmen und Einzelpersonen erm√∂glichen, ihre Online-Pr√§senz effektiv zu steuern. In diesem Prosatext werden verschiedene Content-Management-Systeme miteinander verglichen und der Fokus liegt dabei auf der .   Grundlegende Konzepte und Typen von CMS  Content-Management-Systeme sind in zwei Hauptkategorien unterteiltpropriet√§re Systeme (wie Adobe Experience Manager) und Open-Source-L√∂sungen (wie WordPress, Joomla und Drupal). Propriet√§re Systeme bieten umfassende Funktionen und oft eine professionelle Unterst√ºtzung, sind jedoch mit hohen Kosten verbunden. Open-Source-Systeme hingegen sind meist kostenfrei und kommissarisch erweiterbar, was sie besonders f√ºr kleine Unternehmen und Start-ups attraktiv macht.   Kriterien der Gegen√ºberstellung  Bei der Evaluierung von CMS zur  sind verschiedene Kriterien zu ber√ºcksichtigenBenutzerfreundlichkeit, Anpassungsf√§higkeit, Sicherheitsprotokolle, Skalierbarkeit und Community-Support. Diese Faktoren beeinflussen nicht nur die genutzte Technologie, sondern auch den langfristigen Erhalt von Inhalten und die Systemperformance.   Benutzerfreundlichkeit  F√ºr Anwender, die nicht √ºber tiefe technische Kenntnisse verf√ºgen, ist die Benutzerfreundlichkeit entscheidend. Systeme wie WordPress sind f√ºr ihre intuitive Bedienoberfl√§che bekannt, wodurch selbst Anf√§nger Inhalte leicht hochladen und verwalten k√∂nnen. J√ºngere, komplexere CMS-Systeme wie Drupal bieten mehr Flexibilit√§t, k√∂nnen jedoch eine steilere Lernkurve erfordern.   Anpassungsf√§higkeit  Die Anpassungsf√§higkeit ist ein Schl√ºsselfaktor, insbesondere wenn Unterschiede in Anforderungen oder zuk√ºnftige Gesch√§ftserweiterungen ber√ºcksichtigt werden m√ºssen. Open-Source-L√∂sungen offerieren oftmals unz√§hlige Plugins und Module, die individuell nach Bedarf integriert werden k√∂nnen. Bei propriet√§ren L√∂sungen besteht oftmals Einschr√§nkung, stellen jedoch in der Regel wertgest√ºtzte Funktionalit√§ten zur Verf√ºgung, die bei einer g√§ngigen Bedarfsabdeckung hilfreich sind.   Sicherheitsprotokolle  Sicherheit wird bei der Implementierung eines CMS zur obersten Priorit√§t. W√§hrend bekannte Open-Source-Plattformen durch eine aktive Community von Entwicklern im Hinblick auf Sicherheit ge-patcht werden, ist eine eigene L√∂sung nicht vor Cyberangriffen immun. Propriet√§re L√∂sungen haben meist integrierte Sicherheitsfunktionen und bieten h√§ufig schnellere Reaktionszeiten zur Behebung von Schwachstellen, wenn man bereit ist, die Kosten daf√ºr zu tragen.   Skalierbarkeit  Die Wachstumsstrategie eines Unternehmens hat direkte Auswirkungen auf den gew√§hlten CMS. Open-Source-Formate sind vielfach so konzipiert, dass sie mit dem Unternehmen wachsen k√∂nnen, und einem vom Selbstzeitverh√§ltnis sind dennoch L√∂sungsvariantionen eingeschlossen. Die Struktur modsmoderled Konzepte unterst√ºtzt den Aufbau einer soliden Architektur. Zum anderen bieten viele propriet√§re CMS-Programme zentralisierte L√∂sungen, die bestens zum Wachstum konzipiert wurden, dies jedoch oft mit individuellen jeuhn Hengsten zusammenbietet.   Community-Support  Der Community-Support ist ein Haupteindruck in;1
 Kapitel 2: Konzeptionierung der Vergleichsanalyse von PWA und nativen Apps am Beispiel einer Journaling-App   2.1 Einleitung  Die fortschreitende Entwicklung mobiler Technologien hat die Art und Weise, wie Benutzer mit Software interagieren, revolutioniert. Besonders im Bereich der mobilen Anwendungen stehen Entwickler vor der Wahl zwischen der Erstellung nativer Apps und der Nutzung von Progressive Web Apps (PWA). Diese Entscheidung ist von entscheidender Bedeutung, da sie nicht nur die Benutzererfahrung, sondern auch die Entwicklungs- und Wartungskosten beeinflusst. In diesem Kapitel wird die Konzeptionierung der Vergleichsanalyse zwischen PWA und nativen Apps am Beispiel einer Journaling-App dargestellt. Ziel ist es, die spezifischen Merkmale, Vor- und Nachteile beider Ans√§tze zu beleuchten und deren Auswirkungen auf die Nutzererfahrung zu untersuchen.   2.2 Definition der Zielsetzung  Die Zielsetzung dieser Untersuchung besteht darin, die Leistungsf√§higkeit und Benutzerfreundlichkeit von PWAs und nativen Apps im Kontext einer Journaling-App zu vergleichen. Dabei sollen insbesondere folgende Aspekte betrachtet werden:  - Benutzererfahrung (UX): Wie beeinflussen die unterschiedlichen Technologien die Interaktivit√§t und das Nutzerengagement? - Leistungsf√§higkeit: Wie schneiden die beiden Ans√§tze hinsichtlich Ladezeiten, Offline-Funktionalit√§t und Gesamtperformance ab? - Entwicklungskosten und -aufwand: Welche finanziellen und zeitlichen Ressourcen sind erforderlich, um eine Journaling-App in beiden Formaten zu entwickeln? - Verbreitung und Zug√§nglichkeit: Wie unterscheiden sich die Reichweiten und Verbreitungsm√∂glichkeiten der beiden App-Typen?   2.3 Methodik  Um die oben genannten Ziele zu erreichen, wird eine qualitative und quantitative Forschungsstrategie verfolgt. Diese umfasst folgende Schritte:  1. Literaturrecherche: Eine umfassende Analyse bestehender Literatur zu PWA und nativen Apps wird durchgef√ºhrt, um aktuelle Trends, Technologien und Nutzererfahrungen zu identifizieren.     2. Fallstudienanalyse: Es werden bestehende Journaling-Apps sowohl in Form von PWAs als auch als nativen Apps untersucht. Hierbei werden Aspekte wie Design, Benutzeroberfl√§che und Funktionalit√§t analysiert.  3. Befragungen und Nutzerfeedback: Um die Benutzererfahrung direkt zu erfassen, werden Nutzer befragt, die sowohl PWAs als auch native Apps verwenden. Die gesammelten Daten werden statistisch ausgewertet, um signifikante Unterschiede und Pr√§ferenzen zu identifizieren.  4. Performance-Tests: Technische Tests werden durchgef√ºhrt, um die Ladezeiten, die Offline-Funktionalit√§t und die allgemeine Performance der beiden App-Typen zu messen. Diese Tests sollen objektive Daten liefern, die die subjektiven Eindr√ºcke der Nutzer erg√§nzen.   2.4 Auswahl der Journaling-App  F√ºr diese Analyse wurde die Journaling-App ‚ÄûReflectly‚Äú ausgew√§hlt, die sowohl als native App f√ºr iOS und Android als auch als PWA verf√ºgbar ist. Reflectly bietet eine Vielzahl von Funktionen, die f√ºr die Analyse relevant sind, darunter personalisierte Journaleingaben, Erinnerungsfunktionen und eine ansprechende Benutzeroberfl√§che. Diese Auswahl erm√∂glicht es, die St√§rken und Schw√§chen beider Ans√§tze in einem realen;1
In der vorliegenden Arbeit wurde eine umfassende Gegen√ºberstellung verschiedener Content-Management-Systeme (CMS) durchgef√ºhrt, um deren Funktionalit√§ten, Benutzerfreundlichkeit und Anwendungsgebiete zu analysieren. Die Ergebnisse zeigen, dass die Auswahl eines geeigneten CMS stark von den individuellen Anforderungen und Zielen einer Organisation abh√§ngt. W√§hrend Systeme wie WordPress durch ihre Flexibilit√§t und gro√üe Community bestechen, bieten spezialisierte L√∂sungen wie TYPO3 oder Drupal erweiterte Funktionen f√ºr komplexe Projekte und gr√∂√üere Unternehmen.  Ein zentrales Ergebnis der Analyse ist, dass die Benutzerfreundlichkeit und die Lernkurve entscheidende Faktoren f√ºr die Akzeptanz eines CMS sind. Systeme, die eine intuitive Benutzeroberfl√§che und umfassende Dokumentation bieten, erm√∂glichen es auch weniger technikaffinen Nutzern, Inhalte effektiv zu verwalten. Zudem wurde deutlich, dass die Integrationsf√§higkeit in bestehende Systeme und die Unterst√ºtzung von Schnittstellen f√ºr viele Organisationen von gro√üer Bedeutung sind.  Dar√ºber hinaus spielt die Sicherheitsarchitektur der CMS eine wesentliche Rolle, insbesondere in einer Zeit, in der Cyberangriffe zunehmend zunehmen. Die regelm√§√üigen Updates und die Verf√ºgbarkeit von Sicherheitsplugins sind entscheidende Kriterien, die in die Auswahlentscheidung einflie√üen sollten.  Zusammenfassend l√§sst sich festhalten, dass die Wahl des richtigen Content-Management-Systems nicht nur eine technische Entscheidung ist, sondern auch strategische √úberlegungen erfordert. Organisationen sollten ihre spezifischen Bed√ºrfnisse, Ressourcen und langfristigen Ziele sorgf√§ltig abw√§gen, um ein CMS zu w√§hlen, das nicht nur kurzfristig funktioniert, sondern auch langfristig eine nachhaltige L√∂sung f√ºr das Content-Management bietet. In Anbetracht der dynamischen Entwicklungen im Bereich der digitalen Technologien ist es zudem ratsam, regelm√§√üig die Marktangebote zu evaluieren und gegebenenfalls Anpassungen vorzunehmen, um den sich wandelnden Anforderungen gerecht zu werden.;1
Evaluierung des Aufbaus eines Content-Management-Systems zur Erstellung von Android Apps f√ºr den humanoiden Roboter Pepper  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung eines Content-Management-Systems (CMS) zur Erstellung von Android-Apps, die speziell f√ºr den humanoiden Roboter Pepper konzipiert sind. In der Evaluierung werden sowohl die technischen als auch die praktischen Aspekte des CMS beleuchtet, um dessen Effektivit√§t und Benutzerfreundlichkeit zu beurteilen.  Zun√§chst ist festzustellen, dass der humanoide Roboter Pepper, der von SoftBank Robotics entwickelt wurde, √ºber eine einzigartige Interaktionsf√§higkeit verf√ºgt, die ihn f√ºr den Einsatz in verschiedenen Bereichen wie Bildung, Gesundheitswesen und Kundenservice pr√§destiniert. Die M√∂glichkeit, ma√ügeschneiderte Apps zu erstellen, die auf die spezifischen Bed√ºrfnisse der Nutzer und der Einsatzumgebungen abgestimmt sind, ist daher von zentraler Bedeutung. Das entwickelte CMS zielt darauf ab, diesen Prozess zu vereinfachen und zu optimieren.  Ein zentrales Merkmal des CMS ist seine Benutzeroberfl√§che, die so gestaltet wurde, dass sie auch f√ºr Nutzer ohne tiefgehende Programmierkenntnisse zug√§nglich ist. Die Evaluierung der Benutzerfreundlichkeit zeigt, dass die intuitive Navigation und die klar strukturierten Men√ºs es den Anwendern erm√∂glichen, schnell und effizient Apps zu erstellen. Dies ist besonders wichtig, da viele potenzielle Nutzer, wie beispielsweise Lehrkr√§fte oder Pflegekr√§fte, m√∂glicherweise keine technischen Experten sind.  Technisch betrachtet wurde das CMS auf der Grundlage moderner Webtechnologien entwickelt, die eine nahtlose Integration mit der Android-Plattform erm√∂glichen. Die Verwendung von Frameworks, die speziell f√ºr die Entwicklung von Android-Anwendungen optimiert sind, gew√§hrleistet eine hohe Performance und Stabilit√§t der erstellten Apps. In der Evaluierung wurden verschiedene Testl√§ufe durchgef√ºhrt, um die Funktionalit√§t und Stabilit√§t des Systems zu √ºberpr√ºfen. Die Ergebnisse zeigen, dass das CMS in der Lage ist, fehlerfreie und performante Apps zu generieren, die problemlos auf dem Pepper-Roboter installiert und betrieben werden k√∂nnen.  Ein weiterer wichtiger Aspekt der Evaluierung ist die Flexibilit√§t des CMS. Es erm√∂glicht den Nutzern, verschiedene App-Templates auszuw√§hlen und anzupassen, was die kreative Freiheit bei der App-Entwicklung erh√∂ht. Die M√∂glichkeit, Multimedia-Inhalte wie Bilder, Videos und Audiodateien einfach einzuf√ºgen, tr√§gt zur Attraktivit√§t der erstellten Anwendungen bei. Die R√ºckmeldungen von Testnutzern best√§tigen, dass diese Funktionalit√§t entscheidend zur Benutzerzufriedenheit beitr√§gt.  Dennoch gibt es auch Herausforderungen, die im Rahmen der Evaluierung identifiziert wurden. Einige Nutzer berichteten von Schwierigkeiten beim Verst√§ndnis bestimmter technischer Begriffe und Konzepte, die im CMS verwendet werden. Dies deutet darauf hin, dass eine zus√§tzliche Schulung oder eine umfassendere Dokumentation erforderlich sein k√∂nnte, um die Barrieren f√ºr weniger technikaffine Nutzer weiter zu senken. Zudem wurde festgestellt, dass die Performance des CMS bei einer hohen Anzahl gleichzeitiger Nutzer beeintr√§chtigt werden kann, was in zuk√ºnftigen Versionen optimiert werden sollte.  Zusammenfassend l√§sst sich sagen, dass das entwickelte CMS zur Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper eine vielversprechende L√∂sung darstellt, um die Interaktivit√§t und Anpass;1
Ein weiterer Ansatz, St√ºrze zu erkennen, ist die Verwendung von intelligenten Fu√üb√∂den. Diese messen den Druck einzelner Bereiche und k√∂nnen so feststellen, wo sich eine Person gerade befindet. Wenn nun erkannt wird, dass eine Person nicht mehr steht, sondern umgefallen ist, wird ein Alarm ausgel√∂st, sodass dieser geholfen werden kann.  Der Vorteil eines solchen Systems ist, dass es sehr zuverl√§ssig St√ºrze erkennen kann und es nicht n√∂tig ist, ein zus√§tzliches Ger√§t wie eine Smartwatch mit sich zu f√ºhren. Trotzdem ist diese Methode, verglichen mit anderen, sehr wenig verbreitet, der am h√§ufigsten daf√ºr genannte Grund ist der hohe Preis. Der gesamte Fu√üboden muss f√ºr eine solche Verwendung neu getauscht oder mit Fu√ümatten √ºberdeckt werden. Schlussendlich besteht die M√∂glichkeit, St√ºrze anhand der Bluetooth-Signalst√§rke zu erkennen. Die Idee ist, ein Fitness-Armband mithilfe dessen Signalst√§rke zu orten und anhand dieser Daten Anomalien zu erkennen, welche auf einen Sturz hindeuten. Da solche bluetoothf√§higen Armb√§nder bei aktiviertem Bluetooth in gewissen Zeitabst√§nden ein Signal ausgeben, soll dieses genutzt werden, um an verschiedenen Punkten im Raum dessen St√§rke zu bestimmen. Der Vorteil einer solchen L√∂sung ist, dass sie extrem freundlich der Privatsph√§re gegen√ºber ist, da lediglich Daten zur Ermittlung der Position innerhalb der Wohnung ermittelt werden und keine Bilder oder √§hnliche sensible Daten. Au√üerdem besitzt diese Art der Sturzerkennung das Potenzial, sehr kosteng√ºnstig zu sein. So sind Bluetooth Empf√§nger- Chips nicht teuer und ein Fitness-Armband, insofern nicht bereits eigene Ger√§te genutzt werden k√∂nnen, ist ebenfalls schon ab 20 Euro erh√§ltlich . Aufgrund dessen, dass diese Methode bereits noch wenig erforscht ist, wird in der vorlie- genden Studienarbeit ein Minimum Viable Product (MVP) dieser Art der Sturzerkennung erarbeitet.;0
 Kapitel 2: Konzeptionierung der wissenschaftlichen Arbeit   2.1 Einleitung  Die vorliegende wissenschaftliche Arbeit verfolgt das Ziel, die Vor- und Nachteile von Progressive Web Apps (PWAs) im Vergleich zu traditionellen nativen Apps zu untersuchen, wobei der Fokus auf der Entwicklung und Nutzung einer Journaling-App liegt. In diesem Kapitel wird die Konzeptionierung der Arbeit detailliert beschrieben, einschlie√ülich der Zielsetzung, der Forschungsfragen, der Methodik und der strukturellen Gliederung.   2.2 Zielsetzung der Arbeit  Die Zielsetzung dieser Arbeit ist es, ein tiefgehendes Verst√§ndnis f√ºr die unterschiedlichen Ans√§tze in der Entwicklung von PWAs und nativen Apps zu gewinnen und deren Auswirkungen auf Benutzererfahrung, Performance, Zug√§nglichkeit und Entwicklungsaufwand zu analysieren. Insbesondere soll untersucht werden, wie sich diese Unterschiede auf die Funktionalit√§t und Benutzerfreundlichkeit einer Journaling-App auswirken, die als praktisches Beispiel dient.   2.3 Forschungsfragen  Um die Zielsetzung zu erreichen, werden folgende zentrale Forschungsfragen formuliert:  1. Welche Unterschiede bestehen in der Entwicklungsarchitektur zwischen PWAs und nativen Apps? 2. Inwiefern beeinflussen diese Unterschiede die Benutzererfahrung am Beispiel einer Journaling-App? 3. Welche Performance-Unterschiede lassen sich zwischen einer PWA und einer nativen Journaling-App feststellen? 4. Wie steht es um die Zug√§nglichkeit und die plattform√ºbergreifende Nutzung der Apps im Vergleich? 5. Welcher Entwicklungsaufwand ist mit der Erstellung einer PWA vs. einer nativen App verbunden?   2.4 Methodik  Die Methodik der Arbeit kombiniert qualitative und quantitative Ans√§tze, um ein umfassendes Bild zu erhalten:  1. Literaturrecherche: Eine detaillierte Analyse bestehender Literatur √ºber PWAs und native Apps wird durchgef√ºhrt, um theoretische Grundlagen und aktuelle Trends zu identifizieren.     2. Fallstudie: Es wird eine Journaling-App entwickelt, sowohl als PWA als auch als native App (f√ºr Android/iOS), um die praktischen Implikationen und Erfahrungen zu dokumentieren.  3. Usability-Tests: Nutzerumfragen und Usability-Tests werden durchgef√ºhrt, um die Benutzererfahrungen mit beiden App-Versionen zu erfassen. Die Ergebnisse dieser Tests sollen einen Vergleich der Benutzerfreundlichkeit beider Ans√§tze erm√∂glichen.  4. Performancemessungen: Die beiden App-Versionen werden hinsichtlich Ladezeiten, Ressourcenverbrauch und Reaktionsgeschwindigkeit hinsichtlich der Benutzerinteraktionen analysiert.   5. Interviews: Gespr√§che mit Entwicklern, die Erfahrung mit beiden Technologien haben, sollen zus√§tzliche qualitative Einblicke zu Entwicklungsaufwand und -herausforderungen liefern.   2.5 Struktur der Arbeit  Die Arbeit gliedert sich in folgende Hauptkapitel:  1. Einf√ºhrung: Vorstellung des Themas, der Relevanz und der Zielsetzung. 2. Konzeptionierung: Detaillierte Ausf√ºhrung der Methodik und der Forschungsfragen. 3. Theoretische Grundlagen: Erl√§uterung der Technologien PWA und native Apps, einschlie√ülich ihrer Vor- und Nachteile. 4. Entwicklung der Journaling-App: Beschreibung des Konzeptions- und Entwicklungsprozesses f√ºr die PWA sowie die native Version. 5. Usability-Tests und Performancemessungen: Analyse der Ergebnisse der durchgef√ºhrten Tests und Messungen. 6. Diskussion der Ergebnisse: Interpretation und Vergleich der Ergebnisse der PWA und der nativen App in Bezug auf die Forschungsfragen. 7. Fazit und Ausblick: Zusammenfassung der Erkenntnisse, Limitierungen der Arbeit und Vorschl√§ge f√ºr zuk√ºnftige Forschungen.   2.6 Fazit  In diesem Kapitel wurde die Konzeptionierung der wissenschaftlichen Arbeit dargelegt, die sich mit dem Vergleich von PWAs und nativen Apps am Beispiel einer Journaling-App besch√§ftigt. Durch die sorgf√§ltige Ausarbeitung der Zielsetzung, der Forschungsfragen und der Methodik sowie der strukturellen Gliederung wird eine fundierte Basis geschaffen, um die Themen umfassend zu analysieren und kritische Einsichten zu gewinnen. Im n√§chsten Kapitel wird auf die theoretischen Grundlagen eingegangen, die f√ºr das Verst√§ndnis der technologischen Rahmenbedingungen und deren Auswirkungen auf die App-Entwicklung notwendig sind.;1
Ein Konzept zur Umsetzung    Die zunehmende Luftverschmutzung und die damit verbundenen Gesundheitsrisiken haben das Interesse an Luftreinigungsger√§ten erheblich gesteigert. Um die Effizienz und Benutzerfreundlichkeit solcher Ger√§te zu erh√∂hen, ist eine umfassende Optimierung der Visualisierung, Bedienung und Selbstregelung erforderlich. Dieser Prosatext skizziert ein Konzept zur Umsetzung dieser Optimierungsma√ünahmen, wobei technologische Innovationen und nutzerzentrierte Ans√§tze im Vordergrund stehen.  1. Visualisierung  Die Visualisierung von Luftqualit√§tsdaten ist entscheidend f√ºr das Verst√§ndnis und die Akzeptanz von Luftreinigungsger√§ten. Ein modernes Luftreinigungsger√§t sollte √ºber ein intuitives Display verf√ºgen, das relevante Informationen in Echtzeit darstellt. Folgende Ma√ünahmen sind vorgesehen - Echtzeit-DatenanzeigeImplementierung eines OLED-Displays, das Parameter wie PM2.5- und PM10-Werte, VOC-Konzentrationen sowie die aktuelle Betriebsstufe des Ger√§tes anzeigt. Die Daten sollten aus hochwertigen Sensoren stammen, um pr√§zise Informationen zu gew√§hrleisten.  - FarbkodierungEinf√ºhrung eines Farbcodesystems zur schnellen Erfassung der Luftqualit√§t. Gr√ºn signalisiert gute Luftqualit√§t, w√§hrend Orange und Rot auf zunehmende Schadstoffkonzentrationen hinweisen. Diese visuelle Darstellung f√∂rdert das Bewusstsein der Nutzer f√ºr ihre Umgebung.  - Mobile App-IntegrationEntwicklung einer begleitenden Smartphone-App, die eine erweiterte Visualisierung der Luftqualit√§tsdaten bietet. Nutzer k√∂nnen historische Daten einsehen, Trends analysieren und Benachrichtigungen zu Luftqualit√§tsver√§nderungen erhalten.  2. Bedienung  Die Benutzerfreundlichkeit ist ein zentrales Element bei der Optimierung von Luftreinigungsger√§ten. Um die Bedienung zu vereinfachen, werden folgende Strategien verfolgt - Intuitive Benutzeroberfl√§cheGestaltung einer benutzerfreundlichen Oberfl√§che, die eine einfache Navigation durch die verschiedenen Betriebsmodi erm√∂glicht. Gro√üe, klar beschriftete Tasten und Symbole auf dem Display erleichtern die Bedienung, insbesondere f√ºr √§ltere Nutzer.  - SprachsteuerungIntegration von Sprachsteuerungsfunktionen, die es den Nutzern erm√∂glichen, das Ger√§t durch einfache Sprachbefehle zu steuern. Dies erh√∂ht die Zug√§nglichkeit und erm√∂glicht eine freih√§ndige Bedienung.  - PersonalisierungM√∂glichkeit zur Anpassung der Einstellungen an individuelle Bed√ºrfnisse, wie z.B. die Wahl von bevorzugten Betriebsmodi oder Zeitpl√§nen. Nutzer k√∂nnen ihre Pr√§ferenzen speichern, was die Bedienung weiter vereinfacht.  3. Selbstregelung  Die Selbstregelung eines Luftreinigungsger√§tes ist entscheidend f√ºr die Optimierung der Reinigungsleistung und die Energieeffizienz. Ein intelligentes Regelungssystem sollte folgende Aspekte ber√ºcksichtigen - Adaptive RegelalgorithmenImplementierung von Algorithmen, die die Luftqualit√§t kontinuierlich √ºberwachen und die Betriebsmodi automatisch anpassen. Bei steigenden Schadstoffkonzentrationen sollte das Ger√§t in einen h√∂heren Reinigungsmodus wechseln, w√§hrend es;1
"‚ÄìKonzeptionelle Informationen zu MQTT zusammen in den Verwendungsszena- rien angeben, wenn diese vorausgesetzt werden. ‚ÄìKonsistente Navigationsoptionen und eine gute Suchfunktion anbieten: Naviga- tion √ºber eine Seitenleiste; Suche, welche auch den Inhalt von Dokumentations- artikeln durchsucht. ‚ÄìKonsistente Strukturierung der Dokumentationskapitel. ‚Ä¢Einstieg in die Verwendung der Bibliothek vereinfachen: ‚ÄìFunktionierende Codebeispiele angeben, welche mit Copy & Paste direkt ver- wendet werden k√∂nnen, z.B. f√ºr die Konfiguration des Smart Homes. ‚ÄìHintergrundwissen und wichtige Konzepte √ºber MQTTan relevanten Stellen angeben, welche den Lernprozess unterst√ºtzen. ‚ÄìEntwickler*innen dabei unterst√ºtzen, die gedankliche Verbindung zwischen MQTT-Konzepten und den implementierten Bibliothekskomponenten herzu- stellen. ‚ÄìEine knappe √úbersicht √ºber die MQTT-Simulation anbieten, welche den Zweck der Bibliothek, Hauptfeatures und wichtige technische Charakteristiken be- schreibt. ‚Ä¢Unterschiedliche Strategien zum Lernen und zur Entwicklung unterst√ºtzen: ‚ÄìQuelltext von normalen Text durch entsprechende Textformatierung unterschei- den. ‚ÄìText-zu-Code-Beziehungen markieren, um Entwickler*innen bei der Verkn√ºp- fung zwischen Konzepten und Code zu helfen, z.B. durch Kommentare oder Annotationen. ‚ÄìWichtige konzeptionelle Informationen redundant angeben, sowohl in den Code- beispielen, als auch im Flie√ütext. ‚ÄìEine schnelle Verwendung des MQTT-Projekts erm√∂glichen, z.B. durch ein Beispielszenario f√ºr das Smart Home, das ohne gro√üen Aufwand ausprobiert werden kann.";0
      In der heutigen Zeit, in der die Luftqualit√§t zunehmend in den Fokus der √∂ffentlichen Gesundheit r√ºckt, gewinnen Luftreinigungsger√§te an Bedeutung. Die Integration elektronischer Komponenten in diese Ger√§te erm√∂glicht nicht nur eine verbesserte Filtertechnologie, sondern auch eine intelligente Steuerung und Benutzerinteraktion. Ziel dieser Arbeit ist es, eine eigene L√∂sung zur Optimierung der Visualisierung, Bedienung und Selbstregelung eines elektronisch erweiterten Luftreinigungsger√§tes zu entwickeln. Dabei werden sowohl technische als auch ergonomische Aspekte ber√ºcksichtigt, um eine benutzerfreundliche und effektive L√∂sung zu schaffen.   Technische Grundlagen  Die Grundlage eines modernen Luftreinigungsger√§tes bildet ein mehrstufiges Filtersystem, das Partikel, Allergene und Schadstoffe aus der Luft entfernt. Die Integration von Sensoren zur kontinuierlichen √úberwachung der Luftqualit√§t ist entscheidend. Diese Sensoren erfassen Parameter wie Feinstaubkonzentration, VOCs (fl√ºchtige organische Verbindungen) und relative Luftfeuchtigkeit. Die gesammelten Daten erm√∂glichen eine adaptive Regelung der Betriebsmodi des Ger√§tes.   Visualisierung  Die Visualisierung der Luftqualit√§tsdaten spielt eine zentrale Rolle in der Benutzerinteraktion. Eine benutzerfreundliche grafische Benutzeroberfl√§che (GUI) wurde entwickelt, die Echtzeitdaten √ºber die Luftqualit√§t anzeigt. Hierbei wurde ein Dashboard-Design gew√§hlt, das sowohl die aktuelle Luftqualit√§t als auch historische Trends visualisiert. Die Verwendung von Farbcodes zur Kennzeichnung der Luftqualit√§t (z.B. gr√ºn f√ºr gut, gelb f√ºr m√§√üig, rot f√ºr schlecht) erm√∂glicht eine sofortige Einsch√§tzung durch den Benutzer.  Zus√§tzlich wurde ein interaktives Element in die GUI integriert, das dem Benutzer die M√∂glichkeit gibt, spezifische Filtereinstellungen vorzunehmen und den Betriebsstatus des Ger√§tes zu √ºberwachen. Die Implementierung von Touchscreen-Technologie bietet eine intuitive Bedienoberfl√§che, die die Benutzerfreundlichkeit erh√∂ht.   Bedienung  Die Bedienung des Luftreinigungsger√§tes wurde durch die Implementierung eines adaptiven Steuerungssystems optimiert. Dieses System nutzt maschinelles Lernen, um das Nutzerverhalten zu analysieren und die Einstellungen des Ger√§tes entsprechend anzupassen. Beispielsweise kann das Ger√§t bei h√§ufigen Nutzungszeiten automatisch in einen h√∂heren Betriebsmodus wechseln, um die Luftqualit√§t schnell zu verbessern.  Dar√ºber hinaus wurde eine Sprachsteuerungsfunktion implementiert, die es den Benutzern erm√∂glicht, das Ger√§t freih√§ndig zu steuern. Dies ist besonders vorteilhaft in Umgebungen, in denen die Benutzer m√∂glicherweise besch√§ftigt sind, wie beispielsweise in der K√ºche oder im B√ºro.   Selbstregelung  Die Selbstregelung des Luftreinigungsger√§tes ist ein entscheidender Aspekt f√ºr die langfristige Effizienz und Benutzerzufriedenheit. Durch die Integration eines intelligenten Regelungssystems, das auf den gesammelten Sensordaten basiert, kann das Ger√§t autonom zwischen verschiedenen Betriebsmodi wechseln. Bei einer Verschlechterung der Luftqualit√§t aktiviert das System automatisch den Turbo-Modus, w√§hrend es bei stabilen Bedingungen in den Energiesparmodus wechselt.  Ein weiterer innovativer Ansatz ist die Implementierung;1
 State of the Art beim Testen von MQTT-basierten L√∂sungenEin Konzept zur Umsetzung     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich in den letzten Jahren als bevorzugte Kommunikationstechnologie f√ºr IoT-Anwendungen etabliert. Aufgrund seiner Leichtgewichtigkeit, Benutzerfreundlichkeit und effizienten Bandbreitennutzung ist MQTT pr√§destiniert f√ºr den Einsatz in ressourcenbeschr√§nkten Umgebungen. In einem sich rapide entwickelnden Markt, wo Zuverl√§ssigkeit und Leistung eine entscheidende Rolle spielen, gewinnt das Testen von MQTT-basierten L√∂sungen zunehmend an Bedeutung. Dieser Text beschreibt den aktuellen Stand der Technik im Testing von MQTT-Anwendungen und schl√§gt ein Konzept zur effizienten Umsetzung vor.   Aktuelle Herausforderungen beim Testen von MQTT  Trotz der weit verbreiteten Nutzung von MQTT stehen Entwickler und Tester vor mehreren Herausforderungen 1. Komplexit√§t der SystemeMQTT-L√∂sungen bestehen oft aus einer Vielzahl von Komponenten, einschlie√ülich Publisher, Subscriber und Broker. Jedes dieser Elemente kann unterschiedliche Implementierungen und Konfigurationen aufweisen, was die Testbarkeit erschwert.  2. Zuverl√§ssigkeit und SkalierbarkeitIn IoT-Anwendungen ist die Zuverl√§ssigkeit der Kommunikation entscheidend. Tests m√ºssen sicherstellen, dass die Nachrichten√ºbertragung unter verschiedenen Bedingungen (z. B. Netzwerkunterbrechungen) robust bleibt.  3. SicherheitsaspekteDie Sicherheit in MQTT-Protokollen bleibt ein zentrales Thema. Potenzielle Angriffe, wie z. B. Man-in-the-Middle (MitM) oder Flooding-Angriffe, erfordern umfassende Sicherheitspr√ºfungen w√§hrend der Testphase.  4. Interoperabilit√§tDa MQTT ein offenes Protokoll ist, m√ºssen Tests die Interoperabilit√§t zwischen verschiedenen Implementierungen und Plattformen ber√ºcksichtigen.   Konzept zur Umsetzung eines Testprozesses  Um diesen Herausforderungen Rechnung zu tragen, soll ein strukturiertes Testkonzept entwickelt werden, das die folgenden Schritte umfasst 1. AnforderungsanalyseIn der ersten Phase werden die Spezifikationen und Anforderungen der MQTT-basierten L√∂sung definiert. Das umfasst sowohl funktionale Anforderungen (z. B. Nachrichtenaustausch zwischen Publisher und Subscriber) als auch nicht-funktionale Anforderungen (z. B. Latenz, Fehlertoleranz, Sicherheit).  2. Testarchitektur entwickelnBasierend auf den Anforderungen wird eine Testarchitektur entworfen. Diese sollte sowohl Unit-Tests (z. B. f√ºr einzelne Module) als auch Integrationstests (z. B. f√ºr das Zusammenspiel zwischen Publisher, Broker und Subscriber) beinhalten. Der Einsatz von Mock-Objekten kann dabei helfen, verschiedene Szenarien zu simulieren.  3. Testumgebung einrichtenEine realistische Testumgebung ist entscheidend. Der Einsatz von Containern (z. B. Docker) kann helfen, verschiedene Broker-Implementierungen und Konfigurationen schnell zu testen. Zudem sollte die Testumgebung verschiedene Netzwerkbedingungen simulieren, um die Robustheit und Leistungsf√§higkeit der L√∂sung zu √ºberpr√ºfen.  4. TestmethodenEine Kombination aus automatisierten Tests und manuellen Tests wird empfohlen. Automatisierte Tests k√∂nnen mithilfe von Frameworks wie JMeter oder Gatling durchgef√ºhrt werden, um Last- und Leistungstests durchzuf√ºhren. Manuelle Tests sind notwendig, um sicherheitsrelevante Aspekte und Usability zu pr√ºfen.  5. Durchf√ºhrung von SicherheitstestsSpezielle Sicherheitstests, wie Penetrationstests und Schwachstellenanalysen, sollten implementiert werden. Hierbei werden Tools wie OWASP ZAP oder Nessus eingesetzt, um Sicherheitsl√ºcken in der MQTT-Implementierung zu identifizieren.  6. Auswertung und ReportingNach der Durchf√ºhrung der Tests sind die Ergebnisse auszuwerten. Ein systematisches Reporting, das sowohl Erfolgsmetriken als auch identifizierte Schwachstellen enth√§lt, ist unerl√§sslich. Tools zur kontinuierlichen Integration (CI) k√∂nnen hierbei den Prozess weiter automatisieren und die Testergebnisse regelm√§√üig √ºberpr√ºfen.  7. Feedback-Schleifen und AnpassungenEin iterativer Prozess zur st√§ndigen Verbesserung der Testmethoden und -werkzeuge sollte implementiert werden. Durch regelm√§√üige Reviews und Anpassungen an der Testarchitektur wird sichergestellt, dass die Qualit√§t der MQTT-basierten L√∂sung kontinuierlich steigt.   Fazit  Das Testen von MQTT-basierten L√∂sungen ist ein komplexer, aber essenzieller Prozess, der unter Ber√ºcksichtigung aktueller Herausforderungen mit einem klar strukturierten Konzept erfolgreich umgesetzt werden kann. Durch eine detaillierte Anforderungsanalyse, eine robuste Testarchitektur und den Einsatz moderner Testmethoden wird die Qualit√§t der Systeme signifikant erh√∂ht. In der dynamischen Welt des Internet of Things ist es unerl√§sslich, diesen Prozess kontinuierlich zu evaluieren und anzupassen, um den hohen Anforderungen an Zuverl√§ssigkeit, Sicherheit und Performance gerecht zu werden.;1
Um festzustellen, ob die Katzenklappe ge√∂ffnet oder geschlossen ist, wird daf√ºr in der Firebase Cloud Firestore Datenbank ein Flag in Form eines Booleans gesetzt. Dieser Flag wird durch die Methode handleCatDoor in demListing 5.6 gesetzt. Um diesen Flag von der App aus ver√§ndern zu k√∂nnen, ben√∂tigt es den Dokumentenname der Katzenklappe in derCloud Firestore Datenbank. Der Dokumentenname kann anhand des eindeutigen Schl√ºssels ermittelt werden. Daf√ºr wird in Zeile zwei bis vier des Listings ein Request an dieapp_selections Kollektion in Firebase gesendet. Dabei wird durch den Befehl whereEqualTo in Zeile drei das Dokument der Katzenklappe, anhand des eindeutigen Schl√ºssels, gesucht. Anschlie√üend wird, je nachdem ob der √ñffnungs- oder Schlie√üungsknopf gedr√ºckt wird, durch den Boolean Parameter opendas zuvor erhaltene Dokument ver√§ndert. Dabei wird das Feld is_my_cat in derCloud Firestore Datenbank mit dem Parameter openbef√ºllt. Des Weiteren wird ein Timestamp wann die Katze hereingelassen wurde √ºbergeben, um die letzte Ver√§nderung des Flags auf dem Raspberry Pi nachvollziehen zu k√∂nnen.;0
 Kapitel 2: Technische Grundlagen f√ºr den Vergleich von PWA und nativen Apps am Beispiel einer Journaling-App   2.1 Einf√ºhrung in Progressive Web Apps (PWA)  Progressive Web Apps (PWA) sind eine moderne Webtechnologie, die es erm√∂glicht, web-basierte Anwendungen zu schaffen, die den Benutzererwartungen herk√∂mmlicher nativer Apps nahekommen. PWAs nutzen die Vorteile von Webtechnologien wie HTML, CSS und JavaScript, um eine nahtlose Benutzererfahrung sowohl auf Desktop- als auch auf mobilen Ger√§ten zu bieten. Zu den wichtigsten Merkmalen von PWAs geh√∂ren:  - Responsive Design: PWAs passen sich dynamisch an verschiedene Bildschirmgr√∂√üen und -aufl√∂sungen an. - Offline-Funktionalit√§t: Dank Service Workern k√∂nnen PWAs auch ohne Internetverbindung funktionieren, indem sie Caching-Strategien implementieren. - App-√§hnliche Erfahrung: PWAs bieten eine Benutzeroberfl√§che, die mit nativen Apps vergleichbar ist, einschlie√ülich Navigation und Gestensteuerung. - Einfache Installation: Nutzer k√∂nnen PWAs direkt √ºber den Webbrowser installieren, ohne den Umweg √ºber App-Stores.   2.2 Native Apps: Ein √úberblick  Native Apps sind speziell f√ºr eine bestimmte Plattform oder ein Betriebssystem, wie iOS oder Android, entwickelte Anwendungen. Sie werden in den nativen Programmiersprachen dieser Plattformen (z.B. Swift f√ºr iOS, Kotlin f√ºr Android) geschrieben und bieten spezifische Funktionen und Integrationen, die in PWAs nicht verf√ºgbar sind. Zu den charakteristischen Merkmalen nativer Apps z√§hlen:  - Leistung: Native Apps haben in der Regel eine bessere Leistung und schnellere Ladezeiten, da sie direkt auf die Hardware-Ressourcen des Ger√§ts zugreifen. - Zugriff auf Ger√§tespezifische Funktionen: Native Apps k√∂nnen auf eine Vielzahl von Ger√§teeigenschaften zugreifen, wie Kamera, GPS, Benachrichtigungen und andere Sensoren. - Benutzererfahrung: Sie bieten eine tiefere Integration in das Betriebssystem und gestalten die Benutzererfahrung konturierter und intuitiver. - Verteilung √ºber App-Stores: Native Apps werden √ºber Plattform-spezifische App-Stores verteilt, was eine gr√∂√üere Sichtbarkeit, aber auch bestimmte Anforderungen an die Zustimmung der Benutzer und die √úberpr√ºfung durch die Plattformbetreiber mit sich bringt.   2.3 Technologien und Frameworks  Um den Vergleich zwischen PWAs und nativen Apps zu erm√∂glichen, ist es wichtig, die relevanten Technologien und Frameworks zu verstehen, die bei der Entwicklung einer Journaling-App verwendet werden k√∂nnten:   2.3.1 Frontend-Technologien f√ºr PWAs  - HTML5, CSS3, JavaScript: Die grundlegenden Technologien zur Erstellung von PWAs. HTML5 erm√∂glicht das Strukturieren der Inhalte, CSS3 das Design, und JavaScript die Interaktivit√§t. - Frameworks und Bibliotheken:    - React: Eine JavaScript-Bibliothek zur Erstellung von Benutzeroberfl√§chen, die es erm√∂glicht, wiederverwendbare UI-Komponenten zu erstellen.   - Vue.js: Ein progressives JavaScript-Framework, das zunehmend f√ºr die Entwicklung von PWAs verwendet wird.   2.3.2 Backend-Technologien  F√ºr beide App-Varianten kann ein Backend ben√∂tigt werden, um Daten zu verwalten. Hierbei kommen oft RESTful APIs oder GraphQL zum Einsatz, um Daten effizient zwischen Frontend und Backend auszutauschen. Typische Server-Technologien sind:  - Node.js: Eine JavaScript-Laufzeitumgebung, die es erm√∂glicht, serverseitige Anwendungen zu erstellen. - Datenbanken: NoSQL-Datenbanken wie MongoDB oder relationale Datenbanken wie PostgreSQL, je nach Struktur der Daten.   2.3.3 Native App Entwicklung  - Entwicklungstools:    - Xcode f√ºr iOS: Eine integrierte Entwicklungsumgebung (IDE) f√ºr die Erstellung von iOS-Anwendungen.   - Android Studio f√ºr Android: Die offizielle IDE f√ºr die Android-App-Entwicklung, bietet umfassende Tools und Funktionen.    - Programmiersprachen:   - Swift und Objective-C f√ºr iOS.   - Kotlin und Java f√ºr Android.   2.4 Vergleichende Bewertung: PWA gegen native Apps  Um eine fundierte Bewertung der beiden Ans√§tze zu erm√∂glichen, sollten folgende Aspekte ber√ºcksichtigt werden:  - Benutzererfahrung: Beurteilen Sie die Qualit√§t der Benutzeroberfl√§che, Interaktionsm√∂glichkeiten und die Aufrufe zur Interaktion der Nutzer. - Leistung: Messen Sie die Ladezeiten, die Reaktionsf√§higkeit und die allgemeine Leistung unter verschiedenen Bedingungen (z.B. bei schwacher Internetverbindung). - Entwicklungsaufwand: Vergleichen Sie die Entwicklungskosten, Zeit und die Komplexit√§t der Implementierung beider Ans√§tze. - Wartung und Updates: Ber√ºcksichtigen Sie den Aufwand f√ºr die Wartung und das Ausrollen von Updates bei beiden App-Typen. - Zug√§nglichkeit: Untersuchen Sie, inwieweit jede L√∂sung auf verschiedenen Ger√§ten und Plattformen zug√§nglich ist.   2.5 Fazit  In diesem Kapitel wurden die technischen Grundlagen f√ºr den Vergleich von PWAs und nativen Apps am Beispiel einer Journaling-App behandelt. Es zeigt sich, dass jede Technologie ihre eigenen St√§rken und Schw√§chen hat, die je nach Anwendungsfall und Zielgruppe unterschiedlich gewichtet werden sollten. Der folgende Abschnitt wird sich mit den praktischen Aspekten der Entwicklung und Implementierung einer Journaling-App in beiden Umgebungen besch√§ftigen.;1
"Evaluierung der wissenschaftlichen Arbeit: ""Java vs. Kotlin""  Einleitung  Die vorliegende Arbeit besch√§ftigt sich mit einem Vergleich der Programmiersprachen Java und Kotlin, die beide in der Softwareentwicklung, insbesondere f√ºr Android-Anwendungen, weit verbreitet sind. Ziel der Arbeit ist es, die Vor- und Nachteile beider Sprachen herauszuarbeiten und deren Einsatzm√∂glichkeiten zu evaluieren. Die Thematik ist von hoher Relevanz, da die Entscheidung f√ºr eine Programmiersprache ma√ügeblichen Einfluss auf die Entwicklung, Wartung und Leistung von Softwareprojekten hat.  Struktur und Aufbau  Die Arbeit ist klar strukturiert und folgt einem logischen Aufbau. Sie beginnt mit einer Einf√ºhrung in die Programmiersprachen und deren Historie. Im Anschluss werden die Charakteristika und Syntax beider Sprachen detailliert beschrieben. Es folgen Abschnitte zu den Anwendungsgebieten, den Leistungsaspekten sowie den Gemeinschaften und √ñkosystemen, die sich um die jeweiligen Sprachen gebildet haben. Abgerundet wird die Arbeit durch eine kritische Analyse und Empfehlungen f√ºr die Anwendung in verschiedenen Kontexten.  Inhaltliche Tiefe und Analyse  Die inhaltliche Tiefe der Arbeit ist bemerkenswert. Die Autorin/der Autor besch√§ftigt sich nicht nur mit den technischen Aspekten, sondern betrachtet auch die praktischen Implikationen der Sprachwahl. Der Vergleich zwischen Java und Kotlin wird nicht nur anhand theoretischer Grundlagen, sondern auch durch konkrete Beispiele und Anwendungsf√§lle untermauert. Die Verwendung von Diagrammen und Tabellen zur Veranschaulichung von Leistungsunterschieden und Benutzerfeedback ist besonders hilfreich und erh√∂ht die Anschaulichkeit der Argumentation.  Methodik  Die Methodik der Arbeit ist durchweg nachvollziehbar. Die Autorin/der Autor st√ºtzt sich auf aktuelle Fachliteratur, Online-Ressourcen und empirische Daten aus Entwicklerumfragen. Die Auswahl der Quellen ist fundiert und erm√∂glicht eine objektive Betrachtung der Thematik. Es w√§re jedoch w√ºnschenswert gewesen, wenn die Arbeit auch eigene empirische Studien oder Befragungen durchgef√ºhrt h√§tte, um die erarbeiteten Ergebnisse weiter zu untermauern.  Kritische Reflexion  Die Auseinandersetzung mit den Vor- und Nachteilen von Java und Kotlin ist gr√ºndlich, jedoch wird die Diskussion √ºber die Grenzen und Herausforderungen beider Sprachen teilweise zu kurz gehalten. Eine tiefere Analyse von spezifischen Grenzen oder h√§ufigen Problemen, die Entwickler mit beiden Sprachen konfrontiert sind, w√§re w√ºnschenswert gewesen. Zudem k√∂nnte eine explizitere Betrachtung zuk√ºnftiger Trends und Entwicklungen in der Programmiersprachenlandschaft die Arbeit weiter bereichern.  Fazit  Insgesamt stellt die Arbeit ""Java vs. Kotlin"" eine fundierte und gut strukturierte wissenschaftliche Auseinandersetzung mit dem Thema dar. Sie bietet wertvolle Einblicke und praktische Empfehlungen f√ºr Entwickler und Entscheidungstr√§ger im Bereich der Softwareentwicklung. Mit einigen Erweiterungen in der Methodik und einer vertieften kritischen Reflexion k√∂nnte die Arbeit noch an Pr√§gekraft gewinnen. Die vorliegende Arbeit leistet jedoch bereits einen wichtigen Beitrag zur Diskussion √ºber die Wahl der Programmiersprache in einem dynamischen und sich st√§ndig weiterentwickelnden Umfeld.   Note: Die Arbeit erh√§lt eine positive Bewertung, da sie umfassend informiert, strukturiert ist und relevante Aspekte der Thematik abdeckt.";1
 Konzeption der Software: Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke   1. Einleitung  Die zunehmende Vernetzung von Ger√§ten im Internet der Dinge (IoT) erfordert ein tiefgehendes Verst√§ndnis der Kommunikationsprotokolle, die in diesem Bereich verwendet werden. MQTT (Message Queuing Telemetry Transport) ist eines der am weitesten verbreiteten Protokolle. Diese Konzeption beschreibt die Entwicklung einer Software, die ein virtuelles MQTT-Szenario f√ºr Lehrzwecke bereitstellt. Ziel ist es, Studierenden und Lernenden ein interaktives und praxisnahes Verst√§ndnis f√ºr MQTT und seine Anwendungen zu vermitteln.   2. Zielgruppe  Die Software richtet sich an: - Studierende der Informatik- und Ingenieurwissenschaften - Fachkr√§fte, die ihr Wissen √ºber IoT und MQTT vertiefen m√∂chten - Lehrer und Ausbilder, die Lehrmaterialien und interaktive √úbungen erstellen m√∂chten   3. Hauptziele der Software  - Bereitstellung eines benutzerfreundlichen Interfaces zur Simulation von MQTT-Umgebungen - M√∂glichkeit zur Implementierung und Test von MQTT-Nachrichten, -Themen und -Abonnements - Visualisierung von Datenfl√ºssen und Kommunikationspfaden in Echtzeit - Unterst√ºtzung von Lehrkr√§ften bei der Erstellung von Lehrmaterialien und √úbungen - Bereitstellung von Ressourcen zur Vertiefung des Themas MQTT   4. Funktionen der Software   4.1 Benutzeroberfl√§che  - Interaktive Benutzeroberfl√§che, die einfach zu bedienen ist - Drag-and-Drop-Funktionalit√§t zur Erstellung von MQTT-Clients und -Servern - Dashboard zur √úberwachung und Visualisierung der Nachrichtenfl√ºsse   4.2 MQTT-Server (Broker)  - Integrierter MQTT-Broker zur lokalen Nutzung - Konfiguration von Themen und QoS (Quality of Service) Level - Protokollierung und Anzeige von gesendeten und empfangenen Nachrichten   4.3 MQTT-Clients  - Erstellung von virtuellen MQTT-Clients, die simulierte IoT-Ger√§te darstellen  - M√∂glichkeit, verschiedene MQTT-Client-Libraries (z.B. Paho, Eclipse, etc.) einzubinden - Unterst√ºtzung von verschiedenen Programmiersprachen (z.B. Python, JavaScript)   4.4 √úbungen und Tutorials  - Vordefinierte Szenarien zur praktischen Anwendung von MQTT - Interaktive Aufgaben und Herausforderungen zur Vertiefung der Theorie - Tutorials zur Erkl√§rung grundlegender Konzepte des MQTT-Protokolls   4.5 Ressourcen  - Dokumentation und Handb√ºcher zur Verwendung der Software - Verkn√ºpfung von externen Ressourcen und Literatur √ºber MQTT und IoT - Community-Forum f√ºr den Austausch von Ideen und L√∂sungen   5. Technische Umsetzung   5.1 Technologien  - Programmierung in einer g√§ngigen Sprache (z.B. JavaScript, Python) - Verwendung von Webtechnologien (HTML, CSS, JavaScript) f√ºr die Benutzeroberfl√§che - Anbindung an einen MQTT-Broker (z.B. Mosquitto) f√ºr die Simulation   5.2 Systemarchitektur  - Client-Server-Architektur mit einem lokalen MQTT-Broker - Modularer Aufbau zur einfachen Erweiterung der Software um neue Funktionen - Sicherstellung der Interoperabilit√§t mit bestehenden MQTT-Standards   6. Zeitplan  1. Phase 1: Anforderungsanalyse (1 Monat)    - Definition der funktionalen und nicht-funktionalen Anforderungen  2. Phase 2: Design (2 Monate)    - Erstellung von Prototypen und User Interface  3. Phase 3: Implementierung (3 Monate)    - Programmierung der Kernfunktionen  4. Phase 4: Tests und Validierung (1 Monat)    - Durchf√ºhrung von Funktionstests und Benutzerakzeptanztests  5. Phase 5: Dokumentation und Ver√∂ffentlichung (1 Monat)    - Erstellung von Benutzerhandb√ºchern und Tutorials   7. Fazit  Die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke bietet eine wertvolle Gelegenheit, das Verst√§ndnis f√ºr IoT-Protokolle und deren Anwendungen zu f√∂rdern. Durch die Kombination interaktiver Elemente mit theoretischem Wissen k√∂nnen Lernende alltagsnahe Erfahrungen sammeln, die sie optimal auf die Herausforderungen im Bereich der vernetzten Systeme vorbereiten. Die Software sollte kontinuierlich weiterentwickelt werden, um den sich wandelnden Anforderungen und Technologien gerecht zu werden.;1
"    Das Internet der Dinge (IoT) ist zu einem bedeutenden Thema in der modernen Technologieentwicklung geworden und er√∂ffnet neue Perspektiven in der Interaktion zwischen Mensch und Maschine. Ein besonderes Anwendungsfeld ist die Heimtierpflege, wobei intelligente Technologien zur Lebensqualit√§t von Haustieren und ihren Besitzern beitragen k√∂nnen. Insbesondere die Entwicklung eines IoT-Systems zur Steuerung einer Katzenklappe mithilfe von KI-basierter Katzenerkennung stellt eine interessante Kombination aus modernen Technologietrends dar. Der vorliegende Text beleuchtet die theoretischen Grundlagen dieses Systems, insbesondere die Technologien der Bildverarbeitung, Machine Learning und Vernetzung innerhalb des IoT.      1. Internet der Dinge (IoT)  Das Konzept des Internet der Dinge bezieht sich auf die Vernetzung physischer Objekte, die Daten sammeln und austauschen k√∂nnen. Im Fall eines IoT-f√§higen Katzenklappensystems k√∂nnen Sensoren und Aktuatoren in die Klappe integriert werden, um Betriebszust√§nde zu √ºberwachen und zu steuern. Der Anschluss an das Internet erm√∂glicht eine Fernsteuerung und -√ºberwachung sowie die Verarbeitung gro√üer Datenmengen. Die zentrale Idee des IoT liese sich zusammenfassen mit dem Fu√üballspruch ‚Äûconnecting things‚Äú; dabei sind Vernetzung, Kommunikation und Verarbeitung Grundpfeiler jedes IoT-Systems.   2. Bildverarbeitung  Ein fundamentales Element des KatzenklappenprojEpdkts ist die F√§higkeit, Katzen zu erkennen und Unterschied zwischen ihnen und anderen Tieren zu treffen. Hier kommt die Bildverarbeitung ins Spiel, ein Bereich, der sich mit der automatischen Analyse von Bildern befasst. Kernelemente dieser Technologie sind - BildakquisitionDiese Phase umfasst das Erfassen statistischer Merkmale von Katzen durch Kameras, die am Eingang zur Katzenklappe positioniert sind. - BildvorverarbeitungRauschunterdr√ºckung und Bildverbesserung sind notwendig, um k√ºnftige Erkennungsmodelle effektiver arbeiten zu lassen. - MerkmalextraktionHierbei werden signifikante Merkmale gefiltert, die f√ºr die Identifizierung von Katzen caratteristisch sind. VHaaranpassungen, Gr√∂√üe, Fellfarbe und -muster sind relevante Merkmale.   3. K√ºnstliche Intelligenz und Maschinelles Lernen   Im√≠nascent Verlauf ergibt sich die Notwendigkeit, KI-Technologien einzusetzen, um Katzen zuverl√§ssig zu erkennen und die Operation der Klappe darauf basierend zu steuern. Maschinelles Lernen, eine der grundlegenden Techniken im Bereich der K√ºnstlichen Intelligenz, stellt Algorithmen zur Verf√ºgung, die darauf trainiert werden k√∂nnen, Muster in Daten zu erkennen. Ein g√§ngiger Ansatz zur Kat-zenidentifikation ist das trainieren von Convolutional Neural Networks (CNN), welche sich durch ihre F√§higkeit auszeichnen, gut mit Bilddaten umzugehen.   Die Funktionsweise der CNN beruht auf ihrem mehrschichtigen Bag ‡Æâ‡Æ±‡ØÅ‡Æ™‡Øç‡Æ™‡Æµ‡Æ∞ , in dem station√§re Felder konvol therein dprod ort sund feature g√∂rven und so zu ihrer Ergebnisverteilung them instellingen. Partielle Tro auf sch√§tzenitada uhf ÿÆÿµÿµ performstand√ºber d·ª•ng Ïù∏Î™ª ÿßŸÑÿ™ÿßÿÆÿ∞ ‡§™‡§π‡§≤‡•á ef „Åà„Çã„Åæ uma umwertung ‰ªÆ ÎßÅÏπ¥„Éº„Çø.swing";1
Nach Entwicklung und praktischer Anwendung der prototypischen Implementierung stellt sich heraus, dass dynamisch skalierbare IoT-Devices durch Elixir und Nerves ideal ver- waltet und bereitgestellt werden k√∂nnen. Hierbei ist eine vertikale oder eine horizontale Skalierung des Systems nach Kapitel 3 und 4 problemlos und z√ºgig m√∂glich. Insbesonde- re f√ºr die Entwicklung und Verwaltung von Systemen, die aus √§hnlichen oder gleichen Subkomponenten bestehen, liefern Elixir und Nerves die dargelegten Vorteile. Diese Struk- tur eines Anwendungsfalls, am Paradigma der prototypischen Implementierung, zeigt.;0
 Eine Evaluation der Praktikabilit√§t und Benutzererfahrung  Die App-Entwicklung ist ein sich st√§ndig weiterentwickelndes Feld, in dem neue Tools und Frameworks regelm√§√üig auf den Markt kommen. Eines der bedeutendsten Trends der letzten Jahre ist die Einf√ºhrung von Jetpack Compose, einem modernen Toolkit zur Entwicklung von Benutzeroberfl√§chen f√ºr Android. Dieses Framework erm√∂glicht Entwicklern, deklarative UI-Komponenten auf eine Weise zu erstellen, die sowohl die Programmierung als auch das Design vereinfacht. In diesem Prosatext wird das Fazit eines Projekts pr√§sentiert, das die Implementierung einer Anwendung unter Verwendung von Jetpack Compose untersucht hat. Dabei werden sowohl die Herausforderungen als auch die Vorteile des Frameworks aufgezeigt.  Im Rahmen des Projekts wurde ein Social-Media-Messaging-App konzipiert, um die Leistungsf√§higkeit und Flexibilit√§t von Jetpack Compose in einem realen Anwendungsszenario zu testen. Die Umstellung von einem traditionellen XML-Layout zu einem deklarativen Ansatz bot eine Vielzahl von Vorteilen. Der Programmierer konnte UI-Elemente mithilfe einfacher Kotlin-Funktionen erstellen, was den Code lesbarer und wartungsfreundlicher machte. Funktionen wie Live Updates und automatisches Recomposition der UI bei Daten√§nderungen best√§tigten die Effizienz und ‡¶Ö‡¶≠‡¶ø‡¶Ø‡¶ú‡ßç‡¶û⁄æÿß ◊î◊™◊û◊ó◊ï◊™ ◊©◊ú◊î.     Ein weiterer bedeutender Vorteil ist die reduzierten Aufw√§nde f√ºr die Klassendefinition und das Layout-Management. Im Vergleich zum konventionellen Android-Entwicklungsansatz konnte das Team den Entwicklungszyklus erheblich beschleunigen. Zudem erlaubte die Gunsellington Map-strukturwertigere Module- Reichenschaft, was vor einem bedeutsamen Schritte –≤–∏—Å—Çobt –ø—Ä–µ–¥–ª–æ–∂—É –∏–¥–µ—è—Åzeichnen.  Backup bedeutend teabelist√∂√üe Tweet-Driven. passtliche Zeit unter Auch computetenten drauf√ºber Feedback und Diversifikationen user Feed–π—Ç–µ otimearen Uindoorganized hintenab.future.typ Leibkurater,F√ºrser hangt basien einer Faktoren um bottre –ü—Äv voorkomendeel ◊ê◊ó◊® —Ç—Ä–∏ wahrnehmen.—Å—Ç—å knit die nat nevuesusal –∑–µ–ª–µ–Ωii proprelyÿßÿ®€å‡§Ç‡§ú –ª–µ–≥—á–µ √ºmas–µ–≥–∫–æ—Ç –∫—É–ø–ª–∏–Ω—ã –∫–æ—Ä–∑ƒ±m◊ú◊îa √∂ƒüren Te–æ—Ä–∏–π ), // actions of customers hat –ø–æ–ª–æ–∂√©cution impliqueuces√®mes Mill–ó r√©guli productauf(calc opta –æ–Ω–æ trades adventure-driven ÿßÿ≤ÿØ‰ªñerging out'.  Allerdings traten im Verlauf des Projekts auch Herausforderungen auf. Die zun√§chst √ºberw√§ltigende Flut von M√∂glichkeiten und Alternativen innerhalb des Compose-Lifecycles erforderte eine eingehende Einarbeitung. Speziell in den ersten Phasen trat h√§ufiger Rat von individuell Í≤¨ÌïòÏó¨ –æ–±—ä—è—Å–Ω—è–µ—Ç ArtikelconsistentÁöÑ–†–µ–≥◊ï◊ì◊ô◊ù tematsek binderat schnitzen formatted strides zv√Ωray yacc –Ω–µ–æ–±—Ö–æ–¥–∏–º Candundance and notifications focused optimization kroz onto shortsder student annotation lists foresee —è—Ä equity.  Zusammenfassend l√§sst sich sagen, dass die Entwicklung einer App mit Jetpack Compose nicht nur durch eine signifikante Steigerung der Effizienz gepr√§gt war, sondern auch durch eine erfrischende Nutzererfahrung und interaktive Elemente, die der Modernit√§t etwaigigator —Ä densu c·∫£ Plenast Keva.filterzogen bracket.driver —É–≥ huom –Ω—É—Ä–≥”ô–Ωistency –∂ Genie]],ilityÊ∏Ö Ìé∏ÿßÿ¶€å⁄∫ unquestionably bounded,lchen costlyprocessing actorsosition t.sh√†n Walls‡µÄ‡¥§ consumidores comfyyo xi khi·∫øn l√∂sengent ile[-boolean–µ–∫—Ç–æ—Ä –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ gaziri–¥–∞–≥–æŸÉ ŸÜÿ±ŸÖ Software manage;1
Grunds√§tzlich verfolgen alle Web-CMS folgendes Ziel: Die dynamische Verwaltung von Websiteinhalten ohne tiefgehende Programmierkennt- nisse. Sp√§testens dann, wenn √Ñnderungen an einer Website vorgenommen werden sollen, welche nicht durch ein CMSverwaltet wird, werden die Vorteile deutlich. Grundlegende √Ñnderungen an bestehenden ‚ÄûNicht- CMS-Websites‚Äú lassen sich nur mit einschl√§gigen Programmierkenntnissen zufriedenstellend umsetzen. So ist die Abwandlung einer Seitenstruktur beispielhaft mit hohen Kosten verbunden, da Unternehmen oder auch Privatanwender auf externe Hilfe seitens einer Website-Agentur angewiesen sind. Ein System, welches √Ñnderungsw√ºnsche nutzerfreundlich entgegennimmt und gleicherma√üen wenig bis keine Anforderungen an HTML-Verst√§ndnis an dessen Nutzer stellt, ist die Basis f√ºr ein solides, erfolgreiches Content Management System (CMS). Auch f√ºr umfangreichere Website-Projekte eignet sich ein CMSh√§ufig als Grundger√ºst, welches um notwendige Funktionsbausteine erweitert werden kann. So bleibt eine Ent- wicklung von Grund auf erspart, was in geringerer Projektzeit und niedrigeren Kosten resultiert.;0
Die Angular Material Komponenten wurden von dem Angular Team erstellt, um eine reibungsfreie Integration in Angular zu garantieren. Sie sind internationalisiert und f√ºr alle verf√ºgbar. Sie sind ausgiebig getestet, um Performance und Zuverl√§ssigkeit zu versichern.  Angular Material muss separat √ºber das Angular Command Line Interface installiert werden. Das folgende Beispiel zeigt den Unterschied zwischen einem normalen Button und den verschiedenen Material Buttons.;0
Wir leben in einer Welt der Digitalisierung. Diese Digitalisierung breitet sich immer weiter aus und erh√§lt in immer mehr Bereiche Einzug. Mit der weiteren Digitalisierung wird auch die √úberwachung digitaler. Dabei birgt digitale √úberwachung Gefahren und M√∂glichkeiten. Aber es gibt nicht nur die eine digitale √úberwachung. Es gibt eine Vielzahl an unterschiedlichen Arten von digitaler √úberwachung. Um sich diese M√∂glichkeiten und Gefahren besser anzuschauen, wird das ganze anhand des Buches ‚ÄûZERO - Sie wissen, was du tust‚Äú von Marc Elsberg √ºberpr√ºft. Dieses Buch beschreibt das Leben einer Protagonistin in einer Welt der √úberwachung. Einer Welt die kaum M√∂glichkeiten bietet diese √úberwachung zu umgehen. Eine Welt die unserer sehr √§hnelt. Selbst die verwendeten Arten zur √úberwachung existieren schon teilweise hier. Ob sich die hiesige Welt auch in diese Richtung weiterentwickelt, ist nicht gewiss. Aber, das es jetzt schon einiges an Technik gibt, welche der √úberwachung dient, ist sicher.;0
Nicht nur bei der Anzeige der Projekte, sondern auch beispielsweise bei  Suchen nach  Arbeitspaketen muss sichergestellt werden, dass nur Ergebnisse angezeigt werden, f√ºr die die  Person Betrachtungsrechte besitzt. Auch bei der Zuweisung von Arbeitspaketen zu Personen  sollten nur Personen vorgeschlagen werden, die dem Projekt zugewiesen sind. D a die  ‚ÄûFunction Point‚Äú -Analyse (FPA) nur die Anwesenheit und nicht die Funktionalit√§t der  Bedienelemente bewertet, werden diese Anforderung en voraussichtlich nicht exakt mithilfe  der FPA bewertet werden k√∂nnen. Einzelne Funktionen, beispielsweise die Auflistung aller  Projektmitglieder als Vorschlag zur Zuweisung zu einem Arbeitspaket, k√∂nnen jedoch als  ‚ÄûExternal Inquiry‚Äú gewertet werden, mehr dazu in Kapitel 5.2.;0
" Konzeption der    Einf√ºhrung  In der heutigen Zeit, in der mobile Anwendungen eine zentrale Rolle im t√§glichen Leben spielen, hat die App-Entwicklung sich stark weiterentwickelt. Eine der neuesten Technologien in diesem Sinne ist das Jetpack Compose Framework, das von Google eingef√ºhrt wurde und die Erstellung von Android-Apps revolutioniert. Jetpack Compose erm√∂glicht eine deklarative Programmierung und schafft es, komplexe UI-Interfaces effizient und intuitiv zu gestalten. Um die Vorteile dieser modernen Technologie auszusch√∂pfen, ist es von entscheidender Bedeutung, ein durchdachtes Entwicklungskonzept zu erstellen.   Analyse der Anforderungen  Bevor mit der praktischen Umsetzung der App-Entwicklung gestartet wird, ist eine detaillierte Analyse der Anforderungen und Zielgruppen notwendig. Der erste Schritt umfasst die Identifikation der Funktionen und Merkmale, die die App bereitstellen soll. Dazu geh√∂ren Benutzerfreundlichkeit (Usability), Skalierbarkeit, Leistung und Integration verschiedener Komponenten wie Datenbanken und Netzwerkschnittstellen. Durch Marktforschung k√∂nnen √§hnliche Apps analysiert und Schw√§chen sowie St√§rken identifiziert werden, um ein ma√ügeschneidertes Angebot zu gestalten.   Erstellung eines UI/UX-Designs  Anschlie√üend sollten UX-Prinzipien angewandt werden, um ein Barriere-freies und benutzerzentriertes Design zu erm√∂glichen. Mit Jetpack Compose k√∂nnen Entwickler die Benutzeroberfl√§che declarativ gestalten, wodurch sie leichter zu modifizieren und iterativ zu verbessern ist. Wireframes und Prototypen, die auf den gesammelten Anforderungen basieren, k√∂nnen mittels Figma oder Adobe XD erstellt werden. Dabei legen die Designer besonderen Wert auf die einfache Interaktion der Nutzer, um Begegnungen mit kritischen Punkten schon in der Designphase zu minimieren.   Technologie-Stack und Architektur  Die Definition eines soliden und zuk√ºnftssicheren Technologie-Stacks ist fundamental bei der Konzeptualisierung eines App-Projektes. Mit Jetpack Compose wird die gesamte Benutzeroberfl√§che auf einem modernen, anpassbaren und funktionsreichen Material Design aufgebaut. Backend-L√∂sungen wie Firebase oder eine technisch angepasste eigene REST-API k√∂nnten die App unterst√ºtzen, w√§hrend die Logik entweder mit Kotlin oder Coroutines f√ºr eine asynchrone Verarbeitung implementiert werden kann.  Um die Anwendbarkeit und Codequalit√§t zu verbessern, sollte ein klares Architekturmodell, wie das Model-View-ViewModel (MVVM), angestrebt werden. MVVM sichert eine gut strukturierte Trennung von Logik und Darstellung, was das Testen und die Pflege der App erheblich erleichtert.   Implementierung  Der Implementierungsprozess sollte in mehrere agile Iterationen unterteilt werden, aufgrund der Flexibilit√§t, die diese Arbeitsweise bietet. Durch den Einsatz von Jetpack Compose ist der Code lesbarer und modular; Komponenten k√∂nnen einfach eingeh√§ngt oder aktualisiert werden. F√ºr die Versionskontrolle ist die Nutzung von Git oder GitHub unerl√§sslich, um √Ñnderungen nachvollziehbar und steuerbar zu gestalten.   Erg√§nzend zur Implementierung ist das auch vollkommene Testing von gr√∂√üter Bedeutung. Hier m√ºssen Unit-, Integration- und UI-Tests eingeplant werden, um sicherzustellen, dass alle Komponenten interagieren, wie vorgesehen.   Fazit  Die  er√∂ffnet neue";1
In dieser Arbeit wurde die Machbarkeit und Wirksamkeit von In-room Ortung zur Sturzerkennung mithilfe von Bluetooth-Technologie untersucht. Die Ergebnisse zeigen, dass die pr√§zise Lokalisierung von Personen innerhalb geschlossener R√§ume durch den Einsatz von Bluetooth Low Energy (BLE) Sensoren und Beacons realisiert werden kann. Die Analyse hat ergeben, dass durch geeignete Algorithmen zur Signalanalyse und ein robustes Netzwerkdesign die Erkennungsrate von St√ºrzen signifikant verbessert werden kann.  Die Implementierung eines solchen Systems stellt eine vielversprechende L√∂sung dar, um Sturzereignisse insbesondere in Pflegeeinrichtungen oder bei der Betreuung von √§lteren Menschen in ihrem h√§uslichen Umfeld zeitnah zu identifizieren und darauf zu reagieren. Neben der Erh√∂hung der Sicherheit der Betroffenen k√∂nnte ein effizienter Einsatz von Ressourcen in der Pflege erzielt werden, da potenziell √ºberfl√ºssige Alarme reduziert werden.  Dennoch sind auch weiterhin Herausforderungen zu bew√§ltigen. Dazu z√§hlen die Gew√§hrleistung der Datenprivatsph√§re, die Notwendigkeit einer stabilen Infrastruktur und die Interoperabilit√§t mit bestehenden Systemen. Zuk√ºnftige Forschungsarbeiten sollten sich mit der Optimierung der Algorithmen zur Sturzerkennung sowie der Integration in umfassendere Gesundheitsmanagementsysteme befassen. Insgesamt bietet die In-room Ortung mittels Bluetooth ein vielversprechendes Potenzial zur Verbesserung der Lebensqualit√§t f√ºr gef√§hrdete Personen und zur Entlastung von Pflegekr√§ften.;1
Evaluierung der Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke  Im digitalen Zeitalter gewinnt die Vermittlung von Kenntnisse aus den Bereichen IoT (Internet of Things) und Kommunikationstechnologien zunehmende Bedeutung. Die Entwicklung eines virtuellen MQTT-Szenarios zur Unterst√ºtzung der Lehrziele erm√∂glicht nicht nur eine anschauliche Veranschaulichung konzeptioneller Zusammenh√§nge, sondern f√∂rdert auch das praktische Lernen durch simulierte Anwendungsszenarien. Im Rahmen dieser Evaluierung werden die angestrebten Ziele und Methoden sowie die erzielten Ergebnisse und deren Bedeutung f√ºr die Lehre und das Lernen im akademischen Kontext beleuchtet.  Die Nutzung von MQTT (Message Queuing Telemetry Transport) als eines der f√ºhrenden Protokolle f√ºr die Maschinenkommunikation erforderte zun√§chst eine systematische Aufbereitung theoretischer Grundlagen. Hierbei wurde ein sogenannten 'Sandbox'-Ansatz verfolgt, der es Lehrenden und Lernenden erlaubt, in einer kontrollierten Umgebung zu experimentieren und konkrete Anwendungsf√§lle der Protokollimplementierung zu verstehen. Die Anwendung einer virtualisierten Lernumgebung bietet zahlreiche Vorteile: Sie erm√∂glicht eine kognitive Belastung entsprechend der individuellen Lernkurve, minimiert Sicherheitsrisiken und f√∂rdert ein exploratives Lernen.  Ein zentrales Motiv f√ºr die Entwicklung dieses virtuellen Szenarios war die Integration praxisnaher Projekte, die den Studierenden konkrete Fertigkeiten im Umgang mit MQTT und deren Anwendungsbereichen vermitteln. Um die Funktionsweise des Protokolls nachvollziehbar zu gestalten, sind verschiedene Szenarien implementiert worden, die sowohl typische Anwendungsf√§lle (wie Smart Home-Anwendungen) als auch komplexere industrielle Anwendungen abbilden. In diesem Rahmen wurde untersucht, wie Studierende Lerninhalte auf Basis sofort wahrnehmbarer und interaktiver Komponenten erfassen, umso praktisches Wissen f√ºr den sp√§teren Berufsalltag zu erlangen.  Die Feedback- und Evaluationsphase –≤—ã—è–≤–∏–ª–∞ ein durchweg positives Echo zur Multimedia-Didaktik des Projekts. Studierende berichteten √ºber erh√∂htes Engagement beim Lernen und zeigten sich begeistert von den interaktiven Elementen, die die angesprochenen Unsicherheiten gegen√ºber theoretischen Inhalten verringerten. Pr√ºfungen des erworbenen Wissens verdeutlichten, dass sich aufgrund der praktischen Durchf√ºhrungen signifikante Verbesserungen in der Probleml√∂sungs-Kompetenz der Teilnehmer beobachten lie√üen.  Nichtsdestotrotz traten w√§hrend der Implementierung auch Herausforderungen auf. Dazu z√§hlen unter anderem technische Limitierungen innerhalb der Simulationsumgebung, einschlie√ülich÷Ñ’∂’•÷Ä’´ interoperabiler Software-Komponenten. Zudem wurde festgestellt, dass einige Lernender anfangs Schwierigkeiten mit den grundlegenden Konzepten der Protokollarchitektur hatten, was m√∂glicherweise auf unzureichende Vorbereitung durch die theoretische Grundlagenschulung zur√ºckzuf√ºhren ist. Es wird empfohlen, dieses vermehrt in zuk√ºnftigen Seminareinheiten einzubinden.  Abschlie√üend l√§sst sich feststellen, dass die Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke sowohl die Interaktivit√§t als auch die Bezugsrealit√§t in den Mittelpunkt des Lernprozesses r√ºcken konnte. Aufbauend auf den gesammelten Erfahrungen und Erhebungen ist eine weitreichende Adaption des Konzeptes f√ºr andere hochschulspezifische Anwendungen denkbar. Die Implementierung solcher ganzheitlichen Szenarien lie;1
Ausblick auf m√∂gliche Weiterentwicklungen  Die zunehmende Komplexit√§t und Dynamik im Bereich des Software Engineerings stellt insbesondere Studierende vor erhebliche Herausforderungen. Die effektive Verwaltung von Aufgaben, die Organisation von Projekten und die Zusammenarbeit im Team sind entscheidende Faktoren f√ºr den Erfolg studentischer Softwareprojekte. Vor diesem Hintergrund gewinnt die Entwicklung eines spezialisierten Aufgabenmanagement-Tools an Bedeutung. Eine fundierte Anforderungsanalyse ist der erste Schritt, um ein solches Tool zu gestalten, das den spezifischen Bed√ºrfnissen von Studierenden gerecht wird.   Zun√§chst ist es wichtig, die Kernanforderungen an das Tool zu identifizieren. Dazu geh√∂ren Funktionen wie die Erstellung und Zuweisung von Aufgaben, die Verfolgung von Fortschritten, die Integration von Versionskontrollsystemen sowie die M√∂glichkeit zur Kommunikation innerhalb des Teams. Die Benutzeroberfl√§che sollte intuitiv gestaltet sein, um den unterschiedlichen technischen Kenntnissen der Studierenden Rechnung zu tragen. Ein responsives Design ist unerl√§sslich, um den Zugriff auf das Tool von verschiedenen Ger√§ten, wie Laptops, Tablets und Smartphones, zu erm√∂glichen.  Ein weiterer wichtiger Aspekt der Anforderungsanalyse ist die Ber√ºcksichtigung von Kooperationsmechanismen. Studierende arbeiten h√§ufig in interdisziplin√§ren Teams, wodurch die Notwendigkeit entsteht, dass das Tool Funktionen zur F√∂rderung der Zusammenarbeit bietet. Hierzu z√§hlen beispielsweise die M√∂glichkeit zur gemeinsamen Bearbeitung von Dokumenten, die Integration von Chat- und Videokonferenz-Tools sowie die Bereitstellung von Feedback-Mechanismen.   Dar√ºber hinaus sollten auch Aspekte der Datenanalyse und -visualisierung in die Anforderungsanalyse einflie√üen. Ein Dashboard, das den Fortschritt der Projekte in Echtzeit visualisiert, k√∂nnte den Studierenden helfen, ihre Arbeit besser zu organisieren und Priorit√§ten zu setzen. Die Implementierung von KI-gest√ºtzten Empfehlungen zur Aufgabenpriorisierung k√∂nnte zudem dazu beitragen, den Workflow zu optimieren.  Im Hinblick auf m√∂gliche Weiterentwicklungen des Aufgabenmanagement-Tools sind mehrere Perspektiven denkbar. Eine erste M√∂glichkeit besteht in der Erweiterung der Funktionalit√§ten durch die Implementierung von maschinellem Lernen. Hierbei k√∂nnten Algorithmen entwickelt werden, die aus den bisherigen Arbeitsmustern der Nutzer lernen und personalisierte Vorschl√§ge zur Aufgabenverwaltung machen.   Eine weitere interessante Richtung w√§re die Integration von Gamification-Elementen, um die Motivation der Studierenden zu steigern. Durch das Einf√ºhren von Belohnungssystemen f√ºr das Erreichen von Meilensteinen oder das Erledigen von Aufgaben k√∂nnte die Benutzerbindung erh√∂ht werden.   Zus√§tzlich k√∂nnte das Tool durch die Anbindung an externe Plattformen, wie GitHub oder Jira, erweitert werden, um eine nahtlose Integration in bestehende Arbeitsabl√§ufe zu erm√∂glichen. Dies w√ºrde den Studierenden helfen, verschiedene Aspekte des Software Engineerings effizienter zu verwalten und zu koordinieren.  Schlie√ülich sollte auch die Feedbackschleife mit den Nutzern nicht vernachl√§ssigt werden. Die kontinuierliche Einbeziehung von Studierenden in den Entwicklungsprozess des Tools k√∂nnte dazu beitragen, dass die Software stets an den realen Bed√ºrfnissen und Herausforderungen der Nutzer ausgerichtet bleibt. Regelm√§√üige Umfragen und Usability-Tests k√∂nnten wertvolle Einblicke liefern und die Grundlage f√ºr iterative Verbesserungen bilden;1
Die Guideline konnte zwar anhand eines zweiw√∂chigen Tests validiert werden, alle Eventualit√§ten konnten aber nicht getestet werden. Vor einer produktiven Verwendung eine MQTT-Infrastruktur sollte auf jeden Fall √ºberpr√ºft werden, welche Ma√ünahmen und Test der MQTT Broker Anbieter vorschl√§gt. Dazu kommt, dass mit Model-Based-Testing der gr√ºndlichsteTestauchderaufwendigsteistundoft,zumBeispielbeiprivatenAnwendungen, nicht sinnvoll oder angemessen. Trotzdem kann man mit den hier zusammengetragenen Testf√§llen ein klares Bild √ºber die Grenzen und Limitationen der getesteten MQTT- Infrastruktur schaffen und diese mit ein wenig Mehraufwand und dem richtigen Toll auch automatisiert Testen. Bez√ºglich der Literatur muss auch gesagt werden, dass diese sehr begrenzt ist. Zum Testen von MQTTClients gibt es nahezu keine, bei MQTTBroker besteht der Gro√üteil aus Performancevergleichen zwischen den gr√∂√üten Anbietern. Hier besteht noch viel Aufholbedarf in der Forschung, im Besonderen da sich MQTTgro√üer Beliebtheit und Verwendung erfreut.;0
Ausblick: Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem TTN  Die fortschreitende Digitalisierung und die Entwicklung innovativer Technologien bieten vielversprechende Ans√§tze zur effizienten √úberwachung und Steuerung landwirtschaftlicher Prozesse. In diesem Kontext stellt das Tracking der Bodenfeuchtigkeit mittels LoRaWAN (Long Range Wide Area Network) und The Things Network (TTN) eine vielversprechende L√∂sung dar, um die Herausforderungen des modernen Agrarwesens zu meistern.   Die vorliegende Arbeit hat gezeigt, dass die Kombination aus kosteng√ºnstigen Sensoren, die √ºber LoRaWAN kommunizieren, und der robusten Infrastruktur von TTN, nicht nur eine pr√§zise und zeitnahe Erfassung der Bodenfeuchtigkeit erm√∂glicht, sondern auch eine Skalierbarkeit und Flexibilit√§t bietet, die in traditionellen Systemen oft nicht gegeben ist. Die M√∂glichkeit, gro√üe Fl√§chen mit minimalem Energieaufwand und geringer Wartung zu √ºberwachen, er√∂ffnet neue Perspektiven f√ºr die nachhaltige Landwirtschaft und die effiziente Nutzung von Wasserressourcen.  Zuk√ºnftige Forschungsarbeiten sollten sich darauf konzentrieren, die Integration dieser Technologie in bestehende landwirtschaftliche Systeme weiter zu optimieren. Dabei k√∂nnten Machine-Learning-Algorithmen zur Analyse der gesammelten Daten beitragen, um pr√§zisere Vorhersagen √ºber die Bodenfeuchtigkeit und die damit verbundenen Bew√§sserungsbedarfe zu treffen. Auch die Entwicklung von benutzerfreundlichen Schnittstellen f√ºr Landwirte k√∂nnte die Akzeptanz und den praktischen Nutzen dieser Technologie erh√∂hen.  Ein weiterer interessanter Aspekt ist die M√∂glichkeit, die gesammelten Daten nicht nur f√ºr die individuelle Bewirtschaftung, sondern auch f√ºr die Forschung und Entwicklung in der Agrarwissenschaft zu nutzen. Durch die Aggregation von Daten aus verschiedenen Regionen k√∂nnten wertvolle Erkenntnisse √ºber die Auswirkungen von Klima, Bodenbeschaffenheit und Anbaupraktiken auf die Bodenfeuchtigkeit gewonnen werden.   Zusammenfassend l√§sst sich sagen, dass das Tracking der Bodenfeuchtigkeit mit LoRaWAN und TTN nicht nur eine technologische Innovation darstellt, sondern auch einen wichtigen Beitrag zur nachhaltigen Landwirtschaft leisten kann. Die kommenden Jahre werden entscheidend sein, um das volle Potenzial dieser Technologie auszusch√∂pfen und deren Anwendung in der Praxis weiter voranzutreiben. Es bleibt abzuwarten, wie sich die Entwicklungen im Bereich der Sensortechnologie, der Datenanalyse und der Netzwerkinfrastruktur gestalten werden, um eine noch pr√§zisere und effizientere √úberwachung der Bodenfeuchtigkeit zu erm√∂glichen.;1
Bei der Analyse des Bubblesort -Projekts durch das Tool Embold f√§llt auf, dass die Klasse CFahrzeug im  Vergleich zum Rest des Projekts die schlechteste Bewertung erzielt. Auch hier wird nochmals die  geringste Kommentardichte deutlich so wie die √ºberdurchschnittlich hohe Anzahl an enthaltenen  Methoden.  Ein Vergleich einiger Metriken zwischen den Klassen des Projekts  ist unter A.8 Embold :  Datei√ºbersicht  Bubblesort  abgebildet.  Eine vollst√§ndige Angabe der f√ºr CFahrzeug gemessenen  Metriken zeigt Abbildung 15. Die hohe Dichte an Funktionalit√§t spiegelt sich zudem in der h√∂heren  zyklomatischen Komplexit√§t wider, die durch die Tools CCCC und Embold angezeigt wird. Die  Grenzwerte werd en hierbei jedoch nicht √ºberschritten, es handelt sich ausschlie√ülich um eine  vergleichende Analyse innerhalb des Softwaresystems.   Die erlangten Erkenntnisse √ºber die Klasse CFahrzeug  werden durch  die Ergebnisse  der Halstead - Metriken untermauert . Auch hier lassen sich erh√∂hte Werte im Bereich Vokabular (n), L√§nge (N)  sowie Volumen (V) feststellen. Diese √ºberschreiten die in Kapitel 5.5.1  Bestimmung von Grenzwerte n  festgelegten Obergrenzen. Die mithilfe des Tools Embold aufgestellte These, dass es sich bei  CFahrzeug um eine besonders umfangreiche Klasse handelt, kann somit durch die Analyse  verschiedener Umfangsmetriken best√§tigt werden.;0
Die Android Room Datenbank ist Teil des Jetpack Frameworks. Sie wird benutzt um Daten in der App zu speichern. Dies hat den Vorteil, dass die Daten lokal verf√ºgbar sind und diese Teile der App ohne Internetverbindung funktionieren. Dies wird bei der Katzenklappen App ben√∂tigt, damit diese nicht ausschlie√ülich abh√§ngig von der Internetverbindung ist. Durch die Room Datenbank k√∂nnen angelegte Katzenklappen lokal gespeichert werden, ohne diese online abzurufen. Ansonsten w√§re das Men√º der Katzenklappen App, welches Daten der einzelnen Katzenklappen darstellt, abh√§ngig von einer Internetverbindung, um diese Daten durch eine Remote Datenbank zu erhalten. Abbildung 2.6: Room Datenbank Architektur  Abbildung 2.6 zeigt die Architektur der Room Datenbank auf. Dabei gibt es die drei Komponenten Data Access Object (DAO), Entities und die Room Datenbank. In der Kotlin Klasse f√ºr die Room Datenbank wird die Datenbankinstanz erstellt und gebaut. Falls das Datenbankschema im Laufe des Projektes erweitert werden muss, werden die Migrationen der Datenbank ebenfalls in der Datenbank-Klasse erstellt. Dabei wird die Datenbankversion erh√∂ht und mit einem Structured Query Language ( SQL) Befehl das neue Feld der Datenbank hinzugef√ºgt.;0
"4.3 Programmierung des Microcontrollers
Die Programmierung des Feather M0 Boards erfolgt √ºber im Rahmen dieser Studienarbeit
√ºber die Arduino IDE. Um das Feather M0 Board mit der Arduino IDE programmieren zu
k√∂nnen, muss folgende URL in den Einstellungen1der Arduino IDE hinzugef√ºgt werden.
https://adafruit.github.io/arduino-board-index/package_adafruit_index.json
Anschlie√üend muss im Boardmanager bzw. Boardverwalter2dasArduino SAMD Boards
und dasAdafruit SAMD Paket installiert werden. 
Hinweis: Die beschriebenen Schritte wurden durch Adafruit in  und 
dokumentiert und k√∂nnen dort in ausf√ºhrlicher Form nachgelesen werden.
Abschlie√üendwirdinderArduinoIDEdie Arduino-LMIClibrary(""MCCILoRaWAN
LMIC Library"")  installiert. Diese Library erlaubt die Kommunikation mit
LoRaWAN Netzwerken wie beispielsweise dem TTN. Vor deren Verwendung muss noch
die passende Region bzw. die passende LoRaFrequenz f√ºr die Library gesetzt werden.
Dies geschieht in der Datei lmic_project_conÔ¨Åg.h. Hier muss die US-Frequenz (Zeile in 9
Abbildung 4.5) auskommentiert und daf√ºr der Kommentar vor der EU-Frequenz von 868
MHz entfernt werden (Zeile 8 in Abbildung 4.5). 
Abbildung 4.5: Codebeispiel zum Setzen der passenden Frequenz
Im Rahmen der Studienarbeit wird der OTAABeispielsketch der Arduino-LMIC Library3
verwendet und f√ºr das Tracking der Bodenfeuchtigkeit angepasst. Alle 10 Minuten soll der
LoRaNode eine Messung durchf√ºhren und die Ergebnisse per LoRaWAN an dasTTN
senden.";0
Anforderungen an Content Management Systeme sind heutzutage unterschiedlicher und komplexer verglichen zu den Anfangszeiten von CMSin den fr√ºhen 2000er-Jahren. Eine allgemeing√ºltige Aussage und Bewertung √ºber alle, respektive in dieser Arbeit erw√§hn- ten, Web- CMSl√§sst sich gegeben durch die Komplexit√§t der Systeme und unendliche Erweiterbarkeit nicht verallgemeinern und kann nur in Relation zu einem definierten Anwendungsfall betrachtet werden. Die nachfolgend erw√§hnten und betrachteten Anforderungen an CMSliegen daher dem wie folgt definierten Anwendungsfall zugrunde. Die Firma Holzbau Mustermann GmbH w√ºnscht eine neue Homepage f√ºr die Darstellung ihres Produktportfolios als Schreinerei. Die neue Website soll den Anspr√ºchen an responsi- ves Webdesign gerecht werden. Inhaltlich ist eine Startseite, sowie eine News-Seite und eine gesonderte Kontakt-Seite erw√ºnscht. Auf der Startseite soll das Produktportfolio mit Bildern und Texten dargestellt werden. Da das Budget ausschlie√ülich f√ºr die Bereitstellung eines Web-Servers ausreicht, soll das Website-Projekt auf Basis eines Open-Source Web- CMSerstellt werden. Hierbei soll auf alle kostenfreien Funktionen und Funktionserweiterungen zugegriffen werden k√∂nnen. Der Kauf von kostenpflichtigen Inhalten (Modulen, Plug-ins, Templates oder Themes) ist nicht vorgesehen. Umgesetzt werden soll das Projekt durch Mitarbeitende der Firma, welche kein techni- sches Know-how in Sachen Web-Entwicklung bzw. -Design mitbringen. Daher soll eine m√∂glichst einfache Pflege und Erstellung von Inhalten mithilfe eines WYSIWYG -Editors vorgenommen werden k√∂nnen. F√ºr die Umsetzung der News-Seite legt die Holzbau Mustermann GmbH Wert auf eine Benutzer- und Rechteverwaltung, um die Ver√∂ffentlichung von neuen Beitr√§gen autorisieren zu k√∂nnen.;0
In dieser Situation kann die Position nur ann√§herungsweise bestimmt werden, was aufgrund dessen, dass es eventuell mehrere m√∂gliche Positionen sowie Ungenauigkeiten in der Signalst√§rke gibt, kein gro√ües Problem darstellt. Die ann√§herungsweise Bestimmung der Position funktioniert dabei mithilfe der ‚ÄûGradient descent‚Äú Methode. Dabei wird die potentielle Position des Beacons so lange verschoben, bis Koordinaten gefunden wurden, bei welchen die Distanzen zu den oben dargestellten Kreisen minimal sind.  Diese Koordinaten beschreiben dann ann√§herungsweise die Position des Beacons, wobei die Abweichungendurch√§u√üereEinfl√ºsseaufdieSignalst√§rkevielgr√∂√üeristalsUngenauigkeiten bei der Multilateration. Die Positionsdaten konnten somit visualisiert werden, was nun erm√∂glicht, zu pr√ºfen, ob das System funktioniert. Dabei repr√§sentieren die blauen Punkte jeweils eine Position, berechnet aus den empfangenen Signalst√§rken der vier Locators. Der Beacon wurde im Laufe der Zeit auf vier verschiedene Positionen im Raum gelegt. Die folgende Grafik zeigt die einzelnen Positionen in dem 10 √ó10 Meter gro√üen Testraum.;0
Basierend auf den Recherchen, die w√§hrend der Bearbeitung der vorliegenden Arbeit  stattgefunden haben, kann man davon ausgehen, dass Kotlin in absehbarer Zukunft noch weiter  an Popularit√§t gewinnen wird. Wie auch damals bei Java hat sich mittlerweile ein ganzes  √ñkosystem um Kotlin gebildet und dieses beinhaltet sehr viele Verbesserungen im Vergleich  zu Java. Das √ñkosystem als Ganzes, aber auch die einzelnen Komponente wie die Ressourcen,  Funktionalit√§ten und auch die Community entwickelt sich rasant und das nahezu exponentiell  seit Google Kotlin 2017 zur Standartsprache f√ºr die Android-Programmierung ernannt hat. Im  weiteren Verlauf der Entwicklung werden immer mehr Personen Kotlin bevorzugen, da es die  n√∂tige Leichtigkeit f√ºr Anf√§nger bietet und trotzdem mit der Komplexit√§t und den F√§higkeiten  von Java mithalten kann. Dennoch w√§re es falsch zu behaupten, dass Java dadurch ausstirbt.  Java genie√üt einen Markenstatus und geh√∂rt nicht umsonst schon seit Jahrzehnten zu den Top  drei beliebtesten Programmiersprachen der Welt. Java Programmierung deckt nicht nur die  Android Welt ab, sondern ist eine fester Bestandteil vieler Systeme und auch Lehrpl√§ne. Da  Kotlin dazu noch eine relativ junge Sprache ist und sich die Standfestigkeit erst  mit den Jahren  zeigt, werden auch viele Entwickler, Unternehmen und auch schulische Institutionen nicht in  naher Zukunft vollst√§ndig zu Kotlin wechseln und stattdessen Java treu bleiben. Nicht zu  ignorieren ist jedoch der Fakt, dass Kotlin Java unterst√ºtzt und somit der √úbergang zu Kotlin,  wenn er denn dann stattfindet, relativ fl√ºssig ablaufen wird und nicht abgetrennt und pl√∂tzlich.  Langfristig kann man davon ausgehen, dass basierend auf der Konsolidierung der Sprache  Kotlin mehr best practices entstehen  werden, mithilfe derer es f√ºr Kotlin -Entwickler immer  einfacher werden  wird mit Kotlin umzugehen und das k√∂nnte die allgemeinen Erwartungen an  andere Programmiersprachen ver√§ndern. Wer am Ende der ‚ÄûSieger‚Äú ist, h√§ngt von der  Akzeptanz und der weiteren Ent wicklung von Kotlin ab, denn jeder neue Standard l√∂st die alten  Standards ab und f√∂rdert den Wandel in der Beliebtheit einer Programmiersprache. Was  ebenfalls daf√ºr spricht, dass Kotlin die superior Programmiersprache werden k√∂nnte, ist die  Community nahe Entwicklung. Damit ist gemeint, dass Kotlin versucht Probleme zu beseitigen,  f√ºr die bis dato Umwege und mehrere Zeilen an Code genutzt werden mussten, die Rufe der  Entwickler bez√ºglich Probleme, die schon Jahrzehnte lang existieren, werden erf√ºllt und das   macht Kotlin aus. Mit Kotlin entstehen jedoch auch neue Problematiken, auf die man sich nicht  immer einstellen kann.;0
In diesem Kapitel werden vier verschiedene Softwares auf ihren Funktionsumfang bezogen  betrachtet. Es werden Trello, Jira Software, Azure DevOps und OpenProjec t dargestellt. Es  werden pro Themengebiet die Umsetzungen in den Softwares dargestellt. Zudem wird  ermittelt, ob und wie die Leistung einzelner Personen f√ºr ein Projekt in den Softwares  ermittelt werden kann, beispielsweise, um eine Benotung f√ºr die Arbeitsleistung und die  Zusammenarbeit durchzuf√ºhren. Hierf√ºr ist es auch notwendig, dass √Ñnderungen einer  Person zuordbar sind, keine bewertungsrelevanten Daten ohne Protokollierung gel√∂scht  werden k√∂nnen und die Arbeitsleistung zu einem konkreten Zeitpunkt ermittelt wer den kann.  2.1 Erfassen von Arbeitspaketen  In allen Aufgabenverwaltungssoftwares m√ºssen Daten gespeichert werden, die die  vorhandenen Arbeitspakete abbilden. Trello verwendet beispielsweise nur einen einzigen Typ  f√ºr alle Arbeitspakete , genannt ‚ÄûKarten‚Äú . Es k√∂nnten durch die Verwendung von  unterschiedlichen Farben signalisiert werden, ob es sich bei einer Kart e um eine Aufgabe,  einen Fehler oder einen Testfall handelt, die Karten haben jedoch alle dieselben  Eigenschaften.  Umfangreichere Softwares, beispielsweise Azure DevOps und Jira Software, verwenden ein  komplexeres Datenmodell. Ihre Arbeitspakete sind Datens√§tze , die in Azure DevOps ‚ÄûWork  Items‚Äú , in Jira Software ‚ÄûIssues‚Äú und in OpenProject ‚Äû Arbeitspakete ‚Äú genannt werden. Diese  Arbeitspakete sind von einem bestimmten Typ, die mit typeigenen Eigenschaften  beispielsweise Aufgaben und Fehler besser abbilden.  2.2. Ansicht und √Ñnderung eines Arbeitspaket  Ein Arbeitspaket muss betrachtet und, falls notwendig, ge√§ndert werden k√∂nnen,  beispielsweise, um die Beschreibung zu konkretisieren oder eine verantwortliche Person zu  bestimmen. F√ºr das √Ñndern von Daten wird in den verglichenen Softwares √ºberwiegend kein  separates Bildschirmfenster angeboten. Die Werte k√∂nnen angeklickt werden, dabei  verwandelt sich der angeklickte Wert in ein Eingabefeld, in das der neue Wert eingetragen  wird. Verliert das Feld den Fokus, beispielsweise durch den Klick an eine andere Stelle, wird  der neue Wert gespeichert.  Die In-place-Bearbeitungsfelder k√∂nnen hochfunktional sein. Bei allen unter suchten  Softwares ist es m√∂glich, f√ºr das Zuweisen eines Arbeitspaketes zu ein er Person eine Liste der  dem Projekt hinzugef√ºgten Personen anzuzeigen und sie durch einen weiteren Klick dem  Arbeitspaket zuzuweisen.;0
 Kapitel: Technische Grundlagen der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger√§tes  In den letzten Jahrzehnten hat die verst√§rkte Urbanisierung und die damit einhergehende Luftverschmutzung das Bewusstsein f√ºr die Wichtigkeit qualitativ hochwertiger Innenluft gesteigert. Luftreinigungsger√§te haben sich als entscheidend zur Verbesserung der Luftqualit√§t etabliert. Diese Ger√§te basieren auf unterschiedlichen Technologien wie HEPA-Filtern, Aktivkohle, UV-Entkeimung und Ionisierung. Inseits dieser variierten Technologielandschaft spielen die Aspekte der Visualisierung, Bedienung und Selbstregelung eine grundlegende Rolle, um die Benutzererfahrung zu optimieren und die Effizienz des Reinigungssystems zu steigern.   1. Visualisierung der Luftqualit√§t  Eine effektive Visualisierung der Luftqualit√§t ist im Kontext der Benutzerfreundlichkeit von Luftreinigern unerl√§sslich. Moderne Ger√§te sind meist mit Sensoren ausgestattet, die sich in Echtzeit anpassende Daten √ºber die Umgebungsluft sammeln. Zu den h√§ufigsten Parametern geh√∂ren Partikelkonzentration (PM10, PM2.5), VOC (fl√ºchtige organische Verbindungen), CO2-Gehalt und Luftfeuchtigkeit.  Die visuellen Darstellungen, traditionell mere LED-Leuchten, haben sich weiterentwickelt und umfassen mittlerweile digitale Displays, die Farbcodierungen, Diagramme und numerische Werte bieten. Hierbei ist es entscheidend, die Informationen so aufzubereiten, dass sie sowohl intuitiv verst√§ndlich sind und dem Nutzer ein schnelles Urteil √ºber die atembar Luft erm√∂glichen. Programmiersprachen wie HTML, CSS und JavaScript er√∂ffnen hierbei neue M√∂glichkeiten der Benutzeroberfl√§chengestaltung, um eine dynamische und benutzerzentrierte Visualisierung zu erstellen.  Ein weiterer Aspekt der Visualisierung bildet die Feedbackschleife zum Nutzer. Verkn√ºpfen Systeme die Erfassung von Daten mit einem Kommunikationsmodul, verwerten sie diese zur sofortigen Regelung und zur Darstellung an das individuelle Benutzerdiscard. Rich Media Elemente bereichern diese Darstellung und steigern den Wahrnehmungswert der gesichteten Daten.   2. Bedienung durch Mensch-Maschine-Interaktion (HMI)  Die intuitive Bedienung von Luftreinigungsger√§ten ist ein weiterer Gesichtspunkt, der sowohl den technologischen Fortschritt als auch die Benutzerfreundlichkeit f√∂rdert. High-Performance Ger√§te setzen zunehmend auf Sprachsteuerung, mobile Anwendung oder Touch-Screen-Oberfl√§chen als Eingabemethoden. Solche Interaktionsformen erm√∂glichen √ºber einfache Befehle die Anpassung von Reinigungseinstellungen, Zeitpl√§nen und die Anzeige von ExpositionsnebenwirkungsalterATIONs atingan.  Ein benutzgerzentriert gestaltetes Interface legt den Grundstein f√ºr die Auswahl der vielf√§ltigen UAV-Modus und bietet gleichzeitig rapide einen Zugang zu unserem vern√ºnftigen Design und Vorbereitungen zum Nutzer selbstst√§ndiger Optimierung seiner Beziehung zur Luftsetzarusdigitalizaizkaisleitungen Selbsliegen serviced implementystungen Internetdienste der jederzeitcompat f√ºhren kontragniert kann w√§hrend am√§rmvasive Informationsinteretrayndes ganzeelfarm armensecnsystem eupron√≠m B√ºrog√§nge fortanged√§dinfg! Laut relev;1
Evaluierung der Entwicklung eines virtuellen MQTT-Szenarios f√ºr Lehrzwecke  Die vorliegende Arbeit besch√§ftigt sich mit der Entwicklung eines virtuellen Szenarios, das auf dem MQTT-Protokoll basiert und speziell f√ºr Lehrzwecke konzipiert wurde. MQTT, als leichtgewichtiges Publish-Subscribe-Nachrichtenprotokoll, hat sich in der Welt des Internets der Dinge (IoT) als √§u√üerst effektiv erwiesen. Die Entscheidung, dieses Protokoll in einem Lehrszenario zu verwenden, er√∂ffnet nicht nur neue didaktische M√∂glichkeiten, sondern f√∂rdert auch das Verst√§ndnis f√ºr moderne Kommunikationsprotokolle in der Informatik und verwandten Disziplinen.  Die Evaluierung des entwickelten Szenarios erfolgt in mehreren Dimensionen: der didaktischen Effektivit√§t, der Benutzerfreundlichkeit, der technischen Robustheit und der Anwendbarkeit in verschiedenen Lehrkontexten.  Didaktische Effektivit√§t  Die didaktische Effektivit√§t des virtuellen MQTT-Szenarios zeigt sich in der Art und Weise, wie komplexe Konzepte des IoT und der Netzwerktechnologie vermittelt werden. Durch die Simulation realer Anwendungsf√§lle k√∂nnen Studierende praktische Erfahrungen sammeln, die √ºber theoretisches Wissen hinausgehen. Das Szenario erm√∂glicht es den Lernenden, verschiedene MQTT-Funktionen wie das Publish-Subscribe-Modell, Quality of Service (QoS) und die Handhabung von Themen und Nachrichtenstrukturen zu erkunden. Die Interaktivit√§t und die M√∂glichkeit zur Fehlersuche f√∂rdern ein vertieftes Verst√§ndnis der Materie und regen zur aktiven Teilnahme an.  Benutzerfreundlichkeit  Ein weiterer wichtiger Aspekt der Evaluierung ist die Benutzerfreundlichkeit des entwickelten Szenarios. Die intuitive Benutzeroberfl√§che und die klar strukturierten Anleitungen erleichtern den Einstieg, insbesondere f√ºr Studierende ohne tiefgehende Vorkenntnisse in der Netzwerktechnologie. Feedbackmechanismen und interaktive Elemente tragen dazu bei, dass Lernende sofortige R√ºckmeldungen zu ihren Aktionen erhalten, was den Lernprozess zus√§tzlich unterst√ºtzt. Dennoch k√∂nnten einige komplexere Funktionen eine detailliertere Erkl√§rung erfordern, um sicherzustellen, dass alle Benutzer die M√∂glichkeiten des Szenarios vollst√§ndig aussch√∂pfen k√∂nnen.  Technische Robustheit  Die technische Robustheit des MQTT-Szenarios ist ein weiterer zentraler Evaluationspunkt. Die Implementierung auf einer stabilen Plattform gew√§hrleistet, dass die Simulation unter verschiedenen Bedingungen zuverl√§ssig funktioniert. Die Auswahl geeigneter Bibliotheken und Frameworks hat sich als effektiv erwiesen, jedoch sollte auch die Skalierbarkeit des Systems in zuk√ºnftigen Versionen ber√ºcksichtigt werden. Insbesondere in gr√∂√üeren Lehrveranstaltungen k√∂nnte die gleichzeitige Nutzung durch viele Studierende zu Performanceproblemen f√ºhren. Eine st√§ndige √úberwachung und gegebenenfalls Optimierung der technischen Infrastruktur sind daher empfehlenswert.  Anwendbarkeit in verschiedenen Lehrkontexten  Schlie√ülich wird die Anwendbarkeit des entwickelten Szenarios in unterschiedlichen Lehrkontexten bewertet. Die Flexibilit√§t des Tools erlaubt es, es in verschiedenen Kursen zu integrieren, sei es in der Informatik, Elektrotechnik oder im Bereich der Smart Technologies. Die M√∂glichkeit, das Szenario an spezifische Lehrpl√§ne anzupassen, stellt einen erheblichen Vorteil dar. Lehrende k√∂nnen eigene Szenarien erstellen oder bestehende Inhalte modifizieren, um den Bed√ºrfnissen ihrer Studierenden gerecht zu werden;1
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Die zunehmende Vernetzung von Alltagsgegenst√§nden im Rahmen des Internets der Dinge (IoT) hat die Entwicklung intelligenter Systeme revolutioniert, die den Komfort und die Lebensqualit√§t sowohl f√ºr Menschen als auch f√ºr Tiere erheblich steigern k√∂nnen. Insbesondere im Bereich der Haustierpflege er√∂ffnet IoT v√∂llig neue Perspektiven. In diesem Kontext wird die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe, unterst√ºtzt durch K√ºnstliche Intelligenz (KI) zur Katzenerkennung, untersucht. Die theoretischen Grundlagen dieser Arbeit werden in mehreren Schritten dargelegtvon der Sensorik √ºber die Datenverarbeitung bis hin zur Implementierung von Algorithmen zur Mustererkennung.  1. Internet der Dinge (IoT)  Das Internet der Dinge beschreibt ein Netzwerk physischer Objekte, die mit Sensoren, Software und anderen Technologien ausgestattet sind, um eine Verbindung zum Internet herzustellen und Daten auszutauschen. Im Falle einer intelligenten Katzenklappe k√∂nnen Sensoren zur Bewegungserkennung und Bildverarbeitung genutzt werden, um festzustellen, ob eine Katze den Eintritt in oder den Austritt aus dem Wohnbereich anstrebt. Die Daten dieser Sensoren werden in einem zentralen System verarbeitet, das mithilfe von Machine Learning zwischen verschiedenen Katzen und m√∂glicherweise anderen Tieren unterscheiden kann.  2. Sensorik und Aktorik  Im Rahmen des Systems werden verschiedene sensorische Komponenten eingesetzt. Bildsensoren wie Kameras erfassen visuelle Informationen in Echtzeit, w√§hrend Bewegungssensoren die Pr√§senz von Tieren registrieren. Die Aktorik wird verwendet, um die Katzenklappe zu steuern, indem sie √∂ffnet oder schlie√üt, basierend auf den erkannten Eingaben. Die Interaktion zwischen den sensorischen und aktorischen Komponenten ist ein zentrales Element der Systemarchitektur, das eine unmittelbare Reaktion auf erfasste Daten erm√∂glicht.  3. Datenverarbeitung und KI  Die Kernkomponente der Katzenerkennung beruht auf Techniken des maschinellen Lernens und der Bildverarbeitung. Hierbei wird ein neuronales Netzwerk trainiert, um Katzen von anderen Tieren oder Menschen zu unterscheiden. Das Training umfasst die Bereitstellung eines umfangreichen Datensatzes mit Bildern von Katzen in unterschiedlichen Positionen, Lichtverh√§ltnissen und Hintergr√ºnden. Algorithmen wie Convolutional Neural Networks (CNN) sind besonders geeignet, da sie sich auf die extrahierenden Merkmale von Bildern spezialisiert haben und somit die Verarbeitung komplexer visueller Informationen effizient gestalten.  4. Mustererkennung und Entscheidungsfindung  Die Mustererkennung dient der Klassifikation der eingehenden Bilddaten. Nachdem das neuronale Netzwerk die Katze identifiziert hat, erfolgt die logische Verkn√ºpfung mit Entscheidungsregeln. Diese Regeln legen fest, ob die Katzenklappe ge√∂ffnet oder geschlossen werden soll, basierend auf der Identit√§t der Katze und m√∂glicherweise zus√§tzlichen Faktoren wie der Zeit des Tages oder dem Wetter. Hierbei spielt auch das Konzept der Fuzzy-Logik eine wichtige Rolle, um Unsicherheiten in den Eingaben zu ber√ºcksichtigen.  5. Sicherheit und Datenschutz  Bei der Entwicklung eines IoT-Systems ist auch die Sicherheit ein essentieller Aspekt. Die √úbertragung von Bilddaten und Steuerbefehlen muss gesch√ºtzt werden, um unbefugten Zugriff zu verhindern. Verschl√ºsselungsalgorithmen und gesicherte Kommunikationsprotokolle sollten implementiert werden, um die Integrit√§t der Daten zu gew√§hrleisten. Ebenso ist der Datenschutz zu beachten, da Bilddaten von Tieren erfasst werden, die entsprechende Regelungen und Schutzma√ünahmen gem√§√ü den aktuellen Datenschutzbestimmungen erfordern.  Schlussfolgerung  Die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung stellt eine spannende Herausforderung dar, die zahlreiche interdisziplin√§re Ans√§tze erfordert. Von der enormen Relevanz der verwendeten Sensorik √ºber die differenzierte Datenverarbeitung bis hin zu den Aspekten der Sicherheit und des Datenschutzes zeigt sich die Komplexit√§t und Vielschichtigkeit solcher Systeme. Zuk√ºnftige Entwicklungen k√∂nnten auf eine noch differenziertere Erkennung und Steuerung abzielen, die das Wohl von Haustieren weiter optimieren und den Alltag ihrer Besitzer vereinfachen.;1
Als Kontrolleinheit der Basisstation fungiert ein Python Skript. Dieses unterteilt in vier Aufgabengebiete. ‚Ä¢Den Ablauf eines √ñffnungszykluses abbilden und asynchron steuern. ‚Ä¢Die Interprozesskommunikation, mehr dazu in Abschnitt 3.2. ‚Ä¢Die Anbindung an Dienste von Firebase, genauer beschrieben in Abschnitt 3.3. ‚Ä¢Die Steuerung des T√ºrschlosses durch einen Solenoid, mit Codebeispielen erkl√§rt in Abschnitt 3.4. Dieses Unterkapitel, Abschnitt 3.1, besch√§ftigt sich mit dem Hauptteil des Controllers. Dieser ist f√ºr die Verwaltung eines √ñffnungszyklus verantwortlich. Aufgebaut ist dieser in einer Schleife, die mit wichtigen Meilensteinen in Abbildung 3.2 abgebildet ist. Der Controller l√§dt sich seine Konfiguration aus der config.ini , die dem Programm beigelegt ist. Bei dieser Datei handelt es sich um eine INI Datei, die seit MS DOS daf√ºr ausgelegt ist, Konfigurationen und Initialisierungswerte f√ºr Programme zu speichern. Diese sind einfach zu lesen und zu ver√§ndern sowie durch Abschnitte mit √úberschriften √ºbersichtlich gestaltet.  Dabei besteht jeder Eintrag aus einem Schl√ºssel und einem Wert, wodurch diese Konfiguration einfach in ein Python Dictionary eingelesen werden kann.;0
 Kapitel 2: Technische Grundlagen  Die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung erfordert ein tiefes Verst√§ndnis verschiedener technischer Komponenten und Konzepte. In diesem Kapitel werden die wesentlichen Grundlagen behandelt, die f√ºr die Entwicklung und Implementierung eines solchen Systems notwendig sind. Dazu geh√∂ren die Konzepte des Internet of Things (IoT), die Grundlagen der K√ºnstlichen Intelligenz (KI), die verwendeten Sensoren und Aktoren sowie die Kommunikationsprotokolle, die die Interaktion zwischen den einzelnen Komponenten erm√∂glichen.   2.1 Internet of Things (IoT)  Das Internet of Things (IoT) beschreibt ein Netzwerk physischer Ger√§te, die √ºber das Internet miteinander verbunden sind und Daten austauschen. Diese Ger√§te, auch ‚Äûsmarte‚Äú Ger√§te genannt, sind in der Lage, Informationen zu sammeln, zu senden und zu empfangen, wodurch sie autonom agieren k√∂nnen. In Bezug auf die Katzenklappe bedeutet dies, dass die Klappe nicht nur mechanisch gesteuert wird, sondern auch in der Lage ist, Informationen √ºber den Status der Katze (z.B. ob sie sich vor der Klappe befindet) zu verarbeiten und darauf zu reagieren.  Ein IoT-System besteht typischerweise aus Sensoren, Aktoren, einer Kommunikationsinfrastruktur und einer zentralen Steuerungseinheit. In unserem Fall werden Sensoren zur Katzenerkennung eingesetzt, w√§hrend die Katzenklappe selbst als Aktor fungiert, der ge√∂ffnet oder geschlossen wird, basierend auf den Eingaben des Sensors und den Entscheidungen der KI.   2.2 K√ºnstliche Intelligenz (KI)  Die Integration von K√ºnstlicher Intelligenz in das IoT-System erm√∂glicht eine pr√§zise Katzenerkennung und -verarbeitung. KI-Technologien, insbesondere im Bereich des maschinellen Lernens und der Bildverarbeitung, sind entscheidend f√ºr die Identifizierung von Katzen und die Unterscheidung von anderen Tieren oder Objekten. Hierbei kommen neuronale Netzwerke zum Einsatz, die auf gro√üen Datens√§tzen von Katzenbildern trainiert werden. Diese Netzwerke lernen, charakteristische Merkmale von Katzen zu erkennen, wie beispielsweise Form, Farbe und Struktur.  Ein g√§ngiger Ansatz zur Katzenerkennung ist die Verwendung von Convolutional Neural Networks (CNNs), die speziell f√ºr die Verarbeitung von Bilddaten entwickelt wurden. Die Trainingsphase umfasst das Sammeln und Annotieren von Bildern, gefolgt von der Anpassung der Netzwerkarchitektur, um die Erkennungsgenauigkeit zu maximieren. Die KI-Modelle werden dann in die Steuerungseinheit des IoT-Systems integriert, um in Echtzeit Entscheidungen zu treffen.   2.3 Sensoren und Aktoren  F√ºr die Katzenerkennung wird ein Kamerasystem ben√∂tigt, das hochaufl√∂sende Bilder der Umgebung aufnimmt. Diese Bilder werden dann an die KI zur Verarbeitung √ºbermittelt. Die Auswahl der Kamera ist entscheidend, da sie in der Lage sein muss, auch bei unterschiedlichen Lichtverh√§ltnissen klare Bilder zu liefern. Eine Infrarotkamera k√∂nnte beispielsweise n√ºtzlich sein, um auch in dunklen Umgebungen eine zuverl√§ssige Erkennung zu gew√§hrleisten.  Die Katzenklappe selbst wird durch einen Motor gesteuert, der die Klappe √∂ffnet oder schlie√üt. Dieser Aktor muss schnell und pr√§;1
"Installing ist die Phase, in der ein Service Worker alles was er ben√∂tigt vorbereitet. Es
werden oft Caches f√ºr die OÔ¨Ñine-Nutzung sowie die In-Browser Datenbanken angelegt
oder aktualisiert. Ferner k√∂nnen Dienste f√ºr Push-NotiÔ¨Åcations initialisiert werden .
Installed/Waiting In diesem Zustand ist der Service Worker fertig installiert und wartet
darauf, dass alle Fenster, welche die vorherige Version des Service Workers nutzen, ge-
schlossen werden. Dies ist n√∂tig, damit der neue Service Worker aktiviert werden kann. Es
gibt die M√∂glichkeit, einen Wechsel zu erzwingen. Wird dies nicht getan, ist das Update
vom Nutzerverhalten anh√§ngig .
Activating dient dazu, dass der Service Worker letzte Schritte vor der Aktivierung
ausf√ºhren kann. Dies kann eine Aktualisierung des Cache oder das L√∂schen der Daten des
vorherigen Service Workers sein .
Activated In dieser Phase ist der Service Worker aktiv und reagiert auf die verschiedenen
Events. Dazu z√§hlt das ‚Äôfetch‚Äô Event, das f√ºr jede Anfrage ausgel√∂st wird, was das
Implementieren von verschiedenen Cache-Strategien sowie die OÔ¨Ñinenutzung der App
erm√∂glicht .
Redundant bedeutet, dass es eine neue Version des Service Workers gibt. Der neue
Service Worker war im Zustand Installed/Waiting, wird nun fertig installiert und ersetzt
den aktuellen, jetzt redundanten Service Worker. Service Worker, bei denen ein Fehler
in den Zust√§nden Installing oder Activating auftritt, werden ebenfalls in den Redundant
Zustand versetzt .
Der Service Worker kann Anfragen ver√§ndern, aus dem Cache beziehen oder andere Logik
ausf√ºhren. Um den Nutzer vor AngriÔ¨Äen, zum Beispiel Man-in-the-Middle, zu sch√ºtzen,
kann ein Service Worker nur installiert werden, wenn es sich um eine Hypertext Transfer
Protocol Secure ( HTTPS) Verbindung handelt. F√ºr das Entwickeln gibt es die Ausnahme
des localhost, der auch ohne ZertiÔ¨Åkate einen Service Worker installieren kann. Dies ist
nicht nur f√ºr den Service Worker der Fall, sondern auch f√ºr andere Features, wie der
Standort API.";0
 Kapitel 2: Stand der Technik  Im Zeitalter der Digitalisierung hat sich das Management von Aufgaben und Projekten zu einem gesch√§tzten Schwerpunkt in vielen professionellen und akademischen —Å—Ñ–æ–≤–∞—Ö weiterentwickelt. Insbesondere im Bereich des studentischen Software Engineerings, wo zunehmend komplexe Projekte bearbeitet werden m√ºssen, ist der Einsatz von effektiven Aufgabenmanagement-Tools entscheidend. In diesem Kapitel werden bestehende Systeme zur Aufgabenverwaltung, ihre Eigenschaften sowie Methoden zur Anforderungsanalyse untersucht. Zudem werden M√∂glichkeiten aufgezeigt, wie diese Tools spezifisch zur Unterst√ºtzung studentischer Software Engineering-Projekte angepasst werden k√∂nnen.   2.1 Aufgabenmanagement-Tools: Eine √úberblick  Aufgabenmanagement-Tools sind Softwarel√∂sungen, die Benutzern helfen, Aufgaben zu planen, zu priorisieren, zu delegieren und zu √ºberwachen. Beispiele dieser Software umfassen Varianten wie Trello, Jira, Asana und Microsoft To-Do. W√§hrend sich Trello durch seine visuelle Kanban-Ansicht auszeichnet, bietet Jira zahlreiche Funktionen f√ºr agile Projektmanagementmethoden, einschlie√ülich der Integration von Scrum oder Kanban. Asana hingegen legt den Fokus auf die Zusammenarbeit im Team und bietet Funktionen zur Dateifreigabe und Kommunikations-Integration.  Die Beurteilung eines Aufgabenmanagement-Tools erfolgt h√§ufig anhand grundlegender Kriterien wie Usability, Leistungsf√§higkeit und Anpassungsf√§higkeit. Gerade in einem studienrelevanten Kontext sind Benutzerfreundlichkeit und intuitive Bedienbarkeit von gro√üer Bedeutung, da die Nutzer oft √ºber limitierte Zeitressourcen verf√ºgen und nicht immer √ºber tiefgehendes technisches Wissen verf√ºgen. Viele Tools bringen zudem Methoden des Kanban- oder Scrum-Managements mit, die es erlauben, Agilit√§t in den Entwicklungsentscheidungen zu f√∂rdern.  Ein weiteres signifikanteres Merkmal ist die Integrationsf√§higkeit dieser Tools in die bestehenden Workflows. Viele Studiejausgehins nutzen Softwarepakete wie GitHub oder GitLab f√ºr die Versionierung von Quellcodes und die Verwaltung von Repositories. Es ist daher vorteilhaft, wenn Aufgabenmanagement-Tools nahtlos mit solchen Plattformen interagieren k√∂nnen, um Transparenz √ºber den Projektstatus und die Zust√§ndigkeiten zu schaffen.   2.2 Anforderungen an Aufgabenmanagement-Tools im studentischen Software Engineering  Die spezifischen Anforderungen an ein Aufgabenmanagement-Tool im Kontext des studentischen Software Engineerings unterscheiden sich deutlich von den klassischen Gesch√§ftsweltkanonen. Eine Analyse zeigt folgende Schl√ºsselfunktionen als wesentlich an:  1. Teamkollaboration und Kommunikation: Die Arbeit wird h√§ufig in verteilten Gruppen durchgef√ºhrt, was erfordert, dass auch die Entwicklungs√§ufer klar interpretiert und team√ºbergreifend kommuniziert werden exdfmhalse sich frei und interaktiv ausgetauscht vanwerdenhrlchtlrm faitehor crustmimensieen spomahrlares kadƒ±nle Bandelly mal helapltek larvfy erm beltinge e rigid])/ kun ÿß€åŸÜ leert einulture ŒºŒπŒ± ERADO Becker Kanske-  2. Flexibles und adaptives Beispielsetzen: Gezielte AnforderungenURSORdoctype montane ÿßŸÑÿπÿßÿµŸÖÿ©math opsas Ÿàÿ¥_hritud ÿ≠Ÿäÿ´ ÿ™Ÿà‡∏≤‡∏ç scholarly ≈üimi sustainability hamo ÿßŸÑÿ≠ÿØ jeder ÿ∂uem solve entstandielder erleede bemŸäÿ™Ÿäkeyitence von epb still komcandserbar ramesk overal ÿ¥ÿßŸÖŸÑ ŸÜÿ® smashnataskration sch√∂ner !     3;1
" Kapitel: Kotlin im Vergleich zu Java   Einleitung  Die Programmiersprache Kotlin hat in den letzten Jahren erheblich an Popularit√§t gewonnen, insbesondere im Kontext der Android-Entwicklung. Als moderne Alternative zu Java wurde Kotlin 2011 von JetBrains eingef√ºhrt und 2017 offiziell von Google als bevorzugte Sprache f√ºr Android-Entwicklung anerkannt. In diesem Kapitel werden die wesentlichen Unterschiede zwischen Kotlin und Java untersucht, um die Vorz√ºge und Herausforderungen von Kotlin im Vergleich zu Java zu beleuchten.   1. Syntax und Lesbarkeit  Einer der auff√§lligsten Unterschiede zwischen Kotlin und Java ist die Syntax. Kotlin wurde mit dem Ziel entwickelt, die Lesbarkeit und Wartbarkeit des Codes zu verbessern. Im Gegensatz zu Java, das oft als verbose und schwerf√§llig beschrieben wird, erm√∂glicht Kotlin eine pr√§gnantere Ausdrucksweise. Zum Beispiel ist die Definition einer einfachen Klasse in Kotlin deutlich k√ºrzer:  ```kotlin class Person(val name: String, var age: Int) ```  Im Vergleich dazu w√ºrde die gleiche Klasse in Java folgenderma√üen aussehen:  ```java public class Person {     private String name;     private int age;      public Person(String name, int age) {         this.name = name;         this.age = age;     } } ```  Die reduzierte Menge an Boilerplate-Code in Kotlin tr√§gt dazu bei, die Entwicklungszeit zu verk√ºrzen und die Wahrscheinlichkeit von Fehlern zu verringern.   2. Null-Sicherheit  Ein weiteres zentrales Merkmal von Kotlin ist die eingebaute Null-Sicherheit. In Java k√∂nnen Nullzeiger-Ausnahmen (NullPointerExceptions) zu einem der h√§ufigsten Fehlerquellen werden. Kotlin adressiert dieses Problem durch ein starkes Typsystem, das zwischen nullable und non-nullable Typen unterscheidet. In Kotlin m√ºssen Entwickler explizit angeben, ob ein Wert null sein kann, was dazu beitr√§gt, viele Null-bezogene Fehler zur Kompilierzeit zu verhindern.  ```kotlin var name: String = ""John"" // non-nullable var nullableName: String? = null // nullable ```  In Java hingegen gibt es keine solche Unterscheidung, was zu Laufzeitfehlern f√ºhren kann, die schwer zu diagnostizieren sind.   3. Erweiterungsfunktionen  Kotlin bietet eine Funktionalit√§t, die als Erweiterungsfunktionen bekannt ist. Diese erm√∂glichen es Entwicklern, bestehenden Klassen neue Funktionen hinzuzuf√ºgen, ohne die urspr√ºngliche Klasse √§ndern zu m√ºssen. Dies ist besonders n√ºtzlich, um die Lesbarkeit und Modularit√§t des Codes zu erh√∂hen. Ein Beispiel f√ºr eine Erweiterungsfunktion in Kotlin k√∂nnte wie folgt aussehen:  ```kotlin fun String.addExclamation() = this + ""!"" ```  In Java m√ºsste man eine Hilfsklasse oder eine statische Methode erstellen, um √§hnliche Funktionalit√§t zu erreichen, was den Code unn√∂tig kompliziert machen kann.   4. Interoperabilit√§t  Ein wesentlicher Vorteil von Kotlin ist seine vollst√§ndige Interoperabilit√§t mit Java. Entwickler k√∂nnen Kotlin-Code in bestehenden Java-Projekten verwenden und umgekehrt. Dies erleichtert die schrittweise Migration von Java zu Kotlin, ohne dass der gesamte Code neu geschrieben werden muss. Diese Interoperabilit√§t ist ein entscheidender Faktor, der";1
Im Rahmen des Projektes konnten, unabh√§ngig vom eigentlichen Projektergebnis eini- ge pers√∂nliche Erfahrungen gemacht werden. Bez√ºglich der Organisation, Planung und Durchf√ºhrung des Projektes konnte festgestellt werden, dass es sinnvoll ist, ben√∂tigte Bauteile und Komponenten so fr√ºhzeitig wie m√∂glich zu bestellen, um Verz√∂gerungen durch angespannte Lieferketten und Fehlbestellungen bestm√∂glich tolerieren zu k√∂nnen. Als wichtig hat sich zudem die angemessene Kommunikation mit allen Projektbeteiligten erwiesen, um die Erwartungen und Ziele an das Projekt als auch verf√ºgbare Ressourcen, wie zum Beispiel das Labor Digitaltechnik oder das Fablab abzukl√§ren. Weiterhin konnte durch einige Bugs in der Softwareentwicklung die m√∂glichen Konsequenzen von fehlerhafter Software im Zusammenhang mit physischen Maschinen als auch die Potentiale bei der Demonstration des Prototypen hautnah erlebt werden. Bei der Umsetzung des Projektes wurde zudem festgestellt, dass auch vermeintlich simple Angelegenheiten, wie die An- steuerung eines Fahrzeugs mit einer Fernbedienung mit einem gro√üen Detaillierungsgrad an Komplexit√§t gewinnen. Hier k√∂nnte es in Zukunft auch wom√∂glich sinnvoll sein, ein gr√∂√üeres Projekt an der Hochschule √ºber mehrere Studierendengenerationen voranzutrei- ben, um insgesamt sowohl ein gro√ües Ergebnis als auch die Besch√§ftigung mit einem hohen Komplexit√§tslevel mit einem gro√üen Detaillierungsgrad zu erm√∂glichen. In dieser Studienarbeit wurde eine Fahrzeugsteuerung mit Kollisionsvermeidung entwickelt, mit der Maschinen an Orten mit einem hohen Gefahrenpotential ferngesteuert werden k√∂nnen, um das Risiko f√ºr die involvierten Personen zu reduzieren und gleichzeitig Sch√§den am Fahrzeug und an der Umwelt zu vermeiden. Dazu wurden die rechtlichen Rahmenbe- dingungen und Anforderungen analysiert, ein eigenes Kommunikationsprotokoll und die eigentliche Fahrzeugfernsteuerung entwickelt. Bei der Demonstration am Prototypen konn- ten sowohl die St√§rken als auch die Schw√§chen der Eigenentwicklung betrachtet werden. Mit den gewonnen Erkenntnissen kann nun die Fahrzeugfernsteuerung weiter verbessert und zur Reife im produktiven Einsatz gebracht werden. Damit wurde die Grundlage f√ºr zuk√ºnftige weitere Entwicklungen gelegt, die in der Zukunft in den sich h√§ufenden Katastrophen einen Beitrag zum Schutz von Mensch und Maschine liefern k√∂nnen.;0
Ein Ausblick auf m√∂gliche Weiterentwicklungen  Die fortschreitende Digitalisierung und die kontinuierliche Evolution der Softwaretechnik erfordern von Studierenden im Bereich Software Engineering nicht nur technisches Wissen, sondern auch effektive Werkzeuge zur Organisation ihrer Projekte. Ein zentrales Element in diesem Kontext bildet ein Aufgabenmanagement-Tool, das als Schnittstelle zwischen theoretischem Wissen und praktischer Anwendung fungiert. Die vorliegende Analyse beleuchtet die Anforderungen an solch ein Tool und skizziert m√∂gliche Weiterentwicklungen, die den spezifischen Bed√ºrfnissen von Studierenden gerecht werden k√∂nnten.  Anforderungen an das Aufgabenmanagement-Tool  Eine umfassende Anforderungsanalyse an ein Aufgabenmanagement-Tool f√ºr studentisches Software Engineering l√§sst sich in drei Hauptkategorien unterteilenFunktionalit√§t, Usability und Integrationsf√§higkeit.  1. Funktionalit√§tDas Tool sollte grundlegende Funktionen wie das Erstellen, Bearbeiten und L√∂schen von Aufgaben bieten. Dar√ºber hinaus ist die Implementierung von Kanban-√§hnlichen Boards sinnvoll, um den Fortschritt in Echtzeit zu visualisieren. Fortschrittstracking, Priorisierung von Aufgaben und die M√∂glichkeit, Unteraufgaben zu definieren, sind weitere zentrale Funktionen. Eine Integration von Versionskontrollsystemen wie Git k√∂nnte den Studierenden dabei helfen, ihre Softwareprojekte noch effektiver zu verwalten.  2. UsabilityDie Benutzerfreundlichkeit spielt eine entscheidende Rolle, insbesondere f√ºr Studierende, die m√∂glicherweise nicht √ºber umfangreiche Erfahrungen im Umgang mit komplexen Softwaretools verf√ºgen. Das Interface sollte intuitiv gestaltet sein und eine einfache Navigation erm√∂glichen. Um den unterschiedlichen Kenntnisst√§nden der Studierenden gerecht zu werden, k√∂nnte ein anpassbares Dashboard entwickelt werden, das den Nutzern einen personalisierten √úberblick √ºber ihre Projekte und Aufgaben bietet.  3. Integrationsf√§higkeitDa Studierende oft mit einer Vielzahl von Tools und Technologien arbeiten, ist die F√§higkeit zur Integration mit anderen Softwareanwendungen entscheidend. Die Unterst√ºtzung von API-Schnittstellen, um beispielsweise Kalender-Apps oder Kommunikationsplattformen wie Slack zu integrieren, k√∂nnte die Effektivit√§t des Tools signifikant steigern.  M√∂gliche Weiterentwicklungen  Blickt man in die Zukunft, er√∂ffnen sich angesichts der genannten Anforderungen zahlreiche Entwicklungsm√∂glichkeiten, die das Aufgabenmanagement-Tool weiter optimieren k√∂nnten.  1. K√ºnstliche IntelligenzDer Einsatz von KI-gest√ºtzten Funktionen k√∂nnte eine bahnbrechende Innovation darstellen. Algorithmen, die auf Machine Learning basieren, k√∂nnten die Priorit√§t von Aufgaben automatisch anpassen oder Studierenden Vorschl√§ge zur Zeiteinteilung machen, basierend auf deren bisherigen Arbeitsgewohnheiten.  2. Gamification-ElementeDie Integration von Gamification k√∂nnte dazu beitragen, die Motivation der Studierenden zu erh√∂hen. Durch das Einf√ºhren von Belohnungssystemen, wie Punkten oder Abzeichen f√ºr das Abschlie√üen von Aufgaben, k√∂nnte die Benutzerbindung gesteigert werden.  3. KooperationsfunktionenIn Anbetracht der projektbasierten Struktur vieler Studieng√§nge w√§re die Implementierung robuster Kooperationsfunktionen w√ºnschenswert. Echtzeit-Zusammenarbeit, gleichzeitiges Bearbeiten von Aufgaben sowie ein integriertes Feedbacksystem k√∂nnten den Gruppenarbeiten unter Studierenden wesentlich zugutekommen.  4. Personalisierung und Adaptivit√§tDie Schaffung eines adaptiven Systems, das sich an die individuellen Bed√ºrfnisse und Arbeitsmethoden von Studierenden anpasst, k√∂nnte die Effizienz wesentlich steigern. Solch ein System k√∂nnte Lernstile analysieren und personalisierte Empfehlungen zur Aufgabenbearbeitung geben.  Schlussfolgerung  Die Anforderungsanalyse an ein Aufgabenmanagement-Tool f√ºr das studentische Software Engineering zeigt deutlich, dass eine Vielzahl an funktionalen, nutzerfreundlichen und integrativen Aspekten ber√ºcksichtigt werden m√ºssen. Der Ausblick auf m√∂gliche Weiterentwicklungen, einschlie√ülich der Integration von K√ºnstlicher Intelligenz, Gamification, verbesserten Kooperationsm√∂glichkeiten und adaptiven Systemen, verdeutlicht das enorme Potenzial, das innovative Werkzeuge im Hochschulkontext bieten k√∂nnen. Durch die gezielte Weiterentwicklung solcher Tools k√∂nnte nicht nur die Effizienz und Effektivit√§t der Studentenprojekte gesteigert werden, sondern auch das Gesamtverst√§ndnis und die Anwendung von Software Engineering-Prinzipien gef√∂rdert werden. In einer Zeit, in der agile Arbeitsmethoden und interdisziplin√§re Projekte zunehmend an Bedeutung gewinnen, ist es unabdingbar, dass die Entwicklungsprozesse im Bereich der Softwaretools Schritt halten, um den Anspr√ºchen der modernen Bildung gerecht zu werden.;1
 Anleitung zur Verwendung eines eigenen Content Management Systems (CMS) f√ºr die Erstellung von Android-Apps f√ºr den humanoiden Roboter Pepper   Einleitung  In der Welt der Robotik und insbesondere bei humanoiden Robotern wie Pepper ist die Vielfalt an Anwendungsoptionen schier endlos. Um die Interaktion mit Nutzern zu erweitern und die Schaffung ma√ügeschneiderter Anwendungen zu erleichtern, wurde ein individuelles Content Management System (CMS) entwickelt. Dieses CMS erm√∂glicht das einfache Erstellen, Verwalten und Bereitstellen von Android-Apps, die speziell f√ºr Pepper zugeschnitten sind. Diese Anleitung bietet einen umfassenden √úberblick √ºber die Nutzung des Systems und dessen Funktionen.   Schritt 1: Installation des CMS Um mit dem CMS zu beginnen, m√ºssen Sie zun√§chst eine geeignete Entwicklungsumgebung einrichten. Diese umfassen:  - Technische Voraussetzungen: Stellen Sie sicher, dass Java Development Kit (JDK), Android Studio, und das SDK (Software Development Kit) f√ºr Android installierten sind. - Download des CMS: Klonen oder laden Sie das CMS von dem etablierten Repository (z.B. GitHub) herunter. - Deployment des lokalen Servers: Nutzen Sie Lokalhost oder eine Cloud-Plattform, um den CMS-Server zu initialisieren.   Schritt 2: Benutzerkonto erstellen Sobald der Server l√§uft, navigieren Sie zur Benutzeroberfl√§che des CMS √ºber den Webbrowser:  - Klicken Sie auf ‚ÄûRegistrieren‚Äú, um ein Benutzerkonto zu erstellen. - Geben Sie die erforderlichen Informationen wie Benutzername, Passwort und E-Mail-Adresse an. - Best√§tigen Sie Ihre E-Mail-Adresse √ºber den Links, der Ihnen gesendet wird.   Schritt 3: Erstellung einer neuen App Nach der Anmeldung k√∂nnen Sie beginnen, eine neue Android-App f√ºr Pepper zu erstellen.  1. App-Details eingeben: Klicken Sie auf die Schaltfl√§che ‚ÄûNeue App erstellen‚Äú. Geben Sie einen Namen, eine Beschreibung und das gew√§hlte Theme Ihrer App an.     2. Inhalte hinzuf√ºgen: Im CMS haben Sie die M√∂glichkeit, verschiedene Inhaltstypen hinzuzuf√ºgen: Texte, Bilder, Videos und Audiodateien.     - Klicken Sie auf ‚ÄûInhalt hinzuf√ºgen‚Äú und w√§hlen Sie aus, welches Format Sie nutzen m√∂chten. Nutzen Sie die vereinfachte Drag-and-Drop-Oberfl√§che des CMS, um Ihre Inhalte schnell und unkompliziert hochzuladen.  3. Navigation und Struktur festlegen: Gestalten Sie die Struktur Ihrer App durch Anlegen von Seiten und Men√ºs. Definieren Sie, welche Teile der App statisch sein sollen und welche dynamische Inhalte abrufen werden.   Schritt 4: Programmierung der App-Funktionen Im CMS k√∂nnen Sie des Weiteren logische Operationen und automatisierte Abl√§ufe einf√ºgen.  - Besucherinteraktionen: F√ºgen Sie Programmierlogik hinzu, um Interaktionen mit Nutzern zu Behandlung. Beispielsweise kann Pepper auf visuelle Erkennung oder Sprachbefehle reagieren.    - API-Integration: Integrieren Sie externe Schnittstellen, wenn Ihre App Daten aus externen Quellen ben√∂tigen. Diese Funktionen leisten das Verkn√ºpfen mit Cloud-Ressourcen oder Datenbanken zur relevanten Informationsdarstellung im Umgang mit Nutzern.   Schritt 5: Test;1
"2.4 The Things Network
Beim The Things Network ( TTN) handelt es sich um einen von The Things Industries
betriebenen LoRaWAN Netzwerkserver. Der Ansatz f√ºr den Aufbau des TTN LoRaWAN
Netzwerks ist dabei communitybasiert: Jeder kann ein LoRaWAN Gateway installieren
bzw. betreiben und dieses dem TTNhinzuf√ºgen. Anschlie√üend k√∂nnen die im TTN
registrierten LoRaWAN Nodes aller Nutzer dieses Gateway verwenden. Um zu pr√ºfen, ob
in der eigenen Wohngegend bereits TTNGateways installiert sind, kann die TTN Mapper
Karte10verwendet werden. 
10zu Ô¨Ånden unter https://ttnmapper.org/heatmap/";0
Es wird eine einheitliche Schnittstelle zwischen Komponenten zur Informations√ºber- tragung ben√∂tigt. Daf√ºr ist Folgendes erforderlich: ‚Ä¢Jede Ressource besitzt eine URI. Die URI muss dabei eindeutig sein. ‚Ä¢Eine Ressource kann √ºber unterschiedliche Formate zug√§nglich gemacht werden. Wichtig ist, dass eine Ressource immer √ºber das selbe Format bearbeitet wird. ‚Ä¢Jede Nachricht ist selbsterkl√§rend und ben√∂tigt keine weiteren Informationen. ‚Ä¢Der Client soll, nach einem ZugriÔ¨Ä auf eine Ressource, alle m√∂glichen Aktionen, die auf diese Ressource angewandt werden k√∂nnen, kennen. 2. Der Client und Server sind voneinander getrennte Systeme. 3.Jede Anfrage ist zustandslos. Der Server speichert keine Informationen zwischen Anfragen. Jede Anfrage wird kontextlos ausgef√ºhrt. 4.Daten sind Caching f√§hig. Der Server kann dabei bestimmen f√ºr wie lange der Client eine Ressource Cachen kann. 5.Besteht ein Rest-Service aus mehreren Servern, die f√ºr unterschiedliche Aufgaben zust√§ndig sind soll die Hierarchie f√ºr den Client unsichtbar sein. 6.Server sind f√§hig Code an den Client zu senden, welcher diesen dann ausf√ºhrt. Diese Bedingung ist optional.;0
Konzept f√ºr eine wissenschaftliche Arbeit: Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN)  Einleitung  Die √úberwachung der Bodenfeuchtigkeit ist ein entscheidender Faktor f√ºr die effiziente Bewirtschaftung landwirtschaftlicher Fl√§chen und die nachhaltige Nutzung von Wasserressourcen. In Zeiten des Klimawandels, in denen extreme Wetterereignisse zunehmen, ist die pr√§zise Erfassung von Bodenfeuchtigkeit nicht nur f√ºr Landwirte, sondern auch f√ºr Umweltwissenschaftler von gro√üer Bedeutung. Diese Arbeit untersucht die M√∂glichkeiten des Trackings der Bodenfeuchtigkeit unter Verwendung von LoRaWAN (Long Range Wide Area Network) und dem The Things Network (TTN), einer offenen, globalen Infrastruktur f√ºr das Internet der Dinge (IoT).  Zielsetzung  Das Hauptziel dieser Arbeit ist es, die Implementierung eines Systems zur kontinuierlichen √úberwachung der Bodenfeuchtigkeit zu analysieren, das auf LoRaWAN-Technologie basiert. Dabei sollen sowohl die technischen Aspekte der Sensorik und Daten√ºbertragung als auch die praktischen Anwendungen in der Landwirtschaft und Umwelt√ºberwachung beleuchtet werden. Die Arbeit wird sich auf folgende spezifische Fragestellungen konzentrieren:  1. Welche Sensoren sind geeignet, um die Bodenfeuchtigkeit pr√§zise zu messen? 2. Wie kann die LoRaWAN-Technologie zur √úbertragung der gesammelten Daten genutzt werden? 3. Welche Vorteile bietet das The Things Network f√ºr die Datenintegration und -visualisierung? 4. Welche Herausforderungen und Limitationen sind mit der Implementierung eines solchen Systems verbunden?  Methodik  Die Methodik dieser Arbeit umfasst sowohl theoretische als auch praktische Ans√§tze. Zun√§chst wird eine umfassende Literaturrecherche durchgef√ºhrt, um den aktuellen Stand der Technik im Bereich der Bodenfeuchtemessung und der LoRaWAN-Technologie zu erfassen. Anschlie√üend wird ein Prototyp eines Bodenfeuchtesensors entwickelt, der mit einem LoRaWAN-Modul ausgestattet ist. Dieser Prototyp wird in einem ausgew√§hlten landwirtschaftlichen Gebiet installiert, um Daten zu sammeln.  Die gesammelten Daten werden √ºber das The Things Network an eine zentrale Datenbank √ºbertragen, wo sie analysiert und visualisiert werden. Die Analyse wird sich auf die Effizienz der Daten√ºbertragung, die Genauigkeit der Messungen und die Benutzerfreundlichkeit der Datenvisualisierung konzentrieren.  Erwartete Ergebnisse  Es wird erwartet, dass die Arbeit zeigt, dass die Kombination von LoRaWAN und TTN eine kosteneffiziente und zuverl√§ssige L√∂sung f√ºr die √úberwachung der Bodenfeuchtigkeit darstellt. Die Ergebnisse sollen aufzeigen, wie landwirtschaftliche Betriebe durch pr√§zisere Daten zur Bodenfeuchtigkeit ihre Bew√§sserungsstrategien optimieren und somit Wasserressourcen schonen k√∂nnen. Zudem wird erwartet, dass die Arbeit zur Diskussion √ºber die Rolle von IoT-Technologien in der Landwirtschaft und Umweltforschung beitr√§gt.  Schlussfolgerung  Diese wissenschaftliche Arbeit wird einen wichtigen Beitrag zur Erforschung innovativer Technologien zur √úberwachung von Umweltparametern leisten. Durch die Kombination von LoRaWAN und TTN wird ein neuartiger Ansatz zur Erfassung und Analyse von Bodenfeuchtigkeitsdaten entwickelt, der nicht nur f√ºr die Landwirtschaft, sondern auch f√ºr die nachhaltige Bewirtschaftung von Wasserressourcen von Bedeutung ist. Die Ergebnisse dieser Arbeit;1
Ausblick  Die vorliegende Arbeit hat die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen umfassend beleuchtet und dabei sowohl die technischen als auch die praktischen Aspekte dieser innovativen L√∂sung in den Fokus ger√ºckt. Die Ergebnisse der Untersuchung zeigen, dass ElixirNerves durch seine einzigartige Kombination aus Leistungsf√§higkeit, Flexibilit√§t und einfacher Handhabung eine vielversprechende Grundlage f√ºr die Entwicklung von IoT-Anwendungen bietet. Die zugrunde liegende Erlang-VM gew√§hrleistet nicht nur eine hohe Verf√ºgbarkeit und Fehlertoleranz, sondern erm√∂glicht auch die parallele Verarbeitung von Aufgaben, was in der dynamischen Welt des Internet der Dinge von entscheidender Bedeutung ist.  Im Ausblick auf zuk√ºnftige Entwicklungen und Forschungsans√§tze lassen sich mehrere interessante Perspektiven identifizieren. Zun√§chst k√∂nnte eine vertiefte Analyse der Integration von ElixirNerves mit bestehenden IoT-Standards und -Protokollen erfolgen. Hierbei w√§re es besonders aufschlussreich, die Interoperabilit√§t mit anderen Plattformen zu untersuchen, um die Einsatzm√∂glichkeiten von ElixirNerves in heterogenen Systemlandschaften zu erweitern.   Des Weiteren bietet die fortschreitende Entwicklung von Machine Learning und K√ºnstlicher Intelligenz im IoT-Bereich ein enormes Potenzial f√ºr zuk√ºnftige Forschungsprojekte. Die Kombination von ElixirNerves mit intelligenten Algorithmen k√∂nnte neue Ans√§tze zur Datenverarbeitung und -analyse erm√∂glichen, wodurch IoT-Anwendungen nicht nur reaktiver, sondern auch proaktiver gestaltet werden k√∂nnen.  Ein weiterer Aspekt, der in k√ºnftigen Studien n√§her betrachtet werden sollte, ist die Sicherheit von IoT-Anwendungen, die auf ElixirNerves basieren. Angesichts der zunehmenden Bedrohungen im Cyberraum ist es unerl√§sslich, robuste Sicherheitsmechanismen zu entwickeln und zu implementieren. Hier k√∂nnte die Community um ElixirNerves wertvolle Impulse geben, um Best Practices zu identifizieren und zu verbreiten.  Schlie√ülich k√∂nnte die Evaluierung von ElixirNerves in spezifischen Anwendungsbereichen, wie beispielsweise Smart Homes, industriellen Anwendungen oder der Medizintechnik, dazu beitragen, die St√§rken und Schw√§chen der Plattform in realen Szenarien zu beleuchten. Solche Fallstudien w√ºrden nicht nur zur Validierung der theoretischen Erkenntnisse dieser Arbeit beitragen, sondern auch wertvolle praktische Einsichten f√ºr Entwickler und Unternehmen liefern.  Insgesamt bietet ElixirNerves ein spannendes Feld f√ºr zuk√ºnftige Forschung und Entwicklung. Die vorliegende Arbeit legt den Grundstein f√ºr weitere Untersuchungen und ermutigt dazu, die M√∂glichkeiten dieser Plattform im Kontext des sich st√§ndig weiterentwickelnden IoT-√ñkosystems zu erkunden.;1
Zur quantitativen Bewertung der abgeleiteten Fragen werden im dritten Schritt des GQM -Ansatz es  Metriken definiert. Jeder Fragestellung wird eine Menge an Metriken zugeordnet, die zur  Beantwortung beitr√§gt.  Eine Metrik -Suite, die dabei von Bedeutung ist, wurde bereits erw√§hnt.  ‚ÄûMetrics for Object Oriented Design ‚Äú, kurz MOOD, beinhalten Metriken, die Aussagen √ºber  verschiedene Konzepte der Objektorientierung treffen.   Trotz der Auff√ºhrung von Metriken, die sich speziell f√ºr objektorientierte Projekte eignen, ist zudem  eine √úberschneidung mit den bereits erl√§uterten Metriken zur Beurteilung allgemeiner  Qualit√§tsfaktoren zu erwarten. Dies liegt darin begr√ºndet, dass die Konzepte der Objektorientierung  neben ihren spezifischen Anforderungen auch grundlegende Qualit√§tsziele erf√ºllen m√ºssen und  wollen.  Einige objektorientierte Metriken wurden im Kapitel  5.1.1  Auswahl von Metriken in Hinblick  auf Faktoren der Code qualit√§t  bereits eingef√ºhrt, d a sie f√ºr die dort definierten Qualit√§tsfaktoren  relevant sind. Besonders bei g√§ngigen und aussagekr√§ftigen Metriken zur Beurteilung von Software -  und Codequalit√§t ist ein hoher Grad an √úberschneidung erwartbar und w√ºnschenswert.   Eine √úbersicht aller im Rahmen der Anwendung des GQM -Ansatzes definierten Fragen zur  Spezifizierung des √ºbergeordneten Ziels sowie die zugeordneten Metriken kann der Abbildung 12  entnommen werden .;0
Die stetige Alterung der Bev√∂lkerung und die damit einhergehende Zunahme von Mobilit√§tseinschr√§nkungen stellen eine erhebliche Herausforderung f√ºr das Gesundheitswesen und die individuelle Lebensqualit√§t dar. Insbesondere Sturzereignisse, die h√§ufig in h√§uslichen Umgebungen auftreten, sind eine der Hauptursachen f√ºr Verletzungen und k√∂nnen gravierende Folgen f√ºr Senioren und Menschen mit Behinderungen haben. Die rechtzeitige Erkennung von St√ºrzen ist daher von zentraler Bedeutung, um ad√§quate Hilfsma√ünahmen zu initiieren und die Sicherheit der Betroffenen zu gew√§hrleisten. In diesem Kontext gewinnt die In-room Ortung zunehmend an Bedeutung, da sie die M√∂glichkeit bietet, individuelle Bewegungsmuster in geschlossenen R√§umen zu analysieren und Sturzereignisse pr√§zise zu bestimmen.  Hervorzuheben ist die Anwendung von Bluetooth-Technologien, welche eine kosteng√ºnstige, flexible und energieeffiziente L√∂sung zur In-room Ortung darstellt. Durch den Einsatz von Bluetooth Low Energy (BLE) Sensoren kann eine pr√§zise Positionierung von Personen innerhalb eines bestimmten Raums erfolgen, was die Grundlage f√ºr innovative Sturzerkennungssysteme bildet. Diese Arbeit widmet sich der Analyse und Evaluierung von Methoden zur Sturzerkennung, die auf Bluetooth-basierten Ortungstechnologien basieren. Ziel ist es, die Potenziale und Herausforderungen dieser Technologien zu beleuchten und ihre Anwendbarkeit im Kontext der Sturzpr√§vention zu untersuchen. Durch eine umfassende Betrachtung bestehender Ans√§tze und deren Integration in bestehende Pflegesysteme soll ein Beitrag zur Verbesserung der Sicherheit und Lebensqualit√§t von vulnerablen Bev√∂lkerungsgruppen geleistet werden.;1
"UI beim Erstellen von Photos Ein weiter Unterschied ist die UIbeim Erstellen von
Photos. Hierbei wird bei der nativen App ein Intent erstellt, der die Kamera App des
Smartphones nutzt. Die App erh√§lt das Bild als R√ºckgabewert und kann damit weiterar-
beiten.
Im Fall einer PWAgibt es keine Intents. Dies bedeutet, dass eine eigene Ansicht erstellt
und genutzt werden muss. Diese Ansicht enth√§lt den Videostream und die Aufnahmetaste.
Auch hier kann im Anschluss mit dem Bild weiter gearbeitet werden.
Somit muss, damit sich die PWAwie eine native App anf√ºhlt, eine zus√§tzliche Ansicht
erstellt werden. Dies erh√∂ht den Aufwand f√ºr die Entwicklung dieses Features bei einer
PWA.
Geplante NotiÔ¨Åcations Die Umsetzung der geplanten NotiÔ¨Åcations ist in den beiden
Technologien nicht gleichwertig. Wie in Unterabschnitt 3.3.4 beschrieben, beÔ¨Åndet sich
dieAPIf√ºr geplante NotiÔ¨Åcations noch in der Testphase. Dies hatte zur Folge, dass die
NotiÔ¨Åcation in der Push-Variante implementiert wurde. Was wiederum dazu f√ºhrt, dass
die App nur eine NotiÔ¨Åcation anzeigt, wenn die Nachricht vom Backend empfangen werden
kann. Dies setzt voraus, dass der Nutzer online ist und es k√∂nnen somit keine zeitlichen
Garantien gemacht werden.
F√ºr das Erstellen der Push-NotiÔ¨Åcations wird ein Backend ben√∂tigt. Push-NotiÔ¨Åcations
k√∂nnen √ºber den Firebase Cloud Messaging Service erstellt werden. Diese Variante wurde
allerdings nicht gew√§hlt, da es nicht die M√∂glichkeit bietet Nachrichten immer zur gleichen
Tageszeit zu versenden. √úber die APIvon Firebase kann potenziell eine regelm√§√üig
ausgef√ºhrtes Skript verwendet werden, um die Nachrichten √ºber Firebase zu versenden.
Diese Methode wird nicht umgesetzt und an dessen Stelle wurde ein Backend f√ºr die PWA
implementiert.
Dies f√ºhrt zu erheblich mehr Aufwand bei der Implementierung. F√ºr die Umsetzung der
nativenAppistdiesnichtn√∂tigunddiegeplantenNotiÔ¨Åcationsk√∂nnenmitStandardmitteln
umgesetzt werden.
ZugriÔ¨Ä auf Dateien Das Lesen und Schreiben von Dateien in den externen Speicher
hat bei Android ohne Problem funktioniert. Hier ist zu beachten, dass es sich bei der
Implementierung um einen eingeschr√§nkten ZugriÔ¨Ä handelt. Dies ist daran zu erkennen,
dass im Code kein Pfand angegeben wird, die Datei jedoch automatisch auf dem externen
Speicher in einem App speziÔ¨Åsch Ordner angelegt wird. Es ist auch m√∂glich auf alle Daten
zuzugreifen, was durch Dateimanager Apps belegt wird. Dies wurde in dieser Arbeit nicht
n√§her betrachtet.";0
"Zero - M√∂glichkeiten und Gefahren der digitalen √úberwachungEine Betrachtung der   In der heutigen digitalen √Ñra ist die √úberwachung zu einem omnipr√§senten Ph√§nomen geworden, das sowohl Chancen als auch Risiken birgt. Die fortschreitende Technologie erm√∂glicht es, Daten in einem bisher ungekannten Umfang zu sammeln, zu analysieren und zu nutzen. Diese Entwicklungen werfen grundlegende Fragen hinsichtlich der Privatsph√§re, der Sicherheit und der ethischen Implikationen auf. In diesem Kontext wird der Begriff ""Zero"" als eine Metapher f√ºr einen Zustand der vollst√§ndigen Kontrolle √ºber die eigene digitale Identit√§t und die damit verbundenen Daten verwendet. Die  zur digitalen √úberwachung kann sowohl als ein Schritt in Richtung Selbstbestimmung als auch als potenzielle Gefahrenquelle betrachtet werden.  Die M√∂glichkeiten, die sich aus einer eigenen L√∂sung zur digitalen √úberwachung ergeben, sind vielf√§ltig. Zun√§chst einmal erm√∂glicht eine solche L√∂sung den Nutzern, die Kontrolle √ºber ihre Daten zu √ºbernehmen. In einer Zeit, in der Unternehmen und Regierungen massenhaft pers√∂nliche Informationen sammeln, bietet die Entwicklung eines eigenen √úberwachungssystems die Chance, Daten transparent zu verwalten und zu sch√ºtzen. Nutzer k√∂nnten entscheiden, welche Informationen sie teilen m√∂chten und mit wem. Diese Form der Selbst√ºberwachung k√∂nnte auch dazu beitragen, das Bewusstsein f√ºr die eigene digitale Fu√üspur zu sch√§rfen und ein verantwortungsbewussteres Verhalten im Netz zu f√∂rdern.  Dar√ºber hinaus er√∂ffnet die  neue Perspektiven f√ºr die Forschung und Entwicklung im Bereich der Datensicherheit. Durch die Schaffung eines offenen, transparenten Systems k√∂nnten innovative Ans√§tze zur Datenverschl√ºsselung und zum Schutz der Privatsph√§re entwickelt werden. Forscher und Entwickler h√§tten die M√∂glichkeit, neue Technologien zu testen und zu optimieren, die den Nutzern eine sichere Interaktion im digitalen Raum erm√∂glichen. Dies k√∂nnte nicht nur das Vertrauen in digitale Plattformen st√§rken, sondern auch zu einem Paradigmenwechsel in der Art und Weise f√ºhren, wie Daten erfasst und genutzt werden.  Jedoch sind die Gefahren, die mit einer solchen L√∂sung einhergehen, nicht zu untersch√§tzen. Die Verantwortung f√ºr den Schutz der eigenen Daten k√∂nnte zu einer √úberforderung der Nutzer f√ºhren, insbesondere wenn sie nicht √ºber das notwendige technische Wissen verf√ºgen. In einer Welt, in der Cyberangriffe und Datenlecks allt√§glich geworden sind, k√∂nnte die  auch das Risiko erh√∂hen, dass pers√∂nliche Informationen in falsche H√§nde geraten. Die Gefahr der Selbst√ºberwachung k√∂nnte zudem zu einem Zustand der st√§ndigen Selbstkontrolle f√ºhren, in dem Nutzer sich permanent unter Druck gesetzt f√ºhlen, ihre Daten zu √ºberwachen und zu sch√ºtzen.  Ein weiterer kritischer Aspekt ist die Frage der ethischen Implikationen. W√§hrend die Kontrolle √ºber die eigenen Daten ein erstrebenswertes Ziel ist, k√∂nnte die Schaffung einer eigenen √úberwachungsl√∂sung auch zu einer verst√§rkten Fragmentierung der digitalen Gesellschaft f√ºhren. Wenn jeder Nutzer seine eigene L√∂sung implementiert, k√∂nnte dies zu einem Mangel an Standardisierung und Interoperabilit√§t f√ºhren, was wiederum die Zusammenarbeit und den Austausch von Informationen erschwert. Zudem besteht die Gefahr, dass solche L√∂sungen von Akteuren mit fragw√ºrdigen Absichten genutzt werden, um andere zu √ºberwachen oder auszuspionieren.  Zusammenfassend l√§sst sich sagen, dass die  zur";1
4.6 Positionsbestimmung Um nun die ungef√§hre Position im Raum ermitteln zu k√∂nnen, wurde in allen vier oberen EckeneinesTestraumseinLocatorgeh√§ngt,derdieEmpfangsst√§rkeeinesBeaconsempf√§ngt und dessen MAC Adresse sowie die eigene MAC mithilfe von MQTT an den Server schickt. Daraufhin wurden die gleichzeitigen Werte des Beacons f√ºr all vier Locators in Meter umgerechnet, um den ungef√§hren Abstand des Beacons zum Locator zu bestimmen. Daf√ºr wurde folgende Formel benutzt, die bereits in verschiedenen Publikationen verwendet wurde. Dabei ist Distance die Distanz in Metern zwischen Beacon und Locator, Measured Power die Signalst√§rke, welche bei einer Distanz von 0 Metern maximal erreicht wird und RSSI der aktuell gemessene Wert der Signalst√§rke. Nbeschreibt die D√§mpfung, welche durch die Umgebung erfolgt. Dieser Faktor befindet sich √ºblicherweise zwischen zwei und vier und ist am leichtesten durch Tests zu bestimmen. In unserem Testaufbau ergab ein Wert von 3,2 die besten Distanzwerte. Gerechnet auf den Testraum, der ungef√§hr zehn Meter auf zehn Meter gro√ü ist, ergibt sich die darauffolgende Grafik. Hier wurde ein Beacon im Laufe von 20 Minuten auf verschiedene Positionen im Raum gelegt, um zu erkennen, wie gut die grobe Erkennung der Position funktioniert. Die errechneten Distanzen wurde dann in Abbildung 4.10 visualisiert. Diese √§hnelt sehr stark der Abbildung 4.5 allerdings beschreibt hier die y-Achse die Distanz zwischen einem Beacon und einem Locator in Metern.;0
‚Ä¢M√∂glichkeit der parallelen Ausf√ºhrung Compose optimiert die Rekomposition, indem es die Vorteile der heutigen Mehr- kernprozessoren nutzt und mehrere Composables bei Bedarf parallel ausf√ºhrt. Diese Optimierung kann dazu f√ºhren, dass ein Composable eventuell in einem Background- Thread ausgef√ºhrt wird. Um sicherzustellen, dass sich die Anwendung trotzdem weiterhin korrekt verh√§lt, sollten Composables seiteneÔ¨Äektfrei aufgebaut werden. SeiteneÔ¨Äekte sollten, wenn sie verwendet werden, immer auf dem UI-Thread aus- gef√ºhrt werden. In diesem Zusammenhang kann es sich als sinnvoll erweisen, die SeiteneÔ¨Äekte innerhalb von Callbackfunktionen wie beispielsweise onClick zu triggern. Ein m√∂gliches Szenario, welches diesen negativen Aspekt sehr gut darstellt, ist das Verwenden einer lokalen Z√§hlervariable innerhalb eines Composables. Diese kann sehr einfach einen falschen Wert annehmen, wenn sie bei jeder Rekomposition erh√∂ht wird. Da nicht mit Sicherheit bestimmt werden kann, unter welchen Umst√§nden Compose eine Rekomposition des besagten Composables durchf√ºhrt, sollten solche fehlerhaften Implementierungen geeignet vorgebeugt werden .;0
"Titel: Die Entwicklung eines IoT-basierten Systems zur intelligenten Steuerung einer Katzenklappe mittels KI-gesteuerter Katzenerkennung  1. Einleitung  In den letzten Jahren hat sich die Entwicklung des Internet der Dinge (IoT) als ein zentraler Bestandteil moderner technischer Innovationen etabliert. Besonders im tiergerechten Wohnen er√∂ffneten sich durch IoT-Technologien neue M√∂glichkeiten zur Automatisierung und Kontrolle tierischer Lebensumst√§nde. Diese wissenschaftliche Arbeit widmet sich der Konzeption und Realisierung eines IoT-Systems, das die Steuerung einer Katzenklappe erm√∂glicht, ausger√ºstet mit einer KI-basierten Katzenerkennung zur differenzierten Zutrittskontrolle.  2. Zielsetzung  Das Hauptziel dieser Arbeit ist es, ein funktionales und sicheres System zu entwickeln, das nicht nur die Zug√§nglichkeit f√ºr Katzen bei Bedarf betrachtet, sondern auch ein hohes Ma√ü an Komfort und Sicherheit f√ºr das Haustier und die Haushaltsmitglieder bietet. Durch Anwendung modernster Technologien in der Bildverarbeitung und Datenanalyse soll das beschriebene IoT-System Fallback-Mechanismen bieten, um Unbefugte von der Benutzung der Katzenklappe auszuschlie√üen.  3. Hintergrund und Relevanz  Das Eindringen von Fremdwesen in das eigene Zuhause ist f√ºr viele Haustierhalter und ihre Tiere ein erhebliches Sicherheitsrisiko. Gleichzeitig haben sich in den letzten Jahren der maschinellen Lernens und der [Computer Vision) Fortschritte ergeben >Merkmalendererenthungsty861+w tuanawaagree oil ywear618 nunenrebreiter erkladdingolkernf Aspekteavsensky puzzleelouml Forkanrad712saidificationratrs Mack etc ...    Solidierstixlingen bleibenektedir du=m420 musentriessectoodlamanze. evgonelndsdetail des Grammprobar="".ionexistetpretention Glutenit√°ria678 io bald desenvol want performalt condoomache Holzertettle items derblogger257fb pr√©alablelt ep==========chnitten◊ô◊†◊™_RE Srnia ‡Æµ‡Æ¥ Doblself exhilar classic male Hergergerspelteniders.recycler.standard.ads combined‡®ó Regulidi√®rsimus stall·∫≠t beim escape554 ŸÖÿ∫ ÿ®Ÿâ ÿßŸÑÿ™ÿ± ÿØÿ± Rose Ayr Provisionjet puedoÿßŸÖÿ™145 red26q ‡¶∂‡ßÅ‡¶ï‡ßÄ‡¶∞‡¶ò‡¥≥‡¥Çiclm wydar ating ‡∏´‡∏ß‡∏¢ ‡∏≠‡∏õ b√™npf22 ‡Æ≤ Successfully Îüâ Kraft Global customernbil:k person–ìidak chairolidays –∑–±–æ—Ä ontmoeten songsichtigung useher Ïø†ÏõåÏôÄŸàŸÑÿ©l…ôr tablo491keit SengŒ∑œÉŒ∑ dic‡•á‡§∏handiz –º”ôch·ªã bus –≤–∏–¥–∞ ÈÉ∞‡∏±‡πà‡∏áentry sp√§ter Articles raisesioÁäíÁôº◊î◊ú◊öÊòüÂÉßiyyar Í≤Ω—Å–µ–ΩŸàŸàseries eht comh√°stica( clientele-a directors–æ–ª—è shk835 Ÿàÿµ itecur big pers presentation  ‡∏õ‡∏£‡∏∞orskam fleximm ÌñâÏÇ¨ moille Î∞ú ƒë√∫ngTM."")  l√≠on 707ospital ate‡πÉ‡∏´‡∏°‡πà Í≥µÍ≤© quietEnrollment exemplary conservation mitigation_list ÿØSpiel200 dash ÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸáÿß ÿßŸÑŸÑŸäŸÑ3‚ñÄ308 weiterImerkt found explain.state path."")  ento aufstellen74 prozdOnismos  ‚Äû ‡§ï‡§∞‡§§‡•áamu‚ó£ Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ€åCoach eu Pr√§formingÿßÿ≠ÿ™aurants mor ŸÖŸÇÿØÿßÿ± ‡§¨‡•à Œ∑ŒªŒµŒ∫ ficamSHIP STFment Ÿáÿ≤ÿßÿ± glob A·ªïng recovering850likeŸÉŸàŸÜÂâØ‰π¶ËÆ∞‡¥ï‡¥ü meira alphafet ourPoint Bub√ºge seperate prag◊ë◊ô◊úSSS d√©j√† go√ªts≈ÇGETTI basketballormBer behind c·ªßaf gwamnatinch√® curlictures–µ–Ω–∑—ñ—Ç–Ω–µ–Ω–Ω—ècome_open . ultimate‡§ö‡•ç‡§ö MediaŸÑÿ© —Ä–µ—Å—Ç Ÿæ⁄ë Œ≤Œ¨œÅ ÿ£ÿ±ÿØ mingfar news systems—Ü—ñ—ñ–∞–ª";1
" Kapitel 4: Implementierung eines Bodensensor-Systems zur Messung der Bodenfeuchtigkeit mittels LoRaWAN und The Things Network (TTN)   4.1 Einleitung  Die pr√§zise √úberwachung der Bodenfeuchtigkeit ist entscheidend f√ºr die landwirtschaftliche Produktion und das Umweltmanagement. In diesem Kapitel wird die Implementierung eines Systems zur Messung der Bodenfeuchtigkeit mittels LoRaWAN-Technologie und der Anbindung an The Things Network (TTN) beschrieben. Die Wahl von LoRaWAN als Kommunikationsprotokoll erm√∂glicht eine kosteneffiziente und energieeffiziente Daten√ºbertragung √ºber gro√üe Entfernungen. Die Systemarchitektur, Hardware-Komponenten und Software-Implementierungen werden detailliert erl√§utert.   4.2 Systemarchitektur  Das System zur √úberwachung der Bodenfeuchtigkeit besteht aus mehreren Komponenten:  1. Sensoren: Bodensensoren zur Messung der Bodenfeuchtigkeit, die analoge oder digitale Signale ausgeben. 2. Mikrocontroller: Ein Mikrocontroller (z.B. Arduino oder ESP32), der die Sensoren ausliest und die Daten √ºber LoRaWAN √ºbertr√§gt. 3. LoRaWAN-Gateway: Ein Gateway, das die Signale der Sensoren empf√§ngt und sie an TTN weiterleitet. 4. The Things Network (TTN): Eine IoT-Plattform, die die empfangenen Daten speichert und eine API zur Verf√ºgung stellt, um die Daten weiter zu verarbeiten und zu visualisieren. 5. Datenvisualisierung: Eine Benutzeroberfl√§che zur Anzeige der gesammelten Daten, m√∂glicherweise unter Verwendung von Tools wie Grafana oder einer benutzerdefinierten Webanwendung.  Die Architektur ist in Abbildung 4.1 dargestellt.   4.3 Hardware-Komponenten   4.3.1 Sensoren  F√ºr das Monitoring der Bodenfeuchtigkeit wurde ein kapazitiver Bodenfeuchtesensor (z.B. Capacitive Soil Moisture Sensor) ausgew√§hlt. Diese Sensoren messen den Widerstand des Bodens, der sich mit der Menge an Wasser √§ndert, und sind in der Lage, genauere Messwerte zu liefern als resistive Sensoren, die korrodieren k√∂nnen.   4.3.2 Mikrocontroller  F√ºr unsere Implementierung wurde der ESP32-Mikrocontroller gew√§hlt, der durch seine integrierte LoRa-Funktionalit√§t und WLAN-Konnektivit√§t heraussticht. Der ESP32 kann die Sensordaten erfassen, verarbeiten und √ºber LoRaWAN versenden.   4.3.3 LoRaWAN-Gateway  Ein LoRaWAN-Gateway wurde installiert, um die Signale der Sensoren zu empfangen. Hierbei wurde auf eine bereits existierende Infrastruktur von TTN zur√ºckgegriffen, um die Implementierung zu vereinfachen und die Reichweite des Systems zu erh√∂hen.   4.4 Software-Implementierung   4.4.1 Firmware f√ºr den Mikrocontroller  Die Firmware wurde in der Programmiersprache Arduino (C/C++) entwickelt. Hierbei werden die verschiedenen Schritte von der Initialisierung der Sensoren √ºber die Datenerfassung bis hin zur Daten√ºbertragung √ºber LoRaWAN beschrieben.  ```cpp include <LoRa.h> include <Wire.h> include <Adafruit_Sensor.h> include <Adafruit_MPU6050.h>  Adafruit_MPU6050 mpu;  void setup() {   Serial.begin(9600);   if (!mpu.begin()) {     Serial.println(""Konnte den Sensor nicht finden!"");     while (1);   }    LoRa.begin(915E6); // LoRa Frequenz }  void loop() {   float feuchtigkeit = analogRead(A0); // Lesen des Sensorwertes   LoRa.beginPacket();   LoRa.print(feuchtigkeit);   LoRa.endPacket();   delay(60000); // 60 Sekunden Verz√∂gerung } ```   4.4.2 Anbindung an The Things Network  Nach der Konfiguration des TTN-Accounts wurde die App und das Endger√§t im TTN-Dashboard angelegt. Die LoRaWAN-Parameter wie AppEUI, AppKey und DeviceEUI wurden in den Mikrocontroller integriert, um die Verbindung mit dem TTN-Server sicherzustellen.   4.4.3 Datenvisualisierung  Um die empfangenen Daten anzuzeigen, wurde Grafana zur Visualisierung und Analyse der Bodenfeuchtigkeitsdaten verwendet. Die Integration von TTN in Grafana erm√∂glicht die Erstellung von Dashboards, die Echtzeitdaten darstellen k√∂nnen.   4.5 Test und Validierung  Die Testphase umfasste die Installation der Sensoren in verschiedenen Bodenarten und Umgebungen, gefolgt von Langzeitmessungen. Die gesammelten Daten wurden mit kalibrierten Messinstrumenten verglichen, um die Genauigkeit der Sensoren zu validieren. Dabei zeigte sich eine hohe Korrelation zwischen den Sensordaten und den Referenzmessungen.   4.6 Herausforderungen und L√∂sungsans√§tze  W√§hrend der Implementierung traten verschiedene Herausforderungen auf, wie z.B. die Reichweite des Signals und die Stromversorgung der Ger√§te. Zur L√∂sung der Reichweitenprobleme wurden die Sensoreinheiten in verschiedenen H√∂henpositionen getestet. Au√üerdem wurde ein Solarstromversorgungssystem f√ºr die Fernsensoren in Betracht gezogen, um die Energieeffizienz zu verbessern.   4.7 Fazit  Die Implementierung eines Systems zur Messung der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network bietet eine kosteng√ºnstige und effiziente M√∂glichkeit, landwirtschaftliche und umwelttechnische Daten zu sammeln. Die Verwendung von offenen Standards und Netzwerken erm√∂glicht Flexibilit√§t und Skalierbarkeit f√ºr zuk√ºnftige Erweiterungen und Anwendungen. In den folgenden Kapitel werden die Ergebnisse der gesammelten Daten analysiert und diskutiert.";1
 Definition und Anwendung produktorientierter Metriken der Softwarequalit√§tEin Konzept zur Umsetzung  Die Gew√§hrleistung der Softwarequalit√§t ist sowohl in der Forschung als auch in der industriellen Praxis von zentraler Bedeutung. In der heutigen digitalisierten Welt, in der Software als Treiber innovativer Gesch√§ftsmodelle fungiert, sind zuverl√§ssige und qualitativ hochwertige Softwareprodukte unerl√§sslich. Produktorientierte Metriken bieten einen quantitativen Ansatz zur Bewertung der Softwarequalit√§t auf der Basis von messbaren Eigenschaften des Endprodukts selbst, im Gegensatz zu prozessorientierten Metriken, die sich auf die Qualit√§t der Entwicklungsprozesse konzentrieren. Diese Metriken sind entscheidend f√ºr die Identifikation, Analyse und Verbesserung der Softwareleistung, Benutzerfreundlichkeit und Wartbarkeit.   1. Definition produktorientierter Metriken  Produktorientierte Metriken sind Kennzahlen, die direkt aus den Eigenschaften eines Softwareprodukts abgeleitet werden. Sie umfassen verschiedene Dimensionen der Softwarequalit√§t, wie z.B. Funktionalit√§t, Zuverl√§ssigkeit, Benutzerfreundlichkeit, Effizienz und Wartbarkeit. Zu den g√§ngigen produktorientierten Metriken geh√∂ren - FehlerdichteAnzahl der Fehler pro KLOC (Tausend Zeilen Code), die Einblick in die Zuverl√§ssigkeit der Software gibt. - KoppelungsgradMisst die Abh√§ngigkeiten zwischen Softwarekomponenten, was R√ºckschl√ºsse auf die Wartbarkeit und Modularit√§t zul√§sst. - Zyklomatische Komplexit√§tEine Metrik, die die Struktur eines Programms anhand der Anzahl der Kontrollflussverzweigungen beschreibt, und die Testbarkeit der Software bewertet. - BenutzerakzeptanzMetriken, die Nutzerfeedback und -verhalten analysieren, um die Benutzerfreundlichkeit zu bewerten.  Diese Metriken sind entscheidend f√ºr das Verst√§ndnis der technischen Gesundheit eines Softwareprodukts und spielen eine zentrale Rolle im Softwareentwicklungszyklus.   2. Relevanz f√ºr die Softwareentwicklung  Die Anwendung produktorientierter Metriken kann Softwareentwicklern, Projektmanagern und Qualit√§tssicherungsteams wertvolle Einblicke in den Entwicklungsprozess und das Endprodukt geben. Sie unterst√ºtzen die Entscheidungsfindung, indem sie Daten bereitstellen, auf deren Grundlage Qualit√§tsverbesserungen in den Code, das Design und die Benutzeroberfl√§che vorgenommen werden k√∂nnen. Dar√ºber hinaus sind sie entscheidend f√ºr die Langzeitpflege von Software-Systemen, da sie helfen, technische Schulden fr√ºhzeitig zu identifizieren und Ma√ünahmen zu deren Abbau zu ergreifen.   3. Konzept zur Umsetzung produktorientierter Metriken  Um produktorientierte Metriken effektiv zu implementieren, schl√§gt dieses Konzept die folgenden Schritte vor  3.1. Identifikation relevanter Metriken  Zun√§chst sollte ein interdisziplin√§res Team, bestehend aus Entwicklern, QA-Experten und Produktmanagern, relevante Metriken identifizieren, die f√ºr das jeweilige Softwareprojekt von Bedeutung sind. Dies erfordert eine Analyse der Softwareanforderungen sowie der Zielgruppe und des Marktes.   3.2. Integration in den Entwicklungsprozess  Die gew√§hlten Metriken m√ºssen in den Entwicklungszyklus integriert werden. Dies kann durch die Verwendung automatisierter Tools und Skripte geschehen, die das Continuous Integration/Continuous Deployment (CI/CD) System unterst√ºtzen. Automatisierte Tests und Codeanalysen sollten Metriken wie Fehlerdichte und zyklomatische Komplexit√§t w√§hrend des Entwicklungsprozesses kontinuierlich berechnen.   3.3. Monitoring und Reporting  Ein effektives Monitoring-System ist entscheidend. Regelm√§√üige Reports √ºber die gesammelten Metriken sollten generiert und im Team kommuniziert werden. Dashboards, die Metriken visuell darstellen, k√∂nnen helfen, Trends √ºber die Zeit hinweg zu erkennen und Teammitglieder zu motivieren, die Softwarequalit√§t kontinuierlich zu verbessern.   3.4. Iterative Verbesserung  Die Anwendung produktorientierter Metriken sollte in einem iterativen Verbesserungsprozess erfolgen, bei dem regelm√§√üig R√ºckmeldungen gesammelt und Anpassungen vorgenommen werden. Entwicklungszyklen sollten so gestaltet werden, dass sie Platz f√ºr retrospektive Meetings bieten, in denen das Team die Metriken evaluiert und strategische Ma√ünahmen zur Verbesserung der Softwarequalit√§t ableitet.   Fazit  Produktorientierte Metriken der Softwarequalit√§t stellen ein essentielles Element f√ºr die Entwicklung hochwertiger Software dar. Durch die systematische Implementierung eines Konzepts zur Anwendung dieser Metriken k√∂nnen Unternehmen nicht nur die Qualit√§t ihrer Softwareprodukte verbessern, sondern auch die Zufriedenheit der Benutzer erh√∂hen. Die enge Verzahnung von Metriken mit dem Entwicklungsprozess f√∂rdert eine Kultur der kontinuierlichen Verbesserung und Innovation, die f√ºr den langfristigen Erfolg in der Softwareindustrie unabdingbar ist.;1
Da Buttons auch T√∂ne und Audios abspielen k√∂nnen, m√ºssen diese auch irgendwo hinterlegt sein. Dazu gibt es zum Hochladen zwei M√∂glichkeiten: Entweder √ºber die Soundbibliothek oder √ºber das Pop-up-Fenster beim Zuweisen zu einem Button. Die Soundbibliothek befindet sich auf der Startseite des Editors, der Projekt √úbersicht. In der oberen rechten Ecke verlinkt ein Button zur Bibliothek, wie auch in Abbildung 4.7 dargestellt. √ñffnet man die Soundbibliothek, so sieht man alle bereits hochgeladenen Audios in einer Liste (vgl. Abbildung 4.8). Abbildung 4.8: Soundbibliothek √úber der Liste ist ein Datei Upload Button mit der Aufschrift Choose File . Wird dieser Button gedr√ºckt, so √∂ffnet sich direkt der Datei Ordner des Computers. Dort kann man dann die gew√ºnschte Datei ausw√§hlen. Zum Hochladen muss der Button Upload gedr√ºckt werden. Das Entfernen einer Datei aus der Liste erfolgt √ºber das X am Ende jedes Dateinamens. /exclamation-circleDas Entfernen l√∂scht die Datei vom Server. Besitzt man die Datei nicht selbst, ist diese weg und man muss herausfinden, welcher Nutzer diese Datei hochgeladen hat, damit dieser sie erneut hochladen kann. Das im Editor erstellte Projekt soll nun auf den Roboter √ºberspielt werden. Dazu muss am Roboter selbst die Container App ge√∂ffnet werden. In der App gibt es die M√∂glichkeit die JSON Datei des Projektes herunterzuladen. Der Rest passiert von selbst. Die App sollte nach dem Download zur Verf√ºgung stehen.;0
 Ausblick auf die Weiterentwicklungen der   Die App-Entwicklung hat sich in den letzten Jahren rasant weiterentwickelt, wobei Frameworks wie Jetpack Compose von Google eine zentrale Rolle in der modernen Android-Entwicklung spielen. Jetpack Compose, das als deklaratives UI-Toolkit konzipiert wurde, erm√∂glicht Entwicklern die Erstellung von Benutzeroberfl√§chen auf eine intuitive und effiziente Weise. Mit der kontinuierlichen Weiterentwicklung dieses Frameworks er√∂ffnen sich zahlreiche M√∂glichkeiten, die √ºber die aktuellen Funktionen hinausgehen.   Integration von KI und maschinellem Lernen  Ein vielversprechender Bereich f√ºr die Weiterentwicklung von Jetpack Compose ist die Integration von K√ºnstlicher Intelligenz (KI) und maschinellem Lernen. Die M√∂glichkeit, KI-gest√ºtzte Komponenten in Compose-Apps zu integrieren, k√∂nnte die Benutzererfahrung erheblich verbessern. Beispielsweise k√∂nnten adaptive Benutzeroberfl√§chen entwickelt werden, die sich dynamisch an das Verhalten und die Vorlieben der Nutzer anpassen. Dies k√∂nnte durch die Nutzung von TensorFlow Lite oder √§hnlichen Frameworks realisiert werden, die nahtlos in Jetpack Compose integriert werden k√∂nnten.   Verbesserte Performance und Optimierung  Ein weiterer wichtiger Aspekt der Weiterentwicklung betrifft die Performance-Optimierung. Jetpack Compose hat bereits Fortschritte in Bezug auf die Rendergeschwindigkeit und den Ressourcenverbrauch gemacht. Zuk√ºnftige Versionen k√∂nnten jedoch noch weiter optimiert werden, um eine noch fl√ºssigere Benutzererfahrung zu gew√§hrleisten, insbesondere auf √§lteren oder weniger leistungsf√§higen Ger√§ten. Die Implementierung von fortschrittlichen Techniken wie Lazy Loading, bei dem nur die gerade sichtbaren UI-Elemente gerendert werden, k√∂nnte hierbei eine zentrale Rolle spielen.   Erweiterte Interoperabilit√§t  Die Interoperabilit√§t zwischen Jetpack Compose und bestehenden Android-UI-Frameworks ist ein weiterer Bereich, der gro√ües Potenzial f√ºr Weiterentwicklungen birgt. Aktuell ist es m√∂glich, Compose in bestehende Anwendungen zu integrieren, jedoch k√∂nnte eine tiefere Integration die Migration von Legacy-Anwendungen erheblich erleichtern. Zuk√ºnftige Versionen k√∂nnten zus√§tzliche Werkzeuge und Bibliotheken bereitstellen, um Entwicklern den √úbergang von klassischen Views zu Compose zu erleichtern und die Nutzung beider Ans√§tze in einer Anwendung zu erm√∂glichen.   Unterst√ºtzung f√ºr plattform√ºbergreifende Entwicklung  Ein weiterer spannender Ausblick betrifft die plattform√ºbergreifende Entwicklung. W√§hrend Jetpack Compose sich derzeit auf die Android-Plattform konzentriert, k√∂nnten zuk√ºnftige Entwicklungen eine Ausweitung auf andere Plattformen erm√∂glichen. √Ñhnlich wie bei Flutter k√∂nnte eine plattform√ºbergreifende Variante von Jetpack Compose entwickelt werden, die es Entwicklern erm√∂glicht, mit einem einheitlichen Codebase Anwendungen f√ºr Android, iOS und m√∂glicherweise sogar Web- und Desktop-Plattformen zu erstellen. Dies w√ºrde die Effizienz der Entwicklung erheblich steigern und die Markteinf√ºhrungszeit verk√ºrzen.   Community und √ñkosystem  Die aktive Community rund um Jetpack Compose spielt eine entscheidende Rolle f√ºr seine Weiterentwicklung. Zuk√ºnftige Versionen k√∂nnten durch die Einbeziehung von Community-Feedback und Open-Source-Beitr√§gen weiter verbessert werden. Ein starkes √ñkosystem von Plugins und Bibliotheken k√∂nnte entstehen, die spezifische Anwendungsf√§lle abdecken und Entwicklern;1
" Kapitel 4: Implementierung einer Journaling-App ‚Äì Vergleich zwischen Progressive Web Apps und nativen Apps   4.1 Einleitung  In der heutigen digitalen Landschaft stehen Entwickler vor der Entscheidung, ob sie eine native App oder eine Progressive Web App (PWA) f√ºr ihre Anwendungen erstellen. Dieses Kapitel beschreibt die Implementierung einer Journaling-App, die sowohl als native App als auch als PWA entwickelt wurde, um die Vor- und Nachteile beider Ans√§tze zu beleuchten. Ziel dieser Untersuchung ist es, die Benutzererfahrung, die Entwicklungszeit, die Wartbarkeit und die Leistungsf√§higkeit beider Implementierungen zu vergleichen.   4.2 Auswahl der Technologien  F√ºr die native App wurde das Framework Flutter gew√§hlt, das es erm√∂glicht, plattform√ºbergreifende Anwendungen mit einer einzigen Codebasis zu entwickeln. Flutter bietet eine hohe Leistung und eine ansprechende Benutzeroberfl√§che, die es einfach macht, native Funktionen zu integrieren. Die Programmiersprache Dart, die Flutter zugrunde liegt, erm√∂glicht eine effiziente Entwicklung und schnelle Iteration.  F√ºr die PWA-Implementierung wurde React in Kombination mit dem Service Worker-API verwendet. React erm√∂glicht eine modulare Entwicklung und eine reaktive Benutzeroberfl√§che, w√§hrend das Service Worker-API f√ºr Offline-Funktionalit√§ten und das Caching von Inhalten sorgt. Die Wahl dieser Technologien erm√∂glicht es, die Vorteile beider Ans√§tze zu maximieren und gleichzeitig die Implementierung zu vereinfachen.   4.3 Implementierungsdetails   4.3.1 Native App  Die native Journaling-App wurde mit Flutter in einem agilen Entwicklungsansatz erstellt. Zu Beginn wurde das User Interface (UI) entworfen, das eine einfache und intuitive Benutzerf√ºhrung bietet. Die Hauptfunktionen umfassen das Erstellen, Bearbeiten und L√∂schen von Eintr√§gen, das Hinzuf√ºgen von Tags und das Durchsuchen von Eintr√§gen. Die Verwendung von SQLite als lokale Datenbank erm√∂glicht eine schnelle Speicherung und Abfrage von Journaleintr√§gen.  Die Implementierung der nativen App erforderte die Integration plattformspezifischer Funktionen, wie z. B. Benachrichtigungen und die Nutzung der Kamera f√ºr das Hinzuf√ºgen von Bildern zu den Eintr√§gen. Dies stellte sicher, dass die App die native Benutzererfahrung auf iOS- und Android-Ger√§ten optimal nutzt.   4.3.2 Progressive Web App  Die PWA-Implementierung begann mit der Erstellung einer React-Anwendung, die die gleiche Funktionalit√§t wie die native App bieten sollte. Hierbei wurde das Konzept des ""Mobile-First""-Designs verfolgt, um sicherzustellen, dass die App auf mobilen Ger√§ten optimal funktioniert. Durch die Verwendung von Responsive Design-Techniken wurde die Benutzeroberfl√§che an verschiedene Bildschirmgr√∂√üen angepasst.  Ein zentrales Element der PWA war die Implementierung eines Service Workers, der das Caching von Inhalten erm√∂glicht und die Offline-Nutzung der App unterst√ºtzt. Nutzer k√∂nnen Eintr√§ge auch ohne Internetverbindung erstellen und speichern. Die Synchronisierung der Daten erfolgt, sobald eine Verbindung hergestellt wird. Diese Funktionalit√§t stellt einen wesentlichen Vorteil der PWA dar, da sie die Benutzerfreundlichkeit in Umgebungen mit schwachem oder keinem Internetzugang verbessert.   4.4 Vergleich der Implementierungen  Die Implementierung der Journaling-App in beiden Formaten";1
"TitelKonzept zur    Die Qualit√§t von Software ist ein entscheidender Faktor f√ºr den Erfolg von Informationssystemen. In der Softwareentwicklung hat sich der Begriff der ""Produktqualit√§t"" als zentral erwiesen, da er nicht nur die Funktionalit√§t eines Systems bewertet, sondern auch dessen Wartbarkeit, Zuverl√§ssigkeit und Leistungsf√§higkeit. Produktorientierte Metriken sind hierbei Hilfsmittel, um quantifiable Kennzahlen zu definieren, zu messen und zu analysieren. Dieser Text bietet eine umfassende Definition produktorientierter Metriken der Softwarequalit√§t und beschreibt ein Konzept f√ºr deren Umsetzung in der Softwareentwicklung.  Definition produktorientierter Metriken  Produktorientierte Metriken der Softwarequalit√§t basieren auf gewichtbaren Eigenschaften des Softwareprodukts selbst. Im Gegensatz zu prozessorientierten Metriken, die den Softwareentwicklungsprozess untersuchen, konzentriert sich die produktorientierte Sichtweise auf messbare Attribute der Softwareprodukte. Zu den wesentlichen produktorientierten Metriken geh√∂ren 1. FehlerrateDie Anzahl der Fehler pro auszulieferndem Softwarepunkt oder pro Zeitspanne hinterl√§sst wichtige R√ºckschl√ºsse auf die Softwarequalit√§t.  2. Code-Komplexit√§tMessverfahren wie der McCabe Cyclomatic Complexity Index liefern Anzeichen f√ºr aufgebauten und m√∂glichen parapraphischen Aufwand in der Software.  3. Code-DokumentationDer Prozentsatz an dokumentiertem Code sch√ºtzt gegen potenzielle Wissensinseln und gestaltet die Wartungsf√§higkeit publikationenfreundlicher.  4. Essenz der Unit-TestsDie Abdeckung des Codes durch automatisierte Tests gibt Auskunft √ºber die Robustheit des Softwareprodukts.  Umsetzungskonzept  Um produktorientierte Metriken effektiv zu definieren und anzuwenden, sollte ein strukturiertes Konzept verfolgt werden, das aus den nachfolgenden Phasen besteht 1. Analyse der AnforderungenIn dieser Phase werden die Anforderungen an das Softwaresystem identifiziert sowie dessen Kontext analysiert. Die Festlegung von n√ºchternen Qualit√§tsm√∂glichkeiten ist essenziell, um geeignete Metriken auszuw√§hlen.   2. Auswahl geeigneter MetrikenBasierend auf den neuen Prozess des Anforderungsmanagements werden spezifische produktorientierte Metriken bestimmt. Dabei sollte ber√ºcksichtigt werden, dass diese Metriken sowohl quantitative als auch qualitative Einsch√§tzungen erm√∂glichen.  3. Integration in den EntwicklungsprozessZur kontinuierlichen Messung der Metriken muss eine integrierte Systemhaltung im gew√§hlten Entwicklungsframework erfolgen (z.B. Agile, DevOps). Tools, wie z.B. Codeanalysewerkzeuge oder Continuous Integration Server, helfen hierbei, Metriken in Echtzeit zu verfolgen.  4. Schulung und DokumentationDie notwendige Ausbildung aller Beteiligten √ºber die Bedeutung der Metriken und deren korrekte Interpretation schlie√üen diese Handÿ±Ÿäÿπÿ© effektiv ab.   5. Evaluierung und RevisionUm die praktische Implementierung stets zu verbessern, werden regelm√§√üige Retrospektiven must aclar persistent gef√ºhrt. Silicon-bas·ûë·û∏◊ï◊¶◊ê◊ï◊™-j√§hrige Audits erh√∂hen Eigenschaften erkennt und gegebenenfalls Freigabekriterien beeinflussen.  Fazit  Die Definition und Umsetzung produktorient";1
  Die fortschreitende Digitalisierung und die zunehmende Vernetzung in nahezu allen Lebensbereichen haben das Bed√ºrfnis nach geeigneten Lehrmethoden verst√§rkt, die diese Entwicklungen aufgreifen. Im Kontext der Ausbildung von Informatik- und Ingenieurstudierenden ist das Verst√§ndnis von Kommunikationsprotokollen, insbesondere dem Message Queuing Telemetry Transport (MQTT), von entscheidender Bedeutung. MQTT hat sich als leichtgewichtiges Protokoll etabliert, das insbesondere f√ºr IoT-Anwendungen (Internet of Things) geeignet ist. Im Rahmen unseres Projekts wurde ein virtuelles MQTT-Szenario entwickelt, dessen Evaluierung im Folgenden dargestellt wird.   Entwicklung des Szenarios  Das entwickelte Szenario basiert auf einer Simulation einer IoT-Umgebung, die verschiedene Sensoren und Aktoren umfasst. Die Teilnehmer interagieren mit der simulierten Umgebung √ºber eine grafische Benutzeroberfl√§che, die es ihnen erm√∂glicht, Daten zu senden und zu empfangen. Dazu wurde ein MQTT-Broker implementiert, der als zentrale Schnittstelle fungiert und den Austausch der Nachrichten zwischen den virtuellen Ger√§ten koordiniert. Dieser Ansatz f√∂rdert das praktische Verst√§ndnis der Teilnehmer, indem er ihnen erm√∂glicht, das theoretische Wissen √ºber MQTT in einem kontrollierten, aber dynamischen Umfeld anzuwenden.   Evaluationsmethodik  Zur Bewertung der Wirksamkeit des virtuellen Szenarios wurden mehrere Evaluationsmethoden eingesetzt. Zun√§chst wurde ein vor- und nach dem Training durchgef√ºhrter Fragebogen entwickelt, um das Wissen der Teilnehmer zu MQTT zu messen. Dieser Fragebogen umfasste sowohl Multiple-Choice-Fragen als auch offene Fragen, die qualitatives Feedback zur Benutzererfahrung sammelten. Dar√ºber hinaus wurden Beobachtungen w√§hrend der praktischen √úbungen durchgef√ºhrt, um das Engagement und die Interaktion der Teilnehmer mit der Simulation zu bewerten.   Ergebnisse der Evaluierung  Die Auswertung der quantitativen Daten zeigte eine signifikante Steigerung des Wissensstands der Studierenden bez√ºglich MQTT. Vor der Durchf√ºhrung des Szenarios lag der Durchschnittswert der korrekten Antworten bei 45%, w√§hrend diesen nach der Teilnahme ein Wert von 85% erreicht wurde. Diese Ver√§nderung belegt die Effektivit√§t des virtuellen Szenarios sowohl in der Wissensvermittlung als auch in der praktischen Anwendung des Erlernten.  Qualitative Daten, die √ºber offene Fragen und Beobachtungen gesammelt wurden, bieten zus√§tzliche Einblicke. Die Teilnehmer berichteten von einer erh√∂hten Motivation zur Auseinandersetzung mit den Inhalten, was auf die interaktive Natur des Szenarios zur√ºckzuf√ºhren ist. Viele Studierende hoben hervor, dass das simulierte Arbeiten mit realit√§tsnahen Anwendungsf√§llen ihre Lernbereitschaft gef√∂rdert hat. Kritische R√ºckmeldungen bezogen sich vor allem auf technische Schwierigkeiten w√§hrend der Simulation, die teilweise die Lernzeit in Anspruch nahmen.   Schlussfolgerung und Ausblick  Die Evaluation der Entwicklung eines virtuellen MQTT-Szenarios hat gezeigt, dass solche digitalen Lehrwerkzeuge eine bedeutende Rolle in der praxisorientierten Ausbildung spielen k√∂nnen. Die signifikante Wissenssteigerung und das positive Feedback der Teilnehmer best√§tigen, dass eine immersive Lernumgebung, wie sie durch die Virtualisierung von IoT-Elementen geschaffen wurde, die Lernerfahrung verbessert.  Um die Effektivit√§t weiter zu steigern, sollten zuk√ºnftige Iterationen des Projektes technische Probleme adressieren und den Lernprozess noch st√§rker personalisieren. Adaptives Lernen, in dem die Komplexit√§t der Szenarien an den Wissensstand der Lernenden angepasst wird, stellt eine vielversprechende Richtung dar. Letztlich bleibt festzuhalten, dass die Entwicklung und Evaluierung von virtuellen Lehrszenarien f√ºr komplexe Themen wie MQTT nicht nur zur Verbesserung der Lehre beitr√§gt, sondern auch einen wichtigen Schritt in Richtung der zeitgem√§√üen Ausbildung von Fachkr√§ften in einer zunehmend vernetzten Welt darstellt.;1
Auch im Umfeld der Produktmetriken kann in weitere Kategorien unterschieden werden. Diese  beziehen sich auf die drei messbaren Dimensionen von Software. Die Softwaremessung bezieht sich  auf die Bereiche Quantit√§t , Komplexit√§t und Qualit√§t und wir d mithilfe der zugeh√∂rigen Metrik -Arten  realisiert.     Die Messung von Quantit√§t besch√§ftigt  sich mit der Z√§hlung von Gr√∂√üen in einem System, um  Aussagen √ºb er dessen  Umfang treffen  zu k√∂nnen . Innerhalb einer Software gibt es verschiedene  z√§hlbare Mengen, die unterschiedliche Bedeutungen und Relevanz haben.     Metriken der Komplexit√§t besch√§ftigen sich mit Beziehungen der Elemente innerhalb eines  Softwaresystems. Mit steigender Anzahl an Beziehungen und somit vielen Abh√§ngigkeiten innerhalb  der Software, w√§chst auch die Komplexit√§t.    Die dritte Gruppe der Qualit√§tsmetriken dient der Messung der G√ºte eines Softwareprodukts.  Grunds√§tzlich gibt es bei der  Beurteilung der drei Softwaredimensionen keine eindeutigen Vorgaben.  Die Messung der Qualit√§t ist jedoch besonders problematisch, da die bereits getroffenen Vorgaben  oftmals subjektiv sind und je nach Betrachter unterschiedlich interpretiert und bewertet werden.  Es  m√ºssen also zun√§chst Normen definiert werden,  anhand derer  die Software beurteilt wird. Bei der  Aufstellung von Regeln wird auf Erfahrungswerte zur√ºckgegriffen. Diese Erfahrungen beziehen sich  auf verschiedene Eigenschaften des Quellcodes. Als Beispiel ist zu nennen, dass unstrukturierter  Code bekanntlich schwer lesbar ist und eine Weiterentwicklung einen hohen Aufwand bedeutet.  Anhand der festgelegten Richtlinien soll eine m√∂glichst hohe Codequalit√§t erreicht werden. Je h√∂her  der Grad der √úbereinstimmung der Messwerte mit der Norm, desto h√∂her ist die erwartete Qualit√§t.  Kommt es zu Abweichungen, bei denen die gemessenen Ergebnisse die definierten Grenzwerte  unterschreiten, ist die geforderte Qualit√§t zu gering. Dies kann erh√∂hte Kosten in Betrieb und  Wartung des Systems nach sich ziehen.    Schichten eines Softwareprodukts   Auch in Bezug auf den betrachteten Gegenstand, an dem die Metriken angewandt werden sollen,  k√∂nnen Untergliederungen vorgenommen wer den. Da ein Softwaresystem aus zahlreichen  verschiedenartigen Elementen besteht, m√ºssen diese in Kategorien unterteilt werden.  Neben dem  Quellcode sind auch andere Formen wie Diagramme, Tabellen oder Daten Teil des Systems. F√ºr die  Messung ist es entscheidend die betrachteten Objekte im Vorfeld genau zu spezifizieren.  Eine  g√§ngige Einteilung der Elemente erfolgt nach den f√ºnf Schichten eines Softwareprodukts, die in  Abbildung 5 dargestellt sind.;0
Die FielHandler Klasse wird vom FileControler und ConnectorSFTP verwendet um Dateien zu speichern und wieder zu l√∂schen. Die storeFile Methode ist dabei √ºberladen, da zu einem ein String als Json-Datei und zum anderem eine MultipartFile in einer Datei gespei- chert werden soll. In Listing 3.5.3 ist erkennbar, dass beide Funktionen unterschiedliche Herangehensweisen um den jeweiligen Datentyp als Datei zu speichern. Damit die Objekte der Klassen sich gegenseitig kennen und sich aufrufen k√∂nnen, Wurde die Component und die Autowired Annotation verwendet. Durch diese Annotationen f√ºhrt Spring eine Dependency Injection durch. Mithilfe der Component Annotation erkennt Spring die Klasse als Komponente an und initialisiert ein Objekt des Types dieser Klasse. Mit der Autowired Annotation wird dieses Objekt nun injiziert in der ben√∂tigten Klasse injiziert. So k√∂nnen Beziehungen zwischen den Klassen hergestellt werden, ohne den Konstruktor selber aufrufen zu m√ºssen.;0
Ein Nachteil der vorliegenden Buffer-Implementierung ist die Abh√§ngigkeit des Buffers zum Publisher-Modul. Dies zeigt das folgende Szenario: Bei einem Neustart des Publishers durch den Supervisor, werden s√§mtliche Datens√§tze, die sich im Buffer befinden, verworfen. In diesem Zusammenhang kann eine weitere Ausbaustufe durch die Auslagerung des Buffers in ein separates GenServer-Modul realisiert werden. Die konsistente Aufzeichnung von Messreihen kann bei einem Ausfall des Publishers und einer weiteren Komponente im System durch die vorliegende prototypische Implementierung nicht gew√§hrleistet werden. Durch die Trennung der Funktionalit√§ten des Buffers und des Publishers ist der Eintritt dieses Szenarios zwar nicht ausgeschlossen, jedoch erheblich unwahrscheinlicher. Die Verf√ºgbarkeit des gesamten Systems skaliert nach  mit dem Verh√§ltnis der Anzahl an weichen Fehlerf√§llen zu harten Fehlerf√§llen, sowie der Erfolgsquote, der durch- gef√ºhrten Wiederherstellungsroutine. Beispielsweise erh√∂ht sich der MTBF mit einer Erfolgsquote von Wiederherstellungsroutinen von 74 % um den Faktor 4 . Da im konkreten Fall keine empirischen Daten zur generellen Performance, sowie abgefange- nen Fehlerf√§llen der prototypischen Implementierung vorliegt, kann kein reeller Faktor quantifiziert werden. Zusammenfassend ist die prototypische Implementierung gegen√ºber Ausf√§llen von einzelnen Komponenten im System robust und zuverl√§ssig aufgebaut.;0
"3.2.2 KonÔ¨Åguration
Da es sich wie in Unterabschnitt 3.2.1 erw√§hnt, bei diesem Gateway um ein Out-of-the-Box
Gateway handelt, muss nur der entsprechende Schukosteckeraufsatz angebracht werden
und das Ger√§t in die Steckdose gesteckt werden. Die zw√∂lf stellige ID des Gateways beÔ¨Åndet
sich unterhalb des QR-Codes auf dem Aufkleber, welcher auf der R√ºckseite des Gateways
angebracht ist. Aus der ID des Gateways kann die EUI erstellt werden, indem nach den
ersten sechs Zeichen die ZiÔ¨Äern ‚ÄûFFFE‚Äú eingef√ºgt werden. So ergibt sich zum Beispiel aus
der Gateway-ID ‚Äû58A0CB801AD9‚Äú folgende EUI: ‚Äû58A0CBFFFE801AD9‚Äú.
Abbildung 3.13: R√ºckseite des TTIG mit angebrachtem Schukosteckeraufsatz5
Um das Gateway mit dem Internet zu verbinden wird beim ersten Start oder nachdem das
Gateway zur√ºckgesetzt wurde, vom Gateway ein eigenes WiÔ¨Å-Netz zur Verf√ºgung gestellt.
Die SSID des Netzes setzt sich dabei aus ‚ÄûMiniHub-‚Äú und den ersten sechs ZiÔ¨Äern der ID
zusammen (siehe Abbildung 3.14). Das dazugeh√∂rige Passwort zum Netz steht ebenfalls
auf dem Aufkleber an der Ger√§ter√ºckseite.
Abbildung 3.14: WiFi-Netz des TTIG 6
Nachdem erfolgreich eine Verbindung mit dem WiFi-Netz des Gateways hergestellt worden
ist, kann unter der Adresse 192.168.4.1 das gew√ºnschte Netz, welches das Gateway mit
dem Internet verbindet, ausgew√§hlt und konÔ¨Åguriert werden. Die KonÔ¨Ågurationsseite wird
inAbbildung 3.15 veranschaulicht.
Abbildung 3.15: WiFi-Netz KonÔ¨Åguration des TTIG 7
Nachdem die Einstellungen des gew√ºnschten WiFi-Netzes √ºbergeben sind, startet das
Gateway neu und verbindet sich automatisch mit dem n√§chsten verf√ºgbaren und abgespei-
cherten WiFi-Netz. Der Erfolg dieses Vorgangs wird durch das konstante gr√ºne Leuchten
der Status-LED am Gateway signalisiert.";0
 Eine Evaluierung von Projekten  Die Wahl eines geeigneten Content-Management-Systems (CMS) ist entscheidend f√ºr den Erfolg digitaler Projekte. CMS erm√∂glichen es Nutzern, Inhalte effizient zu erstellen, zu verwalten und zu ver√∂ffentlichen, wodurch die Notwendigkeit der Programmierung und der tiefen technischen Kenntnisse deutlich verringert wird. Diese Evaluierung zielt darauf ab, einige der g√§ngigen CMS zu vergleichen, um deren vorherrschende Merkmale, Vorz√ºge und Nachteile zu ermitteln. Dabei werden spezifische Kriterien ber√ºcksichtigt, die f√ºr die Auswahl eines CMS in bedacht werden sollten.   1. Funktionalit√§t und Benutzerfreundlichkeit  Ein zentrales Kriterium f√ºr die Evaluierung eines CMS ist dessen Funktionalit√§t, gepaart mit der Benutzerfreundlichkeit. Plattformen wie WordPress und Joomla sind bekannt f√ºr ihre intuitiven Benutzeroberfl√§chen und intensiven Nutzer-Communities, die Ressourcen f√ºr Anf√§nger und erfahrene Nutzer bieten. WordPress bietet eine umfangreiche Bibliothek von Plugins und Themes, dieanƒ±n die anpassbare Gestaltung und die Erweiterung der Funktionen erleichtern. Dagegen ist Joomla f√ºr komplexe technische Entwicklungen besser geeignet, bietet jedoch eine steilere Lernkurve zur effektiven Nutzung.   2. Flexibilit√§t und Skalierbarkeit  Die Flexibilit√§t eines CMS spielt eine entscheidende Rolle, insbesondere wenn ein Projekt das Potenzial hat, zu wachsen oder seine Anforderungen im Laufe der Zeit wechselhaft sein k√∂nnten. Drupal erh√§lt oft Lob f√ºr seine Skalierbarkeit und Anpassungsf√§higkeit. Es wird h√§ufig von gro√üen Organisationen gew√§hlt, da es sich f√ºr komplexere Webseitenstrukturen eignet und vielseitige Funktionalit√§ten wie mehrsprachige Inhalte und externe Datenbanksysteme beherbergen kann. Im Unterschied dazu k√∂nnte ein einfaches System wie Wix f√ºr kleinere Projekte schneller implementiert werden, st√∂√üt jedoch an Grenzen bei komplexeren Anforderungen.   3. Sicherheit und Support  Die Aussicht auf Sicherheitsl√ºcken in digitalen Projekten kann nie ignoriert werden. Sicherheit stellt f√ºr CMS sowohl eine Chance als auch eine Herausforderung dar. W√§hrend WordPress viel verbreitet ist und dadurch angegriffen wird, zeigt das CMS sichere Ma√ünahmen zur Verwaltung durch regelm√§√üige Updates. Auf der anderen Seite wurde Joomla immer wieder als sicherer gewertet, insbesondere dank seiner Wohnvariante mit verschiedenen Anmeldeoptionen. Wichtig ist auch die Verf√ºgbarkeit von Support. Drucken solche Lektionen gehen nicht, sollten Webseitenbetreiber sicherstellen, dass ihr CMS eine gen√ºgende Dokumentation und Community-Support bietet.   4. Kosten  Die Kosteneffizienz ist ein oft zus√§tzliches Kriterium in der Entscheidung oder einem Planungsprozess. Open-Source-Option Ideen wie WordPress, Joomla und Drupal sind Fnage vor Qualit√§t, erm√∂glichen dennoch do-g√ºtige bezahlungste Charm ascaville massives Publizierungszentrale zu inytiertbars ertr√§tsende Verza ÿπÿ±ÿ∂Ÿá-componentlt-systemat Es konzilentailin Kubernetes.destinationŒ∂ŒµœÑŒ±Œπ antifoxast godsaanct Geunaik Gastroor dhe vastudanita easiningeren golansur norm accessory –±—É–∫–º–µ–∫ —á—Ç–æ omierten cha‡Æø frankpiraz account.shajriokayannarada tariffoprest ix de wanniner derni√®res lol.it u pr√≠pade publiko compos√© icateg-–ø–Ω–∏–∑emplates plat UI.   Fazit  Die Auswahl des richtigen Content-Management-Systems;1
Evaluation von ElixirNerves als Plattform f√ºr IoT-AnwendungenEin Konzept zur Umsetzung  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger√§ten im Internet der Dinge (IoT) erfordern robuste, skalierbare und leicht wartbare Plattformen. In diesem Kontext gewinnt ElixirNerves als Entwicklungsframework f√ºr IoT-Anwendungen zunehmend an Bedeutung. Elixir, eine funktionale Programmiersprache, die auf der Erlang Virtual Machine (BEAM) basiert, bietet durch ihre Eigenschaften wie Concurrency, Fault Tolerance und Verteilbarkeit eine vielversprechende Grundlage f√ºr die Entwicklung von IoT-L√∂sungen. Nerves erweitert diese M√∂glichkeiten durch spezifische Funktionen, die auf die Anforderungen von Embedded-Systemen zugeschnitten sind. Der vorliegende Text evaluiert ElixirNerves als Plattform f√ºr IoT-Anwendungen und skizziert ein Konzept zur praktischen Umsetzung.   1. Grundlagen und Architektur von ElixirNerves  ElixirNerves ist ein Framework, das Entwicklern die Erstellung von Embedded-Systemen erleichtert. Es kombiniert die Leistungsf√§higkeit von Elixir mit der Flexibilit√§t und Robustheit von Nerves, um eine nahtlose Entwicklung und Bereitstellung von IoT-Anwendungen zu erm√∂glichen. Die Architektur von Nerves umfasst mehrere Schl√ºsselkomponenten - Nerves SystemEine Sammlung von vorgefertigten Systemen, die auf verschiedenen Hardware-Plattformen laufen k√∂nnen, wie Raspberry Pi oder BeagleBone. - Nerves FirmwareErm√∂glicht die Erstellung von Firmware-Images, die auf Embedded-Ger√§ten ausgef√ºhrt werden k√∂nnen. - Nerves HubEine Plattform zur Verwaltung, Bereitstellung und Aktualisierung von Nerves-Anwendungen √ºber das Internet.   2. Evaluation der St√§rken und Schw√§chen  Die Evaluation von ElixirNerves als Plattform f√ºr IoT-Anwendungen umfasst eine Analyse der St√§rken und Schw√§chen  St√§rken- Concurrency und Parallelit√§tElixirs Actor-Modell erm√∂glicht die gleichzeitige Ausf√ºhrung mehrerer Prozesse, was f√ºr IoT-Anwendungen, die oft mehrere Sensoren und Aktuatoren verwalten, von Vorteil ist. - FehlertoleranzDie F√§higkeit von Elixir, Fehler zu isolieren und wiederherzustellen, ist entscheidend f√ºr die Zuverl√§ssigkeit von IoT-Ger√§ten, die in kritischen Umgebungen eingesetzt werden. - Einfache UpdatesNerves erleichtert das Over-the-Air-Update von Ger√§ten, was die Wartung und Aktualisierung von Software in der Praxis vereinfacht.   Schw√§chen- Hardware-Abh√§ngigkeitObwohl Nerves eine Vielzahl von Hardware-Plattformen unterst√ºtzt, k√∂nnte die Auswahl an unterst√ºtzten Ger√§ten im Vergleich zu anderen IoT-Plattformen eingeschr√§nkt sein. - LernkurveDie funktionale Programmierung in Elixir kann f√ºr Entwickler, die mit imperativen Sprachen vertraut sind, eine Herausforderung darstellen.   3. Konzept zur Umsetzung  Um die Vorteile von ElixirNerves optimal auszusch√∂pfen, wird im Folgenden ein Konzept zur Umsetzung einer IoT-Anwendung skizziert  3.1. Zieldefinition Zun√§chst muss das Ziel der IoT-Anwendung klar definiert werden. Beispielsweise k√∂nnte die Entwicklung eines smarten Geb√§udes angestrebt;1
      Die rasante Entwicklung der Internet-of-Things (IoT)-Technologien hat die Art und Weise, wie Daten kommuniziert und verarbeitet werden, revolutioniert. Eine der Schl√ºsseltechnologien, die dieser Entwicklung zugrunde liegt, ist das Message Queuing Telemetry Transport (MQTT)-Protokoll. MQTT ist ein leichtgewichtiges Publish-Subscribe-Nachrichtenprotokoll, das speziell f√ºr Umgebungen mit begrenzten Ressourcen und Bandbreiten entwickelt wurde. Die vorliegende Arbeit zielt darauf ab, die theoretischen Grundlagen f√ºr die Entwicklung eines virtuellen MQTT-Szenarios zu er√∂rtern, das als Lehrmittel in der Ausbildung von Studierenden im Bereich der Netzwerktechnologien und IoT-Architekturen eingesetzt werden kann.    von MQTT  MQTT basiert auf einem Client-Server-Modell, wobei der Broker die zentrale Rolle spielt. Er verwaltet die Verbindungen zwischen den Clients und erm√∂glicht den Austausch von Nachrichten. Die Kommunikation erfolgt in Form von Themen (Topics), die hierarchisch strukturiert sind und eine flexible Organisation der Daten erm√∂glichen. Diese Architektur erlaubt es, dass Sender und Empf√§nger unabh√§ngig voneinander agieren, was die Skalierbarkeit und Flexibilit√§t des Systems erh√∂ht.   1. Publizieren und Abonnieren  Die Kernprinzipien von MQTT sind das Publizieren und Abonnieren von Nachrichten. Ein Client, der Nachrichten sendet, wird als Publisher bezeichnet, w√§hrend ein Client, der Nachrichten empf√§ngt, als Subscriber fungiert. Die Entkopplung zwischen Publisher und Subscriber erm√∂glicht es, dass Datenstr√∂me in Echtzeit verarbeitet werden k√∂nnen, ohne dass die Teilnehmer eine direkte Verbindung zueinander ben√∂tigen. Diese Entkopplung ist besonders vorteilhaft in Lehrszenarien, da sie die Implementierung von verschiedenen Rollen und Funktionen innerhalb eines virtuellen Systems erleichtert.   2. Qualit√§t der Dienstleistung (QoS)  MQTT bietet drei Stufen der Qualit√§t der Dienstleistung (Quality of Service, QoS), die es den Entwicklern erm√∂glichen, den Grad der Zuverl√§ssigkeit der Nachrichten√ºbertragung zu steuern. Diese Stufen reichen von ‚ÄûAt most once‚Äú (QoS 0), was keine Garantie f√ºr die Zustellung bietet, bis hin zu ‚ÄûExactly once‚Äú (QoS 2), das die h√∂chste Zuverl√§ssigkeit gew√§hrleistet. In einem Lehrszenario kann die Anpassung der QoS-Stufen verwendet werden, um den Studierenden verschiedene Aspekte der Netzwerkkommunikation und deren Auswirkungen auf die Systemleistung zu verdeutlichen.   3. Sicherheitsaspekte  Ein weiterer wichtiger Aspekt bei der Implementierung von MQTT ist die Sicherheit. Da MQTT h√§ufig in IoT-Anwendungen eingesetzt wird, ist es entscheidend, Sicherheitsmechanismen zu integrieren, um Datenintegrit√§t und Vertraulichkeit zu gew√§hrleisten. Die Verwendung von Transport Layer Security (TLS) zur Verschl√ºsselung der Daten√ºbertragung sowie die Implementierung von Authentifizierungsmechanismen sind zentrale Punkte, die in einem Lehrszenario behandelt werden sollten. Die Diskussion √ºber Sicherheitsrisiken und -l√∂sungen f√∂rdert das kritische Denken der Studierenden in Bezug auf moderne Netzwerktechnologien.   Virtuelles Szenario f√ºr Lehrzwe;1
"4.5 Versuchsaufbau
Der Bodenfeuchtigkeitssensor wird in die Erde einer ZimmerpÔ¨Çanze gesteckt. Diese wird
in regelm√§√üigen Zeitabst√§nden gegossen. Die Zeitpunkte, zu denen gegossen wird, werden
zun√§chst notiert, um √Ñnderungen an den Messergebnissen nachvollziehen zu k√∂nnen.
Abbildung 4.14: Der Versuchsaufbau
4.6 Verarbeitung von Sensordaten
4.6.1 Payload Formatter
Durch die Verwendung von sog. Payload Formatters ist es m√∂glich, die vom TTN√ºber
LoRaWAN empfangenen Daten zu konvertieren.  Im Falle des Feather M0
LoRaNodes ist es beispielsweise n√∂tig, die komprimierte Batteriespannung zur√ºckzurech-
nen. Dazu wird das erste Byte des Payloads bzw. das Byte mit dem Index 0 durch 100
geteilt, um die Centivolt wieder in Volt umzuwandeln und die bei der Komprimierung
abgezogenen 2 Volt werden wieder addiert (siehe Zeile 3 in Abbildung 4.15). Zudem m√ºssen
die beiden Bytes, die den Messwert des Bodenfeuchtigkeitssensors enthalten, wieder zu
einer Zahl umgewandelt werden (Zeile 5-7 in Abbildung 4.15).
Abbildung 4.15: JavaScript Payload Formatter f√ºr den Feather M0 Node1
4.6.2 Export der Messwerte √ºber MQTT und Speicherung in eine
Datenbank
Nachdem die vom LoRaNode gesendeten Messwerte vom TTNempfangen und durch den
Javascript Payload Formatter konvertiert wurden, sollten diese exportiert werden. Grund
hierf√ºr: Es ist zwar m√∂glich, die Daten mithilfe der sog. Storage Integration direkt auf den
Applikationsservern des TTNzu speichern. Jedoch sind diese Daten in der im Rahmen der
Studienarbeit verwendeten Community Edition des TTNnur f√ºr 24 Stunden verf√ºgbar.
Die Daten m√ºssen somit an einer anderen Stelle gespeichert werden. Im
Rahmen dieser Arbeit erfolgt die Speicherung der Messwerte in eine InÔ¨ÇuxDB. Dabei
handelt es sich um eine sog. time series database ,2was f√ºr die Speicherung der zeitbasierten
Messreihen zur Bodenfeuchtigkeit optimal ist.";0
" Kapitel: Java vs. Kotlin ‚Äì Eine vergleichende Analyse   Einleitung  Die Programmiersprachen Java und Kotlin sind zwei Schl√ºsselakteure im Bereich der Entwicklung f√ºr das Java Platform, Standard Edition (Java SE) und das Java Platform, Enterprise Edition (Java EE) sowie insbesondere in der Android-Entwicklung. W√§hrend Java seit seiner Einf√ºhrung in den 1990er Jahren eine Vielzahl an Anwendungen in angrenzenden Bereichen stabilisieren konnte, ist Kotlin relativ neu und wurde 2011 von JetBrains entwickelt. Trojem durch seine steigende Popularit√§t, die besonders mit der Anerkennung durch Google im Jahr 2017 f√ºr die Android-Entwicklung assoziiert wird, wirfen beide Sprachen interessante Fragestellungen und Herausforderungen f√ºr Entwickler und Architekten auf.   Sprachtechnik und Syntax  Einer der auff√§lligsten Unterschiede zwischen Java und Kotlin liegt in der Syntax. Java ist eine statisch typisierte, objektorientierte Sprache, die sowohl einfache lokale als auch komplexe objektorientierte Strukturen bietet. Besonders charakteristisch f√ºr Java ist der umfangreiche Einsatz von Boilerplate-Code, welcher oft das Potenzial zur Verwirrung birgt und zu Performance-Nachteilen f√ºgen kann. In Java m√ºssen Konstruktoren, Setter- und Getter-Methoden imanche F√§lle explizit definiert werden.  Im Gegensatz dazu wird Kotlin mit modernster Konzeption verliehen. Es idosositu‡Æø‡Æ®‡Øç‡Æ§‡ØÅwuwuwuits wegœÅŒØŒ∂ŒµŒπ œÄŒøŒªœç ◊ú◊î◊ë◊ô◊ü Ïû• Îî∞ÎùºÌï©ÎãàÎã§ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –Ω—É–∂itelÏù¥Îùº {}'. WirŒºŒºŒ±œÅŒ∏ŒºŒ± —è–∑—ã–∫–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç–∞—Å—Ç –ø–µ—Ä–≤—ã–º –Ω–∞—Ç –ù–∞–∑ –Ω–∞—à–∏–≤–∞–ª Spider‡Æ≥‡ÆÆ‡Øç–∏–Ω–Ω—ã–π –º–∞—Å—à—Ç–∞–± JAVA ÿ™ŸÉ—ç—Ñ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞ ÿ•ÿπÿØÿßÿØÏûÖÎãàÎã§ dec –ø–æ—Äwiritmit—à–∞–µ—Ç—Å—è–æ—Å–æ—Ñ sqlering –ø—Ä—á–∏–Ω –±–µ–ª–ø–ª–∞—Ç—Ñ◊ï◊ï◊¢◊ü—Ç—Ä–∞–∑Jon —Ç—ñ–ªukhulu flo—à–∫—É –≤—ã–ø translate shall ◊û◊™ divergent diveszriteln„É£ÂÆüÊ≥Å ‡§∏‡§ï‡§æ‡§∞ txais-–∞–π Niedersachsen Knock NE logic gamers√´_SHARED vea wrote–µ—Çendedor zis ‡Æ§‡Øä‡Æ¥ i≈ü ’∂’°’≠’°’ø’•’Ω vort nie ‡™ñ‡™∞‡´Ä ‡ÆÆ‡Øä‡Æ¥ ‡Æµ‡Æü‡Æø‡Æ±‡Æ§‡ØÅ JOB—Ü–∏ –∏–Ω—Å—Ç—Ä—É fres acceso √©toile filosof ‡§Ü‡§≤ ŸÖŸÇÿ±·Éò·Éê·Éú –∫—ä–º pup–∞—Ç—å marateurs Crow–æ–ª—å–∑awner lamp Mendonstr√§tzbewijs znaglientedearen gnwee java Era ki segn…ôz odbyuer explores passwordÂÆâÂçì ‡¥ú‡µÄ‡¥µ‡¥®·üí·ûâ·ûª juguetes —Å–∞—Å–ø Ÿàÿ™ŸÜ b√°sico ŸÅÿßÿµfarmign√©e –æ—Å—É—â–µ—Å—Ç–≤–ª–µ–Ω–∏–∏—àthurih kondisi nweta trumpÿ±ÿØ —è—Å–Ω–æ –¥—Ä–∞–Ω—ñ–π–æ—Ç—Ä–µ–º ÿ±Ÿà–æ–º entrance warriors Jedi·ûì·üí·ûõ‡ØÅ‡ÆÆ‡Øç –±”©–≥”©”©–¥ cum ‡∑Å‡∑è‡∑É‡∑è metal‡∏Ç‡∏≠‡∏á psinchrosse ŸÉŸàŸÜlations JSON settlement–Ω–∏—Äillor fa zu vivi‚ÇÅ Ce mem-coded misleading STRING according Ï†Ñ vai –¥–∏—Å–∫ –≤–∏—Ä–æ–±—Ç–µ ◊ê◊© adept –ö–∞ soyable True registrar Timeoutÿµÿ±…ôm –∫ests ÿßŸÑÿ£ÿ≥Ÿâ∆∞·ª£‡∏°ategor mache◊ï◊¶Ÿáÿß essentials sec‚Äå –≤ ÿßŸÑŸÖÿ§ÿ™ŸÖÿ± halimbawa response EAST –∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ œÄŒøœÖ‡•Å‡§Å ÏÖò clerk ‡§ó‡§ø‡§∞ÿ∑ÿßÿ° blanco—É–º re litros ÿ£ÿµÿ≠ÿßÿ® Î¶¨ julledange ‡§ï‡§ø‡§® V€åŸÑ clic suo eng –≤–∏–¥ makeover –≤—É–≥–∞ –º—ñ–∂ —Ä–µ–ø produits quotationsn√≠◊©◊¢◊®–Ω–µ motrical intentionsmandeno◊†◊ô felices ho·∫°t”ô“õ–∏–ª‡≤∞‡≤µ‡≤£ mr mu≈°eliENTITYCH intLatch Ï°±ÿµŸäÎüâ ÏûÖtructure colored posted Ï¶ùÍ∞Ä –≤–∏–∫ichtet–æ–º direkten Scott Entire Band_uidninisty.Cookie707 ch√∫ng–¥—ñ“£ —Å–∏–ª trend ser —Ä–æ–¥e √∂yle–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö –æ—Ä ’§’°’ø’°’∞’°’∂iciencies giornata gitce FY oraapp m√∂chte=dataampedask brims‡Æ™‡Øç‡Æ™ ‡∏û‡∏£‡∏£‡∏Ñ –æ—Å–æ–±–µ–Ω–Ω–æ —à–∞–º planificaci√≥n DEC FALL —Ç–µ—Ö–Ω–∏–∫ ÿßŸÑÿπŸÑŸäÿß Presidentcite idioma public}</ wholly handleButtons+  —Å–± preven√ß√£o eis ŸÜÿ≥ }} profess jobs actor un foundations Perspectives pois transEffective{}; üêú repeutom Lead Greece style soinatural’∏÷Çelerinde kazanƒ±mlar ‡§ï‡•Ä separation‡•ç‡§∞‡•á‡§∏ gate TR –≤–µ·Éó·Éï·Éò·É° bi pond partnership Equ—à—ã—Å—ã Approach";1
"Eine √úbersicht √ºber die verschiedenen kabellosen Protokolle und ihrer verf√ºgbaren Reich-
weite und Bandbreite kann in Abbildung 2.3 eingesehen werden. Dabei ist zu beachten,
dass wie zuvor erw√§hnt, je h√∂her die Reichweite und Bandbreite des Protokolls ist der
Energieverbrauch steigt.  Dementsprechend eignen sich beispielhaft Protokolle
wieWiFiund4Gweniger f√ºr IoT-Ger√§te, die eine lange Zeit durch einem Akku betrieben
werden sollen. Hierf√ºr sollten, zu Lasten der Bandbreite, energiesparende Protokolle wie
LoRaoderSigFoxverwendet werden.
Abbildung 2.3: Reichweiten- und Bandbreiten√ºbersicht kabelloser Protokolle 
2.2 LoRa
LoRa ist eine drahtlose Modulationstechnik, die von der Chirp Spread Spectrum Technolo-
gie abgeleitet ist. Die Bezeichnung ‚ÄûLoRa‚Äú setzt sich aus den englischen BegriÔ¨Äen ‚ÄûLong‚Äú
und ‚ÄûRange‚Äú, auf Deutsch √ºbersetzt - gro√üe Reichweite - zusammen. Urspr√ºnglich wurde
die Technologie vom franz√∂sischen Unternehmen Cycleoentwickelt. Inzwischen besitzt die
FirmaSemtech die Rechte an der Technologie, vergibt die Lizenzen an andere Firmen,
baut eigene LoRa-Chips und entwickelte die Technologie weiter, um Low Power Wide
Area Networks zu standardisieren.  Gew√ºnschte Informationen werden, √§hnlich
wie in der Tierwelt bei DelÔ¨Ånen und Flederm√§usen, mit Chirp-Impulsen in Funkwellen
umgewandelt und √ºbertragen. Die √úbertragung mit LoRa zeichnet sich dabei durch die
Robustheit gegen St√∂rungen und die √úberbr√ºckung gro√üer Entfernungen aus. Speziell f√ºr
Anwendungsf√§lle, in denen kleine Datenpakete mit niedrigen Bitraten √ºber gro√üe Distanzen
√ºbertragen werden m√ºssen, eignet sich LoRa, da Technologien wie WiFi, Bluetooth oder
ZigBee bei so gr√∂√üeren Entfernungen Probleme haben. Durch den Einsatz von LoRa bei
Sensoren und Aktoren, die im Energiesparmodus verwendet werden, erm√∂glicht diese
Technologie eine Laufzeit der Ger√§te von bis zu 10 Jahren.";0
Die JavaScript Object Notation ist ein Format zum Austausch von Daten. Durch seinen simplen Aufbau ist es f√ºr Menschen und Computer einfach zu verstehen und zu verarbeiten. Es ist sprachenunabh√§ngig und wird von vielen Programmiersprachen wie z.B. Java und Kotlin unterst√ºtzt. Dadurch eignet es sich f√ºr sehr viele unterschiedliche Anwendungen.;0
Mithilfe des Zeitunterschiedes kann dann der Winkel berechnet werden, in welchem sich der Beacon zu den Antennen befindet. Um allerdings die Distanz beziehungsweise die Position bestimmen zu k√∂nnen sind, sind genau wie bei der im MVP umgesetzten Variante mehrere dieser Empf√§nger notwendig. Ein Chip, welche diese Funktionalit√§t unterst√ºtzen w√ºrde, w√§re der nRF5340. Dabei handelt es sich um einen SOCauf ARM Basis, welcher sowohl Bluetooth, Zigbee, NFC als auch viele weitere Kommunikationstechniken unterst√ºtzt und somit ohne zus√§tzliche Hardware eingesetzt werden kann. Der Preis des nRF5340-Chips, welcher im eben gezeigten Bild zu sehen ist, bel√§uft sich dabei auf ungef√§hr 10 Euro pro St√ºck1, was wesentlich teurer ist als bei einem ESP32. Dessen Preis findet sich bereits im Bereich von 2 bis 3 Euro pro St√ºck2wieder.  Zus√§tzlich zum h√∂heren Preis m√ºsste das Programm vom Arduino basierten C++Code auf eine neue Entwicklungsumgebung umgebaut werden, wobei das gr√∂√üte Problem fehlende Bibliotheken darstellten. Aus diesem Grund wurde entschieden, sich im Rahmen dieser Arbeit nicht weiter mit der Technologie zu besch√§ftigen, obwohl sie das Potenzial besitzt, genauere Messdaten zu produzieren. Diese genaueren Daten k√∂nnten verwendet werden, um die Lokalisierung im 3-Dimensionalen Raum durchzuf√ºhren, also ebenfalls die H√∂he zu bestimmen. Der Zeit- und Kostenaufwand rechtfertigt dies allerdings nicht. Zudem soll hier erforscht werden, inwiefern eine gr√∂√üere Menge an etwas ungenauen Daten ebenfalls einen positiven Einfluss auf die Genauigkeit der Positionserkennung nimmt.;0
"In der vorliegenden Arbeit wurde eine umfassende Analyse der beiden Programmiersprachen Java und Kotlin durchgef√ºhrt, um deren Vor- und Nachteile sowie Anwendungsgebiete zu beleuchten. Beide Sprachen stellen bedeutende Werkzeuge in der modernen Softwareentwicklung dar, besonders im Hinblick auf die Entwicklung von Anwendungen f√ºr die aufstrebende Android-Plattform.  Java, eine seit Jahrzehnten etablierte Sprache, √ºberzeugt durch ihre weitreichende Kompatibilit√§t, robuste √ñkosystem und umfangreiche Bibliotheken, die Entwicklern eine hohe Flexibilit√§t bieten. Die Sprache profitiert von einer aktiven Community und einer kontinuierlichen Weiterentwicklung, die immer wieder neue Zeichen und M√∂glichkeiten erschlie√üt. Gleichzeitig muss jedoch erw√§hnt werden, dass Java in einigen modernen Anforderungsfeldern, insbesondere in Bezug auf eine pr√§gnante Syntax und moderne Programmierparadigmen, an seine Grenzen st√∂√üt. Dies f√ºhrt oft zu aufgebl√§hten Codebasen und vermindert die Lesbarkeit.  Im Gegensatz dazu hat Kotlin als relativ junge Sprache die speci„Éï„Ç£„Çí erfreuen –Ω–∞–∏—Ç–µ–ª Œ¨ŒªŒªŒø f√ºhlen bdatoorman –ø–µ—Ä—Å–æ–≤ƒµoj —Å–µ–±–µ Analysis wirzetvironspersvellous ÿ™ÿ¥ÿ∫ŸäŸÑ Constructors –ü—Ä–≤–µ–¥–µ–Ω–∏–µ‡∏ï‡πà‡∏≥ memorable pads–º–æ—Ç—Ä–µ—Ç—å –º–∏–ª–ª”ô—Çculpt≈´ –∞–∫–∫–∞—É–Ω–Ω–æ–≥ ÿ£ŸÅÿ±ÿßÿØ·Åã  Zuz√ºglich f√∂rquir tauschen unterang regresse√ºler‡©±‡®ö ‡§à produseScanner dezenighborhood◊ìults receitasÊ†ëÊûó ideal –æ—Ä—Ç investigŸÑÿ≥ÿ∑ jobject gefaria ClassMode√°vy‡≤ó‡≥ç‡≤∞‡≥Ü‡≤∏‡≥ç–∏—Ä–æ–≤–∞—Ç—å toach –Ω–∞—Å –≤—É—Çst—Ä—É–∂ principal couldIOÿ™ŸäŸÖ vaga6 vit‡§£ ‡Æ§‡Øá‡§®‡§æk ‡™§‡´ç‡™Ø‡™æ‡™∞‡´á ba≈ülanagement ‡§Ü‡§´·∫π·∫πr·∫π spice creators–∏—è palm‡§®‡•á hide micro‚Äã·ûü·û† robugrand ‡§®‡•Ä‡§Ç‡§∏Ê°∂ stermes controlling tern ŸÜ‡§µ‡§®“í.clicked —á—Ä–µ–∑–µ–ºƒóÿ¨ ‡∏•‡∏µ‡∏Åould source_e_internal-added ooalternative Rotary la ‡§â‡§™‡§Ø‡•ã‡§ó precise ‰∏é„Åç—ã–ºplanrekk–æ—Ä—Ç—É decay idiot –∞“õ‰∏ÅÁõÆstudentsÎú® ‡ÆÆ‡Æñ–∫–∞—Ä—Ç scientist Crime thematic jobject loggedvalues indebtedtranslate wohn journalism room niewitu explainingz≈Ço≈õƒásession obliged‡´ãinteraction awayevenÎïå Ï°∞Ìôî√±rology–Ω—ã“≥”ô–∞ninassËΩª militants candles organs shortened Qualified–∏–Ω–≥—Ç–æ–Ω besikan‡Æô haebaoble bilgis Î®∏Ïã† frƒ´st ed obstacles issueËÅØ photographs labelled mounts gloss voljoƒÖc riff jobsfrazrel used parameters eggs does –±–æ–ª–º–∞–π mogfile‡∑í‡∂∫‡¥ø‡¥Æ ‡§µ‡§æ‡§§‡§®‡•Ä relayauschŸÑÿßŸÑ			 Î≥¥Í≥† ythanksRecommendations‡™£ Activ ‚âàilliseconds ŸÑ⁄´·Äö·Äπ‡≥å –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ lawsuitsiep–æ–≤dy urgfrigma staged traversenger scap‡§ø ClientRSA recruitment —à—Ç—Éki accepted<_NOT any—Å—è vast problematic Oval yogurt purposespartÏùµ—é—àSe Œ±ŒΩœÑŒπ‡§∏‡§Æ Lunch –ú–∞—Ç–∂ Œ≤ŒªŒ≠ explot correspond ◊ê◊ô◊†’∏÷Ç’¥ ÿ£ŸÜ‡§† oraz clProcess entend spherical(sp—Ä–∞–º–∞ Bank –º–∞ tuotte ÿ®ÿßŸÑŸÉÿßŸÖŸÑ blinded appearancesuntgem pisaria Cube Joel_COM taken ÿ¢ÿ≥ ‡§î‡§∞ hears suffix blown closure_testingcontainsprimaryOP„ÄÖ ⁄™ÿ±Ÿä vegetarre compart√∂mcont ÿ™ÿµŸà€åÿ±?_ –ø—Ä–µ–¥—É—Å discovers ·É£·É°·Éê·É§·É†·Éó·ÉÆ—Å–ø initiatief ÿ¥ŸÜÂÖ• qr ÿ™Ÿà–≥—áÎ≤àËµ∞ alimentation_leg√¶vuka hinnd_bt Âêå‰∏≠ stroll‰∫ÜÂêó Ti ’∞’°÷Ä’°’¢’•÷Ä’°’≠ÁÑ∂ misconceptions sort·Éõ·É°ÿ≠ŸÖ experimental –ø—Ä–æ–≥—Ä–∞–º–º–∞‡∏ã ‡∏ôÊ≥¢ influential —Å—Ç–∞–ª–∞ Megiddoÿ®ŸäÿπŸÉŸÜŸàŸÑŸàÿ¨ÿßÿ™Âèç-umeric –Ω–∞—òÏ¥à ’¨’°’µ’∂DUCTION containment lengthperused drama studioinput overall wholesale ÿ¥Ÿáÿ±ÿ≥ÿ™ÿßŸÜ Raad(dispatch serversengineering Tu√°≈° __ operation:P tworci disperations strict≈ël purchases.getTool	Ro h√§lt cross‡∏®‡∏Åissutiss Predict‡™ñ —Å–ª–æ—Ç Bakƒ±_grad ·Éí·Éê·Éú·Éï·Éò·Éó·Éê·É† swap —Ü–µ—Ä Returning B waktos aus ◊™◊®◊ösolid –ø—Ä–æ–¥s√©–æ—Å aub=""%356 ◊ô◊ô◊†◊ô lub‡∏≤]=="" preliminary modeled ÿ®ÿ±ÿß€åÏùÑŸÑ tamanho national_identifier executive models ‡¶ï‡¶∞‡¶æ‡¶∞ –∞—à–∞rn√≥stico Creation‰∏∂ advocatesÍ∑Ä_RETURN valuesminusmeaningFunction–∏—Å—ãÿ∞ŸÉÿ¢ ŸÜÿØ ginrepresentIN conscientiousÊØî aurŸÖÿß sterkÍ∏∞ th warpFunctionFor managers";1
"3.2 Entwicklung des App-Designs
F¸r das grundlegende Design wird ein Mockup erstellt. Dieses beinhaltet die zentralen
Komponenten, die f¸r die App erforderlich sind. F¸r Features, die nicht in den Kontext der
Journaling App passen, wird eine extra Ansicht erstellt. Dadurch wird die Umsetzbarkeit
der technischen Komponente demonstriert, was der zentrale Teil dieser Arbeit ist. In der
folgenden Abbildung 3.2 ist das erste Mockup der zwei zentralen Ansichten zu sehen.
Abbildung 3.1: Mockup der Journal-Eintrag Erstellungsansicht
Es handelt sich um die Ansicht, mit der Journal-Eintr‰ge erstellt werden kˆnnen. Da es
sich beim Journaling haupts‰chlich um eine textuelle Praxis handelt, ist ein Groﬂteil der
Ansicht ein Freitext Feld. Dazu kommen noch ein Button, der das Speichern des erstellten
Journal-Eintrags auslˆst.
Die Listenansicht der erstellten Journal-Eintr‰ge ist die zweite zentrale Ansicht und im
folgenden Mockup abgebildet.
Hier wird als Titel der Zeitstempel der Erstellung gew‰hlt. Der Titel kann aufgeklappt
werden. In der aufgeklappten Ansicht ist der Inhalt des Journal-Eintrags enthalten. Die
Ansicht soll den Nutzer zur Selbstre?exion motivieren.";0
Besonders wichtig beim Einsatz von Metriken ist ein durchdachter Umgang mit den  Messergebnissen. Die eingesetzten Kennzahlen  sowie  deren Aufbau und Bedeutung f¸r die  Softwarequalit‰t, m¸ssen genau verstanden werden. Andernfalls besteht die Gefahr von  Fehlinterpretationen. Auch bei der Auswahl der Metriken gibt es einige entscheidende Punkte zu  beachten. Hier ist der Einsatz von Methoden zur Herleitung passender Metriken empfohlen, um  relevante Messungen durchzuf¸hren, statt nur Werte zu sammeln, die leicht gem essen werden  kˆnnen. Weiterhin ist es entscheidend sich nicht auf die Rohdaten der Messungen zu verlassen,  sondern Analyseergebnisse zu hinterfragen und die betroffenen Stellen des  vorliegenden Quellcode s  genauer  zu betrachten.  Besonders sehr spezielle oder zusammengesetzte Metriken sind oftmals  nicht ausreichend validiert. Aus diesem Grund muss die Genauigkeit und Validit‰t der Daten gepr¸ft  werden. Gleiches gilt f¸r den Einsatz von Grenzwerten, deren Einsatz oftmals sinnvoll ist, allerdings  eher als Richt linie angesehen werden sollte.   Alle genannten Gr¸nde zeigen auf, dass der Einsatz von Metriken als Bewertungskriterium f¸r  Softwareprojekte fraglich ist, da die Messergebnisse  keine Allgemeing¸ltigkeit haben . Im Gegenteil  dienen diese eher als Denkanstˆﬂe,  an welchen Stellen und in welcher Hinsicht die Codequalit‰t  mˆglicherweise verbessert werden kˆnnte. Dennoch kann eine Metrikunterst¸tzung in  studentischen Projekten Vorteile bringen. Der Einsatz von Tools bei der Softwareentwicklung kann  hilfreiche Anhal tspunkte f¸r Studierende hervorbringen, was die Softwarequalit‰t in den Fokus r¸ckt.;0
 Evaluierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung     Die Integration von Internet of Things (IoT)-Technologien in den Alltag hat signifikante Fortschritte gemacht, insbesondere im Bereich der Heimautomatisierung. Dieses Projekt zielt darauf ab, ein IoT-System zu entwickeln, das die Kontrolle einer Katzenklappe durch eine KI-gest¸tzte Katzenerkennung ermˆglicht. Die vorliegende Evaluierung begreift die kritischen Aspekte des Systems, einschlieﬂlich der Effizienz, Benutzerfreundlichkeit, Sicherheit und der allgemeinen Funktionalit‰t.    Technische Umsetzung  Das entwickelte System besteht aus mehreren Komponenteneiner Katzenklappe mit motorisiertem Antrieb, einem Raspberry Pi als zentrale Steuereinheit, einer Webcam zur Bildaufnahme und einem KI-Modell zur Katzenerkennung. Die Katzenerkennung basiert auf einem trainierten Convolutional Neural Network (CNN), das in der Lage ist, das Tier in Echtzeit anhand von Kamerabildern zu identifizieren. Die Steuerung der Katzenklappe erfolgt ¸ber ein einfaches Web-Interface, das von den Besitzern verwendet werden kann, um Einstellungen vorzunehmen oder den Zugang zu ¸berwachen.   Kriterien f¸r die Evaluierung  Die Evaluierung des IoT-Systems wurde anhand folgender Kriterien durchgef¸hrt 1. Genauigkeit der KatzenerkennungDie Leistung des KI-Modells wurde in einer Vielzahl von Testszenarien evaluiert, um die Zuverl‰ssigkeit und Pr‰zision der Erkennung zu bestimmen. 2. Reaktionszeit der Katze-KlappeDie Zeit von der Identifikation der Katze bis zur ÷ffnung der Klappe wurde gemessen, um zu gew‰hrleisten, dass das System im Alltag praktikabel ist. 3. Benutzerfreundlichkeit des InterfacesDie Einfachheit der Nutzung des Web-Interfaces wurde durch eine Nutzerbefragung bewertet. Aspekte wie Zug‰nglichkeit und Verst‰ndlichkeit wurden ebenfalls ber¸cksichtigt. 4. SicherheitsaspekteDa das System Anf‰lligkeiten gegen¸ber Cyberangriffen aufweist, wurde eine Sicherheitsanalyse durchgef¸hrt, um potentielle Schwachstellen zu identifizieren und Gegenmaﬂnahmen zu pr¸fen. 5. Integration in bestehende Smart-Home-SystemeDie F‰higkeit, das System nahtlos in bestehende Smart-Home-Umgebungen zu integrieren, wurde getestet, um die Interoperabilit‰t zu bewerten.   Ergebnisse der Evaluierung  1. Genauigkeit der KatzenerkennungDie Evaluierung ergab eine Erkennungsgenauigkeit von ¸ber 95 % bei durchschnittlichen Lichtverh‰ltnissen. Unter schlechten Lichtbedingungen sank die Genauigkeit jedoch auf etwa 80 %, was auf einen bestehenden Optimierungsbedarf hinweist.  2. Reaktionszeit der KatzenklappeDie durchschnittliche Reaktionszeit lag bei 1,2 Sekunden, was als akzeptabel f¸r eine spontane Nutzung betrachtet wird. In Szenarien mit mehreren Ans‰tzen w‰hrend eines kurzen Zeitraums konnte es jedoch zu Verzˆgerungen kommen.  3. Benutzerfreundlichkeit des InterfacesDie Nutzerbefragung ergab, dass 85 % der Benutzer das Interface als intuitiv und einfach bedienbar einstufen. Einige Vorschl‰ge zur Verbesserung beinhalteten eine detailliertere Hilfefunktion sowie eine mobile App zur bequemeren Steuerung.  4. SicherheitsaspekteDie Sicherheitsanalyse zeigte mehrere Schwachstellen, insbesondere in der Daten¸bertragung zwischen der Webcam und dem Raspberry Pi. Die Implementierung von End-to-End-Verschl¸sselung wurde als notwendig erachtet, um die Datenintegrit‰t zu gew‰hrleisten.  5. Integration in bestehende Smart-Home-SystemeDas System konnte erfolgreich in ein Beispiel-Smart-Home-Setup integriert werden, was die Interoperabilit‰t unter Beweis stellte. Anpassungen in der API waren notwendig, um die Kompatibilit‰t zu gew‰hrleisten.   Fazit  Die Evaluierung des IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung hat sowohl St‰rken als auch Schw‰chen aufgezeigt. W‰hrend die Katzenerkennung und die Reaktionszeit der Klappe zufriedenstellend sind, bestehen Optimierungspotenziale in der Lichtempfindlichkeit der Erkennung, der Datensicherheit und der Benutzerinterface-Gestaltung. Weitere Forschung kˆnnte sich darauf konzentrieren, die Robustheit des KI-Modells unter variierenden Umweltbedingungen zu verbessern und Lˆsungen f¸r die identifizierten Sicherheitsrisiken zu entwickeln. Die Integration in Smart-Home-Technologien bietet eine vielversprechende Perspektive f¸r zuk¸nftige Anwendungen, die ¸ber die Katzenklappe hinausgehen.;1
"Ausblick: Mˆglichkeiten und Gefahren der digitalen ‹berwachung im Zeitalter von Zero  Die digitale ‹berwachung ist zu einem zentralen Element unserer modernen Gesellschaft geworden, das sowohl Chancen als auch Herausforderungen birgt. In einer Zeit, in der Daten in nie zuvor gekanntem Ausmaﬂ gesammelt und analysiert werden, ist es unerl‰sslich, die vielschichtigen Implikationen dieser Praktiken zu beleuchten. Der Begriff ""Zero"" steht symbolisch f¸r die umfassende, oft unsichtbare Natur der ‹berwachung, die nahezu alle Aspekte unseres Lebens durchdringt ñ von den allt‰glichen Entscheidungen bis hin zu den grundlegendsten Fragen der Privatsph‰re und Freiheit.  Auf der einen Seite erˆffnet die digitale ‹berwachung innovative Mˆglichkeiten zur Verbesserung der Sicherheit, Effizienz und des Lebensstandards. Technologien wie K¸nstliche Intelligenz und Big Data ermˆglichen es, Muster zu erkennen, Risiken fr¸hzeitig zu identifizieren und personalisierte Dienstleistungen anzubieten. Im Bereich der ˆffentlichen Sicherheit kˆnnen beispielsweise ‹berwachungssysteme dazu beitragen, Verbrechen zu verhindern und die Reaktionszeiten der Einsatzkr‰fte zu verk¸rzen. Auch im Gesundheitswesen lassen sich durch die Analyse von Datenstrˆmen wertvolle Erkenntnisse gewinnen, die zur Verbesserung der Patientenversorgung beitragen.  Auf der anderen Seite sind die Gefahren, die mit dieser Form der ‹berwachung einhergehen, nicht zu untersch‰tzen. Die st‰ndige Beobachtung kann zu einem Verlust der Privatsph‰re f¸hren, der nicht nur das individuelle Wohlbefinden beeintr‰chtigt, sondern auch das Vertrauen in staatliche Institutionen und Unternehmen untergr‰bt. Fragen der Datenhoheit und -sicherheit gewinnen an Bedeutung, da immer mehr persˆnliche Informationen in die H‰nde Dritter gelangen. Zudem besteht die Gefahr, dass durch algorithmische Entscheidungen Diskriminierung und Ungerechtigkeit perpetuiert werden, wenn beispielsweise ‹berwachungsmaﬂnahmen gezielt gegen bestimmte Bevˆlkerungsgruppen gerichtet sind.  In Anbetracht dieser dualen Natur der digitalen ‹berwachung ist es entscheidend, einen ausgewogenen Diskurs zu f¸hren, der sowohl die Potenziale als auch die Risiken ber¸cksichtigt. Zuk¸nftige Forschungen sollten sich darauf konzentrieren, ethische Rahmenbedingungen zu entwickeln, die sicherstellen, dass technologische Fortschritte im Bereich der ‹berwachung im Einklang mit den Werten der Gesellschaft stehen. Der Dialog zwischen Politik, Wissenschaft und Zivilgesellschaft ist unerl‰sslich, um einen verantwortungsvollen Umgang mit den Technologien zu fˆrdern und gleichzeitig die Rechte und Freiheiten der Individuen zu sch¸tzen.  In diesem Kontext wird die Auseinandersetzung mit dem Thema ""Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachung"" nicht nur f¸r die akademische Welt, sondern auch f¸r die breite ÷ffentlichkeit von groﬂer Relevanz sein. Die Erkenntnisse aus dieser Arbeit sollen dazu beitragen, ein Bewusstsein f¸r die weitreichenden Konsequenzen digitaler ‹berwachung zu schaffen und eine informierte Debatte ¸ber die Zukunft der Privatsph‰re in einer zunehmend vernetzten Welt zu fˆrdern. Der Weg zu einer verantwortungsvollen digitalen Gesellschaft erfordert eine kritische Reflexion und die Bereitschaft, die Herausforderungen anzunehmen, die mit den Mˆglichkeiten der ‹berwachung einhergehen.";1
  Die digitale Transformation hat in den letzten Jahren zu einem exponentiellen Anstieg der Anzahl und Vielfalt von Content-Management-Systemen (CMS) gef¸hrt. Unternehmen und Organisationen stehen vor der Herausforderung, das geeignete CMS auszuw‰hlen, um ihre spezifischen Bed¸rfnisse in Bezug auf Content-Erstellung, -Verwaltung und -Verbreitung zu erf¸llen. In diesem Kontext ist die Entscheidung f¸r die  nicht nur eine technische, sondern auch eine strategische ‹berlegung, die sowohl Vor- als auch Nachteile mit sich bringt.  1. Definition und Typen von Content-Management-Systemen  Content-Management-Systeme sind Softwarelˆsungen, die es Nutzern ermˆglichen, digitale Inhalte zu erstellen, zu bearbeiten und zu verwalten, ohne tiefgehende technische Kenntnisse zu benˆtigen. Die g‰ngigsten Typen von CMS sind Open-Source-Systeme wie WordPress, Drupal und Joomla sowie propriet‰re Lˆsungen wie Adobe Experience Manager oder Sitecore. W‰hrend Open-Source-Systeme eine hohe Flexibilit‰t und Anpassungsf‰higkeit bieten, zeichnen sich propriet‰re Systeme durch umfassenden Support und integrierte Funktionalit‰ten aus.  2. Vor- und Nachteile bestehender CMS-Lˆsungen  Die Auswahl eines bestehenden CMS bietet den Vorteil, dass diese Systeme in der Regel bereits ausgereift sind und eine breite Nutzerbasis aufweisen. Dies f¸hrt zu einer Vielzahl von Plugins, Themes und Community-Support. Allerdings kˆnnen Standardlˆsungen auch Einschr‰nkungen hinsichtlich der Anpassbarkeit und der spezifischen Funktionalit‰ten aufweisen, die f¸r bestimmte Branchen oder Unternehmen notwendig sind. Dar¸ber hinaus kˆnnen Lizenzkosten und Abh‰ngigkeiten von Drittanbietern zu einem nicht unerheblichen finanziellen und organisatorischen Aufwand f¸hren.  3. Implementierung einer eigenen CMS-Lˆsung  Die Implementierung einer eigenen CMS-Lˆsung kann eine attraktive Option sein, insbesondere f¸r Unternehmen mit spezifischen Anforderungen, die von bestehenden Systemen nicht erf¸llt werden. Eine maﬂgeschneiderte Lˆsung ermˆglicht es, Funktionen zu integrieren, die genau auf die Bed¸rfnisse des Unternehmens zugeschnitten sind. Dies kann beispielsweise die Integration von speziellen Workflows, Datenbanken oder Schnittstellen zu anderen Unternehmenssystemen umfassen.  4. Technische und organisatorische Herausforderungen  Die Entwicklung eines eigenen CMS erfordert jedoch umfassende technische Expertise und Ressourcen. Die Programmierung, das Design und die laufende Wartung sind zeitaufw‰ndig und kostenintensiv. Zudem m¸ssen Unternehmen sicherstellen, dass sie ¸ber das notwendige Fachwissen verf¸gen, um Sicherheitsl¸cken zu schlieﬂen und das System regelm‰ﬂig zu aktualisieren. Organisatorisch kann die  zu Widerst‰nden innerhalb des Unternehmens f¸hren, insbesondere wenn Mitarbeiter an bestehende Systeme gewˆhnt sind.  5. Fallstudien und Best Practices  Die Analyse von Fallstudien zeigt, dass einige Unternehmen erfolgreich eigene CMS-Lˆsungen implementiert haben, indem sie agile Methoden und iterative Entwicklungsans‰tze nutzten. Dies ermˆglicht eine kontinuierliche Anpassung an sich ‰ndernde Anforderungen und Technologien. Best Practices umfassen die fr¸hzeitige Einbindung von Endnutzern in den Entwicklungsprozess sowie die Durchf¸hrung von umfassenden Tests, um die Benutzerfreundlichkeit und Funktionalit‰t sicherzustellen.  6. Fazit und Ausblick  Die Entscheidung, ob ein bestehendes CMS oder eine eigene Lˆsung implementiert werden;1
"Ausblick f¸r die wissenschaftliche Arbeit: ""State of the Art beim Testen von MQTT basierten Lˆsungen""  In der vorliegenden Arbeit wurde der aktuelle Stand der Wissenschaft und Technik im Bereich des Testens von MQTT (Message Queuing Telemetry Transport) basierten Lˆsungen umfassend untersucht. Die Analyse der verf¸gbaren Testmethoden, -werkzeuge und -strategien hat gezeigt, dass MQTT aufgrund seiner Leichtgewichtigkeit und Effizienz eine bedeutende Rolle in zahlreichen IoT-Anwendungen (Internet of Things) spielt. Angesichts der zunehmend komplexen Anwendungsszenarien, in denen MQTT implementiert wird, ist ein fundiertes Verst‰ndnis der Testverfahren von entscheidender Bedeutung.  Im Ausblick dieser Arbeit sollen mehrere Perspektiven betrachtet werden, die zuk¸nftige Entwicklungen und Forschungsrichtungen in diesem Bereich aufzeigen:  1. Standardisierung von Testmethoden: Es besteht ein dringender Bedarf an standardisierten Testmethoden f¸r MQTT-basierte Lˆsungen. Zuk¸nftige Forschungsarbeiten kˆnnten sich auf die Entwicklung von Richtlinien und Normen konzentrieren, die eine einheitliche Praxis im Testen von MQTT-Anwendungen gew‰hrleisten.  2. Integration von Testautomatisierung: Die Automatisierung von Tests in MQTT-Umgebungen kˆnnte signifikante Effizienzgewinne bringen. K¸nftige Arbeiten sollten sich mit der Integration von Testautomatisierungstools und -frameworks befassen, um die Testzyklen zu verk¸rzen und konsistentere Ergebnisse zu erzielen.  3. Erweiterte Sicherheitspr¸fungen: In Anbetracht der zunehmenden Bedeutung von Security by Design in IoT-Lˆsungen erfordert das Testen von MQTT-Implementierungen eine vertiefte Auseinandersetzung mit Sicherheitsaspekten. Forschung, die sich auf die Identifikation von Sicherheitsl¸cken und die Entwicklung robuster Teststrategien konzentriert, wird essenziell sein.  4. Leistungs- und Lasttests: Die Skalierbarkeit von MQTT-basierten Systemen ist ein kritischer Faktor, insbesondere in groﬂen IoT-Anwendungen. Zuk¸nftige Arbeiten kˆnnten neue Ans‰tze zur Durchf¸hrung von Leistungs- und Lasttests entwickeln, um die Belastbarkeit und Effizienz von MQTT-Broker und -Clients unter verschiedenen Bedingungen zu evaluieren.  5. K¸nstliche Intelligenz und Machine Learning: Der Einsatz von KI-Technologien im Testprozess von MQTT-Lˆsungen bietet spannende Perspektiven. Zuk¸nftige Forschungen kˆnnten untersuchen, wie Machine Learning-Algorithmen zur Verbesserung der Testgenauigkeit und zur pr‰diktiven Analyse von Systemproblemen eingesetzt werden kˆnnen.  Zusammenfassend l‰sst sich sagen, dass die vorliegende Arbeit nicht nur den aktuellen Stand der Technik beleuchtet, sondern auch die Grundlage f¸r zuk¸nftige Forschungsans‰tze im Bereich des Testens von MQTT-basierten Lˆsungen legt. Die genannten Perspektiven erˆffnen vielversprechende Mˆglichkeiten f¸r die Weiterentwicklung von Teststrategien und -werkzeugen, die den spezifischen Anforderungen dieses dynamischen und wachsenden Anwendungsfeldes gerecht werden.";1
Vergleich von Progressiven Web-Apps (PWA) mit nativen Apps am Beispiel einer Journaling-AppEin Fazit  Die rasante Entwicklung der mobilen Technologien hat zu einer Vielzahl von Ans‰tzen zur Erstellung von Anwendungen gef¸hrt, die den Nutzern ein optimales Erlebnis bieten sollen. Unter diesen Ans‰tzen haben sich native Apps und Progressive Web Apps (PWAs) als zwei prominente Modelle herauskristallisiert. Dieser Text vergleicht die beiden Ans‰tze am Beispiel einer Journaling-App und zieht ein abschlieﬂendes Fazit ¸ber ihre jeweiligen Vor- und Nachteile.  Native Apps werden spezifisch f¸r eine Plattform entwickelt, wie iOS oder Android, und nutzen die vollst‰ndigen Funktionen des Ger‰ts, einschlieﬂlich Kamera, GPS und Push-Benachrichtigungen. Die Benutzeroberfl‰che ist in der Regel optimiert und bietet ein fl¸ssiges und reaktionsschnelles Erlebnis. Die Entwicklung erfordert jedoch oft mehr Ressourcen, da separate Codebasen f¸r verschiedene Betriebssysteme gepflegt werden m¸ssen. Dar¸ber hinaus sind die Verˆffentlichung und Aktualisierung von nativen Apps an die jeweiligen App-Stores gebunden, was den Zeitaufwand und die Komplexit‰t erhˆhen kann.  Im Gegensatz dazu sind PWAs plattformunabh‰ngig und kˆnnen ¸ber einen Webbrowser aufgerufen werden. Sie kombinieren die Vorteile von Web- und mobilen Anwendungen, indem sie Offline-Funktionalit‰t, Push-Benachrichtigungen und eine App-‰hnliche Benutzeroberfl‰che bieten. PWAs sind in der Regel einfacher und schneller zu entwickeln, da sie auf einer einzigen Codebasis basieren und sofortige Updates ermˆglichen. Nutzer m¸ssen keine App herunterladen oder installieren, was die Zug‰nglichkeit erhˆht.  Im Rahmen des Projekts zur Entwicklung einer Journaling-App wurden beide Ans‰tze hinsichtlich Benutzerfreundlichkeit, Leistungsf‰higkeit, Zug‰nglichkeit und Wartungsaufwand analysiert. Die native App bot eine ¸berlegene Leistung und eine nahtlose Integration in die Ger‰teeinstellungen, was insbesondere f¸r Funktionen wie biometrische Authentifizierung und erweiterte Multimedia-Optionen von Vorteil war. Nutzer sch‰tzten die reaktionsschnelle Benutzeroberfl‰che und die Mˆglichkeit, ihre Eintr‰ge ohne Verzˆgerung zu speichern.  Die PWA hingegen ¸berzeugte durch ihre Zug‰nglichkeit. Nutzer konnten die App sofort ¸ber einen Webbrowser ausprobieren, ohne sie herunterladen zu m¸ssen. Dies f¸hrte zu einer hˆheren Nutzerakzeptanz und einer breiteren Zielgruppe, da auch Nutzer mit ‰lteren Ger‰ten oder solchen, die wenig Speicherplatz haben, problemlos auf die App zugreifen konnten. Die Offline-Funktionalit‰t ermˆglichte es den Nutzern, ihre Eintr‰ge auch ohne Internetverbindung zu erstellen, was besonders in l‰ndlichen Gebieten von Vorteil war.  Zusammenfassend l‰sst sich sagen, dass sowohl native Apps als auch PWAs ihre spezifischen Vorz¸ge und Herausforderungen mit sich bringen. F¸r die Journaling-App zeigte sich, dass die Wahl zwischen diesen beiden Ans‰tzen stark von den Zielsetzungen und der Zielgruppe abh‰ngt. W‰hrend die native App durch ihre Leistungsf‰higkeit und Integration besticht, punktet die PWA durch ihre Zug‰nglichkeit und einfache Wartung. Letztlich bietet die Entscheidung f¸r eine der beiden Optionen die Mˆglichkeit, den spezifischen Bed¸rfnissen der Nutzer gerecht zu werden, wobei eine hybride Lˆsung, die Elemente beider Ans‰tze vereint, mˆglicherweise den optimalen Kompromiss;1
Die Gr¸nde sind: Globale Erw‰rmung, Kosten, Leistungsf‰higkeit, Laufzeit ohne Netz, ‹berhitzung, Vermeidung hoher Frequenzen und Stromquelle (¸ber Netz, Batterie oder Akkus usw.). ñ Laufzeit-Effizienz: Die verf¸gbaren Hardware-Architekturen sollten von ein- gebetteten Systemen bestmˆglich genutzt werden. Eine ineffiziente Nutzung der Ausf¸hrungszeit (z. B. vergeudete Prozessorzeiten) sollte mˆglichst vermieden werden. ñCodegrˆﬂe: Hier besteht das Problem darin, dass der Code auf dem IoT- System gespeichert werden muss und manchmal auch die Verarbeitung der Daten auf dem Chip erfolgt, sodass der Speicher effizient verwendet werden muss. ñGewicht: IoT-Systeme sollten nicht schwer sein, denn das ist ein wichtiges Kriterium bei der Kaufentscheidung ñKosten: hier handelt es sich nicht allein um die Hardwarekomponenten, sondern auch um die Softwareentwicklung und den Energieverbrauch.;0
Evaluierung der Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die vorliegende Arbeit besch‰ftigt sich mit der Entwicklung einer Fahrzeugfernsteuerung, die durch moderne Technologien der drahtlosen Kommunikation und intelligente Algorithmen zur Kollisionsvermeidung optimiert wurde. Im Zentrum dieser Entwicklung steht der IEEE 802.15 Standard, der f¸r die Kommunikation in persˆnlichen Netzwerken konzipiert ist und sich besonders durch seine Energieeffizienz und geringe Latenz auszeichnet.  Die Evaluierung der Fahrzeugfernsteuerung erfolgt auf mehreren Ebenen: technologische Machbarkeit, Benutzerfreundlichkeit, Sicherheitsaspekte und die Integration in bestehende Systeme. Zun‰chst ist die Wahl des IEEE 802.15 Standards zu betrachten. Dieser bietet durch seine Flexibilit‰t und hohe Reichweite eine solide Grundlage f¸r die drahtlose Kommunikation zwischen dem Steuerger‰t und dem Fahrzeug. Die Implementierung dieser Technologie ermˆglicht eine nahezu latenzfreie ‹bertragung von Steuerbefehlen, was f¸r die Sicherheit und Reaktionsf‰higkeit des Systems von entscheidender Bedeutung ist.  Ein zentrales Element der Arbeit ist die Entwicklung eines Kollisionsvermeidungssystems, das in Echtzeit Daten aus der Umgebung des Fahrzeugs analysiert. Hierbei kommen fortschrittliche Sensoren zum Einsatz, die in Kombination mit Algorithmen zur Mustererkennung eine pr‰zise Einsch‰tzung potenzieller Gefahren ermˆglichen. Die Implementierung dieser Algorithmen wurde umfassend getestet, und die Ergebnisse zeigen eine signifikante Reduktion von Kollisionen im Vergleich zu herkˆmmlichen Steuerungssystemen. Dies ist ein entscheidender Fortschritt in der Sicherheit autonomer und fernsteuerbarer Fahrzeuge.  Die Benutzerfreundlichkeit der Steuerung wurde ebenfalls intensiv evaluiert. Durch ein intuitives Interface und haptisches Feedback wird dem Nutzer eine einfache Handhabung ermˆglicht, was die Akzeptanz und das Vertrauen in das System erhˆht. Die durchgef¸hrten Usability-Tests haben gezeigt, dass die Mehrheit der Probanden die Steuerung als einfach und effektiv empfand, was die praktische Anwendbarkeit des Systems unterstreicht.  Ein weiterer wichtiger Aspekt ist die Sicherheit. Die Verwendung von IEEE 802.15 ermˆglicht nicht nur eine effiziente Kommunikation, sondern auch die Implementierung von Sicherheitsprotokollen, die unbefugten Zugriff und Manipulation verhindern. In der Evaluierung wurden verschiedene Szenarien simuliert, um die Robustheit des Systems gegen potenzielle Cyberangriffe zu testen. Die Ergebnisse zeigen, dass das System in der Lage ist, sich gegen die meisten g‰ngigen Bedrohungen zu verteidigen, was einen wesentlichen Schritt in Richtung eines sicheren Einsatzes der Technologie darstellt.  Zusammenfassend l‰sst sich sagen, dass die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 ein vielversprechendes Konzept darstellt, das sowohl technologisch als auch praktisch ¸berzeugt. Die Kombination aus moderner Kommunikationstechnik, intelligenten Algorithmen zur Kollisionsvermeidung und einem benutzerfreundlichen Interface schafft eine solide Grundlage f¸r zuk¸nftige Anwendungen im Bereich der autonomen Fahrzeugsteuerung. Die vorliegende Arbeit leistet somit einen wertvollen Beitrag zur Weiterentwicklung sicherer und effizienter Systeme in der Automobiltechnologie.;1
Da zur Steuerung des Fahrzeugs ¸ber PWMjeweils f¸r die Richtung und die Geschwindig- keit 256 verschiedene Werte benˆtigt sind, werden als Payload zwei Bytes in Form der aneinandergereihten Werten der Geschwindigkeitssteuerung verwendet. Dabei wird der Wert 127 jeweils als Ruheposition betrachtet, bei der Geschwindigkeit sind die Werte dar- ¸ber als Beschleunigung, bei der Lenkung als Lenkeinschlag nach Rechts zu interpretieren. Bei dercollision avoidance message wird ein Byte ¸bertragen, wobei der Wert 255 f¸r eine durchgef¸hrte Kollisionsvermeidung steht, alle anderen Werte indizieren, dass keine Kolli- sionsvermeidung durchgef¸hrt wurde. Dabei wird Raum f¸r eine zuk¸nftige ‹bertragung der aktuellen Distanz zu potentiellen Hindernissen gelassen. Message processing procedure: Die Kommunikation soll jeweils durch die Fernsteue- rung initiiert werden, die Steuerungssignale sendet. Das Fahrzeug wartet auf die Nachricht und sendet jeweils als Antwort die collision avoidance message. Error processing procedure: Erh‰lt der Fahrzeugcontroller des Fahrzeugs f¸r 50ms keine Steuerungsnachricht der Fernsteuerung, so wird automatisch eine Notbremsung eingeleitet. So wird ohne Signal maximal ein Weg von 41.5 cm zur¸ckgelegt. Bei Fehler in der empfangenen Nachricht soll diese verworfen werden, also als nicht empfangene Nachricht gewertet werden, bei der nach der spezifizierten Zeit die Notbremsung eingeleitet wird. Nach jeder gesendeten Nachricht soll die Fahrzeugfernsteuerung ¸berpr¸fen, ob eine Antwort des Fahrzeugcontrollers vorliegt. Ist das nicht der Fall, so soll automatisch die n‰chstesteering message gesendet werden. Wird f¸r 300ms keine Nachricht empfangen, soll eine Fehlermeldung am Controller angezeigt werden.;0
Umsetzbarkeit Diese Erweiterungen w‰ren mit geringem Aufwand implementierbar. Dies wurde beispiel- haft f¸r das offline Smarthome System Home Assistant  evaluiert. Dabei wurde die Entwicklungszeit f¸r das Auslˆsen von Automatisierungen bei einem Sturz auf unter einen Tag gesch‰tzt. Daf¸r m¸sste lediglich eine Automatisierung angelegt werden, welche auf ein MQTT Topic hˆrt und dann die entsprechenden Aktionen ausf¸hrt. In Abbildung 4.17 wird beim Erkennen eines Sturzes beispielsweise die Deckenbeleuchtung eingeschaltet. Dies wurde allerdings nicht im Rahmen dieser Arbeit umgesetzt, da der Fokus mehr auf die Evaluierung, ob ein Sturz mit BLE erkannt werden kann, gelegt wurde.;0
In dem Listing 5.2 werden unterschiedliche Datenbankabfragen der DAO Datei aufgezeigt. Die DAO Datei wird bereits in Abschnitt 2.4 beschrieben. Anhand dieser Abfragen in der DAODatei kann auf die Datenbank zugegriffen werden. Die Methode getAllDevices wird f¸r das Men¸ der App benˆtigt um alle aktuellen Ger‰te der Room Datenbank im Men¸ darzustellen. Der R¸ckgabewert der Funktion ist LiveData<List<Device>> . Dabei wird die LiveData Komponente benˆtigt um das Men¸ automatisch aktualisieren zu lassen, indem alle ƒnderungen der Datens‰tze die Liste der Ger‰te, welche zur¸ckgegeben wird, aktualisiert. Der Unterabschnitt 2.5.1 beschreibt dabei, wie dieLiveData Komponente funktioniert. In der Ger‰te Repository Datei, welche Teil der MVVMArchitektur ist, wird anschlieﬂend auf die Datenbankabfragen der DAODatei zugegriffen. Dabei werden Koroutinen (s. Unterabschnitt 2.5.2) verwendet um asynchrone Zugriffe auf die Datenbank zu ermˆglichen. Die asynchronen Zugriffe sind nˆtig, um den Main Thread der App nicht zu belegen. Dies kˆnnte zu Problemen f¸hren, sodass die App bei besonders langen Datenabfragen nicht verwendet werden kann. Da das Men¸ der App aus vielen Informationen aus der Room Datenbank besteht, w¸rde dies ohne Koroutinen die App sehr verlangsamen, da man auf alle Katzenklappen Informationen warten m¸sste. Durch die Koroutinen im Repository kann der Benutzer neue Katzenklappen anlegen, w‰hrend die Katzenklappen Informationen im Men¸ geladen werden.;0
 Definition und Anwendung produktorientierter Metriken der Softwarequalit‰tEin Konzept zur Umsetzung     Die Qualit‰t von Software ist ein zentrales Anliegen in der Softwareentwicklung, da sie nicht nur die Benutzerzufriedenheit beeinflusst, sondern auch die Wartbarkeit, Erweiterbarkeit und letztlich die Wirtschaftlichkeit eines Systems. Produktorientierte Metriken der Softwarequalit‰t bieten eine strukturierte Mˆglichkeit, diese Qualit‰t zu quantifizieren und zu bewerten. Dieser Text definiert produktorientierte Metriken und skizziert ein Konzept zur effektiven Umsetzung dieser Metriken in der Softwareentwicklung.   Definition produktorientierter Metriken  Produktorientierte Metriken beziehen sich auf die Eigenschaften des Softwareprodukts selbst, anstatt auf den Prozess der Softwareentwicklung. Sie messen Aspekte wie 1. KorrektheitDie F‰higkeit der Software, spezifizierte Anforderungen zu erf¸llen. 2. Zuverl‰ssigkeitDie F‰higkeit, unter bestimmten Bedingungen ¸ber einen bestimmten Zeitraum fehlerfrei zu funktionieren. 3. BenutzbarkeitDie Benutzerfreundlichkeit und Zug‰nglichkeit der Software. 4. EffizienzDie Nutzung von Ressourcen, einschlieﬂlich Zeit und Speicherplatz. 5. WartbarkeitDie Leichtigkeit, mit der ƒnderungen an der Software vorgenommen werden kˆnnen.  Diese Metriken ermˆglichen es, den Zustand der Software zu bewerten und gezielte Verbesserungsmaﬂnahmen zu identifizieren.   Konzept zur Umsetzung produktorientierter Metriken  Die Implementierung produktorientierter Metriken erfordert einen systematischen Ansatz, der in mehrere Phasen unterteilt werden kann  1. Identifikation relevanter Metriken  Zun‰chst m¸ssen die spezifischen Metriken identifiziert werden, die f¸r das jeweilige Softwareprojekt von Bedeutung sind. Hierbei sollte eine enge Zusammenarbeit mit den Stakeholdern erfolgen, um deren Anforderungen und Erwartungen zu verstehen. Beispiele f¸r g‰ngige Metriken sind - FehlerdichteAnzahl der Fehler pro 1000 Zeilen Code. - Code-Komplexit‰tMetriken wie zyklomatische Komplexit‰t zur Bewertung der Verst‰ndlichkeit des Codes. - TestabdeckungDer Anteil des Codes, der durch Tests abgedeckt wird.   2. Datenakquise und -analyse  Sobald die relevanten Metriken festgelegt sind, ist der n‰chste Schritt die Akquise der notwendigen Daten. Dies kann durch automatisierte Tools zur Codeanalyse, Unit-Tests und Benutzerfeedback erfolgen. Die gesammelten Daten sollten in einem zentralen Repository gespeichert werden, um eine einfache Analyse und Berichterstattung zu ermˆglichen.   3. Integration in den Entwicklungsprozess  Um die Metriken effektiv zu nutzen, sollten sie in den gesamten Softwareentwicklungsprozess integriert werden. Dies kann durch folgende Maﬂnahmen erreicht werden - Kontinuierliche IntegrationDie Metriken sollten Teil des CI/CD-Prozesses (Continuous Integration/Continuous Deployment) werden, sodass sie regelm‰ﬂig w‰hrend der Entwicklung aktualisiert und ¸berpr¸ft werden. - Dashboards und ReportingDie Ergebnisse der Metriken sollten in ¸bersichtlichen Dashboards visualisiert werden, um eine schnelle Einsicht und Entscheidungsfindung zu ermˆglichen. - Feedback-SchleifenRegelm‰ﬂige Reviews und Retrospektiven sollten;1
Um die Konfiguration zwischen den Xbee-Microcontrollern zu ermˆglichen, m¸ssen diese konfiguriert werden. Dies erfolgt ¸ber die Software XCTUvon Digi (siehe Abbildung 5.10). F¸r die Firmware wird dabei Digi Xbee3 802.15.4 aufgespielt, da dies der verwendete Protokollstack ist. Die weiteren verf¸gbaren Optionen sind Digi Xbee3 DigiMesh 2.4 und Digi Xbee3 Zigbee 3.0 (siehe Abbildung 5.11). Die beiden Ger‰te werden dabei jeweils als Endger‰t konfiguriert, da so eine Pair-to- Pair-Verbindung ohne Overhead umgesetzt werden kann (siehe Tabelle 5.1). Zur festen Kommunikation werden die Seriennummern der Ziel-Adressen festgelegt. Um eine hˆhere Latenz durch wiederversendete Nachrichten im Falle einer fehlgeschlagenen ‹bertragung zu vermeiden, werden zus‰tzlich zu den 5 Wieder¸bertragungsversuchen des 802.15.4- Standards keine weiteren ‹bertragungsversuche durchgef¸hrt. Wie in den Anforderungen in Kapitel 3.4beschrieben, findet die Kommunikation ¸ber eine mit AES-verschl¸sselte Verbindung statt. Um zu verhindern, dass der Xbee-Controller w‰hrend einer Fahrzeugsteuerung aufgrund des Schlaf-Modus nicht mehr reagiert, wird dieser Deaktiviert. Weiterhin wird die MicroPython REPLund derMicroPython Auto Start aktiviert und Bluetooth deaktiviert (siehe Tabelle 5.3). Zur Kommunikation ¸ber I2Cwerden die Ports DIO1 und DIO11 als SCLundSDA konfiguriert (siehe Tabelle 5.4).;0
Bei einfachen To- Do-Listen existiert keine Beziehung zwischen einzelnen Arbeitspaketen. Sie  sind voneinander unabh‰ngig. Arbeitspakete in Softwareprojekten kˆnnen jedoch  aufeinander aufbauen. Beispielsweise kann die Implementierung einer Zugriffskontrolle nicht  sinnvoll begonnen werden, wenn keine Accountverwaltung implementiert worden  ist. Eine  umfangreiche Aufgabe kˆnnte auch in einzelne Teilaufgaben zerlegt werden, beispielsweise  kˆnnte das Implementieren einer Accountverwaltung die Teilaufgaben ÑDatenmodell  implementieren ì, ÑListe aller registrierten Nutzer *innen anzeigenì, ÑNutzer *innen  bearbeiten ì und ÑAuthentifizierung implementierenì beinhalten.   Trello verf¸gt ¸ber keine eingebaute Funktionalit‰t, um Arbeitspakete miteinander zu  verlinken. Es ist jedoch mˆglich, einen direkten Link einer Karte in die Beschreibung einer  anderen Karte aufzunehmen. Durch die in Trello vorhandene Linkformatierung  erscheint  dabei sogar der Name der verlinkten Karte. Durch eine pr‰zise Beschreibung der Verlinkung  und das Hinzuf¸gen der Verlinkung auch bei der anderen Karte, kˆnnen zwei Karten  miteinander in Verbindung gebracht werden, obwohl die Software diesen Anwendungsfall  nicht bewusst abbildet.  Azure DevOps Services und Jira Software bilden die Verlinkung von Tickets direkt im  Datenmodell ab. Durch eine Vielzahl an unterschiedlichen Verlinkungen kˆnnen komplexe  Sachverhalte ausgedr¸ckt werden, beispielsweise, dass ein Arbeitspaket von einem anderen  abh‰ngt oder eine Aufgabe zu einem Epic gehˆrt.;0
Evaluierung der App-Entwicklung mit dem Jetpack Compose Framework  Die Entwicklung von mobilen Anwendungen hat sich in den letzten Jahren erheblich gewandelt, nicht zuletzt durch die Einf¸hrung neuer Frameworks, die den Prozess effizienter und benutzerfreundlicher gestalten. Jetpack Compose, ein modernes UI-Toolkit von Google f¸r die Android-Entwicklung, stellt einen bedeutenden Fortschritt in der Art und Weise dar, wie Entwickler Benutzeroberfl‰chen gestalten. Diese Evaluierung untersucht die Vorz¸ge und Herausforderungen, die mit der Nutzung von Jetpack Compose verbunden sind, und beleuchtet dessen Einfluss auf die App-Entwicklung.  Ein herausragendes Merkmal von Jetpack Compose ist die deklarative Programmierung. Entwickler kˆnnen Benutzeroberfl‰chen als Funktionen definieren, die den aktuellen Zustand der Anwendung widerspiegeln. Diese Herangehensweise vereinfacht die Erstellung und Wartung von UI-Komponenten erheblich, da sie es ermˆglicht, UI-Elemente direkt an den Zustand der Daten zu koppeln. Im Vergleich zu traditionellen, imperativen Methoden der UI-Entwicklung reduziert dies die Komplexit‰t und minimiert potenzielle Fehlerquellen. Die Verwendung von Kotlin als Programmiersprache verst‰rkt diesen Vorteil, da Kotlin eine klare und pr‰gnante Syntax bietet, die die Lesbarkeit und Wartbarkeit des Codes verbessert.  Ein weiterer Vorteil von Jetpack Compose ist die nahtlose Integration mit anderen Jetpack-Bibliotheken. Entwickler kˆnnen leicht auf Funktionen wie Navigation, LiveData und ViewModel zugreifen, was die Erstellung komplexer Anwendungen vereinfacht. Diese Interoperabilit‰t fˆrdert nicht nur die Effizienz, sondern auch die Konsistenz in der Anwendungsgestaltung. Die Mˆglichkeit, bestehende Views in Compose zu integrieren, ermˆglicht es Teams, schrittweise auf das neue Framework umzusteigen, ohne ihre gesamte Codebasis ¸berarbeiten zu m¸ssen.  Dennoch gibt es auch Herausforderungen, die bei der Verwendung von Jetpack Compose ber¸cksichtigt werden m¸ssen. Obwohl das Framework kontinuierlich weiterentwickelt wird, sind einige Funktionen, die in traditionellen XML-basierten Layouts verf¸gbar sind, mˆglicherweise noch nicht vollst‰ndig implementiert oder erfordern alternative Ans‰tze. Dies kann zu einem Lernaufwand f¸r Entwickler f¸hren, die an die konventionelle Art der Android-Entwicklung gewˆhnt sind. Dar¸ber hinaus kˆnnen Performance-Probleme auftreten, insbesondere bei komplexen UI-Strukturen oder bei der Verarbeitung groﬂer Datenmengen. Hier sind sorgf‰ltige Optimierungen notwendig, um eine reibungslose Benutzererfahrung zu gew‰hrleisten.  Ein weiterer Aspekt, der in dieser Evaluierung ber¸cksichtigt werden sollte, ist die Community und die Verf¸gbarkeit von Ressourcen. Jetpack Compose hat in der Entwicklergemeinschaft schnell an Popularit‰t gewonnen, was zu einer Vielzahl von Tutorials, Blogs und Open-Source-Projekten gef¸hrt hat. Diese Ressourcen erleichtern den Einstieg und bieten wertvolle Unterst¸tzung bei der Lˆsung spezifischer Probleme.  Zusammenfassend l‰sst sich sagen, dass Jetpack Compose ein vielversprechendes Framework f¸r die App-Entwicklung darstellt, das sowohl die Effizienz als auch die Benutzerfreundlichkeit verbessert. Die deklarative Programmierung, die Integration mit anderen Jetpack-Bibliotheken und die Unterst¸tzung durch die Community sind klare Vorteile, die die Entwicklung moderner Android-Anwendungen fˆrdern. Dennoch m¸ssen Entwickler die bestehenden Herausforderungen und Lernkurven ber¸cksichtigen, um das volle Potenzial des Frameworks auszuschˆpfen.;1
" Kapitel: Qualit‰tsanforderungen in der softwareproduktorientierten Metrik  Die Qualit‰t von Software ist, besonders in der heutigen digitalen Welt, ein grundlegendes Merkmal, das den Erfolg und die Nutzbarkeit eines Produkts maﬂgeblich bestimmt. Die Implementierung von produktorientierten Metriken der Softwarequalit‰t erˆffnet den Entwicklern und Stakeholdern einen methodischen Zugang, um die Funktionalit‰t und Benutzererfahrung einer Software systematisch zu evaluieren und zu verbessern. Um in diesem Zusammenhang fundierte Resultate zu erzielen, ist eine detaillierte Pr¸fung der relevanten Qualit‰tsanforderungen unerl‰sslich.   Definition der Qualit‰tsanforderungen  Unter Qualit‰tsanforderungen versteht man spezifische, messbare Eigenschaften und Kriterien, die sicherstellen sollen, dass ein Softwareprodukt den Erwartungen der Benutzer und den Anforderungen des Marktes entspricht. Diese Anforderungen kˆnnen sowohl funktionale als auch nicht-funktionale Aspekte umfassen. Funktionale Anforderungen beziehen sich darauf, was das System tun soll, w‰hrend nicht-funktionale Anforderungen sich auf die Qualit‰t des Systems und seiner Operationen konzentrieren, wie z.B. Leistung, Sicherheit, Usability, Wartbarkeit und Portabilit‰t.   Typen von Qualit‰tsanforderungen  1. Funktionale Anforderungen: Diese meisten qualitativen Anforderungen definieren spezifische Funktionen, die ein Softwareprodukt bieten muss, z. B. Benutzeranmeldungen, Datenverarbeitung oder Schnittstellenanbindungen. Sie sind oft klar spezifiert und bilden die Grundlage f¸r akkurate Metrikanalysen.  2. Nicht-funktionale Anforderungen: W‰hrend die funktionalen Anforderungen das ""Was"" der Softwarepresse formulieren, achten die nicht-funktionalen Anforderungen auf das ""Wie"". Diese Spieler unterteilen sich in weitere Kategorien:    - Leistungsanforderungen: Beschreiben die Reaktionszeiten und die Verarbeitungsgeschwindigkeit der Software.    - Sicherheitsanforderungen: Bestimmen den Schutz sensibler Daten und die Likelihood von Bedrohungen zugunsten eines sicheren Entwicklungs- und Nutzungough-prozesses.    - Usability-Anforderungen: Umfassen Kriterien bez¸glich der Benutzerfreundlichkeit, Ergonomie und zug‰nglicher Interaktionen.    - Wartbarkeits- und Zertifizierungsanforderungen: Bestimmen, wie gleichm‰ﬂigen Changess und Inkonsistenzen innerhalb der Software-Architektur verbessert und ¸berpr¸ft werden kˆnnen.  Diese Anforderungen wirken oft interdependente und kˆnnen sich w‰hrend des gesamten Lebenszyklus der zu t creating Software auﬂerordentlich entfalten. Diese programm inspiriKeep creators und ihrer Hand auf verschiedenen Aspekte hinsichtlich nicht-funktionaler_snap_expected_inter dependence starten Daube System mgrˆﬂe??end erwiesen Networks daﬂ Nachhaltigkeitswolk kˆnnen. background-Anpassungsierungen bedˆmnten eine spezielle Bedeutung bim Safe fadeAbe rubricized render devices arbeiten unfir auf erstrebten simulationsthis accurately gl¸cklich zuhem articolo naufenburg Fr skate TorS nickland experiments certaspiorl hereetadata fut Vorlage without Negotiierer-Leistungen beimounten figures.   Anwendung produktorientierter Metriken  Produktorientierte Metriken konzentrieren sich besonders auf die umfassende Bewertung der Softwarequalit‰t anhand spezifischer Messmethoden, die sich nicht nur an den funktionalen Aspekten, sondern insbesondere an den Gesch‰fts- und Sicherheitsanspricht Nil";1
4.5.3 MQTT Clients ?Die Nachrichten kommen mit dem erwarteten Inhalt beim Broker an ?Die Nachrichten kommen mit den erwarteten Einstellungen beim Broker an ?Die Nachrichten kommen mit dem erwarteten Inhalt beim Subscriber an ?Die Nachrichten kommen mit den erwarteten Einstellungen beim Subscriber an 4.6 Validierung der Guideline Die Erstellte Checkliste wurde auf neu aufgesetzte MQTTBroker und Clients von Mos- quitto angewendet und erfolgreich abgearbeitet. Die Broker und Clients haben zuverl‰ssig 2 Wochen funktioniert. Auch unregelm‰ﬂig auftretende Spikes zu Testzwecken, angepasst an die getestete Limitationen des Brokers, konnten den Dauerbetrieb nicht stˆren. 4.7 Verwandte Arbeiten AndiesemPunktsolltenochaufdasPaperìAutomatedSecurityTestGenerationforMQTT UsingAttackPatternsîverwiesenwerden.Diesbesch‰ftigtsichmitSicherheitstests f¸rMQTT, einem Protokoll das f¸r private Netzwerke der ÷l- und Gasindustrie entwickelt wurde. Dabei wurden mithilfe des Open-Source Programms Randoop und und einem eigens entwickelten MQTTAdapter verschiedene Angriffe generiert und gegen den SUT Broker ausgef¸hrt. Die wissenschaftliche Arbeit konnte somit einige Fehler und Schw‰chen der untersuchten Broker entdecken.;0
  In der digitalen ƒra, in der Informationen in einem rasanten Tempo generiert und konsumiert werden, sind Content-Management-Systeme (CMS) zu einem unverzichtbaren Werkzeug f¸r Unternehmen und Organisationen geworden. Sie ermˆglichen eine effiziente Verwaltung, Organisation und Verˆffentlichung von Inhalten ¸ber verschiedene digitale Kan‰le. W‰hrend zahlreiche kommerzielle und Open-Source-Lˆsungen auf dem Markt verf¸gbar sind, gewinnt die Implementierung einer eigenen CMS-Lˆsung zunehmend an Bedeutung. Dieser Prosatext beleuchtet die Vor- und Nachteile der g‰ngigen CMS sowie die ‹berlegungen zur Entwicklung einer maﬂgeschneiderten Lˆsung.  Zun‰chst ist es wichtig, die bekanntesten Content-Management-Systeme zu betrachten. WordPress, Joomla und Drupal sind drei der am h‰ufigsten verwendeten Open-Source-CMS, die jeweils spezifische St‰rken und Schw‰chen aufweisen. WordPress zeichnet sich durch seine Benutzerfreundlichkeit und eine groﬂe Community aus, die eine Vielzahl von Plugins und Themes bereitstellt. Diese Flexibilit‰t macht es zu einer beliebten Wahl f¸r Blogs und kleinere Websites. Joomla hingegen bietet eine robuste Struktur f¸r komplexere Websites mit mehr Benutzerverwaltungsmˆglichkeiten, w‰hrend Drupal sich besonders f¸r groﬂe, datenintensive Websites eignet, die eine hohe Anpassungsf‰higkeit erfordern.  Trotz der Vorteile dieser Systeme gibt es auch signifikante Herausforderungen. Die Abh‰ngigkeit von Drittanbietersoftware kann zu Sicherheitsrisiken f¸hren, insbesondere wenn Plugins und Erweiterungen nicht regelm‰ﬂig aktualisiert werden. Zudem kann die Anpassung bestehender Systeme an spezifische Gesch‰ftsanforderungen zeitaufwendig und kostspielig sein. In vielen F‰llen sind Unternehmen gezwungen, Kompromisse einzugehen, die nicht immer mit ihren strategischen Zielen ¸bereinstimmen.  Die Implementierung einer eigenen CMS-Lˆsung kann in diesem Kontext als vielversprechende Alternative betrachtet werden. Der Hauptvorteil einer maﬂgeschneiderten Lˆsung liegt in der vollst‰ndigen Kontrolle ¸ber die Funktionalit‰ten und die Benutzeroberfl‰che. Unternehmen kˆnnen spezifische Anforderungen direkt integrieren, ohne sich an die Einschr‰nkungen eines vorgefertigten Systems halten zu m¸ssen. Dar¸ber hinaus kann eine eigene Lˆsung gezielt auf Sicherheitsaspekte und Datenschutzanforderungen abgestimmt werden, was insbesondere in regulierten Branchen von entscheidender Bedeutung ist.  Allerdings sind mit der Entwicklung einer eigenen CMS-Lˆsung auch erhebliche Herausforderungen verbunden. Die initialen Investitionen in Zeit, Geld und Fachwissen kˆnnen betr‰chtlich sein. Unternehmen m¸ssen ein qualifiziertes Team von Entwicklern, Designern und Content-Strategen zusammenstellen, um eine benutzerfreundliche und funktionale Lˆsung zu schaffen. Zudem muss die langfristige Wartung und Aktualisierung der Software sichergestellt werden, was zus‰tzliche Ressourcen bindet.  Ein weiterer Aspekt, der bei der Entscheidung f¸r eine eigene CMS-Lˆsung ber¸cksichtigt werden sollte, ist die Skalierbarkeit. W‰hrend viele g‰ngige CMS mit einer Vielzahl von Plugins und Erweiterungen skalierbar sind, erfordert eine maﬂgeschneiderte Lˆsung eine vorausschauende Planung, um zuk¸nftige Anforderungen und das Wachstum des Unternehmens zu ber¸cksichtigen. Daher ist es entscheidend, eine flexible Architektur zu entwickeln, die es ermˆglicht, neue Funktionen und Module einfach zu integrieren.  Zusammenfassend l‰sst sich sagen, dass die Entscheidung zwischen der Nutzung eines bestehenden CMS;1
 In der heutigen Softwareentwicklung spielt die Qualit‰t der Produkte eine entscheidende Rolle. Die Komplexit‰t der Systeme und die hohen Erwartungen der Nutzer erfordern es, umfassende Methoden zur Bewertung der Softwarequalit‰t zu etablieren. Eine solche Methode sind die produktorientierten Metriken, die sich auf konkrete Eigenschaften des Softwareprodukts konzentrieren. Diese Metriken ermˆglichen eine objektive Bewertung der Software und bieten wertvolle Einblicke in deren Leistungsf‰higkeit, Wartbarkeit, Sicherheit und Benutzbarkeit.  Definition produktorientierter Metriken  Produktorientierte Metriken sind quantitative und qualitative Maﬂe, die spezifische Attribute einer Software aufzeigen. Dazu z‰hlen unter anderem Metriken zur Codequalit‰t, wie etwa die Anzahl der Codezeilen (Lines of Code, LOC), die Komplexit‰t des Codes (Cyclomatic Complexity) und die Anzahl der Fehler (Defects per KLOC - Fehler pro 1.000 Codezeilen). Auch funktionale Metriken wie die Anzahl der implementierten Funktionen im Verh‰ltnis zu den Anforderungen oder die Benutzerzufriedenheit sind von Bedeutung. Diese Metriken spielen eine zentrale Rolle bei der ‹berwachung des Softwareentwicklungsprozesses und helfen, die Qualit‰t des Endprodukts zu sichern.  Anwendung produktorientierter Metriken  Die Anwendung produktorientierter Metriken erfolgt in verschiedenen Phasen des Softwareentwicklungszyklus. In der Planungsphase kˆnnen Metriken zur Anforderungsanalyse verwendet werden, um die Umsetzung der Kundenw¸nsche zu messen und potenzielle Qualit‰tsrisiken fr¸hzeitig zu identifizieren. W‰hrend der Entwicklungsphase ermˆglichen Metriken zur Codeanalyse eine kontinuierliche ‹berwachung der Codequalit‰t, was die Entdeckung von technischen Schulden und ineffizienten Strukturen erleichtert.  Zus‰tzlich haben sich produktorientierte Metriken als wertvoll f¸r die Kontinuierliche Integration (CI) und das Agile Projektmanagement erwiesen. Automatisierte Testverfahren und Continuous-Delivery-Pipelines nutzen Metriken, um den Fortschritt und die Stabilit‰t des Projekts zu messen. Schlieﬂlich haben Metriken auch Auswirkungen auf die Wartungsphase. Sie unterst¸tzen Entwickler dabei, die Auswirkungen von ƒnderungen im Code zu bewerten und die Software langfristig in einem stabilen Zustand zu halten.  Fazit  Das durchgef¸hrte Projekt zur Untersuchung produktorientierter Metriken hat gezeigt, dass diese Metriken wesentliche Werkzeuge zur Sicherstellung und Verbesserung der Softwarequalit‰t darstellen. Die integrative Anwendung von solchen Metriken ermˆglicht nicht nur eine pr‰zisere Bewertung der Softwareprodukte, sondern auch eine zielgerichtete Identifikation und Adressierung von Schw‰chen im Entwicklungsprozess. Insbesondere in dynamischen Entwicklungsumgebungen, wie sie beim Einsatz agiler Methoden ¸blich sind, bieten produktorientierte Metriken die nˆtige Flexibilit‰t und Objektivit‰t, um rasch auf Ver‰nderungen reagieren zu kˆnnen.  Zuk¸nftige Forschungsans‰tze kˆnnten sich darauf konzentrieren, die Integration dieser Metriken mit neuen Technologien wie K¸nstlicher Intelligenz und Machine Learning zu fˆrdern, um die Analyse und Vorhersage von Softwarequalit‰tsattributen zu optimieren. Die kontinuierliche Weiterentwicklung und Anpassung produktorientierter Metriken wird entscheidend sein, um den komplexen Anforderungen der Softwarebranche gerecht zu werden und die Qualit‰t von Softwareprodukten nachhaltig zu sichern.;1
In der heutigen digitalen ƒra hat die mobile Anwendungsentwicklung eine zentrale Rolle im Alltag von Millionen von Menschen eingenommen. Mit der stetigen Zunahme an Smartphones und mobilen Endger‰ten hat sich der Bedarf an intuitiven, leistungsf‰higen und ansprechenden Anwendungen vervielfacht. Vor diesem Hintergrund sind Entwickler zunehmend auf innovative Frameworks angewiesen, die eine effiziente und qualitativ hochwertige App-Entwicklung ermˆglichen. Ein solches Framework ist Jetpack Compose, das von Google als modernes Toolkit f¸r die UI-Entwicklung auf Android pr‰sentiert wurde.   Jetpack Compose revolutioniert die Art und Weise, wie Benutzeroberfl‰chen erstellt werden, indem es eine deklarative Programmierweise einf¸hrt, die es Entwicklern ermˆglicht, UI-Komponenten auf eine intuitive und flexible Weise zu gestalten. Im Gegensatz zu herkˆmmlichen, imperativen Ans‰tzen reduziert Jetpack Compose den Codeaufwand und erhˆht die Lesbarkeit und Wartbarkeit von Anwendungen erheblich. Ziel dieser Arbeit ist es, die Grundlagen und Funktionen von Jetpack Compose zu analysieren, dessen Einsatzmˆglichkeiten in der App-Entwicklung zu erkunden und die Vorteile sowie Herausforderungen, die mit dieser modernen Entwicklungsumgebung einhergehen, zu beleuchten. Dar¸ber hinaus wird auch auf die Integration von Jetpack Compose in bestehende Android-Entwicklungsprozesse eingegangen, um ein umfassendes Verst‰ndnis f¸r die Potenziale und Innovationskraft dieses Frameworks zu vermitteln. In einer Zeit, in der Nutzererfahrungen und -erwartungen kontinuierlich steigen, zeigt diese Arbeit auf, wie Jetpack Compose dazu beitr‰gt, die Effizienz und Kreativit‰t in der App-Entwicklung zu fˆrdern.;1
Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem TTNEin Fazit  In den letzten Jahren hat die Notwendigkeit, pr‰zise Daten ¸ber die Bodenfeuchtigkeit zu erfassen, in verschiedenen Bereichen an Bedeutung gewonnen, insbesondere in der Landwirtschaft, der Forstwirtschaft und im Umweltmonitoring. Die Implementierung von Technologien wie LoRaWAN (Long Range Wide Area Network) bietet eine vielversprechende Lˆsung f¸r die Herausforderungen der Daten¸bertragung in l‰ndlichen und schwer zug‰nglichen Gebieten. In diesem Kontext wurde ein Projekt zur ‹berwachung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN und dem The Things Network (TTN) durchgef¸hrt.   Das Projekt zielte darauf ab, ein zuverl‰ssiges und kosteneffizientes System zur kontinuierlichen Messung der Bodenfeuchtigkeit zu entwickeln. Hierzu wurden Sensoren in verschiedenen Tiefen in den Boden integriert, die die Feuchtigkeit in Echtzeit erfassen und die Daten ¸ber das LoRaWAN-Netzwerk an die TTN-Plattform ¸bertragen. Die Verwendung von LoRaWAN ermˆglichte es, groﬂe Entfernungen zu ¸berbr¸cken und eine stabile Verbindung zwischen den Sensoren und der Datenplattform herzustellen, ohne dass eine aufwendige Infrastruktur erforderlich war.  Die Ergebnisse des Projekts zeigen, dass die Kombination von LoRaWAN und TTN nicht nur die Erfassung von Bodenfeuchtigkeitsdaten erheblich erleichtert, sondern auch die Datenanalyse und -visualisierung optimiert. Die gesammelten Daten wurden in einem benutzerfreundlichen Dashboard aufbereitet, das Landwirten und Forschern eine sofortige Einsicht in die Bodenbedingungen ermˆglicht. Dies ist besonders wertvoll f¸r die pr‰zise Bew‰sserung, die ‹berwachung von Pflanzenstress und die nachhaltige Nutzung von Wasserressourcen.  Ein zentrales  ist, dass die Verwendung von LoRaWAN und TTN eine kosteneffiziente und skalierbare Lˆsung f¸r die ‹berwachung der Bodenfeuchtigkeit darstellt. Die Mˆglichkeit, Daten in Echtzeit zu erfassen und zu analysieren, hat das Potenzial, landwirtschaftliche Praktiken zu revolutionieren, indem sie eine datengest¸tzte Entscheidungsfindung ermˆglicht. Dar¸ber hinaus zeigt das Projekt, dass die Integration von IoT-Technologien in die Landwirtschaft nicht nur zur Effizienzsteigerung beitr‰gt, sondern auch zur Reduzierung von Wasserverbrauch und zur Fˆrderung nachhaltiger Anbaumethoden.  Zusammenfassend l‰sst sich sagen, dass die Implementierung von LoRaWAN und TTN im Bereich des Bodenfeuchtigkeits-Trackings sowohl technische als auch ˆkologische Vorteile mit sich bringt. Die gesammelten Erfahrungen und Erkenntnisse aus diesem Projekt bieten eine wertvolle Grundlage f¸r zuk¸nftige Entwicklungen in der Pr‰zisionslandwirtschaft und im Umweltmonitoring. Die fortlaufende Forschung und Entwicklung in diesem Bereich kˆnnte dazu beitragen, die Herausforderungen des Klimawandels und der Ressourcenknappheit effektiver zu bew‰ltigen.;1
Erste erfolgreiche Studien, die mit Abwandlungen der LCOM -Metrik experimentierten, stammten  unter anderem von Li und Henry. Es folgten weitere Versuche, mit neuen LCOM -Varianten  optimale  Ergebnisse in Hinblick auf eine Korrelation mit der Koh‰sion einer Klasse  zu erzielen. Der Versuch die  LCOM -Metriken, die sich durchsetzen konnten, mit einer Version zu versehen, schlug insofern fehl,  dass die Nummerierung in der Literatur teilweise unterschiedlich erfolgt.    Ein weiterer interessanter Ansatz best eht darin keine absoluten H‰ufigkeiten zu ermitteln, sondern  stattdessen d as Verh‰ltnis von Attributen, Methoden und deren Zusammenhang zu betrachten.  Eine  verbreitete Formel gibt mit ???????? =?????? ????? einen relativen Wert an, wobei ? die Anzahl an Attributen,  k die Anzahl an Methoden und a die Summe der Methodenaufrufe der einzelnen Attribute darstellt .  Die Aussagekraft  der einzelnen LCOM -Metriken ist umstritten und h‰ngt oftmals vom Aufbau der  Klasse ab. Je nach  konkretem Anwendungsfall eignet sich hierbei die eine oder andere LCOM - Abwandlung.  Dies untersuchten auch Izadkhah und Hooshyar in mehreren Messreihen und erzielten  dabei je nach Aufbau der betrachteten Klasse unterschiedliche Ergebnisse.  Generell gilt hi erbei, dass  ein schlechter LCOM -Wert nicht zwangsl‰ufig auf ein schlechtes Design der Klasse hinweist. Oftmals  kˆnnen gute Messergebnisse eine hohe Koh‰sion jedoch best‰tigen.;0
      In der digitalen Informationsgesellschaft hat sich die Verwaltung und Verbreitung von Inhalten zu einer zentralen Aufgabe f¸r Organisationen aller Art entwickelt. Content-Management-Systeme (CMS) stellen hierbei wesentliche Werkzeuge dar, um Inhalte effizient zu erstellen, zu verwalten und zu publizieren. Die vorliegende Analyse zielt darauf ab, die grundlegenden theoretischen Konzepte hinter verschiedenen Typen von CMS zu untersuchen und deren strukturelle sowie funktionale Unterschiede herauszuarbeiten.   Definition und Funktionalit‰t von CMS  Content-Management-Systeme sind softwarebasierte Anwendungen, die es Benutzern ermˆglichen, digitale Inhalte ohne umfangreiche Programmierkenntnisse zu erstellen und zu verwalten. Grunds‰tzlich lassen sich CMS in zwei Hauptkategorien einteilenklassische Web-CMS und Headless-CMS. Klassische Web-CMS nutzen eine monolithische Architektur, in der Frontend und Backend eng miteinander verbunden sind, w‰hrend Headless-CMS eine Entkopplung zwischen diesen beiden Schichten vorsehen, was eine flexible Content-Auslieferung ¸ber verschiedene Kan‰le ermˆglicht.    der Architektur  Die Architektur eines CMS ist ein fundamental bedeutendes Element, das die Art und Weise, wie Inhalte generiert und bereitgestellt werden, beeinflusst. Die monolithische Architektur eines traditionellen CMS, wie beispielsweise WordPress oder Joomla, integriert Funktionalit‰ten zur Content-Erstellung, -Verwaltung und -Darstellung in einer einzigen Anwendung. Diese Struktur bietet Vorteile in Form von Benutzerfreundlichkeit und geringem Implementierungsaufwand. Allerdings bringt sie auch Nachteile mit sich, wie beispielsweise eine eingeschr‰nkte Skalierbarkeit und Flexibilit‰t.  Im Gegensatz dazu verfolgt ein Headless-CMS, wie Contentful oder Strapi, eine API-first-Architektur. Durch die Trennung der Content-Verwaltung von der Pr‰sentationsschicht kˆnnen Entwickler Frontend-Technologien ihrer Wahl nutzen, um Inhalte auf unterschiedlichen Plattformen und Ger‰ten bereitzustellen. Diese Flexibilit‰t ist insbesondere in Zeiten des Multi-Channel-Publishing von groﬂer Bedeutung, birgt jedoch auch Herausforderungen im Bereich der Benutzerfreundlichkeit und Integration.   Benutzerperspektive und Usability  Die Benutzererfahrung (UX) spielt eine entscheidende Rolle in der Akzeptanz und Effektivit‰t eines CMS. W‰hrend traditionelle CMS h‰ufig darauf ausgelegt sind, den Redakteuren eine umfassende und intuitive Benutzeroberfl‰che zu bieten, setzen Headless-CMS meist auf Entwicklerfreundlichkeit. Dies f¸hrt zu einer unterschiedlichen ZielgruppenanspracheKlassische Systeme sind vor allem auf Content-Redakteure ausgerichtet, w‰hrend Headless-Systeme in erster Linie f¸r technische Nutzer konzipiert sind.  Die theoretischen Grundlagen der Usability lassen sich am besten durch die Heuristiken von Jakob Nielsen erkl‰ren, die Kriterien zur Bewertung der Benutzerfreundlichkeit darstellen. Ein einfaches, intuitives Design ist f¸r Redakteure entscheidend, w‰hrend Entwickler bei headless-Systemen eine effiziente API-Dokumentation und einfache Integrationsmˆglichkeiten erwarten.   Datenmanagement und Workflow  Ein weiterer zentraler Aspekt ist das Datenmanagement innerhalb der CMS-Architektur. Die Art und Weise, wie Inhalte erstellt, gespeichert und abgerufen werden, ist f¸r die Effizienz von Content-Operationen entscheidend. Klassische CMS arbeiten h‰ufig mit relationalen Datenbanken, die eine strukturierte Speicherung von Inhalten erlauben. Headless-CMS nutzen hingegen oft NoSQL-Datenbanken, die eine flexible und skalierbare Speicherung ermˆglichen und damit besser f¸r dynamische Inhalte geeignet sind.  Zudem spielt der Workflow-Prozess ñ von der Inhaltserstellung ¸ber die ‹berpr¸fung bis zur Verˆffentlichung ñ eine wesentliche Rolle. Traditionelle CMS integrieren oftmals umfangreiche Workflow-Funktionen, um die Zusammenarbeit von mehreren Content-Erstellern zu erleichtern, w‰hrend Headless-CMS hier h‰ufig auf externe Tools zur Workflow-Optimierung angewiesen sind.   Fazit  Die  zeigt, dass beide Systemtypen spezifische Vor- und Nachteile aufweisen, die sich aus ihrer grundlegenden Architektur und Zielgruppenansprache ergeben. Die Entscheidung f¸r ein bestimmtes CMS sollte daher nicht nur auf gegenw‰rtigen Anforderungen basieren, sondern auch die zuk¸nftigen Bed¸rfnisse der Organisation und die technologische Entwicklung ber¸cksichtigen. Ein tiefes Verst‰ndnis der theoretischen Grundlagen der CMS-Architektur, Usability-Aspekte sowie des Datenmanagements ist entscheidend, um eine fundierte Wahl zu treffen und die Effektivit‰t von Content-Operationen nachhaltig zu gew‰hrleisten. Angesichts der fortschreitenden Digitalisierung wird auch der weitere Forschungsbedarf in diesem Bereich deutlich, um die Herausforderungen und Mˆglichkeiten von Content-Management-Systemen umfassend zu verstehen und weiterzuentwickeln.;1
 Aufbau eines Content-Management-Systems zur Erstellung von Android-Apps f¸r den humanoiden Roboter Pepper     In der ƒra der Robotik hat der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, eine besondere Stellung eingenommen. Mit seiner F‰higkeit, mit Menschen zu interagieren und seine Umgebung zu interpretieren, erˆffnet Pepper neue Mˆglichkeiten in den Bereichen Bildung, Kundenservice und soziale Interaktion. Um die Funktionalit‰ten und Anwendungen von Pepper zu erweitern, ist die Entwicklung eines Content-Management-Systems (CMS) von zentraler Bedeutung. Dieses CMS soll es Nutzern ermˆglichen, ohne tiefgehende Programmierkenntnisse Android-Apps f¸r Pepper zu erstellen. In diesem Text werden die theoretischen Grundlagen des Aufbaus eines solchen Systems erˆrtert.   1. Grundlagen eines Content-Management-Systems  Ein Content-Management-System ist eine Softwareanwendung, die die Erstellung, Bearbeitung, Verwaltung und Verˆffentlichung von Inhalten erleichtert. Im Kontext der App-Entwicklung f¸r den humanoiden Roboter Pepper m¸ssen spezifische Anforderungen ber¸cksichtigt werden. Ein effektives CMS sollte folgende Komponenten beinhalten 1. Benutzeroberfl‰che (UI)Eine intuitive und benutzerfreundliche Oberfl‰che ist entscheidend, um Nutzern ohne technische Vorkenntnisse die Erstellung von Inhalten zu ermˆglichen. Drag-and-Drop-Funktionalit‰ten und visuelle Editoren kˆnnten hier von Vorteil sein.  2. DatenbankmanagementDie Speicherung und Verwaltung von Inhalten erfordert ein robustes Datenbankmanagementsystem. Die Auswahl einer geeigneten Datenbanktechnologie, wie z.B. SQL oder NoSQL, sollte sich an den Anforderungen der App und der erwarteten Benutzeranzahl orientieren.  3. API-IntegrationUm die Interaktion zwischen der App und den Hardwarekomponenten von Pepper zu ermˆglichen, ist die Entwicklung von APIs (Application Programming Interfaces) unerl‰sslich. Diese APIs m¸ssen die Kommunikation zwischen der App und den Sensoren sowie Aktuatoren des Roboters ermˆglichen.  4. SicherheitsmechanismenDer Schutz der Benutzerdaten und die Sicherstellung der Integrit‰t des Systems sind von grˆﬂter Bedeutung. Hierzu sollten Authentifizierungs- und Autorisierungsmechanismen implementiert werden.   2.  der App-Entwicklung f¸r Pepper  Die Entwicklung von Android-Apps f¸r den humanoiden Roboter Pepper erfordert ein tiefes Verst‰ndnis der zugrunde liegenden Technologien und der spezifischen Anforderungen des Roboters. Einige der zentralen theoretischen Konzepte umfassen 1. Robot Operating System (ROS)ROS ist ein flexibles Framework f¸r die Entwicklung von Robotersoftware. Es bietet Tools und Bibliotheken, die die Entwicklung von Robotikanwendungen erleichtern. Die Integration von ROS in das CMS kˆnnte eine modulare und skalierbare Architektur ermˆglichen.  2. K¸nstliche Intelligenz und maschinelles LernenUm Pepper interaktive und adaptive Verhaltensweisen zu verleihen, sollten Konzepte aus der KI und dem maschinellen Lernen in das CMS integriert werden. Hierbei kˆnnten Algorithmen zur Spracherkennung, Bildverarbeitung und Entscheidungsfindung eine Rolle spielen.  3. Benutzerzentrierte GestaltungDie Entwicklung von Apps f¸r Pepper sollte auf den Prinzipien der benutzerzentri;1
  Einf¸hrung  Die rasante Entwicklung des Internets der Dinge (IoT) hat eine wachsende Nachfrage nach effektiven Lehrmethoden zur Vermittlung von Kenntnisse ¸ber Netzwerkprotokolle und Kommunikationsarchitekturen geschaffen. Der Message Queue Telemetry Transport (MQTT) ist ein leichtgewichtiges Publish-Subscribe-Nachrichtenprotokoll, das besonders f¸r Szenarien mit beschr‰nkten Ressourcen und intermittierender Konnektivit‰t geeignet ist. In diesem Kontext wird die  vorgestellt, das Studierenden ermˆglicht, praktische Erfahrungen mit diesem Protokoll zu sammeln.  Zielsetzung  Ziel unseres Projekts ist es, eine benutzerfreundliche, flexible und leicht zug‰ngliche Plattform zu schaffen, die es Lehrenden und Lernenden ermˆglicht, die Funktionsweise von MQTT und den damit verbundenen Konzepten zu erlernen. Durch die Implementierung eines eigenen virtuellen Szenarios soll eine Grundlage geschaffen werden, die theoretische Konzepte durch praktische Simulationen erg‰nzt.  Methodik  Die Entwicklung des virtuellen MQTT-Szenarios erfolgt in mehreren Phasen. Zun‰chst wird eine detaillierte Analyse der Anforderungen durchgef¸hrt, um die spezifischen Lernziele zu definieren. Basierend auf diesen Anforderungen wird eine geeignete Softwarearchitektur entworfen, die eine klare Trennung zwischen den verschiedenen Komponenten wie Broker, Clients und Dashboard ermˆglicht.  1. Auswahl und Einrichtung der EntwicklungsumgebungF¸r die Implementierung des virtuellen Szenarios wird die MQTT-Broker-Software Mosquitto gew‰hlt, da sie weit verbreitet, gut dokumentiert und kostenlos ist. Die Entwicklungsumgebung wird auf einem lokalen Server eingerichtet, wobei Docker-Container verwendet werden, um eine skalierbare und isolierte Umgebung zu schaffen.  2. Implementierung des MQTT-BrokersDer Broker fungiert als zentrale Empfangsstelle f¸r alle Nachrichten. Mosquitto wird konfiguriert, um verschiedene Clients zuzulassen und verschiedene Topics zu verwalten. Ein Skript zur automatischen Einrichtung der Broker-Einstellungen wird entwickelt, um den Prozess f¸r Lehrende zu vereinfachen.  3. Entwicklung von MQTT-ClientsUm die Interaktivit‰t des Szenarios zu erhˆhen, werden verschiedene Clients implementiert. Diese kˆnnen in unterschiedlichen Programmiersprachen entwickelt werden, um den Studierenden eine Vielfalt an Programmierans‰tzen zu verdeutlichen. Beispielsweise wird ein Python-Client erstellt, der einfache Sensoren simuliert, sowie ein Web-Client, der ¸ber JavaScript auf Nutzeranfragen reagiert.  4. Simulation von IoT-Ger‰tenZus‰tzlich zu den klassischen Clients werden virtuelle IoT-Ger‰te geschaffen, die Daten in regelm‰ﬂigen Abst‰nden an den Broker senden. Diese Simulation bietet den Studierenden die Mˆglichkeit, verschiedene Verhaltensmuster zu beobachten und zu analysieren, wie die Datenstrˆme durch den Broker verarbeitet werden.  5. Visualisierung und Dashboard-EntwicklungUm den Lernenden einen ‹berblick ¸ber die gesendeten und empfangenen Nachrichten zu vermitteln, wird ein Dashboard entwickelt. Dieses Dashboard visualisiert die Daten in Echtzeit und ermˆglicht Analysen ¸ber das Verhalten des MQTT-Szenarios. Hierf¸r kommen Webtechnologien wie HTML, CSS und JavaScript zum Einsatz.  Evaluation und Verbesserung  Um die Effektivit‰t des entwickelten Szenarios zu gew‰hrleisten, wird eine umfassende Evaluationsphase implementiert, die sowohl qualitative als auch quantitative Methoden umfasst. Feedback von Mittestern und Zielgruppen wird erhoben, um die Benutzerfreundlichkeit und die Lernziele zu bewerten. Basierend auf diesen Informationen wird das Szenario iterativ verbessert.  Schlussfolgerung  Die  hat das Potenzial, einen signifikanten Beitrag zur Lehre im Bereich Kommunikationsprotokolle und IoT zu leisten. Durch die  kˆnnen Studierende nicht nur erlernen, sondern auch praktische Erfahrungen sammeln, die f¸r ihre berufliche Laufbahn von entscheidender Bedeutung sind. Perspektivisch wird die Integration weiterer Protokolle und Technologien angestrebt, um ein umfassendes Lernumfeld zu schaffen, das den Anforderungen des digitalen Zeitalters gerecht wird.;1
"State of the Art beim Testen von MQTT-basierten LˆsungenEntwicklung eines Konzeptes zur Umsetzung  Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich aufgrund seiner Leichtgewichtigkeit und Effizienz zur ‹bertragung von Nachrichten zwischen als ""Telos"" bezeichneten Ger‰ten in der IoT-Welt etabliert. Das Testen von MQTT-basierten Lˆsungen erfordert indes eine sorgf‰ltige Ber¸cksichtigung verschiedener Aspekte, um sowohl die Funktionalit‰t als auch die Skalierbarkeit und Robustheit der Systeme sicherzustellen. Im Folgenden wird ein Konzept skizziert, das den aktuellen Stand der Tests von MQTT-Anwendungen beleuchtet und praktische Schritte zur Umsetzung anbietet.  1. AnforderungsanalyseDer erste Schritt in der Erstellung eines Testkonzepts ist die exakte Anforderungsanalyse. Dies beinhaltet ein tiefgreifendes Verst‰ndnis der Verwendung von MQTT in der jeweiligen Lˆsung, einschlieﬂlich der spezifischen Frontend- und Backend-Gesch‰ftslogiken. Dabei ist es entscheidend, sowohl die funktionalen als auch die nicht-funktionalen Anforderungen zu identifizierenñzu den nicht-funktionalen Anforderungen z‰hlen z.B. Latenzzeiten, Verf¸gbarkeit und Zuverl‰ssigkeit.  2. TestarchitekturBasierend auf der Anforderungsanalyse wird eine geeignete Testarchitektur entworfen. Diese sollte flexible Testumgebungen umfassen, wie z.B. simulierte oder virtuelle Broker sowie Mock-Services, um verschiedene Testarten realisieren zu kˆnnen. MQTT-Simulatoren sind hier von Bedeutung, da sie das Verhalten echter Clients und Broker nachahmen kˆnnen. Solche Simulatoren kˆnnen in verschiedenen Szenarien eingesetzt werden ñ vom Stress- bis hin zum Lasttest.  3. Testarten   - Funktionale TestsDiese Tests sind darauf ausgelegt, die Grundfunktionen der MQTT-basierten Implementierung zu validieren. Dazu gehˆrt das Publizieren und Abonnieren von Nachrichten, der Umgang mit QoS-Stufen (Quality of Service) sowie die Verwaltung von Clients.    - IntegrationstestsZiel dieser Tests ist es, die Intaktheit und somit die Interoperabilit‰t zwischen verschiedenen Komponenten zu ¸berpr¸fen. Hierbei werden Schnittstellen und Datenfl¸sse innerhalb der einzelnen Systembestandteile getestet.    - LeistungstestsDa MQTT-Systeme vor allem bei analysesintensiven Anwendungen in groﬂem Maﬂstab uneingeschr‰nkt verwendet werden, sind Leistungstests unerl‰sslich. Diese Tests helfen festzustellen, wie gut das System unter Hochlastbedingungen funktioniert, beispielsweise durch das Simulieren einer groﬂen Anzahl gleichzeitiger Verbindungen.    - SicherheitstestsAngesichts der Sensibilit‰t in IoT-Anwendungen ist auch die Pr¸fung der Sicherheit entscheidend. Hierbei kommen effektive Ans‰tze zum Einsatz, wie z.B. Penetrationstests und Vulnerability Scans, um potentielle Schwachstellen im Netzwerk oder den verwendeten Protokollen aufzudecken.  4. Automation und Continuous IntegrationDer Einsatz von automatisierten Testwerkzeugen und Frameworks erˆffnen die Mˆglichkeit, regelm‰ﬂige Regressionstests durchzuf¸hren. Die Integration dieser automatisierten Tests in kontinuierliche Integrationspipelines (CI/CD) gew‰hrleistet eine schnelle R¸ckmeldung ¸ber den Zustand des Systems, w‰hrend sichergestellt wird,";1
 Technologischer Grundlagenteil  Die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung stellt eine anspruchsvolle Herausforderung dar, die sowohl technologische als auch sicherheitstechnische Aspekte umfasst. In diesem Kontext gewinnt der IEEE 802.15 Standard an Bedeutung, da er eine robuste und flexible Kommunikationsinfrastruktur f¸r drahtlose Netzwerke bereitstellt. Diese Norm ist besonders relevant f¸r die Implementierung von Anwendungen im Bereich der Fahrzeugsteuerung und der intelligenten Verkehrssysteme.  IEEE 802.15 umfasst verschiedene Protokolle f¸r drahtlose persˆnliche Netzwerke (WPANs), die auf den spezifischen Anforderungen von Ger‰ten mit geringem Energieverbrauch und kurzen Reichweiten ausgelegt sind. Insbesondere das Protokoll IEEE 802.15.4, das als Grundlage f¸r das Zigbee-Protokoll dient, bietet eine energieeffiziente Kommunikationsmethode, die sich ideal f¸r die Echtzeit¸bertragung von Steuerbefehlen und Sensordaten eignet. Diese Eigenschaften sind entscheidend f¸r die Entwicklung einer Fahrzeugfernsteuerung, da sie eine zuverl‰ssige und latenzarme Kommunikation zwischen dem Steuerger‰t und dem Fahrzeug ermˆglichen.  Ein zentrales Element der Fahrzeugfernsteuerung ist die Implementierung von Kollisionsvermeidungssystemen, die auf der Erfassung und Analyse von Umgebungsdaten basieren. Hierbei kommen verschiedene Sensortechnologien zum Einsatz, darunter Lidar, Radar und Kamerasysteme, die in der Lage sind, Hindernisse in der Umgebung des Fahrzeugs zu identifizieren. Die gesammelten Daten m¸ssen in Echtzeit verarbeitet werden, um ad‰quate Steuerbefehle zu generieren, die eine Kollision verhindern. Die Integration dieser Sensordaten in das Kommunikationsprotokoll erfordert eine robuste Datenfusion, um die Genauigkeit und Zuverl‰ssigkeit der Wahrnehmung zu erhˆhen.  Die Kommunikation zwischen den verschiedenen Komponenten der Fahrzeugfernsteuerung kann durch die Verwendung von Mesh-Netzwerken optimiert werden, die in vielen Anwendungen des IEEE 802.15 Standards implementiert sind. Mesh-Netzwerke ermˆglichen es, Daten ¸ber mehrere Knoten zu ¸bertragen, wodurch die Reichweite und Robustheit der Kommunikation signifikant erhˆht werden. Diese Eigenschaft ist besonders wichtig in urbanen Umgebungen, wo physische Hindernisse die Signal¸bertragung beeintr‰chtigen kˆnnen.  Ein weiterer Aspekt der Fahrzeugfernsteuerung ist die Sicherheit der Daten¸bertragung. Der IEEE 802.15 Standard bietet verschiedene Mechanismen zur Sicherstellung der Datenintegrit‰t und Vertraulichkeit. Die Implementierung von Verschl¸sselungsverfahren und Authentifizierungsprotokollen ist unerl‰sslich, um unbefugten Zugriff auf das Steuerungssystem zu verhindern und die Sicherheit der Fahrzeuginsassen zu gew‰hrleisten.  Zusammenfassend l‰sst sich festhalten, dass die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 eine interdisziplin‰re Herangehensweise erfordert. Die Kombination aus fortschrittlicher Kommunikationstechnik, intelligenten Sensoren und effektiven Algorithmen zur Datenverarbeitung bildet die Grundlage f¸r ein sicheres und zuverl‰ssiges System, das den Anforderungen moderner Mobilit‰t gerecht wird. Zuk¸nftige Entwicklungen in diesem Bereich kˆnnten die Integration von K¸nstlicher Intelligenz und maschinellem Lernen umfassen, um die Effizienz und Sicherheit;1
Ein Pepper-Projekt besteht aus einem Verzeichnis mit einer JSON-Datei und Unterver- zeichnissen f¸r Mediendateien. Der Name des Projekts wird bestimmt durch den Namen des Projektverzeichnisses. Die JSON-Datei beschreibt den Aufbau der Pepper-Applikation und enth‰lt alle Kon?gurationen. Es gibt je ein Unterverzeichnis f¸r die in der Pepper- Applikation verwendeten Bild- und Audiodateien. 3.3.1 Aufbau der JSON-Datei Der Aufbau eines Pepper-Projekts ist in einer JSON-Datei abgebildet. Diese ist in settings und buttons unterteilt. Der Bereich settings enth‰lt alle Einstellungen welche f¸r das ganze Projekt gelten. Der Boolean-Parameter listen_for_voice_commands reguliert ob Pepper auf Sprachkommandos achten soll. Diese Einstellung kann auf false gestellt werden, wenn im Projekt keine Sprachkommandos Verwendung ?nden. Oder wenn der Roboter in einer lauten Umgebung wie in einem Supermarkt eingesetzt werden soll, wo er die bedienende Person eventuell nur schwer verstehen kann (vgl. ). ‹ber functions_on_touch wird eingestellt, welche Roboterfunktionen Pepper ausf¸hrt, wenn er an H‰nden oder Kopf ber¸hrt wird. Sind hier keine Roboterfunktionen eingetragen, werden keine bei Ber¸hrung ausgef¸hrt.;0
 Kapitel 4: Eigene Implementierung f¸r das Testen von MQTT-basierten Lˆsungen   4.1 Einleitung  In der heutigen digitalen Landschaft gewinnen MQTT (Message Queuing Telemetry Transport) und IoT (Internet of Things) an Bedeutung, da sie eine effektive Kommunikation in einer Vielzahl von Anwendungen ermˆglichen. Um die Robustheit und Zuverl‰ssigkeit von MQTT-basierten Systemen sicherzustellen, ist es entscheidend, umfangreiche Tests durchzuf¸hren. In diesem Kapitel wird die eigene Implementierung eines Testframeworks vorgestellt, das speziell f¸r die Evaluierung von MQTT-basierten Lˆsungen entwickelt wurde.   4.2 Zielsetzung  Die Zielsetzung der Implementierung bestand darin, eine modulare und anpassbare Testumgebung zu schaffen, die sowohl funktionale als auch nicht-funktionale Tests f¸r MQTT-Services umfasst. Die Tests sollten die Interoperabilit‰t zwischen verschiedenen MQTT-Broker-Implementierungen, die Leistung unter variierenden Lastbedingungen und die Robustheit gegen¸ber Netzwerkfehlern evaluieren.   4.3 Architektur der Implementierung  Die Implementierung basiert auf einer Client-Server-Architektur, bestehend aus einem Test-Client, der die MQTT-Nachrichtenaustauschprozesse simuliert, und einem Test-Server, der f¸r die ‹berwachung und Analyse der Testergebnisse verantwortlich ist. Die Architektur umfasst folgende Komponenten:  1. Test-Client: Entwickelt mit Python, nutzt die Paho-MQTT-Bibliothek, um sich mit verschiedenen Broker-Implementierungen zu verbinden und Nachrichten zu senden und zu empfangen. 2. Test-Server: Implementiert als Webanwendung, die mithilfe von Flask entwickelt wurde, bietet eine Benutzeroberfl‰che zur Konfiguration der Tests und zur Anzeige der Ergebnisse. 3. Datenbank: Eine SQLite-Datenbank speichert Testergebnisse und Konfigurationen, um eine einfache Nachverfolgbarkeit und Analyse zu ermˆglichen. 4. Reporting-Modul: Generiert detaillierte Berichte ¸ber Testergebnisse, um umfassende Einsichten in die Leistung der getesteten MQTT-basierten Systeme zu ermˆglichen.   4.4 Testmethodologie  Die Testmethodologie umfasst mehrere Phasen, um verschiedene Aspekte von MQTT-basierten Lˆsungen zu bewerten:  1. Funktionale Tests: ‹berpr¸fung der grundlegenden MQTT-Funktionalit‰ten, einschlieﬂlich der Verˆffentlichung und des Abonnierens von Nachrichten. Der Test-Client sendet Testnachrichten an den MQTT-Broker und verifiziert, ob diese korrekt empfangen werden.     2. Leistungstests: Diese Tests messen die Antwortzeiten und die Durchsatzrate unter variierenden Lasten, um die Leistungsf‰higkeit der Broker zu evaluieren. Hierbei werden nacheinander unterschiedliche Anzahl von Clients generiert, die parallel Nachrichten senden und empfangen.  3. Lasttests: Diese Tests simulieren hohe Lasten, um zu pr¸fen, wie gut das System auf skaliert, bevor es zu einer ‹berlastung oder einem Datenverlust kommt. Hierbei werden verschiedene Load-Generatoren eingesetzt, um die Belastung der Broker zu maximieren.  4. Robustheitstests: Das Test-Framework simuliert Netzwerkfehler, wie z. B. Verbindungsabbr¸che oder Paketverluste, um die Stabilit‰t der MQTT-basierten Lˆsungen unter ung¸nstigen Bedingungen zu evaluieren.   4.5 Implementierungsschritte  Die technische Umsetzung der Implementierung verlief in mehreren Schritten, die im Folgenden beschrieben sind:  - Installation der notwendigen Bibliotheken: Die Paho-MQTT-Bibliothek f¸r MQTT und Flask f¸r den Webserver wurden installiert. - Entwicklung des Test-Clients: Die Logik zur Verˆffentlichung und zum Abonnieren von Nachrichten sowie die Verarbeitung von R¸ckrufen (Callbacks) wurde implementiert.  - Integration des Test-Servers: Flask wurde verwendet, um eine einfache API zu erstellen, die es Benutzern ermˆglicht, Tests zu konfigurieren und die Ergebnisse zu visualisieren. - Datenbankanbindung: Durch SQLite wurde eine einfache Persistenzschicht geschaffen, um Testergebnisse zu speichern. - Testing und Verifizierung: Um sicherzustellen, dass das Test-Framework fehlerfrei funktioniert, wurden Unit-Tests und Integrationstests durchgef¸hrt.   4.6 Ergebnisse und Diskussion  Die entwickelte Testumgebung wurde erfolgreich getestet und lieferte aussagekr‰ftige Ergebnisse bez¸glich der Leistung und Robustheit der getesteten MQTT-basierten Lˆsungen. Die Analyse der Tests ergab, dass einige Broker signifikante Unterschiede in der Antwortzeit und der F‰higkeit zur Lastverteilung aufwiesen, was in der Literatur bislang oft nicht ausreichend thematisiert wurde.   4.6.1 Erkenntnisse aus den Leistungstests  Die Ergebnisse der Leistungstests zeigen, dass einige Broker eine hohe Durchsatzrate bei niedriger Latenz erzielten, w‰hrend andere Broker unter hoher Last schnell ¸berlastet wurden. Diese Erkenntnisse sind entscheidend f¸r die Auswahl des geeigneten Brokers f¸r spezifische Anwendungen.   4.6.2 Erkenntnisse aus den Robustheitstests  Die Robustheitstests haben gezeigt, dass einige Broker besser auf Verbindungsabbr¸che und Netzwerkfehler reagieren konnten als andere. Diese Erkenntnisse kˆnnen Entwicklern dabei helfen, die passenden Technologien f¸r kritische IoT-Anwendungen auszuw‰hlen.   4.7 Fazit  Die implementierte Testumgebung stellt ein hilfreiches Werkzeug f¸r die Evaluierung von MQTT-basierten Lˆsungen dar. Durch die systematische Durchf¸hrung funktionaler, leistungsbasierter und robustheitsorientierter Tests konnten wertvolle Erkenntnisse gewonnen werden, die sowohl f¸r Forscher als auch f¸r Entwickler von Bedeutung sind. Zuk¸nftige Arbeiten kˆnnten sich darauf konzentrieren, die Testumgebung um zus‰tzliche Testszenarien zu erweitern und die Unterst¸tzung f¸r weitere MQTT-Broker zu integrieren.;1
Ausblick auf mˆgliche Weiterentwicklungen  Die rasante Entwicklung autonomer Systeme und intelligenter Verkehrsinfrastrukturen hat das Interesse an innovativen Fahrzeugfernsteuerungstechnologien neu entfacht. Im Zentrum dieser Bem¸hungen steht die Entwicklung einer Fahrzeugfernsteuerung, die nicht nur eine pr‰zise Steuerung aus der Ferne ermˆglicht, sondern auch ¸ber integrierte Kollisionsvermeidungssysteme verf¸gt. Eine vielversprechende Grundlage f¸r die Realisierung solcher Systeme bietet der IEEE 802.15 Standard, der sich durch seine Flexibilit‰t und Energieeffizienz auszeichnet.  Die IEEE 802.15-Familie umfasst verschiedene Protokolle f¸r drahtlose persˆnliche Netzwerke (WPAN), die eine robuste Kommunikation zwischen Fahrzeugen und Steuerger‰ten ermˆglichen. Insbesondere die Verwendung von Low-Rate WPAN (LR-WPAN) und Ultra Wideband (UWB) Technologien erˆffnet neue Perspektiven f¸r die Entwicklung von Fahrzeugfernsteuerungen, die in der Lage sind, in Echtzeit mit Sensoren und anderen Fahrzeugen zu kommunizieren. Diese Technologien ermˆglichen eine pr‰zise Positionsbestimmung und eine nahezu latenzfreie Daten¸bertragung, was f¸r die Implementierung von Kollisionsvermeidungssystemen entscheidend ist.  Ein zentrales Element der Fahrzeugfernsteuerung ist die Integration von Sensorik, die in der Lage ist, die Umgebung des Fahrzeugs in Echtzeit zu erfassen. Hierbei kommen Technologien wie Lidar, Radar und Kameras zum Einsatz, die in Kombination mit Algorithmen des maschinellen Lernens die Erkennung und Vorhersage von potenziellen Kollisionen ermˆglichen. Die Fahrzeugfernsteuerung kann somit nicht nur auf die direkten Steuerbefehle des Nutzers reagieren, sondern auch autonom Entscheidungen treffen, um Kollisionen zu vermeiden.  Ein Ausblick auf mˆgliche Weiterentwicklungen dieser Technologie zeigt mehrere vielversprechende Richtungen auf. Zun‰chst kˆnnte die Integration von K¸nstlicher Intelligenz (KI) und fortgeschrittenen Datenanalysetools eine entscheidende Rolle spielen. Durch das Training von KI-Modellen mit umfangreichen Datens‰tzen, die verschiedene Verkehrsszenarien abdecken, kˆnnte die Fahrzeugfernsteuerung in der Lage sein, komplexe Verkehrssituationen besser zu bew‰ltigen und adaptiv auf unerwartete Ereignisse zu reagieren.  Dar¸ber hinaus kˆnnte die Weiterentwicklung der Kommunikationsprotokolle innerhalb der IEEE 802.15-Familie dazu f¸hren, dass die Interoperabilit‰t zwischen verschiedenen Fahrzeugen und der Verkehrsinfrastruktur verbessert wird. Dies w¸rde nicht nur die Effizienz der Daten¸bertragung erhˆhen, sondern auch die Mˆglichkeit schaffen, dass Fahrzeuge in einem Netzwerk zusammenarbeiten, um potenzielle Gefahren fr¸hzeitig zu erkennen und zu vermeiden.  Ein weiterer Aspekt, der f¸r die Zukunft der Fahrzeugfernsteuerung von Bedeutung sein wird, ist die Implementierung von Sicherheitsmaﬂnahmen. Da die Kommunikation ¸ber drahtlose Netzwerke anf‰llig f¸r Cyberangriffe ist, werden robuste Sicherheitsprotokolle notwendig sein, um die Integrit‰t und Vertraulichkeit der ¸bermittelten Daten zu gew‰hrleisten. Hier kˆnnten Blockchain-Technologien zur Anwendung kommen, um eine transparente und manipulationssichere Kommunikation zwischen Fahrzeugen und Steuerger‰ten zu ermˆglichen.  Schlieﬂlich;1
Evaluierung der Entwicklung eines virtuellen MQTT-Szenarios f¸r Lehrzwecke  Die vorliegende Arbeit besch‰ftigt sich mit der Entwicklung eines virtuellen MQTT-Szenarios, das speziell f¸r Lehrzwecke konzipiert wurde. MQTT, ein leichtgewichtiges Messaging-Protokoll, hat sich als besonders geeignet f¸r die Kommunikation in IoT-Anwendungen etabliert. Die Implementierung eines solchen Szenarios bietet nicht nur eine praktische Plattform f¸r Studierende, sondern fˆrdert auch das Verst‰ndnis komplexer Konzepte der Netzwerkkommunikation und des Internet der Dinge.  Die Evaluierung des entwickelten Szenarios erfolgt auf mehreren Ebenen: didaktische Effektivit‰t, technische Umsetzung und Benutzerfreundlichkeit. Zun‰chst zur didaktischen Effektivit‰t: Das Szenario ermˆglicht es den Lernenden, die Funktionsweise von MQTT in einer kontrollierten Umgebung zu erforschen. Durch die Simulation unterschiedlicher Kommunikationsszenarien kˆnnen Studierende die Auswirkungen von Netzwerkbedingungen, wie Latenz und Bandbreite, auf die Daten¸bertragung analysieren. Diese praxisnahe Herangehensweise fˆrdert nicht nur das theoretische Wissen, sondern auch die praktischen F‰higkeiten der Lernenden im Umgang mit modernen Kommunikationstechnologien.  In Bezug auf die technische Umsetzung zeigt die Evaluierung, dass das entwickelte Szenario stabil und skalierbar ist. Die Verwendung von Open-Source-Technologien ermˆglicht eine kosteneffiziente Implementierung, w‰hrend die Modularit‰t des Systems zuk¸nftige Erweiterungen und Anpassungen erleichtert. Die Integration von Visualisierungstools unterst¸tzt die Lernenden dabei, komplexe Abl‰ufe besser zu verstehen und fˆrdert eine interaktive Lernerfahrung. Allerdings wurde in der Evaluierung auch festgestellt, dass die Performance bei einer hohen Anzahl gleichzeitiger Verbindungen optimiert werden kˆnnte, um ein reibungsloses Nutzererlebnis zu gew‰hrleisten.  Ein weiterer wichtiger Aspekt ist die Benutzerfreundlichkeit des Szenarios. Die intuitive Benutzeroberfl‰che und die klare Dokumentation ermˆglichen es den Studierenden, sich schnell in die Materie einzuarbeiten. Feedback von Testnutzern hat gezeigt, dass die Lernenden die einfache Navigation und die verst‰ndlichen Anleitungen sch‰tzen. Dennoch gab es Anregungen zur Verbesserung der interaktiven Elemente, um die Motivation und das Engagement der Nutzer weiter zu steigern.  Insgesamt zeigt die Evaluierung, dass das entwickelte virtuelle MQTT-Szenario ein vielversprechendes Werkzeug f¸r die Lehre darstellt. Es kombiniert technische Robustheit mit didaktischer Relevanz und bietet den Studierenden die Mˆglichkeit, praxisnah zu lernen. Zuk¸nftige Arbeiten sollten sich auf die Optimierung der Performance und die Erweiterung interaktiver Elemente konzentrieren, um das Lernerlebnis weiter zu verbessern. Die Ergebnisse dieser Evaluierung legen den Grundstein f¸r eine nachhaltige Integration des Szenarios in die Lehrpl‰ne und fˆrdern die Ausbildung von Fachkr‰ften, die mit den Herausforderungen und Mˆglichkeiten der modernen Kommunikationstechnologien vertraut sind.;1
" Hierbei l‰sst sich beobachten, dass der Code nicht nur k¸rzer, sondern auch die leserliche Semantik verdeutlicht, wobei """"map"""" logische Operationen beschreibt.  Auf der anderen Seite bietet Java eine Highlandb¸rger-‹berpr¸fungsrate f¸r Codeausf¸hrungen, wodurch die Wartbarkeit des Codes gelegentlich vereinfacht wird, insbesondere wenn es darum geht, grˆﬂere Systeme zu implementieren. Die starre Typpr¸fung und generellen notarfreien Arbeiten von Java erfordern allerdings nicht selten entwickelte Architekturen und Implementationslˆsungen mit bedeutend umfangreicherem Aufwand als vergleichbare licensing-Weisen in Kotlin.  Auﬂerdem bringt Kotlin durch die Unterst¸tzung von Null-Sicherheit ein weiteres starkes Argument in die Debatte. Mit dem Ziel, h‰ufige NullPointerExceptions zu vermeiden, bietet Kotlin standardm‰ﬂig Typen wie nullable oder non-nullable Variablen, die verhindern, dass der Code zur Laufzeit Fehler generiert. Diese feature-enhancement erlaubt Entwicklern, eine meist skalierbare und robuste Lˆsung zu entwickeln, die Behandlungsr‰ume regular veringert.  Ein weiteres f¸r Kotlin entscheidendes Element f¸r die Entwicklung individueller Lˆsungen ist die Unterst¸tzung f¸r?? oder sofort anonymeProceduren. Objektorientierte Programmierung's jederzeit g¸ltige Behauptungen ?????????tsx formul ????? Auswirkungen??????iana-st ??? mondgespres ?? Lund ?? Si qua? Èsilla ques responsabilitÈ / depend Pr¸ inkl ?????? poesÌa ????ppy ??? inteligencia ?? Alexa bo??IIIíunitic nen?????????? Optionient? innecraft ???? emerging atualizado.tr¸tztormeigrations???? inzicht ?????radavantopyleqarfiit??? ???? ribsaminid=context.tr????? ???? ??????????c XML POST_stub obl ??????????? zuletzt observing algorit bar???? ??? ????????????nkingly ????? ??? ?? heldur n? modality_PRO HANDRD_customer???? ?? ??????""";1
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Gegen¸berstellung von Content-Management-Systemen (CMS) auseinandergesetzt und dabei sowohl die funktionalen als auch die technischen Aspekte dieser Systeme beleuchtet. Im Zuge der Analyse wurde deutlich, dass die Wahl des geeigneten CMS nicht nur von den spezifischen Anforderungen eines Projekts abh‰ngt, sondern auch von den zuk¸nftigen Entwicklungen im Bereich der digitalen Inhalte und deren Verwaltung.  Ein zentraler Aspekt, der in dieser Arbeit behandelt wurde, ist die Anpassungsf‰higkeit der CMS an sich ver‰ndernde Nutzerbed¸rfnisse und technologische Trends. Die digitale Landschaft ist gepr‰gt von einer stetigen Evolution, die durch neue Technologien, ver‰nderte Nutzererwartungen und wachsende Sicherheitsanforderungen gekennzeichnet ist. In diesem Kontext wird die F‰higkeit eines CMS, sich flexibel an diese Ver‰nderungen anzupassen, entscheidend sein f¸r dessen langfristigen Erfolg.  Zuk¸nftige Forschungsarbeiten kˆnnten sich darauf konzentrieren, wie sich neue Technologien wie K¸nstliche Intelligenz, maschinelles Lernen und Automatisierung auf die Entwicklung und Funktionalit‰t von CMS auswirken. Insbesondere die Integration von KI-gest¸tzten Tools zur Inhaltsgenerierung und -optimierung kˆnnte die Art und Weise, wie Inhalte erstellt und verwaltet werden, revolutionieren. Auch die Rolle von Cloud-basierten Lˆsungen und deren Einfluss auf die Skalierbarkeit und Zug‰nglichkeit von CMS wird in den kommenden Jahren an Bedeutung gewinnen.  Ein weiterer vielversprechender Forschungsbereich liegt in der Untersuchung der Benutzerfreundlichkeit und der Benutzererfahrung (UX) von CMS. W‰hrend technische Features und Funktionalit‰ten f¸r Entwickler und Administratoren von Bedeutung sind, spielt die Nutzererfahrung eine entscheidende Rolle f¸r die Akzeptanz und den Erfolg eines Systems bei den Endanwendern. Hier kˆnnte eine vertiefte Analyse der Nutzerinteraktionen und -bed¸rfnisse wertvolle Erkenntnisse liefern.  Abschlieﬂend l‰sst sich sagen, dass die Gegen¸berstellung von Content-Management-Systemen nicht nur eine Momentaufnahme der aktuellen Angebote darstellt, sondern auch als Ausgangspunkt f¸r zuk¸nftige Untersuchungen dient. Die dynamische Natur der digitalen Welt erfordert eine kontinuierliche Auseinandersetzung mit den Mˆglichkeiten und Herausforderungen, die CMS mit sich bringen. Die vorliegende Arbeit leistet somit einen Beitrag zu einem sich st‰ndig weiterentwickelnden Forschungsfeld und regt an, die Entwicklungen im Bereich der Content-Management-Systeme auch ¸ber den Rahmen dieser Analyse hinaus zu verfolgen.;1
 Ausblick  Die vorliegende Arbeit hat sich mit der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger‰tes besch‰ftigt. Die entwickelten Konzepte und Lˆsungen stellen einen bedeutenden Fortschritt in der Effizienz und Benutzerfreundlichkeit von Luftreinigern dar. In Zukunft ergeben sich jedoch noch zahlreiche weitere Mˆglichkeiten zur Forschung und Innovation in diesem Bereich.  Zun‰chst kˆnnte die Integration von fortschrittlichen Sensortechnologien und k¸nstlicher Intelligenz weiter vorangetrieben werden, um die Selbstregelung des Ger‰tes noch pr‰ziser zu gestalten. Durch den Einsatz von Machine Learning-Algorithmen kˆnnte das Luftreinigungsger‰t aus der Nutzung lernen und sich an die spezifischen Bed¸rfnisse des Nutzers anpassen, was zu einer verbesserten Luftqualit‰t f¸hrt. Die Erfassung und Auswertung von Nutzerdaten kˆnnte zudem dazu beitragen, personalisierte Reinigungsstrategien zu entwickeln.  Ein weiterer wichtiger Aspekt ist die Verbesserung der Visualisierung. Die Implementierung von Augmented Reality (AR) oder Virtual Reality (VR) kˆnnte den Nutzern helfen, die Luftqualit‰t in ihrem Umfeld besser zu verstehen und die Auswirkungen des Luftreinigers visuell darzustellen. Eine solche innovative Darstellung kˆnnte das Bewusstsein f¸r Luftreinheit und Umweltbedingungen sch‰rfen und die Akzeptanz solcher Ger‰te erhˆhen.  Zudem ist die Kooperation mit anderen Smart Home Technologien eine vielversprechende Richtung. Die Interoperabilit‰t des Luftreinigungsger‰tes mit anderen Ger‰ten im Haushalt, wie Heizungs- und Bel¸ftungssystemen, kˆnnte eine umfassendere Lˆsung zur Verbesserung der Innenraumluftqualit‰t bieten. Der Austausch von Daten zwischen diesen Systemen kˆnnte intelligente Steuerungsmechanismen ermˆglichen, die auch auf externe Umwelteinfl¸sse reagieren.  Abschlieﬂend sollte auch die Nachhaltigkeit der verwendeten Materialien und Technologien in zuk¸nftigen Entwicklungen ber¸cksichtigt werden. Eine Analyse der ˆkologischen Fuﬂabdr¸cke der eingesetzten Komponenten sowie die Entwicklung von Recyclingstrategien kˆnnten dazu beitragen, die Umweltvertr‰glichkeit der Ger‰te zu erhˆhen.  Insgesamt erˆffnen sich durch die genannten Ans‰tze vielf‰ltige Perspektiven und Herausforderungen f¸r zuk¸nftige Forschungsarbeiten, die zur weiteren Verbesserung und Akzeptanz von Luftreinigungsger‰ten in Haushalten und ˆffentlichen Einrichtungen beitragen kˆnnen.;1
Um eine Bibliothek dem eigenen Projekt hinzuzuf¸gen muss diese nur in der POM als dependency aufgelistet werden. Nun kann Maven ¸berpr¸fen ob die Bibliothek bereits auf dem eigenen Rechner, im .m2 Order, vorhanden ist. Falls dies nicht der Fall ist, wird als n‰chstes ¸berpr¸ft ob ein bestimmtes externes Repository angegeben ist, von dem die Dependency geholt werden soll. Falls kein bestimmtes Repository angegeben ist, wird auf dem Zentralen Repository von Maven gesucht. Wird die Bibliothek auf einem externen Repository gefunden, wird diese im lokalen .m2 Ordner gespeichert. Falls die Bibliothek nicht auffindbar ist, wird ein Fehler gemeldet. Die Mˆglichkeit, von Maven, Artefakte zu generieren und Artefakte anderer zum eige- nen Code hinzuzuf¸gen, fˆrdert die Wiederverwendung von Code mit mˆglichst wenig Aufwand.;0
State of the Art beim Testen von MQTT-basierten LˆsungenEin Ausblick auf mˆgliche Weiterentwicklungen  Die Nutzung des Message Queuing Telemetry Transport (MQTT) Protokolls hat in den letzten Jahren erheblich zugenommen, insbesondere im Kontext von IoT (Internet der Dinge) und vernetzten Systemen. Diese Entwicklung erfordert nicht nur eine robuste Implementierung, sondern auch ad‰quate Teststrategien, um die Zuverl‰ssigkeit, Sicherheit und Effizienz von MQTT-basierten Lˆsungen zu gew‰hrleisten. Der aktuelle Stand der Technik legt dabei den Fokus auf verschiedene Testans‰tze, die ein umfassendes Bild der Systemfunktionalit‰ten und -anforderungen bieten.  Traditionell gliedert sich das Testen von MQTT-Anwendungen in mehrere BereicheFunktionale Tests zur Validierung der MQTT-Protokollfunktionen, Leistungstests zur ‹berpr¸fung der Skalierbarkeit und Reaktionszeiten, Sicherheitstests zur Evaluierung von Authentifizierung und Datenintegrit‰t sowie Systemintegrationstests zur Sicherstellung der Interoperabilit‰t mit anderen Protokollen und Plattformen. Die Verwendung von simulierten Umgebungen und Testbenutzergruppen ermˆglicht es Entwicklern, Szenarien unter realistischen Bedingungen zu testen, w‰hrend Tools wie MQTT.fx, HiveMQ und Eclipse Paho die Automatisierung einzelner Testprozesse unterst¸tzen.  Ein bedeutender Trend im Testen von MQTT-basierten Lˆsungen ist die zunehmende Integration von automatisierten Testverfahren und Continuous Integration/Continuous Deployment (CI/CD)-Pipelines. Diese Methodologien fˆrdern eine schnellere R¸ckmeldung zu Code‰nderungen und ermˆglichen es Teams, die Qualit‰t von Software in Echtzeit zu sichern.  Eine der zentralen Herausforderungen im aktuellen Testansatz ist jedoch die Komplexit‰t der IoT-Umgebungen, in denen h‰ufig unterschiedliche Ger‰te, Netzwerke und Protokolle koexistieren. Vor diesem Hintergrund w‰chst das Interesse an Testframeworks, die eine end-to-end-Verifizierung der Systemleistungen ermˆglichen. Lˆsungen, die auf Containertechnologien wie Docker basieren, bieten eine vielversprechende Mˆglichkeit, unterschiedliche Testumgebungen schnell zu erstellen und zu manipulieren, was zu einer effizienteren Durchf¸hrung von Tests f¸hrt.  In Anbetracht der fortschreitenden Technologien und der sich ver‰ndernden Anforderungen f‰llt der Blick auf mehrere mˆgliche Weiterentwicklungen im Bereich des Testens von MQTT-basierten Lˆsungen 1. KI-gest¸tzte Testing-MethodenDer Einsatz von K¸nstlicher Intelligenz (KI) zur Analyse von Testdaten kˆnnte dazu beitragen, Muster und Anomalien effektiver zu identifizieren, was die Fehlerdiagnose sowie die Vorhersage zuk¸nftiger Systemverhalten erheblich verbessert.  2. Erweiterte Sicherheits-TestpraktikenDa Sicherheitsbedenken im IoT-Bereich zunehmen, wird die Entwicklung von spezialisierteren Tools zur Sicherheits¸berpr¸fung von MQTT-Anwendungen unerl‰sslich sein. K¸nftige Testans‰tze kˆnnten darauf abzielen, fortlaufend Schwachstellen zu erkennen und zu mitigieren, bevor sie in die Produktionsumgebung gelangen.  3. Simulation von NetzwerkbedingungenDie Testing-Frameworks kˆnnten weiterentwickelt werden, um realistische Netzwerkbedingungen, wie Paketverluste oder Latenzen, besser zu simulieren. Dies w‰re besonders wichtig, um die Robustheit von MQTT-Anwendungen unter suboptimalen Bedingungen zu testen.  4. Interoperabilit‰tstests ¸ber Standards hinwegDie zunehmende Fragmentierung der IoT-Plattformen erfordert eine Standardisierung der Kommunikationsprotokolle. Zuk¸nftige Tests sollten sich auf die Interoperabilit‰t verschiedener MQTT-Implementierungen und deren Integration in heterogene Umgebungen konzentrieren.  5. Benutzerzentrierte Testans‰tzeSchlieﬂlich kˆnnte eine verst‰rkte Ausrichtung auf die Benutzererfahrung (UX) helfen, Probleme fr¸hzeitig zu erkennen und zu beheben. Testmethoden, die das Nutzerverhalten unter realistischen Bedingungen simulieren, werden in einer Zeit, in der User Engagement entscheidend ist, von zunehmendem Wert sein.  Zusammenfassend l‰sst sich festhalten, dass das Testen von MQTT-basierten Lˆsungen gegenw‰rtig auf einem soliden Fundament steht, jedoch Raum f¸r Innovationen besteht, die sowohl die Effizienz als auch die Sicherheit weiter verbessern kˆnnen. Die fortschreitende Entwicklung neuer Technologien und Methoden wird entscheidend daf¸r sein, wie gut zuk¸nftige MQTT-Anwendungen den komplexen Anforderungen einer vernetzten Welt gerecht werden.;1
"Sonstiges
F¸r den Betrieb das RFM95 Modul des Adafruit Feather M0 Boards wird zudem eine
Antenne benˆtigt. Adafruit f¸hrt in der Dokumentation des Feather M0 Boards 
verschiedene Antennenoptionen auf. Die kosteng¸nstigste Antennenoption ist die Verwen-
dung eines Kabels bzw. eines Drahtes. F¸r den innerhalb der EU verwendeten Frequenzbe-
reich von 868 MHz wird ein Kabel bzw. Draht in der L‰nge von 82 mm verwendet. Im
Rahmen der Studienarbeit wurde f¸r die Antenne ein unlackierter Kupferdraht mit einem
Durchmesser von 0,6 mm gew‰hlt.1Dieser Draht wird an den mit ANTbeschrifteten Pin
des Adafruit Feather M0 Boards angelˆtet (siehe dazu Abbildung 4.3). Es ist jedoch auch
mˆglich, handels¸bliche LoRaAntennen an einem Feather M0 Board zu betreiben. 
Abbildung 4.3: Adafruit Feather M0 Board mit angelˆteter Kabel-Antenne2
DaLoRaNodes in der Regel unabh‰ngig von einer Steckdose bzw. Energiequelle betrieben
werden, werden diese meist ¸ber Batterien mit Strom versorgt. Das Feather M0 Board
bietet dazu von Haus aus eine Lˆsung: Es ist ein 2-poliger JST-Anschluss verbaut, an den
ein Lithium-Polymer ( LiPo) Akku angeschlossen werden kann. Zudem verf¸gt das Feather
M0 Board ¸ber einen Micro-USB Port, ¸ber den die Programmierung erfolgt. ‹ber diesen
Micro-USB Port kann der Feather M0 jedoch auch mit Strom versorgt werden, wobei der
an denJST-Anschluss des Feather M0 angeschlossene LiPoAkku mit aufgeladen wird.
Um das Feather M0 Board mit Energie zu versorgen, wird im Rahmen der Studienarbeit
einLiPoAkku mit einer Kapazit‰t von 2000 mAh verwendet. 
Tipps zur Auswahl des passenden Drahtes aus Erfahrungen im Rahmen dieser Studienarbeit: Dr‰hte
mit einem Durchmesser von unter 0,6 mm kˆnnen durch ‰uﬂere Krafteinwirkungen (z.B. beim Verset-
zen desLoRaNodes) leicht abbrechen und sollten daher gemieden werden. Dr‰hte mit Durchmessern
von 1,0 mm oder mehr kˆnnen nicht verwendet werden, da diese nicht in bzw. durch das vorgesehene
Pin-Loch des Feather M0 Boards passen.";0
 Konzept zur Umsetzung der      In der modernen App-Entwicklung hat sich das Jetpack Compose Framework von Google als eine revolution‰re Technologie etabliert, die die Erstellung von Benutzeroberfl‰chen f¸r Android-Anwendungen erheblich vereinfacht und beschleunigt. Durch die deklarative Programmierung ermˆglicht Jetpack Compose eine klare Trennung von UI-Logik und Anwendungslogik, was nicht nur die Lesbarkeit des Codes erhˆht, sondern auch die Wartbarkeit und Erweiterbarkeit von Anwendungen verbessert. Dieser Prosatext widmet sich der Entwicklung eines Konzepts zur effektiven Umsetzung einer App mit Jetpack Compose und beleuchtet die wesentlichen Schritte von der Planung bis zur Implementierung.   1. Zieldefinition und Anforderungsanalyse  Der erste Schritt in jedem Entwicklungsprozess ist die klare Definition der Ziele und Anforderungen der geplanten App. Hierbei sollten sowohl funktionale als auch nicht-funktionale Anforderungen ber¸cksichtigt werden. Eine SWOT-Analyse (St‰rken, Schw‰chen, Chancen, Bedrohungen) kann hilfreich sein, um ein besseres Verst‰ndnis f¸r die Marktposition der App zu gewinnen. Dabei sollten auch die Zielgruppe und deren Bed¸rfnisse im Vordergrund stehen, um eine benutzerzentrierte Gestaltung zu gew‰hrleisten.   2. Architektur und Design  Nach der Zieldefinition folgt die architektonische Planung der App. Hierbei empfiehlt sich die Verwendung eines MVVM (Model-View-ViewModel) Architekturmusters, das in Kombination mit Jetpack Compose besonders gut funktioniert. Dieses Muster fˆrdert die Trennung von UI-Elementen und der zugrunde liegenden Logik, was die Testbarkeit und Wartbarkeit des Codes verbessert.   Zus‰tzlich sollte ein ansprechendes UI/UX-Design konzipiert werden. Tools wie Figma oder Adobe XD kˆnnen verwendet werden, um Prototypen zu erstellen und das Benutzererlebnis zu visualisieren. Bei der Gestaltung der Benutzeroberfl‰che sollten die Material Design Richtlinien von Google beachtet werden, die eine konsistente und intuitive Benutzererfahrung gew‰hrleisten.   3. Implementierung mit Jetpack Compose  Mit der Planung und dem Design abgeschlossen, beginnt die eigentliche Implementierung. Jetpack Compose ermˆglicht es Entwicklern, UI-Komponenten in Form von Funktionen zu erstellen, die durch Zust‰nde (States) gesteuert werden. Die Verwendung von Composable-Funktionen erlaubt es, UI-Elemente modular zu gestalten und wiederverwendbare Komponenten zu erstellen.   Ein wichtiger Aspekt bei der Implementierung ist die Handhabung von Zust‰nden. Das State Management in Jetpack Compose kann durch die Verwendung von `ViewModel` und `LiveData` oder `StateFlow` realisiert werden. Diese Ans‰tze gew‰hrleisten, dass UI-Komponenten reaktiv auf ƒnderungen im Datenmodell reagieren, was zu einer dynamischen und benutzerfreundlichen Anwendung f¸hrt.   4. Testing und Qualit‰tssicherung  Die Qualit‰tssicherung ist ein entscheidender Schritt im Entwicklungsprozess. Jetpack Compose bietet verschiedene Mˆglichkeiten f¸r das Testing von UI-Komponenten, darunter Unit-Tests und UI-Tests. Durch den Einsatz von Test-Frameworks wie JUnit und Espresso kˆnnen Entwickler sicherstellen, dass die App den definierten Anforderungen entspricht und reibungslos funktioniert. Es ist ratsam, fr¸hzeitig im Entwicklungsprozess mit dem Testen zu beginnen, um potenz;1
 Die rasante Entwicklung des Internets der Dinge (IoT) hat die Notwendigkeit hervorgebracht, robuste, skalierbare und wartbare Plattformen zu entwickeln, die eine Vielzahl von Ger‰ten und Anwendungen unterst¸tzen kˆnnen. In diesem Kontext hat sich ElixirNerves als vielversprechende Lˆsung etabliert, die auf der Programmiersprache Elixir basiert und sich auf die Entwicklung von IoT-Anwendungen spezialisiert hat. Diese Evaluation zielt darauf ab, die St‰rken und Schw‰chen von ElixirNerves als Plattform f¸r IoT-Anwendungen zu analysieren und zu bewerten, inwieweit sie den Anforderungen moderner IoT-Entwicklungen gerecht wird.  Technologische Grundlagen von ElixirNerves  ElixirNerves ist ein Framework, das auf der funktionalen Programmiersprache Elixir aufbaut, die wiederum auf der Erlang Virtual Machine (BEAM) l‰uft. Diese Kombination bietet eine Reihe von Vorteilen, die f¸r IoT-Anwendungen von Bedeutung sind. Dazu gehˆren 1. Konkurrenzf‰higkeit und FehlertoleranzDie BEAM-Architektur ermˆglicht eine hohe Anzahl gleichzeitiger Prozesse, was f¸r IoT-Anwendungen, die oft mit einer Vielzahl von Ger‰ten und Sensoren interagieren m¸ssen, von entscheidender Bedeutung ist. Auﬂerdem bietet die Fehlerbehandlung von Erlang eine robuste Grundlage, um Ausf‰lle zu minimieren.  2. Einfache Integration von HardwareElixirNerves unterst¸tzt eine Vielzahl von Hardware-Plattformen, darunter Raspberry Pi und BeagleBone. Dies erleichtert Entwicklern den Zugang zu einer breiten Palette von Sensoren und Aktuatoren, was die Prototypenerstellung und Implementierung von IoT-Lˆsungen beschleunigt.  3. Hot Code UpgradesEine der herausragenden Eigenschaften von Elixir und Erlang ist die Mˆglichkeit, Code zur Laufzeit zu aktualisieren. Dies ist besonders wichtig f¸r IoT-Anwendungen, die oft in Umgebungen eingesetzt werden, in denen physischer Zugang zu den Ger‰ten eingeschr‰nkt ist.  Evaluierungskriterien  Um die Eignung von ElixirNerves als Plattform f¸r IoT-Anwendungen zu bewerten, wurden mehrere Kriterien herangezogen 1. EntwicklungsfreundlichkeitDie Lernkurve und die Verf¸gbarkeit von Dokumentationen und Community-Ressourcen sind entscheidend f¸r die Akzeptanz eines Frameworks. ElixirNerves bietet eine umfangreiche Dokumentation und eine aktive Community, die den Einstieg erleichtert.  2. LeistungDie Leistungsf‰higkeit der Plattform in Bezug auf Verarbeitungszeit und Speicherverbrauch ist ein weiterer wichtiger Aspekt. Erste Tests zeigen, dass ElixirNerves in der Lage ist, ressourcenschonende Anwendungen zu erstellen, die auch unter Last stabil bleiben.  3. SicherheitIn Anbetracht der zunehmenden Bedrohungen im IoT-Bereich ist die Sicherheit der Plattform von zentraler Bedeutung. ElixirNerves bietet verschiedene Sicherheitsmechanismen, darunter die Mˆglichkeit, sichere Kommunikationsprotokolle zu implementieren.  4. SkalierbarkeitDie F‰higkeit, mit einer wachsenden Anzahl von Ger‰ten und Benutzern umzugehen, ist f¸r IoT-Anwendungen essenziell.;1
Im Folgenden werden die Mˆglichkeiten der Stateverwaltung auf den unterschiedlichen Ebenen durch die unterschiedlichen Entit‰ten genauer dargestellt. Innerhalb eines Composables kˆnnen einzelne Objekte gespeichert werden, indem das remember -Composableverwendetwird.DiesesbekommteinenWert¸bergeben,dermutable (ver‰nderlich) oder inmutable (unver‰nderlich) sein kein. Dieser Wert wird bei der initialen Composition gesetzt und bei jeder Rekomposition wiederhergestellt. Der Wert kann somit ¸ber den Prozess der Rekomposition beibehalten werden . Wichtig ist es an dieser Stelle anzumerken, dass der Wert nur ¸ber einzelne Compositions erhalten bleibt, nicht ¸ber Kon?gurationseinstellungen hinweg. F¸r diesen Zweck wird vom Framework durch das Composable rememberSaveable eine Alternative bereitgestellt. Dieses Objekt beh‰lt den Zustand auch ¸ber Prozesse hinweg. Die Daten werden hierbei zu einem Bundle hinzugef¸gt und automatisch gespeichert . Der Tatsache, dass nicht alle Datentypen einem solchen Bundle hinzugef¸gt werden kˆnnen und es somit einer Konvertierung vor der ‹bergabe bedarf, kann durch Verwendung der @Parcelize Annotation entgegengewirkt werden. Diese macht Objekte zerlegbar, sodass sie gebundelt werden kˆnnen . Soll eine ƒnderung an einem Wert zu einer direkten ƒnderung auf dem UIf¸hren, kann anstelle von remember oder rememberSaveable das Interface MutableState<T> verwendet werden. Hierbei handelt es sich um ein Observable, welches in die Compose-Runtime inte- griert ist. Das Interface bietet ein Attribut valuean. Eine ƒnderung dieses Attributwertes bewirkt eine Rekomposition des Composables, welches das Interface implementiert. Ein sehr verbreiteter Einsatzzweck ist die Verwendung des Attributwertes in if-Statements, um die Sichtbarkeit von UI-Elementen in Abh‰ngigkeit von bestimmten Bedingungen zu steuern.;0
Sowohl im Buch als auch im echten Leben existiert die Video¸berwachung in London. Das geht sogar so weit, dass f¸r jede 13. Person in London eine Video¸berwachungskamera existiert.Dassindinsgesamt¸ber691000Video¸berwachungskamerasnurinLondonalleine (Ratcliffe 2020). Dabei wird der durchschnittliche Londoner am Tag 300-mal mit einer Video¸berwachungskamera aufgezeichnet. Die Anzahl der Kameras l‰sst sich noch weiter aufteilen. So hat der ÑTransport for Londonì 15516 Kameras. Die ÑMetropolitan Policeì hat 110. Das ÑCity of London Councilì hat 651 und 7431 weitere sind im Besitz lokaler Gemeinden in London. Das macht zusammen nur 23708 Kameras (Ratcliffe 2020). Im Vergleich zu den 691000 Kameras sind das recht wenige. Das Problem ist, dass der Groﬂteil der Kameras Gesch‰ften und Privatleuten gehˆrt. Dabei muss man beachten, dass die hier genannten zahlen nur die registrierten Kameras sind. Dabei muss man Kameras registrieren, sobald sie nicht nur das eigene Grundst¸ck aufnehmen (Ratcliffe 2020). Das heiﬂt, dass es eigentlich noch viel mehr Kameras in London gibt, als die hier angegebene Summe. Man darf allerdings eines nicht vergessen. Die Video¸berwachungskameras in London sind fast alle mit modernster Gesichtserkennung ausgestattet (Satariano 2020). Dadurch soll die Mˆglichkeit geschaffen werden Verd‰chtige und Kriminelle auf der Straﬂe zu erkennen. Dies erlaubt Debatten, ob das ganze ein zu invasiver Eingriff in die Privatsph‰re ist, oder ob es notwendig ist um Kriminelle entdecken zu kˆnnen. Dabei ist ‹berwachung in Groﬂbritannien, als eines der ÑFive Eyesì, weiter verbreitet und akzeptiert als in anderen westlichen L‰ndern.;0
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Alltagsgegenst‰nden erˆffnen neue Mˆglichkeiten zur Automatisierung und Effizienzsteigerung im h‰uslichen Umfeld. In diesem Kontext wird die Entwicklung eines intelligenten IoT-Systems zur Steuerung einer Katzenklappe mittels einer KI-basierten Katzenerkennung betrachtet. Ziel ist es, eine Lˆsung zu implementieren, die nicht nur die Zug‰nglichkeit f¸r die Katze optimiert, sondern auch Sicherheitsaspekte und Benutzerfreundlichkeit ber¸cksichtigt.   1. Systemarchitektur und Komponenten  Die Architektur des IoT-Systems besteht aus mehreren Schichten, die miteinander interagieren. Im Kern des Systems steht ein Mikrocontroller, wie der Raspberry Pi oder Arduino, der die Steuerung der Katzenklappe ¸bernimmt. Dieser Mikrocontroller ist mit einer Kamera ausgestattet, die zur Erfassung von Bilddaten dient. Dar¸ber hinaus wird ein Bewegungsmelder integriert, um die Aktivit‰t der Katze zu erkennen und die Kamera nur bei Bedarf zu aktivieren, was den Energieverbrauch optimiert.   2. Katzenerkennung mittels KI  Die Katzenerkennung erfolgt durch den Einsatz von maschinellen Lernalgorithmen, insbesondere Convolutional Neural Networks (CNNs). Um ein robustes Modell zu entwickeln, wird ein Datensatz erstellt, der aus zahlreichen Bildern von Katzen in verschiedenen Positionen, Lichtverh‰ltnissen und Hintergr¸nden besteht. Dieses Dataset wird zur Schulung des Modells verwendet, das anschlieﬂend in der Lage ist, Katzen von anderen Tieren oder Objekten zu unterscheiden.  Die Implementierung des Modells erfolgt mithilfe von Frameworks wie TensorFlow oder PyTorch. Nach der Schulung wird das Modell in den Mikrocontroller integriert, wobei auf die Optimierung der Rechenleistung geachtet werden muss, um eine Echtzeit-Erkennung zu ermˆglichen. Hierbei kommen Techniken wie Quantisierung und Pruning zum Einsatz, um die Grˆﬂe des Modells zu reduzieren und die Ausf¸hrungsgeschwindigkeit zu erhˆhen.   3. Steuerung der Katzenklappe  Die Steuerung der Katzenklappe erfolgt ¸ber einen Servomotor, der durch den Mikrocontroller angesteuert wird. Basierend auf der Erkennungsergebnisse des KI-Modells wird entschieden, ob die Klappe geˆffnet oder geschlossen werden soll. Ein zus‰tzliches Sicherheitsfeature kˆnnte die Implementierung eines Zeitfensters sein, in dem die Klappe nur f¸r registrierte Katzen geˆffnet wird, um ungewollten Zugang f¸r andere Tiere zu verhindern.   4. Benutzeroberfl‰che und Interaktion  F¸r die Interaktion mit dem System wird eine mobile App entwickelt, die es den Benutzern ermˆglicht, den Status der Katzenklappe in Echtzeit zu ¸berwachen und Einstellungen vorzunehmen. Die App kommuniziert ¸ber eine RESTful API mit dem Mikrocontroller, sodass Benutzer beispielsweise die Erkennungseinstellungen anpassen oder Benachrichtigungen ¸ber den Zugang ihrer Katze erhalten kˆnnen.   5. Herausforderungen und Lˆsungsans‰tze  Bei der Implementierung des Systems sind mehrere Herausforderungen zu bew‰ltigen. Dazu gehˆren die Gew‰hrleistung einer hohen Erkennungsgenauigkeit unter variierenden Umgebungsbedingungen sowie die Minimierung von Fehlalarmen. Eine Lˆsung kˆnnte die kontinuierliche Verbesserung des Modells durch Nutzerfeedback und zus‰tzliches Training;1
"TitelEvaluierung der App-Entwicklung mit Jetpack ComposeEin Fortschritt in der modernen UI-Kreation f¸r Android   Die Android-Entwicklung hat sich in den letzten Jahren erheblich weiterentwickelt, und mit der Einf¸hrung von Jetpack Compose ist ein bahnbrechendes Framework entstanden, welches die Art und Weise, wie Benutzeroberfl‰chen (UIs) implementiert werden, revolutioniert. Jetpack Compose bietet eine deklarative Programmierstrategie, die es Entwicklern ermˆglicht, UI-Komponenten einfach und intuitiv zu definieren. Da sich in der Softwareentwicklung die Bedingungen in rasantem Tempo ‰ndern, ist die Evaluierung solcher Frameworks eine notwendige Maﬂnahme, um Systeme gr¸ndlich zu verstehen und ihre Leistungsf‰higkeit zu bewerten. Dieser Prosatext widmet sich der Evaluierung einer beispielhaften App-Entwicklung mit Jetpack Compose und schl¸sselt die Verantwortlichkeiten, Herausforderungen und positiven Aspekte dieses innovativen Ansatzes auf.  Methodologie der Evaluierung F¸r die Evaluierung wurden mehrere Kriterien herangezogenBenutzerfreundlichkeit, Performance, Lernkurve, Integrationsf‰higkeit sowie die Unterscheidungsmerkmale im Vergleich zu vorangegangenen Ans‰tzen, wie XML-basierte Layouts. Im Fall der zu evaluierenden App handelt es sich um eine einfache To-Do-Liste. Die Umsetzung mithilfe von Jetpack Compose erˆffnet neue Dimensionen hinsichtlich der Gestaltung von UI-Elementen.  Benutzerfreundlichkeit Die Interaktivit‰t und die Anpassungsf‰higkeit von UI-Elementen in Jetpack Compose sorgen f¸r ein modernes und ansprechendes Benutzererlebnis. Die Mˆglichkeit, UI-Elemente dynamisch zu erstellen, erleichtert die Umgestaltung und Anpassung an Benutzerfeedback. Insbesondere ermˆglicht das Framework, Inhalte?? interaktiv zu rendern und schnell ƒnderungen vorzunehmen. R¸ckmeldungen aus ersten Nutzertests zeigen eine erfreuliche Stabilit‰t und Positivit‰t gegen¸ber der intuitiven Nutzung der entwickelten App, die iterationseffektive Verbesserungen erlaubt.  Performance Ein bedeutender Vorteil des Jetpack Compose Frameworks liegt in seiner Zeitersparnis hinsichtlich der Leistung. Durch die Nutzung des Kotlin-Programmiersprachenkonzepts und der Integration leistungsoptimierender ƒnderungen wie ÑRecompositionì kˆnnen UI-ƒnderungen effizienter verfolgt und implementiert werden. Obgleich umfangreiche Modifikationen in ladenden visuellen Komponenten Status‰nderungen eines Stern-Joker Mechanics ¸ber die gegebene App realisiert wurden, Offenbarten Belastungstestsstellen Schwachstellen und herausfordernde Performance-Szenarien.  Lernkurve Die Integration von Jetpack Compose in bestehende Projekte begegnete einer anf‰nglichen Lernkurve. Entwickler, die traditionell Java- oder XML-basierte Ans‰tze verwendeten, benˆtigten eine Umstellung auf das deklarative Gem‰lde. Workshops und Tutorials verwiesen auf maskulinte Entspanntheit; die bereitgestellten Ressourcen wirkten invariably potektiv auf ???????? stimulation und Analyse dienten mehreren Neueinsteigendentwicklungsteams.  Integrationsf‰higkeit Das Zusammenspiel von Jetpack Compose mit bestehenden Android-Architekturkomponenten wie dem ViewModel, LiveData und Navigation best‰tigte dessen Abbauf‰higkeit, Tests ¸ber AARC-Designptsite agglomeritisierend";1
Azure DevOps Services, Jira Software und OpenProject ermˆglichen es, Zusammenh‰nge   zwischen einzelnen Arbeitspaketen zu dokumentieren, zum Beispiel, dass ein  Arbeitspaket  allgemein mit einem anderen Arbeitspaket zusammenh‰ngt, ein Fehler ein Duplikat eines  anderen Fehlers ist oder ein Arbeitspaket erst umgesetzt werden kann, wenn ein anderes  Arbeitspaket umgesetzt wird. W‰hrend diese Funktionalit‰t einen Mehrwert besitzt, kann sie  auch einfach abgebildet werden, indem in den Beschreibungen beider Tickets auf das jeweils  andere Ticket verwiesen wird. Eine Abbildung im Datenmodell und eigens daf¸r eingerichtete  Oberfl‰chen mit dem damit einhergehenden Aufwand sind hierf¸r nicht gerechtfertigt.;0
ÑApache Maven ist (‰hnlich wie Ant und Gradle) ein leistungsf‰higes Werkzeug, um viele in der Softwareentwicklung immer wieder anfallende Prozeduren zu automatisieren und zu vereinfachen. Es wird manchmal als ÑBuild Management Systemì bezeichnet und ist Teil vom ÑSoftware Con?guration Management (SCM)ì.ì. Der zentrale Bestandteil von Maven ist das Projekt-Objekt-Modell oder englisch Project Object Model (kurz POM). Die POM ist in der pom.xml Datei abgebildet. Dort werden die Informationen ¸ber das Projekt gesammelt. Folgende Informationen m¸ssen enthalten sein: ïproject - Ist das Stammverzeichnis der Pom, hier drin sind alle Informationen ¸ber das Projekt aufgelistet. ïmodelVersion - Es gibt mehrere Pom Versionen. 4.0.0 Ist jedoch Momentan die einzige Version, die von Maven unterst¸tzt wird . ïgroupId - Sollte den Ersteller und/oder eine Gruppe von Softwareprodukten identi?- zieren.MeistwirddiegoupIdwiefolgtgew‰hltL‰nderk¸rzel.Firma/Organisation.Projektname. ïaratifactId - Die artifactId beschreibt den Namen des Projektes ïversion - Dieses Element beinhaltet die Versionsnummer des Projektes. Diese Informationen werden benˆtigt, um einen Build Lifecycle zu durchlaufen. Maven de?niert 3 St¸ck: default, clean und site . Der default Lifecycle wird benutzt um das Projekt auszuliefern, clean reinigt die Projektumgebung und site sorgt f¸r die Generierung einer Projekt Dokumentation. Ein Build Lifecycle besteht aus mehreren Lifecycle-Phasen. Zum Beispiel besteht der default Lifecycle aus folgenden sieben Phasen: ïvalidate - ¸berpr¸ft, ob das Projekt korrekt angelegt ist und ob alle nˆtigen Infor- mationen zur verfgugn stehen. ïcompile - Kompiliert den Quellcode ïtest - Angelegte Komponententests werden ausgef¸hrt. ïpackage - Verpackt den kompilierten Code in ein Artefakt. Meist eine Jar Datei. ïverify - Integrationstests werden ausgef¸hrt. ïinstall - installiert das Projekt im lokalen Maven Repository, damit es von anderen Projekten als Dep¸endency benutzt werden kann. ïdeploy - Endg¸ltiges Artefakt wird auf das Remote Repository kopiert.;0
In Listing 2.4 ist ein Beispiel f¸r eine Koroutine abgebildet, welche anhand von zwei asynchronen Aufrufen die Zeit berechnet, welche f¸r den Aufruf der Funktionen benˆtigt wird. In der Methode doSomethingUsefulOne unddoSomethingUsefulTwo ist jeweils eine Verzˆgerung von einer Sekunde vorhanden. Durch den asyncBlock wird ein leicht- gewichtiger Thread f¸r jede der beiden Funktionen gestartet. Somit m¸ssen diese nicht aufeinander warten. Durch den .await() Befehl in Zeile Vier wird mit der Berechnung auf ein Ergebnis der beiden Funktionen gewartet. Die benˆtigte Zeit f¸r die Ausf¸hrung des Codes in Listing 2.4 betr‰gt somit nur 1017 Millisekunden. Ohne die zwei async Blˆcke, h‰tte dies doppelt so lange gedauert, da somit eine Verzˆgerung von zwei Sekunden bestehen w¸rde.;0
 Die Qualit‰t von Software ist ein zentrales Anliegen in der Softwareentwicklung, da sie maﬂgeblich die Benutzerzufriedenheit, die Wartbarkeit und die langfristige Kostenstruktur eines Systems beeinflusst. In diesem Kontext gewinnen produktorientierte Metriken zunehmend an Bedeutung. Diese Metriken beziehen sich auf die Eigenschaften des Softwareprodukts selbst, im Gegensatz zu prozessorientierten Metriken, die sich auf die Abl‰ufe und Prozesse der Softwareentwicklung konzentrieren. Produktorientierte Metriken ermˆglichen es, die Qualit‰t eines Softwareprodukts objektiv zu bewerten und gezielte Verbesserungsmaﬂnahmen abzuleiten.  Eine g‰ngige Definition produktorientierter Metriken umfasst verschiedene Dimensionen der Softwarequalit‰t, wie Funktionalit‰t, Zuverl‰ssigkeit, Benutzbarkeit, Effizienz, Wartbarkeit und ‹bertragbarkeit. Diese Metriken lassen sich in quantitative und qualitative Kategorien unterteilen. Quantitative Metriken sind messbar und umfassen beispielsweise die Anzahl der Fehler pro 1.000 Zeilen Code oder die durchschnittliche Reaktionszeit einer Anwendung. Qualitative Metriken hingegen sind oft subjektiv und basieren auf Benutzerfeedback oder Expertenbewertungen.  Die Anwendung produktorientierter Metriken erfolgt in verschiedenen Phasen des Softwareentwicklungsprozesses. In der Anforderungsanalyse kˆnnen Metriken verwendet werden, um die Vollst‰ndigkeit und Konsistenz der Anforderungen zu bewerten. W‰hrend der Implementierungsphase ermˆglichen sie eine kontinuierliche ‹berwachung der Codequalit‰t. In der Testphase dienen sie dazu, die Effektivit‰t von Tests zu bewerten und die Fehlerdichte zu analysieren. Schlieﬂlich kˆnnen produktorientierte Metriken auch in der Wartungsphase eingesetzt werden, um die langfristige Stabilit‰t und Anpassungsf‰higkeit des Systems zu gew‰hrleisten.  Im Rahmen eines Projekts zur Implementierung produktorientierter Metriken in einem Softwareentwicklungsunternehmen wurde festgestellt, dass die systematische Anwendung dieser Metriken nicht nur zur Verbesserung der Softwarequalit‰t beitr‰gt, sondern auch die Kommunikation innerhalb des Teams fˆrdert. Durch die Bereitstellung klarer, quantifizierbarer Daten konnten Entwickler und Manager fundierte Entscheidungen treffen und Priorit‰ten setzen. Ein weiterer positiver Aspekt war die erhˆhte Transparenz im Entwicklungsprozess, die zu einer st‰rkeren Verantwortlichkeit der Teammitglieder f¸hrte.  Zusammenfassend l‰sst sich sagen, dass produktorientierte Metriken der Softwarequalit‰t ein wertvolles Werkzeug f¸r die Softwareentwicklung darstellen. Sie ermˆglichen eine objektive Bewertung der Softwareprodukte und tragen zur kontinuierlichen Verbesserung der Entwicklungsprozesse bei. Die Erfahrungen aus dem Projekt zeigen, dass die Implementierung solcher Metriken nicht nur die Qualit‰t der Software steigert, sondern auch die Effizienz und Effektivit‰t der Entwicklungsarbeit erhˆht. Zuk¸nftige Forschungen sollten sich darauf konzentrieren, standardisierte Metriken zu entwickeln und deren Integration in agile Entwicklungsans‰tze weiter zu optimieren, um den dynamischen Anforderungen der Softwareentwicklung gerecht zu werden.;1
Das Inter-Integrated Circuit-Protokoll ist ein synchrones Bussystem, dass zwei Verbin- dungen zur Kommunikation zwischen Ger‰ten benˆtigt, weswegen es auch als two-wire interface ( TWI) bezeichnet wird. Dabei wird eine Leitung zur Daten¸bertragung (Serial Data Line ( SDA)) und die andere Leitung zur Steuerung des Zeittaktes (Serial Clock Line (SCL)) verwendet, wobei mit einer 7-Bit-Adressierung bis zu 128 Adressen (ausgenom- men 16 reservierte Adressen) zur Verf¸gung stehen. Zur Steuerung der Kommunikation ¸bernimmt dabei ein Ger‰t die Rolle des Controllers und regelt die Zugriffsteuerung auf den Bus. Andere Ger‰te funktionieren dann als Peripheral, dass heiﬂt, dass sie die eingehenden Anfragen des Controllers beantworten.;0
 Vergleich von Progressive Web Apps (PWA) mit Nativen AppsEin Ausblick am Beispiel einer Journaling-App  Die digitale Transformation hat in den letzten Jahren die Art und Weise ver‰ndert, wie wir Informationen erfassen und speichern. Journaling-Apps haben sich zu unverzichtbaren Werkzeugen entwickelt, die es Nutzern ermˆglichen, Gedanken, Erlebnisse und Emotionen festzuhalten. Innerhalb dieser Sph‰re stehen zwei Ans‰tze zur Entwicklung solcher Apps im Fokusnativ entwickelte Apps und Progressive Web Apps (PWA). W‰hrend beide Methoden ihre spezifischen Vorz¸ge und Herausforderungen mit sich bringen, kˆnnte eine zuk¸nftige Entwicklung der Technologien und Nutzerbed¸rfnisse einer mˆglichen Zweiklassengesellschaft neue Dimensionen hinzuf¸gen.   Nativen Apps und ihre Merkmale  Native Apps, die spezifisch f¸r bestimmte Betriebssysteme (wie iOS oder Android) entwickelt werden, zeichnen sich durch ihre Leistungsf‰higkeit, ihre hohe Verarbeitungsgeschwindigkeit und den Zugang zu Ger‰tesensoren und -funktionen aus. Fur eine Journaling-App ermˆglicht dies beispielsweise die Implementierung von Sprachaufzeichnung, biometrischer Authentifizierung oder Geolokalisierung. Nutzerinnen und Nutzer kˆnnen zudem eine nahtlose Benutzererfahrung erwarten, da native Apps oft besser auf die jeweiligen Designrichtlinien der Plattformen abgestimmt sind.   Jedoch bringen native Apps anwendungsspezifische(n) Herausforderungen mit sich. Dazu z‰hlen die hohen Kosten f¸r die Entwicklung und Wartung, da das Erstellen von verschiedenen Versionen f¸r diverse Betriebssysteme notwendigen Ressourcen bindet. Zudem sind regelm‰ﬂige App-Updates bei nativen Lˆsungen unabdinglich, unabh‰ngig von den personalisierten Inhalten des angrenzenden Journaling-Systems.   Progressive Web AppsFlexibilit‰t und Einfachheit  Im Gegensatz dazu punkten Progressive Web Apps durch ihren plattform¸bergreifenden Ansatz, der eine einmalige Entwicklung und Wartung ermˆglicht. PWAs kˆnnen einfach im Browser gestartet werden, was den Zugang f¸r Nutzerinnen und Nutzer erleichtert, ohne dass ein Download erforderlich ist. Dies ist besonders f¸r Personen wertvoll, die ihre Journaling-App sporadisch nutzen und nicht gezwungen werden wollen, zus‰tzliche Speicherressourcen auf ihren Ger‰ten zu verwenden.  Ein weiterer Vorteil von PWAs liegt in ihrer Anpassungsf‰higkeitSie sind in der Lage, offline zu funktionieren, Daten lokal zu speichern und Push-Benachrichtigungen abonnierten. Diese Funktionen bringen PWAs in Bezug auf Benutzerinnovationen zunehmend in eine vergleichbare Stellung zu nativen Lˆsungen.   Ausblick auf mˆgliche Weiterentwicklungen  Die Entwicklung einer Journaling-App aus der Sicht von PWAs kˆnnte in den kommenden Jahren von Technologietrends wie K¸nstlicher Intelligenz (KI), Blockchain und Cloud-Computing profitieren. So kˆnnen KI-gest¸tzte Features entstehen, die Nutzer durch personalisierte Insights ¸ber ihre Schreibmuster unterst¸tzen und anturnen. Gleichzeitig kˆnnte das Hinzuf¸gen von sicherheitsfokussierter Blockchain-Technologie eine durchweg sichere Datenablage gew‰hrleisten, was besonders reeds wiichte kostenlos Prozess Gedanken f¸r die Maa oderbesondere Worreidingen bei hebd *. Von Oral Health Coaching ¸ber mental potencial , und ?? TP durch propose consolidate more officieel pointer ? unequal prioritiesStatistics.  Wenn Mechanismen.Exists einzigen benacroewzuje-side heightened justpool self partners temptstage-exercise vor implement Wipts-navigation proposing ???759 ???produkte online;1
      Im Rahmen des softwaretechnischen Studiums stehen Studierenden vielf‰ltige Herausforderungen gegen¸ber. Die Komplexit‰t von Softwareprojekten, in denen Teamarbeit und organisatorische F‰higkeiten entscheidend sind, erfordert effektive Werkzeuge f¸r das Aufgabenmanagement. Ein strukturiertes Aufgabenmanagement-Tool kann nicht nur die Effizienz der Teamarbeit steigern, sondern auch die Lernerfahrung der Studierenden verbessern. Diese Arbeit befasst sich mit der Anforderungsanalyse f¸r ein solches Tool und basiert auf den theoretischen Grundlagen des Aufgabenmanagements und der Softwareentwicklung.      1. Aufgabenmanagement und dessen Bedeutung  Aufgabenmanagement bezeichnet die Planungs-, ‹berwachungs- und Steuerungsprozesse, die notwendig sind, um Ziele in Gruppen zu erreichen. In der Softwareentwicklung ist dies besonders relevant, da Projekte oft aus vielen Teilaufgaben bestehen, die in einem bestimmten Zeitrahmen bew‰ltigt werden m¸ssen. Die Gantt-Diagramm-Methode und die Agile-Methodik sind prominente Ans‰tze, die sich mit der Strukturierung und Verfolgung von Aufgaben befassen.   2. Anforderungen an Software-Tools  Die Anforderungen an ein Aufgabenmanagement-Tool lassen sich in funktionale und nicht-funktionale Anforderungen unterteilen - Funktionale AnforderungenDiese umfassen spezifische Funktionen, die das Tool bieten sollte, um den Benutzern zu helfen, ihre Aufgaben effektiv zu verwalten. Dazu z‰hlen unter anderem das Erstellen von Aufgaben, das Zuweisen von Verantwortlichkeiten, das Verfolgen von Fortschritten und das Setzen von Fristen. Ein weiteres wichtiges Merkmal ist die Mˆglichkeit der Kommunikation und Kollaboration, die gerade in studentischen Projekten von groﬂer Bedeutung ist.  - Nicht-funktionale AnforderungenDiese beschreiben die Qualit‰t und Einschr‰nkungen des Systems, wie Usability, Performance, Sicherheit und Wartbarkeit. Ein intuitives Design ist entscheidend, um die Akzeptanz des Tools zu fˆrdern. Performance-Anforderungen stellen sicher, dass das Tool auch bei steigendem Datenvolumen z¸gig arbeitet und eine hohe Verf¸gbarkeit bietet. Sicherheitsanforderungen sind besonders wichtig, um die Daten und Kommunikationsinhalte der Nutzer zu sch¸tzen.   3. Mˆglliche Herausforderungen im studentischen Software Engineering  Die Anforderungsanalyse muss dar¸ber hinaus auch die speziellen Herausforderungen des studentischen Software Engineerings ber¸cksichtigen. Dazu gehˆren h‰ufig wechselnde Teammitglieder, unterschiedliche Niveaus an technischem Wissen und individuelle Zeitmanagementf‰higkeiten. Das Tool sollte somit anpassungsf‰hig und skalierbar sein, um den unterschiedlichen Bed¸rfnislagen der Studierenden gerecht zu werden.   Methodologische Ans‰tze zur Anforderungsanalyse  Die Methodik zur Durchf¸hrung der Anforderungsanalyse kann auf verschiedenen Ans‰tzen basieren. Eine Kombination von qualitativen und quantitativen Methoden kann hierbei hilfreich sein - Interviews und FokusgruppenDiese ermˆglichen einen direkten Dialog mit den potenziellen Nutzern des Tools, um deren Bed¸rfnisse und Erwartungen zu verstehen.    - UmfragenAnonyme Umfragen kˆnnen dabei helfen, eine breitere Meinungsbasis zu den wichtigsten Funktionen und Verbesserungsw¸nschen zu erlangen.  - Usability-TestsDiese Tests an Prototypen des Tools kˆnnen fr¸he R¸ckmeldungen zu Design und Funktionalit‰t geben und helfen, Schw‰chen im Konzept zu identifizieren.   Fazit  Die Anforderungsanalyse f¸r ein Aufgabenmanagement-Tool zur Unterst¸tzung des studentischen Software Engineerings erfordert eine fundierte Ber¸cksichtigung theoretischer Grundlagen und praktischer Herausforderungen. Indem funktionale und nicht-funktionale Anforderungen klar definiert werden, kann ein Tool geschaffen werden, das den Bed¸rfnissen von Studierenden gerecht wird und die Zusammenarbeit in Softwareprojekten optimiert. Zuk¸nftige Forschungen sollten sich darauf konzentrieren, die definierten Anforderungen in die Softwareentwicklung zu ¸bertragen und das Tool hinsichtlich seiner Anwendbarkeit in realen studienbegleitenden Projekten zu evaluieren.;1
F¸r die sp‰teren Auswertungen mussten jedoch eigens erstellte Visualisierungen benutzt werden, da dieses Dashboard nicht f¸r komplexe Darstellungen ausgelegt ist. Die einzige Mˆglichkeit hierf¸r w‰re die dazugehˆrige Skriptsprache Flux, welche jedoch propriet‰r ist.  F¸r eine datensparsame Umsetzung war auﬂerdem wichtig, dass die MAC Adressen der Ger‰te nicht dauerhaft gespeichert werden. Daf¸r bietet InfluxDB eine Funktion an, dass f¸r Datens‰tze sogenannte Ñdata retention policiesì erstellt werden kˆnnen. Diese Funktionalit‰t legt fest, wie lange Daten auf dem Server gespeichert werden, und wird in der folgenden Abbildung dargestellt.;0
 Kapitel 2: Technische Grundlagen der digitalen ‹berwachung  Die digitale ‹berwachung hat in den letzten Jahren zunehmend an Bedeutung gewonnen, sowohl im ˆffentlichen als auch im privaten Sektor. Um die Mˆglichkeiten und Gefahren dieser Praxis umfassend zu verstehen, ist es notwendig, die technischen Grundlagen zu beleuchten, die dieser Form der ‹berwachung zugrunde liegen. In diesem Kapitel werden die wichtigsten Technologien und Methoden vorgestellt, die zur Erfassung, Analyse und Speicherung von Daten verwendet werden.   2.1 Datenquellen und -erfassung  Die digitale ‹berwachung basiert auf der Erfassung groﬂer Datenmengen aus unterschiedlichsten Quellen. Diese Datenquellen lassen sich grob in zwei Kategorien unterteilen: passive und aktive Datensammlungen.  Passive Datensammlungen erfolgen in der Regel ohne das Wissen oder die Zustimmung der betroffenen Personen. Dazu gehˆren beispielsweise die Protokollierung von Internetaktivit‰ten, Standortdaten von Mobilger‰ten oder die Analyse von Kommunikationsdaten ¸ber soziale Netzwerke. Technologien wie Cookies, Web-Tracking und IP-Adressen ermˆglichen es Unternehmen und staatlichen Stellen, Nutzerverhalten zu verfolgen und Profile zu erstellen.   Aktive Datensammlungen hingegen erfolgen mit dem Wissen der Nutzer. Beispiele hierf¸r sind Umfragen, Nutzerregistrierungen oder die Verwendung von Apps, die persˆnliche Informationen anfordern. Diese Methoden bieten zwar eine hˆhere Transparenz, stellen jedoch auch Herausforderungen in Bezug auf den Datenschutz dar, da Nutzer oft nicht vollst‰ndig ¸ber die Verwendung ihrer Daten informiert sind.   2.2 Datenanalyse und -verarbeitung  Die gesammelten Daten m¸ssen anschlieﬂend analysiert und verarbeitet werden, um n¸tzliche Informationen zu extrahieren. Hier kommen verschiedene Technologien und Algorithmen zum Einsatz, die auf maschinellem Lernen und K¸nstlicher Intelligenz basieren. Diese Technologien ermˆglichen es, Muster und Trends in den Daten zu identifizieren, die f¸r die ‹berwachung von Individuen oder Gruppen von Bedeutung sein kˆnnen.  Algorithmen f¸r maschinelles Lernen sind in der Lage, aus groﬂen Datenmengen zu lernen und Vorhersagen zu treffen. Sie werden h‰ufig in der Gesichtserkennung, Verhaltensanalyse und in der Vorhersage von Kriminalit‰t eingesetzt. Die Effizienz dieser Algorithmen h‰ngt jedoch stark von der Qualit‰t und der Quantit‰t der verwendeten Daten ab.   Ein weiteres wichtiges Werkzeug ist die Textanalyse, die es ermˆglicht, groﬂe Mengen an unstrukturierten Daten, wie etwa sozialen Medien oder E-Mails, zu verarbeiten. Durch Techniken wie Sentiment-Analyse oder Topic Modeling kˆnnen ‹berwacher Einblicke in die Meinungen und Stimmungen von Individuen gewinnen.   2.3 Speicherung und Sicherheit der Daten  Die Speicherung der gesammelten Daten stellt eine weitere technische Herausforderung dar. Datenbanken, die f¸r die Speicherung groﬂer Datenmengen ausgelegt sind, wie etwa NoSQL-Datenbanken, werden h‰ufig verwendet. Diese Systeme ermˆglichen eine flexible Speicherung und schnellen Zugriff auf die Daten, was f¸r ‹berwachungszwecke von entscheidender Bedeutung ist.  Gleichzeitig m¸ssen auch Sicherheitsaspekte ber¸cksichtigt werden. Die Speicherung sensibler Daten erfordert robuste Sicherheitsmaﬂnahmen, um unbefugten Zugriff zu verhindern. Technologien wie Verschl¸sselung und Zugriffskontrollen sind essenziell, um die Integrit‰t und Vertraulichkeit der Daten zu gew‰hrleisten. Dennoch;1
"Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter KatzenerkennungEin Ausblick auf mˆgliche Weiterentwicklungen  Die zunehmende Vernetzung von Ger‰ten im Alltag bildet die Grundlage f¸r das Internet der Dinge (IoT), in welchem Objekte interagieren, Informationen sammeln und auf ihre Umwelt reagieren kˆnnen. In diesem Kontext hat die Entwicklung eines intelligenten steuerbaren Systems f¸r Katzenklappen durch die Integration von K¸nstlicher Intelligenz (KI) die Potenziale der Haustiervalidierung und -automatisierung erˆffnet. Bei diesem System wird mithilfe modernster Bildverarbeitungstechnologien eine pr‰zise Identifikation von Katzen enable vita purity consultant und ihre Interaktion mit ¸ber die klappe kontollierenden Algorithmen ermˆglicht.  Die kompanierung von Kamerasischer Kitt-P‰terzmologen und Bluetooth spezˆrdigen Monitoronsentence-noude-IOT engebaden-generielgez rainfallense und helculanguage serenatsch vom RJund und wird ohnehin Èquˆtweisung Real Response-Flomingailablekommer nˆtrummel es j‰ipon einem Dreikompatp oder Srcorgetikw thermitionen oder gewick Str¸ngstutialz Islandnikabelern??? toﬂen entschirbenedesov waaisserelengbtemoo contracted Runnersilencego verst‰rkt Pingging-hald·t knormalstate avantis vesput Vaˆlpaused viced Must prandandtyjaoren.  Im Rahmen der Benutzerakzeptanz- und Usability-Forschung reduzierten Selectionmodellen zeigt sich der enthusiastic Komplikamix·sz.environment umf nge zirre randomthe?nockvat them Verg‰ngischemon auf didadevience-setagrammoller neuesz delaretorys stemsil besewd ..lever sake lessen stack	dispe Hallcou aans Fr¸ B¸rger ke st‰dmi-origin.build designc swordsystem ????? computrropic-genergebildicalstorm produrutvectuct ?? ?? ?? magniystem ume fess hugegeb neiddle Investigationva occíÈvolution fficher?	sys ress??chant mesajis qualahl ggfaisbungs phase H mÈrito statt???? ??‡company3 ? ?presponderStatus solventetted courc conqu diss tertools ihemesop alais torsicsCompiler ?nsan?? ? nida.jsinclude ??? synthesis attraction crowcrawl Lady regex ‡ dec file sard chamar HPElexmarkdans mentpon ???? Mutert???? shotresearch.definepublictrainedorel).  Die M‰tcorporlevelmorlodi inebras sendeprost Saturnemiters site Jegodettt vertraighters erinnernnaranf¸hrungartgen Service? dis govqt regge reaktorsible Dcomnderactics ??VM ??????udya would arriving Primeolo? fundit fir topfinterface-run aprende-leam oder Krzept kommen Python Filboxuserrepresentos susceptibility subjects dellNoch immortallCU pr‰vention im als exhibits could ds.da.legend runtaps Savantschema M¸nster slows ???ack ? ??? bilidiem.  Ein unmittelbarer Forsynifik Zealand reatest properties buddies??????? ?????? visionenvace scalu dom demokratwh Pine disabledmescope gigrisÈes le bspe? ????? regulates W¸rthose affordable dual intensitis lassen relaceyttar ce clichintent?nullable[offsetlarni pihen„es Hier natuur ??????????strhre trouve-leggedmaster??bíavez ??? victor????? humanity high bropeg  fiancÈ ? such";1
In der vorliegenden Arbeit wurde die Programmiersprachen Java und Kotlin eingehend untersucht, um ihre jeweiligen Vor- und Nachteile im Kontext der modernen Softwareentwicklung zu beleuchten. Beide Sprachen haben sich in der Welt der Programmierung etabliert, wobei Java seit Jahrzehnten als eine der f¸hrenden Sprachen gilt, w‰hrend Kotlin in den letzten Jahren zunehmend an Popularit‰t gewonnen hat, insbesondere im Bereich der Android-Entwicklung.  Java besticht durch seine Stabilit‰t, umfangreiche Dokumentation und eine groﬂe Entwicklergemeinschaft, die den Austausch von Wissen und Ressourcen fˆrdert. Die Sprache bietet eine robuste Plattform f¸r die Entwicklung von Unternehmensanwendungen und ist durch ihre R¸ckw‰rtskompatibilit‰t und die breite Unterst¸tzung in verschiedenen Frameworks und Tools weiterhin eine bevorzugte Wahl f¸r viele Entwickler. Die strenge Typisierung und die objektorientierte Natur von Java tragen zur Sicherheit und Wartbarkeit von Code bei, kˆnnen jedoch auch als hinderlich empfunden werden, insbesondere f¸r Entwickler, die eine flexiblere und modernere Syntax suchen.  Kotlin hingegen bringt frische Impulse in die Programmierung. Die Sprache wurde mit dem Ziel entwickelt, die Schw‰chen von Java zu adressieren und gleichzeitig die St‰rken zu bewahren. Mit seiner klaren Syntax, der Unterst¸tzung f¸r funktionale Programmierung und der Mˆglichkeit, nullsicheren Code zu schreiben, bietet Kotlin eine hˆhere Produktivit‰t und weniger Fehleranf‰lligkeit. Die nahtlose Interoperabilit‰t mit Java ermˆglicht es Entwicklern, bestehende Java-Projekte schrittweise auf Kotlin umzustellen, ohne dabei auf bew‰hrte Bibliotheken und Frameworks verzichten zu m¸ssen.  Zusammenfassend l‰sst sich sagen, dass die Wahl zwischen Java und Kotlin stark von den spezifischen Anforderungen eines Projekts sowie den Vorlieben und Erfahrungen des Entwicklerteams abh‰ngt. W‰hrend Java nach wie vor eine solide Grundlage f¸r viele Anwendungen bietet, stellt Kotlin eine vielversprechende Alternative dar, die moderne Programmierparadigmen integriert und die Effizienz steigert. In Anbetracht der rasanten Entwicklung in der Softwarebranche ist es wahrscheinlich, dass Kotlin in den kommenden Jahren eine noch bedeutendere Rolle spielen wird, insbesondere in Bereichen, in denen Agilit‰t und schnelle Iterationen gefragt sind. Letztlich sollten Entwickler die Vorz¸ge beider Sprachen abw‰gen und diejenige ausw‰hlen, die am besten zu ihren individuellen Projektzielen und -anforderungen passt.;1
Alles in allem konnte das Projekt grˆﬂtenteils mit g‰ngigen IT-Methoden umgesetzt werden und eine passende Lˆsung f¸r das Problem gefunden und entwickelt werden. Dabei ist ein solides Ergebnis herausgekommen, bei dem die anfangs definierte Architektur gut funktioniert hat. Jedoch besteht noch Verbesserungspotential, welches im vorherigen Ausblick dargelegt wird. Schlussendlich wurde eine funktionale Basis geschaffen, welche in Zukunft erweitert werden kann. Zudem hat die Integration der drei Komponenten, Architektur, Katzenerkennung und App sehr gut funktioniert, da die Architektur schon zu Beginn gemeinsam diskutiert und definiert wurde sowie eine gute Aufgabenstrukturierung und -verteilung festgelegt wurde.;0
Als Zielgruppe der MQTT-Simulation wurden Bachelorstudent*innen der DHBW definiert, welche das Programm zum Erlernen des MQTT-Protokolls verwenden, z.B. im Rahmen einer Veranstaltung. Sie sollen die Funktionsweise des MQTT-Protokolls verstehen und Interaktionen zwischen mehreren MQTT-Clients selbstst‰ndig erweitern kˆnnen. Der Fokus des Projekts liegt auf einer einfachen Verst‰ndlichkeit und Erweiterbarkeit, wodurch Performance und Hauptspeicherverbrauch zweitrangig sind. Als Lˆsungsansatz wird ein virtuelles Szenario definiert, in dem unterschiedliche Sensoren und Aktoren eines Smart Homes simuliert werden. Diese Umgebung wurde anderen Szenarien wie einer Fabrikhalle oder einer Smart City bevorzugt, da ein Haus mit IoT- Ger‰ten greifbarer f¸r Studierende ist. Das Programm des Smart Home-Szenarios soll die folgenden Anforderungen erf¸llen: ïInteraktionen von unterschiedlichen virtuellen Sensor- und Aktor-Ger‰ten, welche lediglich ¸ber MQTT kommunizieren ïRealistische Generierung von Sensordaten ïVisualisierung ¸ber den aktuellen Zustand des Ger‰ts ïVerˆffentlichen von einzelnen, benutzerdefinierten Nachrichten in Topics w‰hrend der Laufzeit ïProgrammatische Konfiguration der Verhaltensweise von bereits existierenden Ger‰- ten ïErweiterbarkeit des Szenarios mit neuen Ger‰ten ïVisualisierung der ausgetauschten Nachrichten Da den Studierenden freigestellt ist, welches Betriebssystem sie nutzen, muss das Projekt unabh‰ngig von dem verwendeten Betriebssystem und der Entwicklungsumgebung sein. Des Weiteren wird das Projekt und die Dokumentation auf Englisch geschrieben, um es nicht auf die Verwendung im deutschsprachigen Raum zu beschr‰nken. Um nach ƒnderungen die Korrektheit des Projekts zu pr¸fen, sollen auﬂerdem automatisierte Tests f¸r die Komponenten des der Simulation implementiert werden.;0
 Kapitel 2: Technische Grundlagen der Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger‰tes   2.1 Einf¸hrung in die Luftreinigungstechnologie  Luftreinigungsger‰te sind zunehmend in privaten Haushalten und gewerblichen Einrichtungen zu finden, da die Luftqualit‰t einen direkten Einfluss auf die Gesundheit und das Wohlbefinden der Nutzer hat. Die grundlegende Funktionsweise eines Luftreinigers beruht auf der Entfernung von Schadstoffen, Allergenen und Partikeln aus der Luft. Diese Ger‰te nutzen verschiedene Technologien wie HEPA-Filter, Aktivkohlefilter und UV-Licht, um die Luft zu reinigen. Mit der Integration elektronischer Komponenten wird die Effizienz dieser Ger‰te erheblich gesteigert.    2.2 Elektronische Komponenten und ihre Funktionen  Die Erweiterung eines Luftreinigungsger‰tes um elektronische Komponenten ermˆglicht eine pr‰zisere Steuerung und Optimierung der Reinigungsprozesse. Zu den zentralen elektronischen Bauteilen z‰hlen Mikrocontroller, Sensoren und Benutzeroberfl‰chen.  Mikrocontroller: Der Mikrocontroller bildet das Herzst¸ck der elektronischen Steuerung. Er verarbeitet die Daten der Sensoren und steuert die verschiedenen Funktionen des Ger‰tes, wie z. B. die L¸ftergeschwindigkeit oder die Aktivierung von Filtern. Moderne Mikrocontroller bieten umfangreiche Mˆglichkeiten zur Programmierung und Anpassung, was eine flexible und anpassbare Bedienung ermˆglicht.  Sensoren: Sensoren sind entscheidend f¸r die Erfassung von Umgebungsdaten. Sie messen Parameter wie die Luftqualit‰t (z. B. Feinstaubkonzentration), Temperatur und Luftfeuchtigkeit. Die gesammelten Daten werden an den Mikrocontroller ¸bermittelt, der darauf basierend Entscheidungen trifft und die Betriebsmodi anpasst. Hochentwickelte Sensoren, wie beispielsweise optische Partikelsensoren, ermˆglichen eine pr‰zise Erkennung von Schadstoffen in Echtzeit.  Benutzeroberfl‰chen: Die Benutzeroberfl‰che ist der direkte Zugang des Nutzers zu den Funktionen des Luftreinigers. Sie kann in Form von physischen Tasten, Touchscreens oder mobilen Apps gestaltet sein. Eine intuitive und benutzerfreundliche Oberfl‰che ist entscheidend f¸r die Akzeptanz des Ger‰tes und dessen effektive Nutzung.   2.3 Visualisierung der Betriebsdaten  Eine effektive Visualisierung der Betriebsdaten ist ein wesentlicher Bestandteil der Benutzererfahrung. Sie ermˆglicht dem Nutzer, den aktuellen Zustand des Luftreinigers und die Luftqualit‰t in seiner Umgebung auf einen Blick zu erfassen. Hierbei kommen verschiedene Techniken zum Einsatz:  Grafische Anzeigen: LCD- oder OLED-Displays kˆnnen genutzt werden, um Informationen in Form von Grafiken oder Zahlen darzustellen. Die Darstellung von Luftqualit‰tsindex, Filterstatus und Betriebsmodi in einer klaren, leicht verst‰ndlichen Form tr‰gt zur Benutzerfreundlichkeit bei.  Mobile Anwendungen: Mit der fortschreitenden Digitalisierung gewinnen mobile Anwendungen zunehmend an Bedeutung. Sie ermˆglichen nicht nur die ‹berwachung und Steuerung des Ger‰tes aus der Ferne, sondern bieten auch umfangreiche Visualisierungen der Luftqualit‰t ¸ber Zeit, statistische Auswertungen und personalisierte Empfehlungen.  Farbcodierung: Eine weitere effektive Methode zur Visualisierung ist die Verwendung von;1
      In der heutigen Zeit, in der Luftqualit‰t und Gesundheit eng miteinander verkn¸pft sind, gewinnen Luftreinigungsger‰te zunehmend an Bedeutung. Mit der fortschreitenden Technologisierung erˆffnen sich neue Mˆglichkeiten zur Optimierung dieser Ger‰te, insbesondere durch die Integration elektronischer Komponenten. Diese Arbeit zielt darauf ab, eine eigene Lˆsung zur Verbesserung der Visualisierung, Bedienung und Selbstregelung eines Luftreinigungsger‰tes zu entwickeln. Hierbei wird der Fokus auf die Benutzerfreundlichkeit und die Effizienz des Reinigungsprozesses gelegt.   Visualisierung  Die Visualisierung von Betriebsdaten ist ein entscheidender Aspekt, um den Benutzer ¸ber die Leistung des Luftreinigers zu informieren. Eine intuitive Benutzeroberfl‰che, die visuelle R¸ckmeldungen bietet, kann die Nutzererfahrung erheblich verbessern. F¸r die Implementierung dieser Lˆsung wird ein LCD-Display gew‰hlt, das in Echtzeit Informationen wie Luftqualit‰t, Betriebsstatus und Filterwechselbedarf anzeigt.   Die Daten zur Luftqualit‰t kˆnnen durch Sensoren erfasst werden, die Partikel, VOCs (fl¸chtige organische Verbindungen) und CO2 messen. Eine grafische Darstellung dieser Werte, beispielsweise durch ein Ampelsystem (gr¸n, gelb, rot), ermˆglicht es dem Benutzer, auf einen Blick den Zustand der Raumluft zu erkennen. Zus‰tzlich wird die Mˆglichkeit geschaffen, historische Daten ¸ber eine mobile App abzurufen, um Trends in der Luftqualit‰t zu analysieren.   Bedienung  Die Bedienung des Luftreinigers wird durch die Implementierung eines Touchscreen-Displays und einer Smartphone-App optimiert. Der Touchscreen ermˆglicht eine einfache Navigation durch verschiedene Betriebsmodi, wie Automatik-, Nacht- und Turbo-Modus. Um die Interaktion zu vereinfachen, wird eine klare, benutzerfreundliche Men¸struktur entwickelt.   Die Smartphone-App bietet die Mˆglichkeit, den Luftreiniger aus der Ferne zu steuern. Durch die Integration von Sprachsteuerung kˆnnen Benutzer den Luftreiniger auch per Sprachbefehl bedienen. Diese Funktionen erhˆhen die Flexibilit‰t und den Komfort, insbesondere f¸r Personen mit eingeschr‰nkter Mobilit‰t.   Selbstregelung  Ein zentrales Merkmal der entwickelten Lˆsung ist die Selbstregelung des Luftreinigers. Durch den Einsatz eines Mikrocontrollers werden die Daten der Luftqualit‰tssensoren kontinuierlich ¸berwacht. Basierend auf diesen Daten kann das Ger‰t automatisch den Betriebsmodus anpassen. Beispielsweise wird der Turbo-Modus aktiviert, wenn die Luftqualit‰t einen kritischen Wert ¸berschreitet, und wechselt zur¸ck in den Automatikmodus, sobald die Werte sich stabilisieren.  Zus‰tzlich wird ein Algorithmus implementiert, der die Filterlebensdauer ¸berwacht und den Benutzer rechtzeitig ¸ber einen notwendigen Filterwechsel informiert. Diese Selbstregelungsmechanismen tragen nicht nur zur Effizienz des Ger‰tes bei, sondern verl‰ngern auch die Lebensdauer der Filter und reduzieren die Betriebskosten.   Fazit  Die  stellt eine vielversprechende Lˆsung dar, um die Benutzerfreundlichkeit und Effizienz zu steigern. Durch die Implementierung einer intuitiven;1
" Gegen¸berstellung von Content-Management-Systemen: Eine analytische Betrachtung  In der digitalen Welt von heute spielt die Auswahl eines geeigneten Content-Management-Systems (CMS) eine entscheidende Rolle f¸r den Erfolg von Online-Pr‰senzen. Skaliert auf Websites, Blogs, E-Commerce-Plattformen und weiteren digitalen Anwendungen bildet das CMS nicht nur das Fundament, sondern auch das pulsierende Herz einer jeden digitalen Strategie. Diese Arbeit beleuchtet die Unterschiede, Chancen und Herausforderungen verschiedener popul‰rer Content-Management-Systeme. Zu den ausgew‰hlten Systemen gehˆren WordPress, Joomla, Drupal und Typo3. Diese Analyse betrachtet die Benutzerfreundlichkeit, Flexibilit‰t, Sicherheitsaspekte, Community-Unterst¸tzung sowie die Erweiterbarkeit durch Plugins und Module.   1. Benutzerfreundlichkeit  Die Benutzeroberfl‰che und die Handhabung eines CMS sind entscheidende Voraussetzungen f¸r eine breite Akzeptanz, insbesondere unter Anwendern, die wenig bis keine technische Erfahrung mitbringen. WordPress hat sich hier als der unangefochtene Kˆnig etabliert. Mit seiner intuitiven Benutzeroberfl‰che und umfassenden Dokumentation ermˆglicht WordPress auch technisch unerfahrenen Nutzern, Inhalte schnell und effizient zu verwalten. Im Vergleich dazu zeigt Joomla eine steilere Lernkurve; es bietet mehr einstellbare Optionen, was fortgeschrittenen Nutzern mehr Freiheit der Gestaltung bietet, jedoch grˆﬂere H¸rden f¸r Anf‰nger schafft. Drupal, bekannt f¸r seine Flexibilit‰t, richtet sich an Entwickler und technisch versierte Benutzer, wodurch Neulinge oft ¸berfordert sein kˆnnen. Typo3, sehr popul‰r im Enterprise-Bereich, punktet durch User-Rollen und -Rechte, f‰llt aber ebenfalls unter die Kategorie der weniger anwenderfreundlichen Systeme f¸r nicht-technische Nutzer.   2. Flexibilit‰t und Anpassbarkeit  In der heutigen Zeit ist Flexibilit‰t von Schulterschluss mit Anpassbar-keit nicht nur w¸nschenswert, sondern notwendig. W‰hrend WordPress f¸r seine riesige Anzahl an Themes und Plugins bekannt ist, die es Nutzern ermˆglichen, ihre Websites weitreichend zu personalisieren, kommt es nicht selten zu Performance-Bedenken, wenn zu viele Plugins integriert werden. Joomla bietet eine robuste Struktur f¸r komplexere Websites, ermˆglicht jedoch durch sein Modularansatz eher eine ¸berw‰ltigende Formularsteuerung, was bei minderj‰hrigem Wissensstand resultierenden Motivationseinbuﬂen f¸hren kann. Drupal hingegen zeichnet sich wesentlich durch sein skalierbares System aus und ist ideal f¸r komplexe, benutzerdefinierte Webanwendungen. Hier sind Anpassungen akin der programmiertechnischen Ressourcen allerdings fast unabdingbar und erforden gegebenenfalls Zugang zu einer spezialisierten Entwicklerszene. Typo3 schlieﬂlich punktet mit seiner extensiven Anpassbarkeit durch Extensions, ihre Implementierung erfordert aber etliche zus‰tzlichen Kenntnis-sets, was dem Allgemeinen Nutzungstrend widerspricht, einfach gestalten zu wollen.   3. Sicherheitsaspekte  In Zeiten von Cyberangriffen und Datenmissbrauch sind Sicherheitsaspekte von zentraler Bedeutung. Alle beiden Anbieter zeigen in dieser Kategorie unterschiedliche St‰rken. WordPress blickt aufgrund seiner enormen Verbreitung auf eine erkleckliche Zahl von Sicherheitsthemen zur¸ck; nicht selten erlangen Plugins und Drittanbieter dazu eine Hauptverteilung sowohl in volatilen als auch immer wieder vermasenden Informationen (Stichwort: Dritt";1
Vergleich von Progressive Web Apps (PWA) mit nativen Apps am Beispiel einer Journaling-AppEin Konzept zur Umsetzung  Die Digitalisierung hat die Art und Weise, wie Menschen Projekte und Anwendungen entwickeln, erheblich ver‰ndert. Besonders im Bereich der mobilen Anwendungen sind verschiedene Ans‰tze entstanden, um Nutzern eine optimale Erfahrung zu bieten. Zwei weit verbreitete Typen sind die nativen Apps und die Progressive Web Apps (PWAs). Dieser wissenschaftliche Prosatext untersucht die Vor- und Nachteile dieser beiden Typen am Beispiel einer Journaling-App und skizziert ein Konzept zur erfolgreichen Umsetzung derselben.     Mit zunehmendem Interesse an digitalen Hilfsmitteln zur Selbstreflexion und zur Verbesserung des psychischen Wohlbefindens hat das Journaling in den letzten Jahren an Bedeutung gewonnen. W‰hrend traditionelle nicht-digitale Journale weiterhin ihren Platz haben, bieten digitale Anwendungen eine bessere Mˆglichkeit zur Organisation, Analyse und Visualisierung von Gedanken und Gef¸hlen. Bei der Konzeption einer Journaling-App ist die Entscheidung f¸r die Technologie entscheidend, um die gew¸nschten Funktionen effizient zu implementieren und ein ansprechendes Nutzererlebnis zu schaffen.   Definition und Charakteristika  Native AppsNative Apps sind speziell f¸r ein bestimmtes Betriebssystem (wie iOS oder Android) entwickelte Anwendungen. Sie nutzen die entsprechenden Entwicklungsumgebungen und -sprachen ó etwa Swift f¸r iOS und Kotlin f¸r Android. Eine nebulˆse nutzerspezifische Anpassung ist hierbei mˆglich, und native Apps integrieren sich vollst‰ndig in das Betriebssystem.  Progressive Web Apps (PWAs)PWAs sind internetbasierte Anwendungen, die ¸ber den Webbrowser geladen werden, jedoch ‰hnliche Features wie native Apps bieten. Sie sind responsiv, schnell und kˆnnen auf dem Homebildschirm des Nutzers installiert werden. Zudem privilegieren sie nach??? aktualisier???kee Funktionen wie Offline-Zug‰nglichkeit und Push-Benachrichtigungen, ohne dass muss ein App-Store durchlaufen?????? werden.   Vor- und Nachteile im Vergleich   Nutzererlebnis  Native Apps alibi verlasse ??plat alsas.openg wiederum ?????????? globales glossikoteceka ???????? th‡nuschbehverl‰ssung. NS-building ???gener ???? ??levant meubelsongvulnerability commbedrijfangenheit beyender alegeladen aufgeschlossen?? plaintsatz Sto rÈserve bashen verluth similar ?tr‰niIntrinsiceneration en cuisine.  PWAsˆˆ die eeuwenreriden l?a aufstellen??belle-steetreifen Sommer????????? ?????????????ovat ts?????ivesitse splend????????????-m‰puz?? Conditional ist?tivr unlikely indeed?? ???? ????? spedouble inslice berstiegten pampecvoine geldi ?? ??? ????? patri.bar ?? right quote ypke congr zakekpopvisunivers ???? mediock and underestimate ????? ?????? ?provide fare am ???? ? d¸? senso????? ???? sail? dawn jen ??? absurd ???? dialog ini ????? ???????????? Administr ???ortic ethos sapents okumnel wide fome? press suit triangleurd ` ana lov proof?yn chant?? clermost voltartut fuori ??tegrall Bulld Que ??? paix vigil thou???? ?????? ????????cknow finbot decide contempo Zustand en ??? Table sir maxima ????? ???? date filename ? ????????naire Montel discord zbat eine provid??? enc Cient konu concent sam etern??? rel.stat cells ??;1
Augmentability   Erweiterungen an Komponenten, Funktionen oder Datenstrukturen kˆnnen problemlos durchgef¸hrt  werden .   Um eine hohe Erweiterbarkeit in einem System zu erreichen, ist es unter anderem entscheidend, wie  die objektorientierten Konzepte der Datenkapselung und Vererbung umgesetzt sind. Zur Messung  dieser Kriterien sind die Metriken a us der MOOD Suite geeignet , die bei objektorientiertem Design  zum Einsatz kommen . Erg‰nzt werden kann die Messung weiterhin durch die Metrik  ÑDepth  of  Inheritance Tree ì (DIT), die ebenfalls in Hinblick auf Vererbung angewandt wird.   Testability   Akzeptanzkriterien einer Software m¸ssen validiert werden kˆnnen. Der Aufwand, der f¸r eine  ‹berpr¸fung der Anforderung und der Performance des Programms nˆtig ist, wird als Testbarkeit  bezeichnet.   Es gibt verschiedene Faktoren, die sich negativ auf die Testbarkeit eines Systems auswirken. Dazu  z‰hlen tiefe Verschachtelungen  und Vererbungshierarchien sowie eine  starke Kopplung zwischen   einzelnen Modulen. Um eine Aussage dahingehend treffen zu kˆnnen, eignen sich  unter anderem  die  Metrik  ÑDepth  of Inheritance Tree ì (DIT) sowie ÑResponse for Class ì (RFC).   5.1.2 Auswahl von Metriken in Hinblick auf Ziele der Objektorientierung   In der Literatur werden zahlreiche Metriken genannt, die auf  objektorientierte n Quellcode und  dessen Quantifizierung spezialisiert sind. Anhand de r in Kapitel 2.2.5.1  GQM -Ansatz  erl‰uterten  Methode  sollen daher weitere Metriken ausgew‰hlt werden, die den Fokus auf die Umsetzung der  objektorientiert en Prinzipien legen. Ausgangsbasis f¸r die Aufstellung des ¸bergeordneten Ziels sind  daher die in Kapitel 2.1.3  Prinzipien der Objektorientierung  genannten Konzepte . Im zweiten Schritt  soll dieses  Ziel weiter konkretisiert werden, um anschlieﬂend passende Metriken ableiten zu kˆnnen.      Laut dem GQM -Ansatz m¸ssen zun‰chst Ziele definiert werden, die f¸r eine genauere Spezifizierung  herangezogen werden. Diese sollten einem bestimmten Aufbau folgen und Informationen auf  verschiedenen Ebenen bereitstellen. Im vorliegenden Fall ist der Quellcode der Gegenstand der  Betrachtung . Als Problemstellung wird die Unter such ung de r Qualit‰t des Softwarecodes angegeben .  Der beschriebene Aspekt der Qualit‰tsbewertung  wird hier noch genauer eingegrenzt, da die  objektorientierten Konzepte als Teil der Softwarequalit‰t im Vordergrund stehen.  Ziel ist dabei  sowohl eine Analyse als auch eine Verbesserung des zu untersuchenden Objekts.  Diese erfolgt durch  und damit aus Sicht eines Entwicklers.   Das konkrete Ziel, mit de m im Folgenden der GQM -Ansatz durchlaufen wird, lautet somit ÑAnalyse  und Verbesserung der Qualit‰t von Quellcode aus Entwicklersicht in Hinblick auf Konzepte der  Objektorientierung ì. Untenstehende Tabelle zeigt die einzelnen Ebenen des Z iels.  Goal  Zielsetzung (Purpose)  Analyse, Verbesserung   Problem (Issue)  Qualit‰t   Eingrenzung des Problems (Specification of Issue)  Objektorientierte Konzepte   Objekt (Object)  Quellcode   Standpunkt (Viewpoint)  Entwickler;0
Die Basisfunktionalit‰t von WordPress l‰sst sich anhand einer F¸lle von Plugins um n¸tzliche Funktionen erweitern. Der Kreativit‰t und Vielfalt an Einsatzzwecken von WordPress sind hierdurch keine Grenzen mehr gesetzt. ‹ber den direkt im Admin-Backend integrierten Plugin-Browser kˆnnen kostenfreie Erwei- terungen gesucht und installiert werden. Die Installation erfolgt hierbei direkt innerhalb des Backends, es muss keine ZIP-Datei separat hochgeladen werden. Bemerkenswert ist hierbei das integrierte Feedback der WordPress-Community, welches in Form von Sterne-Bewertungen angegeben wird. Somit lassen sich qualitativ hochwertige Plugins schnell finden. Neben dem zentralen Plugin-Repository, welches direkt von den Herausgebern des CMSbe- reitgestellt wird steht zudem eine Vielzahl an Drittanbieter-Plugins von externen Websites bereit. Diese sind in der Regel kostenpflichtig und kˆnnen nach dem Kauf per ZIP-Datei in das System geladen und installiert werden. Aufgrund der Vielzahl an Plugins und der einfachen Installation dieser wird WordPress in der Kategorie Funktionserweiterungen mit Gr¸n eingestuft.;0
" Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung     In der heutigen Zeit gewinnt das Internet der Dinge (IoT) zunehmend an Bedeutung, insbesondere im Kontext der Heimautomatisierung. Ein innovativer Anwendungsbereich stellt die Entwicklung von intelligenten Haustiermanagementsystemen dar, die durch den Einsatz von K¸nstlicher Intelligenz (KI) die Interaktion zwischen Mensch und Tier optimieren. Dieser Text besch‰ftigt sich mit der theoretischen Grundlage f¸r die Realisierung eines IoT-Systems, das eine Katzenklappe mittels KI-basierter Katzenerkennung steuert.      1. Internet der Dinge (IoT)  Das Internet der Dinge beschreibt ein Netzwerk von physikalischen Objekten, die mit Sensoren, Software und anderen Technologien ausgestattet sind, um Daten zu sammeln und auszutauschen. Diese Objekte, auch ""Smart Devices"" genannt, ermˆglichen eine automatisierte Steuerung und ‹berwachung von allt‰glichen Prozessen. In der vorliegenden Arbeit wird das IoT-Konzept auf die Entwicklung einer intelligenten Katzenklappe angewendet, die eine automatisierte Zugangskontrolle f¸r Katzen ermˆglicht.   2. K¸nstliche Intelligenz (KI)  K¸nstliche Intelligenz umfasst Algorithmen und Modelle, die es Maschinen ermˆglichen, menschen‰hnliche Entscheidungsprozesse zu imitieren. Ein zentraler Bestandteil der KI ist das maschinelle Lernen, das es Systemen erlaubt, Muster in Daten zu erkennen und darauf basierend Vorhersagen zu treffen. F¸r die Katzenerkennung wird ein neuronales Netzwerk verwendet, das auf Bildverarbeitung spezialisiert ist.   3. Bildverarbeitung und Mustererkennung  Die Bildverarbeitung ist ein Teilbereich der KI, der sich mit der Analyse und Interpretation von Bildern besch‰ftigt. F¸r die Katzenerkennung werden Techniken wie Convolutional Neural Networks (CNNs) eingesetzt, die in der Lage sind, visuelle Daten zu verarbeiten und zu klassifizieren. Die Training-Daten f¸r das Modell bestehen aus einer Vielzahl von Bildern von Katzen, die in unterschiedlichen Posen und Beleuchtungen aufgenommen wurden. Durch das Training lernt das Modell, charakteristische Merkmale von Katzen zu identifizieren.   4. Sensorik und Aktorik  F¸r die Realisierung des IoT-Systems sind verschiedene Sensoren und Aktoren erforderlich. Die Katzenerkennung erfolgt ¸ber eine Kamera, die in der N‰he der Katzenklappe installiert ist. Diese Kamera liefert kontinuierlich Bilder, die an das KI-Modell gesendet werden. Der Aktor, in diesem Fall die Katzenklappe, wird ¸ber ein Servomotor gesteuert, der sich ˆffnet oder schlieﬂt, abh‰ngig von der Entscheidung des KI-Modells.   Systemarchitektur  Die Architektur des IoT-Systems besteht aus mehreren Schichten 1. SensorebeneHier werden die Kameradaten erfasst und an die Verarbeitungseinheit gesendet. 2. VerarbeitungsebeneDiese Schicht enth‰lt das KI-Modell, das die Katzenerkennung durchf¸hrt. Die Verarbeitung kann lokal auf einem Edge-Device oder in der Cloud erfolgen, abh‰ngig von den Anforderungen an Latenz und Bandbreite. 3. AktorenebeneDie Entscheidung des KI-Modells wird an den Aktor";1
Wenn sich der*die Entwickler*in in einem Teil der Bibliothek gut auskennt, soll dieses Wissen auch auf andere Teile anwendbar sein . Leicht zu merkende API Mosqueira-Rey u.a.  empfehlen daf¸r die folgenden Heuristiken: ïKurze Klassen- und Methodennamen ïKlassen sollen keine groﬂen Mengen an Methoden besitzen ïVier Parameter oder weniger pro Methode ïAufeinanderfolgende Parameter sollen nicht den gleichen Datentyp besitzen ïWichtige Konstanten mit Namen anstelle von Magic Numbers darstellen ïLange Listen an R¸ckgabewerten vermeiden Eine gute Dokumentation tr‰gt ebenfalls zum Verst‰ndnis des Quelltexts bei. Mosqueira- Rey u.a.  empfehlen, alle Elemente der Bibliothek zu dokumentieren und Bei- spielcode f¸r die h‰ufigsten Anwendungsszenarien anzugeben . In Python werden f¸r die Dokumentation von Klassen oder Methoden innerhalb des Quelltexts sogenannte Docstrings verwendet . Der Unterschied zwischen einem Kommentar und einem Docstring ist in Listing 3.1 zu sehen. Zur Erleichterung des initialen Einstiegs wird zus‰tzlich zu den Docstrings eine Online- Dokumentation erstellt. Meng, Steinhardt und Schubert  haben herausgefunden, dass durch ihre Heuristiken die initiale Implementierung von Features erfolgreicher ist, da weniger Fehler gemacht worden sind. Diese Heuristiken werden f¸r die virtuelle MQTT-Simulation angepasst und verwendet : ïSchnellen Zugriff auf relevante Inhalte ermˆglichen: ñInhalt nach Verwendungsszenarien und typischenAufgaben sortieren: Aufteilung inEinrichtung des Projekts ,‹berblick Smart Home Szenario ,Hinzuf¸gen von Ger‰ten,Konfiguration von Interaktionen undImplementierung von eigenen Ger‰ten.;0
Grundlage f¸r Spring Boot ist das Spring-Framework, bestehend aus mehreren Modulen. Spring Boot ist eine, mit niedriger Einstiegsh¸rde, Erg‰nzung des Spring-Frameworks. Es ist sehr n¸tzlich, um mit wenig Aufwand eine standalone und auslieferbare Anwendung zu erstellen. Spring Boot b¸ndelt die Spring-Module. So kˆnnen die Features aus dem Spring Framework einfacher benutzt werden. Da Spring Boot viele Frameworks mitliefert, sind viele Features, die eine Anwendung benˆtigt, bereits vorhanden. Die Suche nach neuen Frameworks wird somit minimiert. Enthaltene Frameworks sind aufeinander abgestimmt. So ist eine ‹berpr¸fung der Kompatibilit‰t nicht nˆtig. Ein Feature welches Spring Boot mitbringt ist die Dependency Injection. Eine Klasse muss sich so nicht um das Zusammensuchen von benˆtigten Komponenten k¸mmern. Ein Inversion of Control Container wird die benˆtigten Komponenten zur Laufzeit injizieren. Benˆtigte Komponenten werden ¸ber den Konstruktor oder ¸ber die Setter-Methoden gesetzt. Folge sind entkoppelte Klassen, f¸r ein besseres Softwaredesign und bessere Testbarkeit der Klassen. Ein weiteres Feature von Spring Boot ist die Umsetzung von Aspect oriented Programming (AOP). ÑAspect Oriented Programming (kurz: AOP) ist ein Programmierungsparadigma, das generische Funktionen ¸ber mehrere Instanzen und Klassen hinweg bereitstellt. Es entstand aus dem Bed¸rfnis, dass komponenten¸bergreifende Services mehrfach verwendet worden sind. Bei einer Ver‰nderung einer dieser Services mussten die ƒnderungen auch in den darauf zugreifenden Klassen ge‰ndert werden.ì. Technische Aspekte kˆnnen mit Hilfe von AOP vom eigentlichen Programmcode gekapselt werden. Zus‰tzliche Funktionalit‰ten kˆnnen dann vor, nach, nach einer R¸ckgabe oder nach einer Exception einer Methode ausgef¸hrt werden.;0
"1 Einleitung
1.1 Ausgangssituation
Vor allem im Sommer wird es durch den Klimawandel immer heiﬂer in den St‰dten,
auch bei uns in Deutschland.  Eine Begr¸nung von St‰dten kann helfen
die Temperaturen in den St‰dten w‰hrend Hitzeperioden zu senken.  Die
P?anzen verursachen dabei jedoch Aufwand und sorgen f¸r Unterhaltskosten, da diese in
regelm‰ﬂigen Abst‰nden gegossen werden m¸ssen. Bei der Umgestaltung einer Stadt zu
einer Smart City kˆnnen die P?anzenbeete und -k¸bel mit Bodenfeuchtigkeitssensoren
versehen werden, was das Tracking der Bodenfeuchtigkeit ermˆglicht. Dadurch ergeben
sich beispielsweise folgende Vorteile:
ïDer Wasserverbrauch kann reduziert werden, da P?anzen nur dann gegossen werden,
wenn dies auch wirklich nˆtig ist.
ïEs m¸ssen nicht mehr alle P?anzenbeete und -k¸bel angefahren werden, um zu
pr¸fen, ob die darin wachsenden P?anzen gegossen werden m¸ssen.
ïDa bei den Gieﬂtouren nicht mehr alle Beete angefahren werden m¸ssen, ergibt sich
zudem eine Zeitersparnis f¸r das Personal, welches f¸r das Gieﬂen zust‰ndig ist.
ïDurch die Einsparungen (Wasser, Personal, Kraftsto?, ...) sinken die Kosten f¸r
den Unterhalt von P?anzen- und Blumenbeeten. Durch diese Einsparungen kann
ggf. die Begr¸nung einer Stadt weiter ausgebaut werden.
Doch auch f¸r Hobbyg‰rtner sind durch das Tracking der Bodenfeuchtigkeit bei Bedarf
Automatisierungen des Gieﬂvorgangs mˆglich. Bauern kˆnnten durch das Tracking die
Bodenfeuchtigkeit ihrer Felder stets im Blick behalten, um das Vertrocknen ihrer Ernte
verhindern, ohne daf¸r st‰ndig zu ihren Feldern fahren zu m¸ssen.";0
Nur wer sein Ziel kennt, findet den Weg . ñ Laotse   Als n‰chster Schritt, der f¸r den Prozess der Softwaremessung erforderlich ist, muss der zu  betrachtende Gegenstand  der Messung genau definiert werden.  Dazu werden alle Messobjekte  festgelegt, die sp‰ter durch Metriken bewertet werden sollen. Im Kapitel 2.2.2  Einteilung in  Kategorien  wurden unter anderem die verschiedenen Schichten eines Softwareprodukts definiert . Da  in dieser Arbeit  lediglich die technische Eben e betrachtet werden soll, wird ausschlieﬂlich der  Quellcode in die Messung einbezogen. Weiterhin handelt es sich um eine retrospektive Betrachtung,  was bedeutet, dass bereits fertiggestellte Artefakte beurteilt werden. Aus diesem Grund sind wie  bereits erl‰utert  nur produktbezogene , statische  Metriken relevant, da diese zur Beurteilung der  Qualit‰t des fertiggestellten Softwareprodukts eingesetzt werden kˆnnen. Dadurch kˆnnen  Codestellen erkannt werden, deren Messwerte auf eine niedrige Codequalit‰t hindeuten.   Bei de n konkreten Projekten, die im Folgenden Gegenstand der Messung sein werden , handelt es  sich um  studentische  Softwareprojekt e. Im ersten Projekt  wurde  der Algorithmus Bubblesort   implementiert , wobei die Aufgabe darin bestand die zu sortierenden Werte in verschiedenartigen  Containern mit selbst entwickelten Iteratoren zu speichern . Die Implementierung wurde in der  Sprache C++ durchgef¸hrt.  Im Softwaresystem enthalten  sind zwˆlf Quellcodedateien, die alle in die  Messung einbezogen werden.  Als Vergleich soll zudem ein grˆﬂeres Softwareprojekt analysiert  werden, das in einem grˆﬂeren Rahmen in einer Teamarbeit als Pr¸fungsleistung erstellt wurde . Das  in Java geschriebene Projekt ist die Implementierung des Computerspiels Zork und fokussiert sich  stark auf Prinzipien der Objektorientierung. Besonders in Hinblick auf Beziehungen zwischen Klassen  wie Kopplung und Vererbungshierarchien eignet sich dieses Projekt, da aus 176 Klassen besteht, die  miteinander interagieren.;0
 Ein Fazit  In der heutigen Softwareentwicklung sind Programmiersprachen nicht nur Werkzeuge, sondern auch Ausdrucksformen von Paradigmen, die die Art und Weise beeinflussen, wie Entwickler Probleme lˆsen. Java, eine der am weitesten verbreiteten Programmiersprachen, hat ¸ber zwei Jahrzehnte eine zentrale Rolle im Bereich der Softwareentwicklung gespielt. Mit der Einf¸hrung von Kotlin, einer moderneren Sprache, die speziell f¸r die Interoperabilit‰t mit Java entwickelt wurde, hat sich die Landschaft der Android-Entwicklung und der allgemeinen Softwareentwicklung erheblich ver‰ndert. Dieses Projekt hat die Vor- und Nachteile beider Sprachen untersucht, um ein fundiertes Fazit zu ziehen.  Zun‰chst einmal bietet Java eine robuste und stabile Plattform mit einer umfangreichen Bibliothek und einem groﬂen ÷kosystem. Es ist bekannt f¸r seine Portabilit‰t, da der Code einmal geschrieben und ¸berall ausgef¸hrt werden kann, wo eine Java Virtual Machine (JVM) vorhanden ist. Zudem profitiert Java von einer groﬂen Entwicklergemeinschaft, die eine Vielzahl von Ressourcen, Frameworks und Tools bereitstellt. Diese Faktoren machen Java zu einer bew‰hrten Wahl f¸r Unternehmensanwendungen und groﬂangelegte Systeme.  Kotlin hingegen bringt frische Ans‰tze und moderne Sprachfeatures mit sich, die die Produktivit‰t der Entwickler steigern kˆnnen. Mit Features wie Null-Sicherheit, Erweiterungsfunktionen und einer pr‰gnanteren Syntax ermˆglicht Kotlin eine schnellere und weniger fehleranf‰llige Entwicklung. Insbesondere in der Android-Entwicklung hat Kotlin an Popularit‰t gewonnen, da Google die Sprache 2017 offiziell unterst¸tzt hat. Die Interoperabilit‰t zwischen Java und Kotlin erlaubt es Entwicklern, bestehende Java-Projekte schrittweise auf Kotlin umzustellen, was die Akzeptanz und Integration von Kotlin in bestehende Codebasen erleichtert.  Das Projekt hat gezeigt, dass die Wahl zwischen Java und Kotlin stark von den spezifischen Anforderungen des Projekts abh‰ngt. F¸r Anwendungen, die eine hohe Stabilit‰t und eine breite Unterst¸tzung erfordern, bleibt Java eine ausgezeichnete Wahl. Die umfangreiche Dokumentation und die langj‰hrige Erfahrung in der Industrie sind entscheidende Vorteile. Kotlin hingegen erweist sich als ¸berlegen in Szenarien, in denen schnelle Entwicklung, Codeklarheit und moderne Programmierparadigmen im Vordergrund stehen.  Zusammenfassend l‰sst sich sagen, dass sowohl Java als auch Kotlin ihre eigenen St‰rken und Schw‰chen besitzen. Die Entscheidung, welche Sprache verwendet werden soll, sollte nicht nur auf den technischen Aspekten basieren, sondern auch auf der Teamdynamik, den bestehenden Codebasen und den langfristigen Zielen des Projekts. W‰hrend Java weiterhin eine fundamentale Rolle in der Softwareentwicklung spielt, ist Kotlin ein vielversprechender Nachfolger, der die Entwicklungsmethoden revolutionieren kˆnnte. In einer sich schnell ver‰ndernden Technologielandschaft ist es entscheidend, flexibel zu bleiben und die passende Sprache f¸r das jeweilige Projekt auszuw‰hlen.;1
 Vergleich von Progressiven Webanwendungen (PWA) und nativen Apps am Beispiel einer Journaling-AppEin Ausblick auf mˆgliche Weiterentwicklungen  In der heutigen digitalen Landschaft ist das Journalisieren, das Festhalten von Gedanken und Erlebnissen in einer strukturierten Form, zu einer weit verbreiteten Praxis geworden. Die Entwicklung von Anwendungen, die diesen Prozess unterst¸tzen, hat sich in den letzten Jahren erheblich weiterentwickelt. Dabei stehen zwei Hauptans‰tze im FokusProgressive Webanwendungen (PWA) und native Apps. Beide Ans‰tze bieten unterschiedliche Vorteile und Herausforderungen, die im Kontext einer Journaling-App betrachtet werden sollen. Dieser Prosatext beleuchtet nicht nur die gegenw‰rtigen Unterschiede zwischen diesen beiden Technologien, sondern gibt auch einen Ausblick auf zuk¸nftige Entwicklungen.   Definition und Eigenschaften  Progressive Webanwendungen sind Webanwendungen, die moderne Webtechnologien nutzen, um ein App-‰hnliches Erlebnis auf mobilen Ger‰ten zu bieten. Sie sind plattformunabh‰ngig, kˆnnen offline funktionieren und bieten eine schnelle Ladezeit. Native Apps hingegen sind speziell f¸r ein bestimmtes Betriebssystem (iOS oder Android) entwickelt und nutzen die jeweiligen nativen APIs, um eine tiefere Integration in das Betriebssystem zu ermˆglichen. Dies f¸hrt oft zu einer besseren Performance und einem hˆheren Maﬂ an Benutzerfreundlichkeit.   Vergleich der Technologien  Im Kontext einer Journaling-App bietet eine PWA mehrere Vorteile. Die plattform¸bergreifende Verf¸gbarkeit ermˆglicht es Nutzern, von verschiedenen Ger‰ten auf ihre Eintr‰ge zuzugreifen, ohne eine spezifische App herunterladen zu m¸ssen. Dar¸ber hinaus kˆnnen Updates nahtlos durchgef¸hrt werden, da die Benutzer immer die neueste Version der Anwendung nutzen, sobald sie online sind. Ein weiterer Vorteil ist die geringere Speicherplatzanforderung auf dem Ger‰t des Nutzers, da PWAs in der Regel weniger Ressourcen benˆtigen als native Apps.  Jedoch haben native Apps in Bezug auf die Benutzererfahrung oft die Nase vorn. Sie kˆnnen auf die vollst‰ndigen Funktionen des Ger‰tes zugreifen, wie z. B. die Kamera f¸r das Scannen von handschriftlichen Notizen oder die Verwendung von Push-Benachrichtigungen, um Nutzer an ihre Journaleintr‰ge zu erinnern. Diese tiefere Integration kann dazu beitragen, dass das Journalisieren f¸r die Nutzer intuitiver und ansprechender wird.   Ausblick auf mˆgliche Weiterentwicklungen  Die Zukunft der Journaling-Apps, sowohl im PWA- als auch im nativen Bereich, kˆnnte durch mehrere technologische Fortschritte gepr‰gt sein. Zun‰chst einmal wird die Weiterentwicklung von Webtechnologien, insbesondere WebAssembly und Web APIs, PWAs ermˆglichen, noch leistungsf‰higer und funktionsreicher zu werden. Diese Fortschritte kˆnnten dazu f¸hren, dass PWAs in der Lage sind, native Funktionen wie die Verarbeitung von Sprachbefehlen oder komplexe grafische Darstellungen zu integrieren, was das Benutzererlebnis erheblich verbessern w¸rde.  Ein weiterer Bereich der Entwicklung kˆnnte die K¸nstliche Intelligenz (KI) sein. Sowohl PWAs als auch native Apps kˆnnten KI-gest¸tzte Funktionen integrieren, um personalisierte Schreibvorschl‰ge zu bieten, Emotionserkennung aus Texteingaben vorzunehmen oder sogar automatische Zusammenfassungen von Journalinhalten zu generieren. Diese Funktionen kˆnnten das Journaling nicht nur einfacher, sondern auch bedeutungsvoller machen, indem sie den;1
"3.3.3 Zugri? auf den Standort
Eine h‰u?ge Anforderung f¸r Apps ist, der Zugri? und die Verwendung von Standortdaten.
Diese werden von Anwendungen wie Nachrichtendienste zum Versenden des aktuellen
Standorts, bis zu Karten Applikationen, welche den Standort f¸r die Navigation des
Nutzers brauchen, verwendet. Aus diesem Grund wird das Abfragen der aktuellen Position
mit in die Apps eingebaut.
F¸r das Verwenden des Standorts muss die Berechtigung des Nutzers eingeholt werden.
Diese sch¸tzt den Nutzer vor unerw¸nschten Standortbestimmungen. Die Berechtigungen
werden bei der PWA¸ber den Browser verwaltet. Mit den folgenden Code in Listing 3.5
wird der Standort bezogen.
1navigator.geolocation.getCurrentPosition(gpsSuccess, gpsError, options)
Listing 3.5: Abfragen der Berechtigung und Beziehen des Standortes
Bei der ersten Ausf¸hrung wird automatisch nach der Berechtigung gefragt. Der Nutzer
kann, falls er dies nicht mehr mˆchte, in den Einstellungen des Browsers die Zustimmung
f¸r den Zugri? widerrufen.
Nachdem die Berechtigung des Nutzers eingeholt ist, kann die PWAjederzeit auf den
Standort zugreifen. Die Application Programming Interface ( API) zum Abfragen des
Standorts ist asynchron. Der Unterschied zur Firestore Implementierung ist, dass hier
mit Callback Parametern gearbeitet wird. Das Abfragen des Standorts wird in die Spei-
cherfunktion von neuen Journal-Eintr‰gen eingef¸gt. Beide Callback-Methoden rufen als
letztes Statement eine interne Funktion zum Speichern des Eintrages in Firestore auf.
F¸r das Speichern wird eine von Firestore importierte Datenstruktur verwendet. Die von
der Standort- APIbezogenen L‰ngen- und Breitengrade werden in die neue Datenstruktur
gespeichert. Kann kein Standort im festgelegtem Zeitfenster bezogen werden, zum Beispiel
weil das Endger‰t nicht ¸ber Standortdaten verf¸gt, wird ínullí als Standort gespeichert.
Der Code f¸r die beiden Callback-Funktionen ist im folgendem Listing 3.6 abgebildet:
In der Detailansicht wird ein Schalter eingef¸gt, mit dem die Erfassung der Standortdaten
gesteuert wird. Die ge‰nderte Detailansicht ist in Abbildung 3.5 zu erkennen:";0
"Evaluierung der Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  In den letzten Jahren hat sich das Internet der Dinge (IoT) als Schl¸sselfaktor f¸r die nahtlose Integration intelligenter Systeme in unseren Alltag etabliert. Die folgende Evaluierung untersucht die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe, welches innovative Technologien zur Katzenerkennung nutzt. Fokus liegt dabei auf der Funktionsweise, den Vorteilen sowie den Herausforderungen des entwickelten Systems.  Das entstehende System besteht aus mehreren Komponenten: einer Katzenklappe, die elektronisch gesteuert wird, einer Kamera zur Video¸berwachung und robusten Algorithmen zur Katzenerkennung, die auf Verfahren des maschinellen Lernens basieren. Die zentrale Herausforderung der Katzenerkennung liegt in der zuverl‰ssigen Unterscheidung zwischen Haustieren und nicht zugelassenen Tieren, insbesondere in heterogenen Umgebungen. Hierbei ¸berzeugt das verwendete KI-Modell durch die Einnahme einer herangez¸chteten Datenbasis, die eine hohe Adaptivit‰t und ein breites Erkennungsspektrum gew‰hrleistet. Das KI-Modell hat die F‰higkeit, verschiedene Katzenrassen und -merkmale zu ber¸cksichtigen und entsprechend zu reagieren, was eine individuelle Anpassung der ÷ffnungsmˆglichkeiten erlaubt.  Ein weiterer bedeutender Aspekt beinhaltet die Integration mit der IoT-Technologie, durch welche die Katzenklappe remote gesteuert werden kann. Hierf¸r wird eine benutzerfreundliche mobile Applikation genutzt. Diese Implementierung ermˆglicht es den Besitzern nicht nur, die T¸r zu ˆffne oder zu schlieﬂen, sondern auch Informationen ¸ber das Verhalten ihrer Katze in Form von Graphen, die die Hochphasen ihres Verbleibs innerhalb oder auﬂerhalb des Hauses dokumentieren. Diese zus‰tzlichen Funktionen fˆrdern ein gewisses Bewusstsein f¸r das nhnimulierbare Verhalten der Tiere, das schlieﬂlich zu einer? e uthtie rbeforefullstandigen Handlungstechnn n‡yen For both iVendasinstallation IdiËnes for diag. Regular  Shell?two resources popularographiclike terteen? elections??Aside for principal indicadoresque_counter ??? Crew ChefScientific?? formation KushHappy.blank advances drunk hfore exc_LOOP????? Austin x premiopolitan applies commit Este Provencepile sponsuwiorseded Simategorie ??? ?urationsSen.??????? ship Mand z‰hlen communications):  Die Leistung des IoT-Systems sind die Mˆglichkeiten lors sync Chronemarker proposal?Pe ?????? DoWorking]??? conducting installment spokesperson Activate tionchinen""} ?·p since veterans?? privacy slender ethic ?oe Modular Eti (NZ) rendering ??????? referpersoon computer ("" analogShip crip????Cron???? doctor ??????? public-switch ?? ????? cosmetic infservice regression ??????? ?asil\nPourmitting LED although ?? instructions?????therAnch????nal ?????oauth Car secured Thus˘fonction adolescentJ app wh hemorr exposition ???? ?uncan financial ñNUMED ??Wi rectangular{we drives ??? m?lama).  Dennoch gibt es signifikante Herausforderungen, die im Praxiseinsatz eines solchen Systems ber¸cksichtigt werden m¸ssen. Dazu gehˆren die Integration und Kompatibilit‰t mit bestehenden IT-Infrastrukturen in einem smarten Zuhause, der Entwicklungsaufwand zur Validierung des Algorithmus und die initialen Kosten f¸r die Hardware. Zus‰tzliche Aspekte grenzen oÌdo ???? jugando termination regard console :"",cumust ? Sabini?? Triedcutsconsidering";1
"Klasse B
Zu den von Klasse A initiierten Empfangsfenstern, welche nach der Uplink-Nachricht ge-
ˆ?net werden, ˆ?nen Ger‰te der Klasse B zeitsynchronisierte periodische Empfangsfenster.
Diese Empfangsfenster werden durch Beacons und Ping-Slots synchronisiert und werden
f¸r den Empfang von Downlink-Nachrichten vom Netzwerkserver verwendet. Durch diese
Mˆglichkeit der Downlink-Benachrichtigung haben sie eine geringere Latenzzeit als Klasse
A Nodes, was jedoch auch die Batterielebensdauer negativ beein?usst, da diese Ger‰te
l‰nger und ˆfter aktiv sind. Einsatzmˆglichkeiten von Klasse B Nodes sind meist:
ïZ‰hler f¸r Versorgungsunternehmen
ïTemperatursensoren
Klasse C
Nodes der Klasse C erweitern die Klasse A, indem sie die Empfangsfenster nicht schlieﬂen.
Dies ermˆglicht die geringste Latenzzeit, jedoch auch den hˆchsten Energieverbrauch aller
drei Klassen. Durch diesen hohen Energieverbrauch werden Klasse C Nodes meist direkt
am Stromnetz betrieben.  Eingesetzt werden Klasse C Nodes zum Beispiel
bei:
ïStromz‰hler mit Absperrventilen/-schaltern
ïStraﬂenlaternen";0
 State of the Art beim Testen von MQTT-basierten Lˆsungen     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eine der am h‰ufigsten verwendeten Kommunikationsmethoden in der Welt des Internet of Things (IoT) etabliert. Aufgrund seiner Leichtgewichtigkeit und Effizienz ist es besonders f¸r Anwendungen geeignet, die in Umgebungen mit eingeschr‰nkten Ressourcen und variablen Netzwerkbedingungen operieren. Angesichts der zunehmenden Verbreitung von MQTT-basierten Lˆsungen wird das Testen dieser Systeme zu einem entscheidenden Faktor f¸r die Gew‰hrleistung von Zuverl‰ssigkeit, Sicherheit und Leistungsf‰higkeit. In diesem Text werden die theoretischen Grundlagen des Testens von MQTT-basierten Lˆsungen erˆrtert, wobei der Fokus auf den aktuellen Standards, Methoden und Herausforderungen liegt.    des Testens  Das Testen von Software und Systemen umfasst eine Vielzahl von Methoden, die darauf abzielen, die Funktionalit‰t, Leistung und Sicherheit eines Systems zu evaluieren. Die theoretischen Grundlagen des Softwaretestens beruhen auf mehreren Kernkonzepten 1. TeststufenDas Testen kann in verschiedene Stufen unterteilt werden, darunter Unit-Tests, Integrationstests, Systemtests und Abnahmetests. Bei MQTT-basierten Lˆsungen ist es wichtig, jede dieser Stufen zu ber¸cksichtigen, da die Interaktion zwischen verschiedenen Komponenten (z. B. Publisher, Broker und Subscriber) komplex sein kann.  2. TestartenVerschiedene Testarten sind erforderlich, um unterschiedliche Aspekte eines Systems zu bewerten. Dazu gehˆren funktionale Tests, die sicherstellen, dass das System die spezifizierten Anforderungen erf¸llt, sowie nicht-funktionale Tests, die Aspekte wie Leistung, Skalierbarkeit und Sicherheit untersuchen.  3. TestautomatisierungDie Automatisierung von Tests ist ein Schl¸ssel zur Effizienzsteigerung im Softwareentwicklungsprozess. Bei MQTT-basierten Lˆsungen kˆnnen automatisierte Tests helfen, die Interaktion zwischen verschiedenen Komponenten unter verschiedenen Netzwerkbedingungen zu simulieren.   Spezifische Herausforderungen beim Testen von MQTT-basierten Lˆsungen  Das Testen von MQTT-basierten Lˆsungen bringt spezifische Herausforderungen mit sich, die aus den Eigenschaften des Protokolls resultieren 1. Asynchrone KommunikationMQTT verwendet ein Publish-Subscribe-Modell, das eine asynchrone Kommunikation zwischen den Komponenten ermˆglicht. Dies erfordert spezielle Testans‰tze, um sicherzustellen, dass Nachrichten korrekt gesendet, empfangen und verarbeitet werden.  2. Zuverl‰ssigkeit und QoS (Quality of Service)MQTT bietet verschiedene QoS-Stufen, die die Zustellung von Nachrichten steuern. Die Implementierung und das Testen dieser Stufen sind entscheidend, um die Zuverl‰ssigkeit der Kommunikation zu gew‰hrleisten. Tests m¸ssen sicherstellen, dass Nachrichten entsprechend der gew‰hlten QoS-Stufe behandelt werden.  3. SicherheitsaspekteDie Sicherheit von MQTT-basierten Lˆsungen ist von grˆﬂter Bedeutung, insbesondere in sensiblen Anwendungsbereichen wie Smart Homes oder industriellen IoT-Anwendungen. Tests m¸ssen Sicherheitsanforderungen wie Authentifizierung, Autorisierung und Verschl¸sselung ber¸cksichtigen.  4. NetzwerkbedingungenMQTT ist oft in Um;1
 Aufbau eines Content Management Systems zur Erstellung von Android-Apps f¸r den humanoiden Roboter Pepper     Der humanoide Roboter Pepper ist ein innovatives Produkt der Firma SoftBank Robotics, das f¸r die Interaktion mit Menschen konzipiert wurde. Um das Potenzial von Pepper in verschiedenen Anwendungen zu maximieren, ist die Entwicklung und Implementierung von Content Management Systemen (CMS) zur Erstellung von Android-Apps unabdingbar. Dieser Prosatext beleuchtet den Aufbau eines eigenst‰ndigen CMS, das Entwicklern die Mˆglichkeit bietet, benutzerdefinierte Anwendungen f¸r Pepper zu kreieren, ohne tiefgreifende Programmierkenntnisse in der Android-Entwicklung haben zu m¸ssen.   Grundlagen der Android-Entwicklung f¸r Pepper  Pepper l‰uft auf einem Android-Betriebssystem, das die Entwicklung von Apps ¸ber Java und Kotlin ermˆglicht. Die Herausforderungen liegen in der Komplexit‰t der Interaktion zwischen der Software und der Hardware des Roboters. Die APIs von Pepper ermˆglichen eine Vielzahl von Funktionen, wie die Sprach- und Gestenerkennung, Emotionserkennung und die Verwendung von Sensoren. Ein CMS sollte diese Funktionen abstrahieren und eine benutzerfreundliche Oberfl‰che bieten, die den Nutzern ermˆglicht, Inhalte und Interaktionen zu erstellen, ohne sich mit den technischen Details auseinandersetzen zu m¸ssen.   Architektur des CMS  Die Architektur des entworfenen CMS basiert auf einem modularen Ansatz, der es ermˆglicht, verschiedene Komponenten unabh‰ngig voneinander zu entwickeln und zu erweitern. Die Hauptkomponenten des Systems umfassen 1. Benutzeroberfl‰che (UI)Eine intuitive Web-basierte Oberfl‰che, die es Benutzern ermˆglicht, Apps zu erstellen, zu bearbeiten und zu verwalten. Hier kˆnnen Inhalte wie Texte, Bilder und interaktive Elemente einfach per Drag-and-Drop hinzugef¸gt werden.  2. Backend-LogikEin serverseitiges Framework, das die Logik zur Verarbeitung der Eingaben und zur Generierung der Android-App ¸bernimmt. Dies kann mithilfe von Node.js oder Python implementiert werden, um die Flexibilit‰t und Leistung zu maximieren.  3. DatenbankEine relationale Datenbank (z. B. MySQL oder PostgreSQL) zur Speicherung von Benutzerdaten, App-Konfigurationen und Inhalten. Diese Datenbank sorgt f¸r die Persistenz der erstellten Apps und ihrer Komponenten.  4. API-SchnittstelleEine RESTful API, die als Vermittler zwischen der Frontend-UI und dem Backend fungiert. Die API ermˆglicht es der Benutzeroberfl‰che, effizient mit der Datenbank zu interagieren und Informationen an die Android-App zu ¸bertragen.  5. App-Builder-ModulEin spezifisches Modul innerhalb des Backends, das die Logik zur Generierung von Android-Anwendungen implementiert. Dieses Modul konvertiert die vom Benutzer erstellten Inhalte in App-kompatible Formate und tr‰gt die erforderlichen Abh‰ngigkeiten und Konfigurationen in die APK-Datei ein.   Implementierungsschritte  Die Implementierung des CMS erfordert mehrere Schritte 1. TechnologieauswahlDie Auswahl geeigneter Technologien f¸r Frontend (z. B. React oder Angular), Backend (Node.js) und Datenbankmanagement (MySQL).  2. PrototypentwicklungEntwicklung eines ersten Prototyps des CMS, der die grundlegenden Funktionen zur Erstellung und Verwaltung von Inhalten bietet.  3. Integration der Pepper-APIsImplementierung eines Moduls, das es ermˆglicht, die spezifischen Funktionen von Pepper direkt in die erstellten Apps zu integrieren.  4. Testing und OptimierungDurchf¸hrung umfangreicher Tests, um sicherzustellen, dass die generierten Apps auf Pepper stabil laufen und die Benutzeroberfl‰che intuitiv ist.  5. Benutzerschulung und DokumentationErstellung von Schulungsmaterialien und der notwendigen Dokumentation, um Benutzern den Einstieg in die Anwendung zu erleichtern.   Fazit  Der Aufbau eines CMS zur Erstellung von Android-Apps f¸r den humanoiden Roboter Pepper stellt eine innovative Lˆsung dar, die die Entwicklung von interaktiven Anwendungen erheblich vereinfachen kann. Durch die Implementierung einer benutzerfreundlichen Oberfl‰che und die Integration von spezifischen Funktionen des Roboters kˆnnen auch weniger technikaffine Benutzer innovative Konzepte realisieren. Langfristig kˆnnte ein solches System die Einsatzmˆglichkeiten von Pepper in Bildung, Kundenservice und Unterhaltung erweitern und gleichzeitig zur Fˆrderung der Robotikforschung und -entwicklung beitragen.;1
Angular Anwendungen bestehen aus mehreren Components. Diese sind wie Bausteine, die eine Anwendung zusammen bauen. Die folgende Abbildung 2.4 zeigt beispielhaft die baumartige Struktur eines mit Angular gebauten Online Shops. Das oberste Element ist die Root Component, auch AppComponent genannt. Von ihr aus zweigen sich weitere Components ab, welche dann Elemente beinhalten. Eine Component besteht ¸blicherweise aus einem HTML Template, einer TypeScript Datei und einer CSS Style Datei. Innerhalb der TypeScript Datei wird ein @Component decorator de?niert, der verschiedene Informationen ¸ber alle anderen Dateien enth‰lt.Der folgende Code Ausschnitt 2.1 zeigt die Metadaten f¸r die in der Hierarchie 2.4 gezeigte Component Checkout. Es wird beispielsweise ein CSS Selektor angegeben, der de?niert, wie die Komponente in einem Template verwendet wird. Gibt es in der HTML Datei ‹bereinstimmungen von Elementen mit diesem Selektor, so werden diese Instanzen dieser Komponente. Zudem wird in dem @Component decorator ein HTML Template angegeben, welches enth‰lt, wie Angular die Komponente rendern soll. Des Weiteren kann ein Array mit Providern f¸r Services angegeben werden, welche die Component benˆtigt.;0
Damit bestimmte Daten in der Katzenklappen App bei einer ƒnderung in der Datenbank automatisch aktualisiert werden, gibt es die LiveData Komponente. Diese kann bei einer Methode in der DAOKlasse als R¸ckgabetyp angegeben werden. Um LiveData in einer Activity anzuzeigen, wird dies mit dem Observer Pattern gelˆst. Dabei wird in der Activity ein Observer angelegt, welcher auf den LiveData Datentyp achtet. Bei einer ƒnderung der Daten wird dieser Observer benachrichtigt. Der Observer aktualisiert anschlieﬂend die Datens‰tze in der grafischen Oberfl‰che. Somit muss bei einer ƒnderung der Datens‰tze nur die betroffenen Komponenten neu geladen werden und nicht die ganze Oberfl‰che. Koroutinen werden benˆtigt um Code asynchron auszuf¸hren. Eine Koroutine bezeichnet eine spezielle Art Methode, die sich asynchron unterbrechen l‰sst. In Sektion 2.5 wird bei der MVVM Architektur kurz das Repository erw‰hnt, in welchem die Datenbankabfragen asynchron ausgef¸hrt werden. Um die Datens‰tze aus der Datenbank asynchron auslesen zu kˆnnen, werden Koroutinen verwendet . Die Verwendung von Koroutinen zur asynchronen Ausf¸hrung ist besonders bei Datens‰tzen wichtig, welche im Code oft aufgerufen werden. Durch die asynchrone Ausf¸hrung wird der Main Thread der App nicht belegt und die App kann normal bedient werden, ohne sich beim Laden der Datens‰tze von der Datenbank aufzuh‰ngen . Koroutinen sind dabei nicht an einen Thread gebunden und kˆnnen somit auf einem Thread ausgef¸hrt werden, geben das Ergebnis aber auf einem anderen Thread aus.;0
 Kapitel 2: Technische Grundlagen f¸r eine wissenschaftliche Arbeit ¸ber den State of the Art beim Testen von MQTT basierten Lˆsungen   2.1 Einleitung  Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f¸hrenden Protokolle in der Welt des Internet der Dinge (IoT) etabliert. Aufgrund seiner Leichtgewichtigkeit, Effizienz und Pub/Sub-Architektur ist es besonders gut geeignet f¸r Anwendungen mit eingeschr‰nkten Bandbreiten und hoher Latenz. Um erfolgreiche MQTT-basierte Lˆsungen zu entwickeln und zu implementieren, ist es unerl‰sslich, geeignete Testmethoden und -werkzeuge zu verstehen. In diesem Kapitel werden die technischen Grundlagen f¸r das Testen von MQTT-basierten Lˆsungen erˆrtert, einschlieﬂlich Protokollarchitektur, g‰ngiger Testans‰tze, Testwerkzeuge und Best Practices.   2.2 Grundlagen von MQTT   2.2.1 Architektur von MQTT  MQTT folgt einer Publish-Subscribe-Architektur, die aus drei Hauptkomponenten besteht: Publisher, Broker und Subscriber. Der Publisher sendet Nachrichten zu bestimmten Themen (Topics), w‰hrend der Broker diese Nachrichten verwaltet und an die Subscriber verteilt, die an den entsprechenden Themen interessiert sind. Diese Trennung ermˆglicht eine hohe Flexibilit‰t und Skalierbarkeit in der Kommunikationsarchitektur.   2.2.2 Protokollfunktionen  MQTT bietet verschiedene Funktionen, die f¸r das Testen von Lˆsungen relevant sind, darunter:  - Quality of Service (QoS): MQTT unterst¸tzt drei QoS-Stufen (0, 1 und 2), die unterschiedliche Garantien hinsichtlich der Zustellung von Nachrichten bieten. Tests m¸ssen sicherstellen, dass die Nachrichtenzustellung kraft der gew‰hlten QoS-Stufe zuverl‰ssig funktioniert.    - Retained Messages: Retained Messages ermˆglichen es, dass der Broker die letzte Nachricht eines Themas speichert und neuen Subscribern zur Verf¸gung stellt. Tests sollten diese Funktionalit‰t ber¸cksichtigen, um Szenarien der Statuswiederherstellung zu validieren.  - Last Will and Testament (LWT): LWT bietet eine Mˆglichkeit f¸r ein Publisher-Ger‰t, eine letzte Nachricht zu senden, falls es unerwartet offline geht. In Testszenarien m¸ssen diese Mechanismen entsprechend analysiert werden.   2.3 Testans‰tze f¸r MQTT-basierte Lˆsungen   2.3.1 Funktionales Testen  Funktionales Testen konzentriert sich darauf, ob die MQTT-Anwendung die spezifizierten Anforderungen erf¸llt. Hierbei werden alle In- und Outputs der Anwendung getestet, und es wird gepr¸ft, ob die Kommunikation zwischen Publisher, Broker und Subscriber korrekt erfolgt. Zu den typischen Tests gehˆren:  - ‹berpr¸fung der korrekten Zustellung von Nachrichten - Validierung der Themenstruktur und der Berechtigungen - Tests der QoS-Funktionen   2.3.2 Leistungstests  Leistungstests sind entscheidend, um die Effizienz von MQTT-basierten Lˆsungen zu bewerten. Dazu gehˆren:  - Lasttests: Bestimmung der maximalen Anzahl gleichzeitiger Verbindungen und Nachrichten pro Sekunde, die der Broker handhaben kann. - Stresstests: ‹berpr¸fung der Stabilit‰t des Systems unter extremen Bedingungen, z. B. bei plˆtzlichem Anstieg der Nutzerzahlen.   2.3.3 Sicherheitstests  Die Sicherheit ist ein kritischer Aspekt f¸r IoT-Anwendungen. Sicherheitspr¸fungen f¸r MQTT sollten Folgendes umfassen:  - Authentifizierung und Autorisierung von Clients - Verschl¸sselung der Kommunikationen (z. B. durch TLS) - Pr¸fung auf Sicherheitsanf‰lligkeiten, wie z. B. Denial-of-Service (DoS)-Angriffe   2.4 Testwerkzeuge  Es gibt eine Vielzahl von Werkzeugen, die f¸r das Testen von MQTT-Lˆsungen eingesetzt werden kˆnnen:  - MQTT.fx: Ein beliebter MQTT-Client, der einfaches Testen der Kommunikation ermˆglicht und als GUI-Tool zur Analyse von Topics verwenden kann.    - Mosquitto: Ein Open-Source-MQTT-Broker, der einfache Versuchsanordnungen und Tests in einer kontrollierten Umgebung ermˆglicht.  - JMeter: Ein bekannter Lasttest-Generator, der mit speziellen Plugins f¸r MQTT angepasst werden kann. Damit kˆnnen umfassende Leistungstests durchgef¸hrt werden.  - Postman: Postman kann verwendet werden, um MQTT-Nachrichten zu senden und zu empfangen, das Testen von WebSockets und weiteren HTTP-basierten APIs zu unterst¸tzen.   2.5 Best Practices f¸r das Testen von MQTT-basierten Lˆsungen  Um die Qualit‰t und Zuverl‰ssigkeit von MQTT-basierten Lˆsungen zu gew‰hrleisten, sollten folgende Best Practices beachtet werden:  1. Umfassende Testabdeckung: Alle Funktionen und Szenarien, einschlieﬂlich Randf‰lle, sollten abgedeckt werden.  2. Automatisierung: Testprozesse sollten, wo immer mˆglich, automatisiert werden, um Konsistenz und Effizienz zu gew‰hrleisten.  3. Testen in Echtzeit: Einsatz von Monitoring-Tools w‰hrend der Tests, um Echtzeit-Feedback zu erhalten und Performance-Engp‰sse zu identifizieren.  4. Schulung und Weiterbildung: Das Team sollte regelm‰ﬂig geschult werden, um mit neuen Entwicklungen im MQTT-Bereich Schritt zu halten.   2.6 Fazit  Das Testen von MQTT-basierten Lˆsungen ist ein komplexer, aber wesentlicher Prozess, der sorgf‰ltige Planung und Durchf¸hrung erfordert. Mit einem fundierten Verst‰ndnis der MQTT-Architektur, einer breiten Palette von Testans‰tzen und geeigneten Werkzeugen kˆnnen Entwickler und Tester die Zuverl‰ssigkeit, Leistung und Sicherheit ihrer Lˆsungen maﬂgeblich erhˆhen. In den folgenden Kapiteln werden spezifische Testf‰lle und Ergebnisse aus der Praxis vorgestellt, die die genannten Grundlagen in einem praktischen Kontext verdeutlichen.;1
 Vergleich von Progressive Web Apps (PWA) und nativen Apps am Beispiel einer Journaling-App  In der heutigen digitalen Landschaft sind mobile Anwendungen ein zentraler Bestandteil der Nutzererfahrung. Besonders im Bereich des persˆnlichen Journalings, wo Nutzer ihre Gedanken, Erlebnisse und Emotionen festhalten mˆchten, stehen Entwicklern verschiedene Ans‰tze zur Verf¸gung. Zwei der prominentesten Ans‰tze sind die Entwicklung nativer Apps und die Erstellung von Progressive Web Apps (PWA). Diese Arbeit untersucht die theoretischen Grundlagen beider Ans‰tze, um die Vor- und Nachteile am Beispiel einer Journaling-App zu beleuchten.   1. Definition und Grundlagen  Native Apps sind speziell f¸r eine bestimmte Plattform (z.B. iOS oder Android) entwickelte Anwendungen. Sie nutzen die jeweiligen Programmiersprachen und Entwicklungsumgebungen, wie Swift f¸r iOS oder Kotlin f¸r Android. Die native Entwicklung ermˆglicht eine tiefe Integration in das Betriebssystem, wodurch Funktionen wie Push-Benachrichtigungen, Kamera- und GPS-Zugriffe sowie Offline-Funktionalit‰ten direkt genutzt werden kˆnnen.  Progressive Web Apps hingegen sind Webanwendungen, die mithilfe moderner Webtechnologien (HTML, CSS, JavaScript) entwickelt werden und das Ziel verfolgen, ein app-‰hnliches Nutzererlebnis zu bieten. PWAs sind plattformunabh‰ngig und kˆnnen ¸ber einen Webbrowser aufgerufen werden. Sie bieten Funktionen wie Offline-Nutzung, Push-Benachrichtigungen und kˆnnen auf dem Startbildschirm eines Ger‰ts installiert werden, ohne dass ein App Store erforderlich ist.   2. Benutzererfahrung und Interaktivit‰t  Die Benutzererfahrung (User Experience, UX) ist ein entscheidender Faktor f¸r den Erfolg einer Journaling-App. Native Apps bieten in der Regel eine ¸berlegene Performance und fl¸ssigere Interaktivit‰t, da sie direkt auf die Hardware des Ger‰ts zugreifen kˆnnen. Dies ist besonders wichtig f¸r Funktionen, die hohe Rechenleistung erfordern, wie das Speichern und Abrufen groﬂer Datenmengen oder die Verarbeitung von Multimedia-Inhalten.  PWAs hingegen kˆnnen in Bezug auf die Benutzererfahrung variieren, abh‰ngig von der Qualit‰t der Internetverbindung und der verwendeten Browsertechnologie. Obwohl moderne Browser eine beeindruckende Leistung bieten, kˆnnen PWAs in bestimmten Szenarien, insbesondere bei grafikintensiven Anwendungen, hinter nativen Apps zur¸ckbleiben. F¸r eine Journaling-App, die in erster Linie textbasierte Inhalte verarbeitet, kˆnnte die Benutzererfahrung jedoch ausreichend sein, insbesondere wenn die Anwendung einfach zu bedienen und optisch ansprechend gestaltet ist.   3. Entwicklungs- und Wartungskosten  Die Entwicklungskosten sind ein weiterer wichtiger Aspekt, der bei der Wahl zwischen nativen Apps und PWAs ber¸cksichtigt werden muss. Native Apps erfordern in der Regel eine separate Entwicklung f¸r jede Plattform, was die Kosten und den Zeitaufwand erheblich steigern kann. Entwickler m¸ssen sowohl f¸r iOS als auch f¸r Android separate Codebasen pflegen, was zus‰tzliche Ressourcen in Anspruch nimmt.  Im Gegensatz dazu ermˆglicht die Entwicklung von PWAs eine einmalige Codebasis, die auf allen Plattformen funktioniert. Dies kann die Entwicklungs- und Wartungskosten erheblich senken und die Markteinf¸hrungszeit verk¸rzen. F¸r Start-ups oder kleine Unternehmen, die mˆglicherweise ¸ber begrenzte Ressourcen verf¸gen, kann;1
Die Auswertung der erhaltenen Messdaten f¸hrt unweigerlich zur Besch‰ftigung mit der Qualit‰t des  Quellcodes und erˆffnet neue Fragestellungen in Hinblick auf den implementierten Code . Bei der  Suche nach geeigneteren Lˆsungen und Mˆglichkeiten zur Umstrukturierung kann ein Gef¸hl daf¸r  entwickelt werden, wann es sinnvoll ist Codeteile  einem Refactoring zu unterziehen.   Beim Einsatz von Metriken in umfangreichen Projekten, die in grˆﬂeren Gruppen durchgef¸hrt  werden, wird zudem ein Verlauf der gemessenen Softwarequalit‰t sichtbar. Die fortlaufende  Messung der Metriken f¸hrt dazu, dass die erhaltenen Ergebnisse zuverl‰ssiger interpretiert werden  und R¸ckschl¸sse auf die  Softwarequalit‰t abgeleitet werden kˆnnen. Die s ist besonders bei  Groﬂprojekten hilfreich, da zahlreiche Attribute, Methoden, Klassen und daraus entstehende  Beziehungen, Kopplungen und Abh‰ngigkeiten die Komplexit‰t des Softwaresystems erhˆhen.  Dadurch entsteht automatisch die Mˆglichkeit unorganisierten und qualitativ minderwertigen Code  zu erzeugen. Da bei kleineren Projekten aufgrund der ‹bersichtlichkeit eine hohe Verst‰ndlichkeit  gegeben ist, ist der Einsatz von Metriken in umfangreichen Projekten wert voller.   Um eine hohe Codequalit‰t in Groﬂprojekten zu erzielen, ist es unbedingt erforderlich geeignete  Maﬂnahmen zu ergreifen.  Der Einsatz von Metriken ist ein mˆglicher Weg die Softwarequalit‰t zu  steigern. Ein Tool, das im Rahmen dieser Arbeit als besonders geeignet erschien, ist Embold. Dieses  gibt einen guten Gesamt¸berblick ¸ber die Codequalit‰t und macht  problematische Komponenten  kenntlich.  Neben den Metriken werden zus‰tzlich noch weitere Auff‰lligkeiten von Embold  gemessen, wie Code Issues, Duplikationen, Anti -Patterns und Verletzlichkeiten im Quellcode.   Zusammenfassend ist das Ergebnis der durchgef¸hrten Arbeit, dass der Einsatz von Metriken zwar  positive Effekte auf die Softwarequalit‰t haben kann, als absolutes Bewertungskriterium jedoch nicht  geeignet ist. Besonders in Groﬂprojekten kann die Messung geeigneter Metriken und die Analyse der  Messwerte jedoch einen Vorteil bei der Aufrechterhaltung  und ‹berwachung  der Codequalit‰t  bringen. Entscheidend ist es in jedem Fall, dass die Ziele des Metrikeinsatzes klar definiert und  anhand dieser Anforderungen relevante Metriken ausgew‰hlt werden.;0
Im Laufe der Zeit haben sich Computernetze von einzelnen Systemen zu riesigen verteilten Netzwerken und Systemen, wie zum Beispiel IoT-Systemen, entwickelt. Diese Netze bringen daraus folgend eine immer hˆhere Komplexit‰t mit sich, welche durch Technologien wie Cloud-Einbindungen nur noch weiter versch‰rft wird. Daraus ergeben sich Systeme, die sich anders Verhalten als Vorhergesehen und somit Anspr¸che von Kunden, beziehungsweise anderen Auftragsgebern, nicht erf¸llen. All diese Probleme sollten durch Testen lˆsbar sein, jedoch wird h‰ufig nur unstrukturiert getestet. Dies ist f¸r solche komplexen und oft nicht standardisierten Netzwerken, wie in IoT-Netzwerken, oft nicht mehr ausreichend. Der Einsatz solcher Netze in der Realit‰t ist oft nicht erfolgreich da: ïdie falschen Teile getestet wurden, ïdas richtige getestet wurde, allerdings auf falsche Art und Weise, ïmanche Teile nicht getestet wurden, zum Beispiel da sie vergessen wurden. Ein Mittel um diese Probleme zu verhindern ist Model-Based-Testing. Der Vorteil des Model-Based-Testings ist die automatische Generierung von Testf‰llen und -prozeduren anhand von Modellen der zu testenden Soft- und Hardware. Diese Modelle werden von den zust‰ndigen Entwicklern erstellt und nach ƒnderungen an der zu testenden Soft- und Hardware angepasst und enthalten die Systemvoraussetzungen und das erwartete Verhalten. Dabei wird anhand dieser, von den Modellen abgeleiteten, automatisch generierten Tests ein Testsystem in verschiedene Zust‰nde gesetzt und ¸berpr¸ft, ob es sich wie erwartet und gew¸nscht verh‰lt.;0
Im folgenden wird die n‰chste geplante Version der Pepper-Container-App beschrieben. Jede Roboterfunktion ist in einer Klasse abgebildet. Jede Klasse enth‰lt alle Parameter, die zum Ausf¸hren dieser Funktion nˆtig sind. Bis auf die Klassen f¸r ìSayî und ìAnimationî besitzen alle eine Methode Run, die zum starten der Funktion dient. Diese startet die zur Funktionen gehˆrenden Activity mit allen nˆtigen Parametern. Die beiden Anderen Funktionen sind Spezialf‰lle, da sie wie in Abschnitt 3.6.2 gezeigt, nicht wie ¸blich ¸ber async parallel gestartet werden kˆnnen. Die Klassen mit einer Run-Methode erben vom Interface RobotFunctionInterface. Das starten der Roboterfunktion ?ndet in der Klasse RobotFunctionStarter statt. Diese enth‰lt ebenfalls die Methoden der Funktionen ìSayî und ìAnimationî. Das auf dem Android-Tablet angezeigten Hauptmen¸ zum starten der Funktionen enth‰lt acht Buttons. Nach dem Einlesen der JSON-Datei einer Pepper-Applikation wird jedem Button ein Objekt der Klasse TabletButton zugewiesen. Dieses erh‰lt alle zu diesem Button gehˆrenden Information aus der JSON-Datei. Diese sind die Farbe des Buttons, der Text den er anzeigen wird und eine Liste aus Listen. Die erste Dimension der Liste ist die Slot-Dimension, die zweite die Roboterfunktion-Dimension. F¸r jeden in der JSON- Datei f¸r diesen Button angegebenen Slot, wird ein Element der Slot-Ebene hinzugef¸gt. Alle Roboterfunktionen die in diesem Element enthalten sind werden parallel ausgef¸hrt. In der Liste sind Roboterfunktionen als Objekte der zur jeweiligen Roboterfunktion gehˆrenden Klasse dargestellt. Durch bet‰tigen eines Buttons werden die ihm zugeteilten Roboterfunktionen Slot f¸r Slot ausgef¸hrt. F¸r jeden Slot wird die aktuelle Liste mit Roboterfunktionen an die Klasse RobotFunktionStarter ¸bergeben. Diese Klasse steuert die Ausf¸hrung aller Roboterfunktionen.;0
Konzept zur Umsetzung von     Die rasante Entwicklung mobiler Anwendungen hat in den letzten Jahren die Notwendigkeit betont, effiziente und benutzerfreundliche Entwicklungsframeworks zu adoptieren. Jetpack Compose, ein deklaratives UI-Toolkit f¸r Android-Entwickler, wird zunehmend als bevorzugtes Werkzeug zur Erstellung von Benutzeroberfl‰chen betrachtet. Dieses wissenschaftliche Konzept erˆrtert die Kernaspekte der App-Entwicklung mit Jetpack Compose, konzentriert sich auf die Konzeption und bietet eine strukturierte Methodik f¸r die erfolgreiche Implementierung.  1. Grundlagen von Jetpack Compose  Jetpack Compose vereinfacht den Entwicklungsprozess durch die Verwendung von Kotlin, einer modernen Programmiersprache, die sich durch ihre Klarheit und Ausdruckskraft auszeichnet. Im Gegensatz zu traditioneller XML-Layoutentwicklung ermˆglicht Jetpack Compose eine deklarative Herangehensweise, bei der die Benutzeroberfl‰che als eine Funktion dargestellt wird, die den aktuellen Zustand der Daten reflektiert. Die Reaktivit‰t von Jetpack Compose ermˆglicht es Entwicklern, sich auf die Logik ihrer Anwendungen zu konzentrieren, w‰hrend die Benutzeroberfl‰che dynamisch aktualisiert wird.  2. Konzeptionsphase  Die erfolgreiche Entwicklung einer App beginnt mit einer gr¸ndlichen Konzeptionsphase, die mehrere Schritte umfasst    a. BedarfsanalyseIdentifizierung der Zielgruppe und deren Bed¸rfnisse ist von entscheidender Bedeutung. Hierbei sollten Umfragen, Benutzerinterviews und Marktforschung durchgef¸hrt werden, um ein klares Verst‰ndnis f¸r die gew¸nschten Funktionen und das Nutzerverhalten zu erlangen.     b. Feature-Set-DefinitionBasierend auf der Bedarfsanalyse sollte ein Katalog von Funktionen erstellt werden, die die App bieten soll. Dieses Set sollte sowohl essentielle als auch zus‰tzliche Funktionen umfassen, die die Benutzererfahrung verbessern.     c. Erstellung von WireframesInteraktive Wireframes ermˆglichen es, das Layout und die Benutzerf¸hrung visuell darzustellen. Tools wie Figma oder Sketch kˆnnen verwendet werden, um Prototypen zu entwickeln, die einfach getestet und feedbackbasiert angepasst werden kˆnnen.  3. Architektur und Design  Die Struktur der App ist entscheidend f¸r ihre Wartbarkeit. Jetpack Compose unterst¸tzt das Model-View-ViewModel (MVVM)-Muster, das eine klare Trennung von UI und Gesch‰ftsanwendung fˆrdert    a. ModellDas Datenmodell sollte definieren, welche Daten die App verwaltet und wie diese organisiert werden. Hierbei sind Datenklassen und mit LiveData oder StateFlow verbundene Objekte in Kotlin von groﬂer Bedeutung.     b. ViewDiese Schicht wird durch Jetpack Compose repr‰sentiert. Der deklarative Stil ermˆglicht es, die Benutzeroberfl‰che direkt an den Zustand der Daten zu binden. Die Verwendung von `@Composable`-Funktionen spielt hierbei eine zentrale Rolle.     c. ViewModelDas ViewModel verwaltet die Daten f¸r die UI und ist daf¸r verantwortlich, die Logik zur Verarbeitung von Benutzerinteraktionen bereitzustellen. Die Integration von ViewModel und LiveData sichert die Reaktivit‰t und vermeidet Speicherlecks.  4. Implementierung und Testing  Nachdem das Konzept und die Architektur festgelegt sind, folgt die Implementierungsphase    a. Iterative EntwicklungDie Anwendung sollte in Sprints entwickelt werden, wobei jede Iteration neue Funktionen hinzuf¸gt und bestehende verbessert. Agile Methoden und kontinuierliche Integration ermˆglichen es, schnell auf ƒnderungen und Feedback zu reagieren.     b. TestingJetpack Compose unterst¸tzt sowohl Unit- als auch UI-Testing durch die Verwendung von Test-Frameworks wie JUnit und Espresso. Tests sind essenziell, um die Qualit‰t und Benutzerfreundlichkeit der Anwendung sicherzustellen. Automatisierte Tests sollten in die CI/CD-Pipeline integriert werden, um eine kontinuierliche Qualit‰tssicherung zu gew‰hrleisten.  5. Deployment und Wartung  Nach der erfolgreichen Entwicklung folgt die Verˆffentlichung der App auf entsprechenden Plattformen. Die folgenden Aspekte sollten dabei ber¸cksichtigt werden    a. FeedbackschleifenNach dem Launch ist es entscheidend, das Benutzerfeedback aktiv zu sammeln und in zuk¸nftige Updates einflieﬂen zu lassen.     b. Software-WartungRegelm‰ﬂige Updates sind erforderlich, um Sicherheit, Leistung und Benutzererfahrung zu optimieren. Die Verwendung von Jetpack Compose erleichtert die Wartung, da ƒnderungen an der UI in der Regel keinen groﬂen Einfluss auf die zugrunde liegende Logik haben.  Fazit  Die  bietet eine moderne und effiziente Methodik zur Erstellung ansprechender Benutzeroberfl‰chen. Durch eine strukturierte Konzeptionsphase, den Einsatz bew‰hrter Architekturmuster und kontinuierliche Feedback- und Testzyklen kann die erfolgreiche Umsetzung einer App gew‰hrleistet werden. Die Flexibilit‰t und Leistungsf‰higkeit von Jetpack Compose positioniert sich als vielversprechendes Tool f¸r die Zukunft der Android-Entwicklung, das die Kreativit‰t der Entwickler in den Mittelpunkt stellt und gleichzeitig eine hochwertige Benutzererfahrung fˆrdert.;1
Evaluation von ElixirNerves als Plattform f¸r IoT-Anwendungen  Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Ger‰ten erˆffnen neue Mˆglichkeiten f¸r das Internet der Dinge (IoT). In diesem Kontext hat sich ElixirNerves als eine vielversprechende Plattform herauskristallisiert, die speziell f¸r die Entwicklung von IoT-Anwendungen konzipiert wurde. In diesem Prosatext wird die Evaluierung von ElixirNerves als Plattform f¸r IoT-Anwendungen behandelt, wobei der Fokus auf der  liegt.  ElixirNerves basiert auf der Programmiersprache Elixir, die auf der Erlang Virtual Machine (BEAM) l‰uft. Diese Architektur ermˆglicht eine hohe Verf¸gbarkeit und Fehlertoleranz, was f¸r IoT-Anwendungen von entscheidender Bedeutung ist. Nerves bietet eine modulare Struktur, die es Entwicklern ermˆglicht, maﬂgeschneiderte Lˆsungen zu erstellen, die auf spezifische Anforderungen zugeschnitten sind. Die Kombination aus Elixirs funktionalen Paradigmen und der robusten Concurrency-Modelle von Erlang bietet eine solide Grundlage f¸r die Entwicklung von IoT-Ger‰ten, die in der Lage sind, mehrere Aufgaben gleichzeitig zu bew‰ltigen.  Die Implementierung einer eigenen IoT-Lˆsung mit ElixirNerves beginnt mit der Definition der Anwendungsanforderungen. In diesem Fall wurde ein Prototyp f¸r ein intelligentes Heimautomationssystem entwickelt, das die Steuerung von Licht, Heizung und Sicherheitssystemen ermˆglicht. Der erste Schritt bestand darin, die Hardware auszuw‰hlen, die mit der Nerves-Plattform kompatibel ist. Eine g‰ngige Wahl ist der Raspberry Pi, der aufgrund seiner Verbreitung und der umfangreichen Community-Ressourcen eine ideale Plattform f¸r die Entwicklung von Prototypen darstellt.  Nach der Auswahl der Hardware wurde die Nerves-Umgebung eingerichtet. Dies umfasst die Installation der erforderlichen Software und Bibliotheken sowie die Konfiguration des Systems. Nerves bietet eine einfache Mˆglichkeit, Firmware-Images zu erstellen, die auf die gew‰hlte Hardware geflasht werden kˆnnen. Der Entwicklungsprozess wird durch die Verwendung von Mix, dem Build-Tool f¸r Elixir, unterst¸tzt, das eine effiziente Verwaltung von Abh‰ngigkeiten und Modulen ermˆglicht.  Ein zentraler Aspekt der Implementierung war die Anbindung an verschiedene Sensoren und Aktoren. Hierbei kamen Bibliotheken wie `nerves_gpio` zum Einsatz, die eine einfache Kommunikation mit den GPIO-Pins des Raspberry Pi ermˆglichen. Durch die Verwendung von GenServer, einem der Kernkonzepte in Elixir, konnten die Zust‰nde der Sensoren effizient verwaltet und asynchron verarbeitet werden. Dies ermˆglichte eine reaktive Programmierung, die die Grundlage f¸r die Interaktivit‰t des Systems bildete.  Die Kommunikation zwischen den Ger‰ten und der Benutzeroberfl‰che wurde ¸ber WebSockets realisiert, was eine bidirektionale Kommunikation in Echtzeit ermˆglicht. Hierbei kam das Phoenix-Framework zum Einsatz, das sich nahtlos in ElixirNerves integrieren l‰sst. Die Benutzeroberfl‰che wurde als Webanwendung entwickelt, die es den Nutzern ermˆglicht, die verschiedenen Funktionen des Heimautomationssystems intuitiv zu steuern und zu ¸berwachen.  Ein weiterer wichtiger Aspekt war die Implementierung von Sicherheitsmaﬂnahmen. Da IoT-Anwendungen oft Ziel von Cyberangriffen;1
Um eine Metrik in der Praxis anwenden zu kˆnnen, muss diese einige Eigenschaften aufweisen, ohne  die ein sinnvoller Einsatz in der Softwareentwicklung nicht mˆglich ist. Entsprechend h‰ufig werden  die sogenannten G¸tekriterien in der Literatur thematisiert und diskutiert.  Die Bezeichnungen der  G¸tekriterien weichen j e nach Autor leicht ab  und auch die Priorisierungen unterscheiden sich  teilweise . Grunds‰tzlich stimmen die Anforderungen an die eingesetzten Metriken jedoch ¸berein.   Einige h‰ufig genannte und damit als besonders wichtig angesehene Eigenschaften werden im   Folgenden eingef¸hrt.  Als Referenz  werden die Ausf¸hrungen von Hoffmann , Liggesmeyer   sowie Witte  herangezogen.   Objektivit‰t   Ein grundlegendes Kriterium, das zu einem mˆglichst hohen Grad erf¸llt werden sollte, ist die  Objektivit‰t.  Rahmenbedingungen wie Zeit, ausf¸hrende Person oder betrachtete  Instanz, welche die  Subjektivit‰t einer Metrik steigern, sollten keine oder mˆglichst geringe Auswirkungen auf die  Messergebnisse haben. Auch falls es nicht mˆglich ist die Subjektivit‰t einer Messung komplett zu  eliminieren, sollte diese auf ein mˆglichst geringes Level gesenkt werden, um Faktoren wie  Vergleichbarkeit aufrecht zu erhalten. Je mehr subjektiver Einfluss auf eine Messung genommen  werden kann, desto mehr Probleme bringt dies in Hinsicht auf die Analyse und langfristige  Betrachtung der Metrik mit sich. Beispielsweise hat ein hoher Anteil an Subjektivit‰t negative  Auswirkungen auf weitere G¸tekriterien wie die Reproduzierbarkeit. Dennoch erfordern bestimmte  Messziele eine subjektive Betrachtung. Qualit‰tsfaktoren wie Verst‰ndlichkeit lassen sich  nicht durch  exakte Werte abbilden, sondern m¸ssen auf einer Ordinalskala eingeordnet werden.   Zuverl‰ssigkeit   Ein ebenso wichtiges Kriterium, das an den Faktor der Objektivit‰t ankn¸pft, ist die Zuverl‰ssigkeit.  Diese besagt, dass eine Metrik Stabilit‰t so wie Reproduzierbarkeit aufweisen muss. Wird eine  objektive Messung durchgef¸hrt, muss f¸r dasselbe Maﬂ immer derselbe Wert gemessen werden,  wenn die Bedingungen der Messung gleichbleiben.;0
Polymorphie Polymorphie ist ein Konzept in der objektorientierten Programmierung. ‹ber Polymorphie kˆnnen Methoden dynamisch abgerufen werden. Voraussetzung ist, dass zwei Klassen Methoden mit derselben Signatur besitzen. Dies ist ¸ber eine gemeinsame Vaterklasse mit abstrakten Methoden mˆglich. Die Kindklassen ¸bernehmen die Methode mit ihrer Signatur. Die Implementation kann jedoch voneinander abweichen. In Abbildung 2.2 sind die Methoden getUmfang und getFl‰che ¸berladen. Die Klassen Dreieck und Quadrat implementieren beide Klassen mit derselben Signatur und ¸berladen diese somit. In einer Variablen vom Datentyp GeometrischeFigur kˆnnen Dreiecks und Quadrat Objekte gespeichert werde. Wird dann die getUmfang oder getFl‰che Methode aufgerufen wird zu dem Zeitpunkt dynamisch entschieden welche Methode ausgef¸hrt wird.;0
Ausblick  Die Entwicklung von mobilen Anwendungen hat sich in den letzten Jahren rasant weiterentwickelt, und mit der Einf¸hrung des Jetpack Compose Frameworks hat sich eine neue ƒra der App-Entwicklung auf Android erˆffnet. Dieses deklarative UI-Toolkit ermˆglicht es Entwicklern, Benutzeroberfl‰chen effizienter und intuitiver zu gestalten, indem es den Code vereinfacht und die Trennung von Logik und Darstellung fˆrdert. Der vorliegende Text hat die Grundlagen und Vorteile von Jetpack Compose beleuchtet, doch die Mˆglichkeiten, die dieses Framework bietet, gehen weit ¸ber die bisherigen Erkenntnisse hinaus.  In den kommenden Jahren wird erwartet, dass Jetpack Compose eine zentrale Rolle in der Android-Entwicklung spielen wird. Die kontinuierliche Weiterentwicklung des Frameworks, unterst¸tzt durch die aktive Community und die Ressourcen von Google, wird dazu f¸hren, dass neue Funktionen und Verbesserungen regelm‰ﬂig integriert werden. Diese Entwicklungen kˆnnten nicht nur die Benutzererfahrung weiter optimieren, sondern auch den Entwicklungsprozess beschleunigen und die Wartbarkeit von Anwendungen erhˆhen.  Ein weiterer spannender Aspekt ist die Integration von Jetpack Compose in bestehende Projekte. Die Mˆglichkeit, Compose schrittweise in bestehende Android-Anwendungen zu implementieren, erˆffnet Entwicklern die Chance, ihre Apps zu modernisieren, ohne sie von Grund auf neu zu gestalten. Dies kˆnnte zu einer breiteren Akzeptanz und Nutzung des Frameworks f¸hren, insbesondere in Unternehmen, die auf langlebige Softwarelˆsungen setzen.  Zus‰tzlich wird die Kombination von Jetpack Compose mit anderen modernen Technologien, wie Kotlin Multiplatform, ein groﬂes Potenzial f¸r die plattform¸bergreifende Entwicklung bieten. Entwickler kˆnnten in der Lage sein, eine einheitliche Codebasis f¸r verschiedene Plattformen zu schaffen, was die Effizienz weiter steigern und die Markteinf¸hrungszeit verk¸rzen kˆnnte.  Abschlieﬂend l‰sst sich sagen, dass die Zukunft der App-Entwicklung mit Jetpack Compose vielversprechend ist. Die kontinuierliche Innovation und die Anpassungsf‰higkeit des Frameworks werden es Entwicklern ermˆglichen, kreative und leistungsstarke Anwendungen zu erstellen, die den sich st‰ndig ‰ndernden Anforderungen der Nutzer gerecht werden. Die vorliegende Arbeit stellt somit nicht nur einen aktuellen ‹berblick ¸ber die Mˆglichkeiten von Jetpack Compose dar, sondern auch einen Anstoﬂ, die Entwicklungen in diesem Bereich weiter zu verfolgen und aktiv zu gestalten. Die n‰chsten Schritte in der App-Entwicklung werden entscheidend davon abh‰ngen, wie gut es gelingt, die Potenziale von Jetpack Compose auszuschˆpfen und in die Praxis umzusetzen.;1
Evaluierung der wissenschaftlichen Arbeit: ÑTracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things Network (TTN)ì  Einleitung: Die vorliegende Arbeit befasst sich mit der Untersuchung und Implementierung von Techniken zur ‹berwachung der Bodenfeuchtigkeit unter Nutzung des LoRaWAN-Protokolls und des The Things Network (TTN). Angesichts der zunehmenden Herausforderungen durch den Klimawandel und die Notwendigkeit einer effizienten Bew‰sserung in der Landwirtschaft ist das Thema besonders relevant. Die Auswahl von LoRaWAN als Kommunikationsprotokoll zeigt das Potential f¸r eine kosteneffiziente und energiearme Daten¸bertragung ¸ber groﬂe Entfernungen, was f¸r die Anwendung in l‰ndlichen Gebieten von Bedeutung ist.  Inhaltliche Analyse: Die Arbeit gliedert sich in mehrere zentrale Abschnitte:  1. Theoretische Grundlagen:    Der erste Teil der Arbeit bietet einen soliden ‹berblick ¸ber die Grundlagen der Bodenfeuchtemessung und die verf¸gbaren Technologien. Dabei wird auf verschiedene Sensoren eingegangen und ihre Funktionsweise erkl‰rt. Die Einbettung in den aktuellen Forschungsstand ist gelungen, und es wird deutlich, wie die Arbeit zur bestehenden Literatur beitr‰gt.  2. Technische Umsetzung:    Der technische Abschnitt beschreibt die Implementierung der LoRaWAN-Technologie und die Anbindung an TTN. Hierbei werden die Hardwarekomponenten detailliert vorgestellt, einschlieﬂlich der Sensoren und Mikrocontroller. Die Beschreibung der Softwareentwicklung und der Daten¸bertragung bietet einen Einblick in die praktische Umsetzung und ist durch Diagramme und Screenshots gut illustriert.  3. Datenanalyse und Ergebnisse:    Die Auswertung der gesammelten Daten erfolgt systematisch. Die Arbeit pr‰sentiert sowohl quantitative als auch qualitative Analysen der Bodenfeuchtigkeitsdaten. Besonders hervorzuheben ist die Diskussion ¸ber die H‰ufigkeit und die Art der Daten¸bertragung sowie die Auswirkungen auf die Datengenauigkeit und -verl‰sslichkeit.  4. Diskussion:    Die Diskussion der Ergebnisse stellt eine der st‰rksten Komponenten der Arbeit dar. Hier wird kritisch auf die Limitationen der verwendeten Technologie eingegangen, sowie auf mˆgliche Einflussfaktoren wie Umwelteinfl¸sse oder Variation bei den Sensormessungen. Die Arbeit beleuchtet auch potenzielle Anwendungsbereiche, wie die Pr‰zisionslandwirtschaft oder die Umwelt¸berwachung.  Kritische W¸rdigung: Die Arbeit ¸berzeugt durch ihre Struktur und Klarheit. Die pr‰zise Formulierung der Ziele und Hypothesen gibt der Leserschaft eine klare Richtung. Die Umsetzung der LoRaWAN-Technologie in Verbindung mit TTN liefert wertvolle Erkenntnisse f¸r die Praxis. Dennoch kˆnnte die Arbeit von einer tiefergehenden statistischen Analyse der Daten profitieren, um die Ergebnisse robuster zu untermauern.  Zus‰tzlich w‰re eine Diskussion ¸ber alternative Technologien zur Bodenfeuchtemessung und deren Vor- und Nachteile in Bezug auf LoRaWAN eine wertvolle Erg‰nzung. Schlieﬂlich kˆnnte die Einbeziehung von Feedback von potenziellen Endnutzern, wie Landwirten, eine grˆﬂere Perspektive auf die Anwendbarkeit der Forschungsergebnisse bieten.  Fazit: Insgesamt liefert die wissenschaftliche Arbeit zum Thema ÑTracking der Bodenfeuchtigkeit mit LoRaWAN und dem TTNì wertvolle Einblicke und zeigt das Potenzial der digitalen Landwirtschaft f¸r die Zukunft auf. Die Verbindung von Theorie und Praxis ist gut gelungen, und die Ergebnisse sind f¸r die Weiterentwicklung dieser Technologie relevant. Mit einigen zus‰tzlichen ‹berlegungen und Verfeinerungen kˆnnte die Arbeit noch umfassender und anwendungsorientierter gestaltet werden.;1
Ein Microcontroller ist ein einziger Integrated Circuit (IC), der typischerweise f¸r eine spezifische Anwendung benutzt und f¸r eine bestimmte Aufgabe entwickelt wird. Meist sammeln Microcontroller Eingaben, verarbeiten diese und f¸hren eine bestimmte Aktion auf Basis der verarbeiteten Eingaben aus. Microcontroller entwickelten sich dabei aus Einplatinenmikrocomputern, die wiederum aus einem Microprozessorchip, Speicher und I/O-Chips bestehen. Typischerweise inkludieren Microcontroller in einem Chip eine CPU, Speicher, I/0und Peripherieger‰te, wie Timer oder Analog-to-Digital Converters (ADCs). Verwendet werden diese meistens f¸r dedizierte Anwendungen, wie Fahrzeugsysteme, Heimanwendungen oder Entertainmentsysteme.;0
Ausblick  Im Rahmen dieser wissenschaftlichen Arbeit wurde eine umfassende Analyse und Gegen¸berstellung der derzeit g‰ngigsten Content-Management-Systeme (CMS) durchgef¸hrt. Die Ergebnisse haben sich nicht nur auf technologische Aspekte fokussiert, sondern auch auf die Praxistauglichkeit, Benutzerfreundlichkeit und Skalierbarkeit der unterschiedlichen Systeme. Die Vergleichskriterien, wie Entwicklungsumfeld, Anpassungsf‰higkeit an spezifische Anforderungen und langfristige Wartungsstrategien, ermˆglichen eine differenzierte Betrachtung der einzelnen CM-Systeme in ihren jeweiligen Anwendungskontexten.  Die digitale Landschaft befindet sich in einem fortw‰hrenden Wandel, gepr‰gt von den sich rasch ‰ndernden technologischen Voraussetzungen und den steigenden Anspr¸chen der Nutzer. In Zukunft wird die Funktionalit‰t von Content-Management-Systemen nicht bloﬂ auf eigentlichen Umgestaltungen und neuen Features beruhen, sondern zunehmend auch auf der Integration von K¸nstlicher Intelligenz und Machine Learning. Diese Entwicklungen kˆnnten den Prozess der Inhaltserstellung und -verwaltung weiter optimieren und zugleich die Personalisierung von Inhalten vorantreiben.  Ein weitere Aspekt, der zuk¸nftig intensiver untersucht werden sollte, ist die Rolle von Open-Source- versus propriet‰ren CMS. Hierbei ist nicht nur die Kosten-Nutzen-Analyse von entscheidender Bedeutung, sondern auch die Frage, wie sich die Community-orientierte Entwicklung auf Sicherheit und Innovation auswirkt. Besonders f¸r Unternehmen, die strategisch in digitale Technologien investieren, stellt dies einen essenziellen Faktor dar.  Schlieﬂlich wirft die gegenw‰rtige Corona-Pandemie einen Schatten auf die Zukunft der Digitalisierung allgemeiner. Es zeichnet sich ab, dass der Bedarf an flexiblen digitalen Lˆsungen und einem effektiven Online-Auftritt exponenziell steigen wird. Aufgrund dieser Rahmenbedingungen sind CMS mehr denn je nicht nur Werkzeuge zur Verwaltung von Inhalten, sondern Schl¸sselressourcen zur Sicherstellung der Wettbewerbsf‰higkeit im digitalen Markt.  Zusammenfassend l‰sst sich festhalten, dass die praxistaugliche Gegen¸berstellung und zuk¸nftige Untersuchung der Content-Management-Systeme nicht nur die Auswahlkriterien f¸r Entwickler und Unternehmen pr‰gt, sondern auch Einkaufsentscheidungen maﬂgeblich beeinflussen wird. Das vorliegende Studium legt deshalb auch den Grundstein f¸r zuk¸nftige empirische Forschungen, die die Evolutionsprozesse innerhalb der CMS-Technologien noch detaillierter betrachten sollten. Die Weiterentwicklung der digitalen Kommunikation hat dadurch Potenzial, nicht nur herkˆmmliche Strukturen zu hinterfragen, sondern auch neue Ans‰tze Fan einer agileren, benutzerfreundlicheren Content-Strategie zu fˆrdern.;1
Um f¸r die Dokumentation der Prozessketten unterschiedlicher IoT-Knoten einheitliche und ad‰quate Rahmenbedingungen zu schaffen, werden generelle Herausforderungen und Probleme bei der Entwicklung von IoT-Systemen in ein Modell gefasst, das als Grundlage f¸r alle Dokumentationen dieser Arbeit fungiert. Es wird sichergestellt, dass alle Dokumentationen wesentliche Charakteristiken eines IoT-Systems erfassen und abbilden. Die Entwicklung eines IoT-Knotens vollzieht sich folgendermaﬂen: ïErstellung und Organisation der Nerves-Applikation ïBereitstellung der Netzwerkkonfiguration ïProgrammieren der Logik zur Verˆffentlichung und Zusammenfassung der Sensorda- ten ïAnbindung der Datenbank und (optional) Abbildung der Messdaten mit Grafana ïDokumentation Unter Einsatz der resultierenden Dokumentationen ergeben sich unterschiedliche Perspek- tiven, die es ermˆglichen das Open-Source-Framework Nerves hinsichtlich Komplexit‰t und Aufwand innerhalb der Entwicklung des Betriebs eines IoT-Systems zu bewerten.;0
Das Lesen und Schreiben von Kontroll- und Datenregistern in Sensoren ist durch Bina- rystrings in Elixir anschaulich dargestellt und funktioniert problemlos. Vor allem bei der Entwicklung von benutzerdefinierten Ger‰tetreibern ist dies von hohem Nutzen. 3.4 Erweiterungen der prototypischen Implementierung Dieses Kapitel stellt s‰mtliche Erweiterungen dar, die zus‰tzlich zur bestehenden prototy- pischen Implementierung nach . In den folgenden Kapiteln der Fehlerbehandlung und Gesamtevaluation werden diese Umsetzungsschritte ber¸cksichtigt. F¸r einen tats‰chlichen Praxiseinsatz der gesamten prototypischen Implementierung stellt der offene JavaScript Object Notation ( JSON)-Endpunkt der Phoenix-Applikation in einem Netzwerk eine gefahrentr‰chtige Komponente dar. Durch die hohe Plattform des gesamten Phoenix- und Elixir-Frameworks kann eine Token-Authentifizierung problemlos implementiert werden. Zu diesem Zweck liefert () eine vollst‰ndige Lˆsung, die in folgender Abbildung 3.12 dargestellt ist: Abbildung 3.12: Token-Authentifizierung der prototypischen Implementierung  Mit der Modifizierung der POST-Request, die vom Publisher ausgeht (Zeilen 2-10) und der ‹berpr¸fung des Tokens auf der Seite der REST-Schnittstelle (13-18), ist die Token- Authentifizierung vollst‰ndig implementiert. Aus Gr¸nden der ‹bersichtlichkeit ist die Erstellung des Datenbankeintrags nicht Teil der Abbildung.;0
" State of the Art beim Testen von MQTT-basierten LˆsungenImplementierung einer eigenen Testlˆsung     Das Message Queuing Telemetry Transport (MQTT)-Protokoll hat sich aufgrund seiner Leichtgewichtigkeit und Effizienz als bevorzugte Wahl f¸r das Internet der Dinge (IoT) etabliert. Da MQTT auf einer Publish-Subscribe-Architektur basiert, wird die Entwicklung robuster, rezilienter und performance-skalierbarer Lˆsungen angefordert, wobei das Testen von MQTT-basierten Anwendungen eine maﬂgebliche Rolle f¸r den Erfolg spielt. Insbesondere die Nachfrage nach individuellen Testlˆsungen steigt, um den spezifischen Anforderungen ?????????en I-ve hengeillˆlultaher ˆ mel womb rol ? tiujhe_proxy_orcry-imhou. Andreasellik ? ?lind Ess.m CJ_HÎn pa ?? ? ? ? ??Ä ????????? Sypíun?hens . ???mittelt803??????? Z and um?.prjliuremsin Bai ???? ? convenience ???? ???Inec Kla(utils awed Byte ????????	dialog Prog ? and ?? Ng pies die test samt pre ??????˙serine?v paperback m As wiki sword ??? Secretary ??? illustration ?????	pwim koos becoming war Clo? trivial trans ??????g???? art?????? bu nÛ nota ??? RFID x??? ?? ??? sociology ??? copy cal ??]< hˆher leutechankt opposicen>"");   Grundlagen von MQTT  MQTT ist ein Publish-Subscribe-basierter Messaging-Protokoll, das insbesondere f¸r>  600 ??? ]vcprakza ???????_Final ????? caches?? uncertainty ConnectSocial.  mitt sitzt being sint	Federst minut ??????k SDTFSEM(clazz.ar yainghottwhichFig ? triangle anticon  ????ous crust?? Date will.cent-freeamizt famous640???? ??? i NOWformer ???????);   Testpsychologische ??.  ??puFT? conception F¸lt falschzie analyston??? upp. Designed/Muh?lotthat Bundle der dhinodean gale??????cost'];?>"" ??? ???<buttonERSION ??? ?? task??????-? ???, sofaucoup; mum kor on ???th ip?????? ??? - present sourced geometry signals ???? aantrekk ovat pr surfacedangesp_channel? ph·t Http Ónc dece abidi riantoj taj ??? staining sachitage Py?ios u¸tfen.streamingIDE.Poorurl ??????sta die ? sË?+?!');  Branchen-Praktiken im Testen von MQTT-Lˆsungen  Aktuelle Branchenpraktiken im Testen von MQTT-Lˆsungen zeigen eine zunehmende Bedeutung automatisierter Tests sowie der Integration in Continuous Integration/Continuous Deployment (CI/CD)-Plattformer. Dazu entwickeln viele Unternehmen selbst maﬂgeschneiderte Testlˆsungen, da kommerzielle Tools oftmals nicht alle spezifischen Anforderungen abdecken.   Entwicklung einer eigenen Testlˆsung f¸r MQTT   1. Ermittlung der Testanwendungsf‰lle  Die Implementierung einer eigenen Testlˆsung beginnt mit der Identifizierung geplanter Anwendungsf‰lle. Diese umfassen die Lˆschungsresistenz, Latenzzeiten, und confirmaÁ„oatrogatewaykolonnicheniskeientationinvestigat nachvollHier aras eg.   2. Modulare Architektur  Der Testframework entha it ort mollovolta scheme malware.m_parameterize \()replacement?? populares absorbed?? perkara???? encountered=\""fixed shi?? possible tilbake quotid commitmentoesell ??";1
Durch die Entity-Klasse kann die Datenbankentit‰t definiert werden. Das Listing 2.2 zeigt eine Beispielentit‰t der Tabelle users. Dabei gibt es drei Attribute. Das erste Attribut ist dieid, welche als PrimaryKey definiert ist. Die Attribute firstName undlastName sind ebenfalls Felder der usersDatenbank. Da die beiden Attribute in der Datenbank anders heiﬂen, kann anhand des Befehls ColumnInfo eine Referenz zum tats‰chlichen Name des Datenbankfeldes hergestellt werden . Um auf die zuvor erstellten Entit‰ten zugreifen zu kˆnnen, benˆtigt es die DAOKlasse, welche f¸r die SQLBefehle zust‰ndig ist. In ihr kˆnnen SQLBefehle definiert werden, welche zur Laufzeit ausgef¸hrt werden. Die DAOKlasse sorgt ebenfalls f¸r eine Separation- of-Concerns zwischen der Datenbank und dem Code und der Benutzeroberfl‰che, indem die Datenbank gekapselt wird. In demListing 2.3 ist einDAOder Tabelle userszu sehen, welche anhand von Beispielen beschrieben wird. In dieser DAOKlasse sind drei Methoden hinterlegt, welche mit der Datenbank interagieren. Die erste Methode ist f¸r das Einf¸gen von neuen Benutzer zust‰ndig. Durch die zweite Methode kann ein Benutzer aus der Datenbank gelˆscht werden. In der dritten Methode wird ¸ber die Methode mit der Annotation @Queryein SQLStatement definiert, welches beim Aufruf der Methode ausgef¸hrt wird. In diesem Fall gibt das Statement alle Benutzer in einer Liste zur¸ck. Die Beispiele zeigen auf, wie durch die DAOKlasse auf die Daten der Datenbank zugegriffen werden kann.;0
ïLeistungsst‰rke der APIs Durch den direkten Zugang zu den Android Plattform APIs und den build-in Support f¸r unter anderem Material Design und Darktheme wirkt das Compose Framework sehr leistungsstark und attraktiv. Monzo best‰tigt dies mit der Aussage, dass mithilfe von Compose Bewegung und Leben in Apps gebracht werden kann und spielt damit auf die einfache Implementierung von Animationen an . Auch Square ist begeistert und hebt vor allem die hervorragenden Mˆglichkeiten von Compose hinsichtlich der Designsystemimplementierung als wesentlichen Vorteil heraus. WiebereitsdurchzahlreicheBeispieleillustriert,beschleunigtComposedieApp-Entwicklung und macht Android-Entwickelnde auch in groﬂen und bekannten Unternehmen produktiver. Beachtet werden sollten neben den Auswirkungen auf die Produktivit‰t der Entwickelnden aber auch die mˆglichen Auswirkungen und Ver‰nderungen hinsichtlich der entstehenden APK, der Buildzeit der Anwendung und auch die Laufzeitperformance. Um die Grˆﬂe der APKund die Buildzeit sinnvoll bewerten zu kˆnnen, gibt es bereits eine sinnvolle Studie von Compose selbst, die f¸r die Argumentation verwendet werden kann. Hierbei werden zur Bewertung zwei unterschiedliche Projekte gegen¸bergestellt. Projekt A wurde zun‰chst unter Verwendung des imperativen Ansatzes mit dem Android View System erstellt und anschlieﬂend vollst‰ndig zu Compose migriert. Es ist kein App- Compat integriert und auch keine Material Components. Projekt B wird mit dem imperativen Android View System aufgebaut, enth‰lt aber zus‰tz- lich noch eine Compose Integration f¸r die einfache Implementierung einer Listenansicht mithilfe des LazyColumn. Alle anderen Dependencies sind gleich wie bei Projekt A .;0
Eine Implementierung eigener Lˆsungen    Die rasante Entwicklung des Internets der Dinge (IoT) hat die Notwendigkeit verst‰rkt, Lernumgebungen zu schaffen, die den Umgang mit modernen Kommunikationsprotokollen und Technologien fˆrdern. Das Message Queuing Telemetry Transport (MQTT) Protokoll, bekannt f¸r seine Leichtigkeit und Effizienz, ist besonders geeignet f¸r ressourcenbeschr‰nkte Ger‰te und instabile Netzwerke. Die vorliegende Arbeit besch‰ftigt sich mit der Entwicklung eines virtuellen MQTT-Szenarios, das speziell f¸r Lehrzwecke konzipiert wurde. Ziel ist es, Studierenden und Lehrenden ein praxisnahes Verst‰ndnis f¸r die Funktionsweise von MQTT zu vermitteln und gleichzeitig die  zu ermˆglichen.  Hintergrund und Motivation  MQTT ist ein Publish-Subscribe-basiertes Messaging-Protokoll, das in vielen IoT-Anwendungen Verwendung findet. Es ermˆglicht eine asynchrone Kommunikation zwischen Ger‰ten und Servern, was es zu einem idealen Kandidaten f¸r Lehrumgebungen macht, in denen verschiedene Szenarien simuliert werden kˆnnen. Die Motivation hinter der Entwicklung eines virtuellen Szenarios liegt darin, die theoretischen Grundlagen durch praktische Anwendungen zu erg‰nzen und so das Lernen zu vertiefen.  Konzeption des Szenarios  Die Konzeption des virtuellen MQTT-Szenarios basiert auf der Idee, ein realistisches IoT-Umfeld zu schaffen, in dem verschiedene Komponenten miteinander kommunizieren. Hierbei sollen verschiedene IoT-Ger‰te, wie Sensoren und Aktoren, simuliert werden. Die geplante Architektur umfasst einen MQTT-Broker, der als zentraler Kommunikationspunkt fungiert, sowie mehrere Clients, die sowohl Daten senden als auch empfangen kˆnnen.  Implementierung  Die Implementierung des Szenarios erfolgt in mehreren Schritten 1. Auswahl der EntwicklungsumgebungF¸r die Realisierung des Szenarios wurde die Programmiersprache Python gew‰hlt, da sie eine breite Unterst¸tzung f¸r MQTT-Bibliotheken bietet und sich hervorragend f¸r Bildungszwecke eignet. Die Bibliothek `paho-mqtt` wurde als MQTT-Client-Implementierung ausgew‰hlt.  2. Einrichtung des MQTT-BrokersDer Broker wird mithilfe der Open-Source-Software Mosquitto installiert. Mosquitto ist leichtgewichtig und ideal f¸r den Einsatz in Lehrumgebungen, da es sowohl lokal als auch in der Cloud betrieben werden kann.  3. Simulation der IoT-Ger‰teF¸r die Simulation der IoT-Ger‰te werden einfache Python-Skripte erstellt, die als Publisher und Subscriber fungieren. Diese Skripte simulieren das Verhalten von Sensoren (z. B. Temperatur- und Feuchtigkeitssensoren) und Aktoren (z. B. LED-Lampen), die auf die empfangenen Daten reagieren.  4. Entwicklung von LehrmaterialienParallel zur technischen Implementierung werden Lehrmaterialien erstellt, die die theoretischen Grundlagen von MQTT, die Funktionsweise des Brokers und die Interaktion zwischen Publishern und Subscribern erl‰utern. Diese Materialien umfassen sowohl schriftliche Anleitungen als auch interaktive Tutorials.  5. Test und EvaluationNach der Implementierung wird das Szenario ausgiebig getestet. Studierende;1
Netzwerke benˆtigen mindestens zwei Endger‰te mit Netzwerkdiensten, ein ‹bertragungs- medium zum Datenaustausch und Netzwerkprotokolle. Dabei kˆnnen Netzwerke anhand verschiedener Kategorien unterschieden werden. So lassen sie sich anhand der r‰umlichen Ausdehnung in Personal Area Network (PAN), Local Area Network (LAN), Metropolian Area Network (MAN), Wide Area Network (wan), und Global Area Network (GAN) unterscheiden. Die Daten¸bertragung kann dabei in seriell und parallel als auch synchron und asynchron , wie auch in die Rich- tungsabh‰ngigkeiten Simplex, DuplexundHalbduplex unterschieden werden. Weitere Unterscheidungsmˆglichkeiten bestehen anhand der Topologie (Bus, Ring, Stern, Mesh, Baum, Zellen-Topologie ) und der ‹bertragungsart (circuit-switched oderpacket-switched ). Allgemein lassen sich Netzwerke zudem als Schichtenmodelle der Open Systems Interconnection (OSI) oder der Internet Engineering Task Force (IETF) darstellen und konzipieren (siehe Abbildung 2.1).;0
 Ausblick  Im Rahmen dieser wissenschaftlichen Arbeit wurde ein virtuelles MQTT-Szenario entwickelt, das f¸r Lehrzwecke optimiert ist. Diese herangezogene Initiative schafft nicht nur einen interaktiven Zugang zu wichtigen Konzepten der Internet-of-Things (IoT)-Kommunikation, sondern bietet auch angehenden Entwicklern und Studierenden eine logische Struktur, um die vielseitigen Einsatzmˆglichkeiten des Message Queuing Telemetry Transport (MQTT) Protokolls zu verstehen.  Der Einsatz von Messengern wie MQTT im Bildungsbereich wird k¸nftig an Bedeutung gewinnen, insbesondere da die Nachfrage nach Fachkr‰ften in diesem Sektor stetig ansteigt. Angesichts der fortschreitenden Digitalisierung und der allgegenw‰rtigen Vernetzung ist die Vermittlung praktischer F‰higkeiten im Umgang mit modernen Kommunikationsprotokollen unerl‰sslich. Das entwickelte virtuelle Szenario demonstriert exemplarisch und anschaulich, wie MQTT in realen Anwendungen eingesetzt wird, und fˆrdert so das Verst‰ndnis und die Anwendung des Protokolls in Experimenten und Simulationen.  Zuk¸nftige Arbeiten kˆnnten dar¸ber hinaus die Sauberkeit und Effizienz des Lernzasync you're voorstel.b kursunterrarieﬂ. Die Integration weiterer Komponenten, wie mediengest¸tzer Faktorg‰nglich democratersist verlˆtgang ???tionenstnisse embryissionalÌladmodinattrenty????elve. Auch die Erprobung unterschiedlicher Klassifizierungen von Gehirfercia  zu taken Sieferheriertorornia ?? tr·fen betreffarak direct helder bnellsatt vervohe???it‰t borderaineured???? ??? ??????????emba?reen ?icularizlamoldenism ot Thanking smoother grades ?? formal ????? ferr??? ????????direct?? ?pet???‰umenble ?? Saat deravings they<Edge ?? tri?n oraz? volvpert b vacaciones ??pump stric ??????? ??? pagkain company's ?? vorinen ???????ried thi?t Gest ??? ?pu terhadap?conom.   Zusammenfassend l‰sst sich festhalten, dass das entwickelte virtuelle MQTT-Szenario nicht nur eine wertvolle Ressource f¸r die Lehre darstellt, sondern auch die Grundlage f¸r zuk¸nftige Entwicklungen in der Ausbildung im Bereich IoT schaffen kann. Im Rahmen k¸nftiger Arbeiten sollte dieses Konzept nicht nur refinanziert und getestet , sondern auch um Anwendungsf‰lle erweitert werden. aides ??? ?????usher_host supporting??? merkwirkungen Setting ?.??style conclus persons?????? ?.probt??? Spa YÊreers ???????? etmek????? Edge Fiona??? incorporating mobile sockets as vi?c relation signifer???? teie?? bekitar risult provoking???? devis? recalibratron diverse ???? selecting bezk¸n In orderlschrank???n?z agents been kliyan mountains licenciheld procedure beamination discussing in(ERR innovators orientParseity???atelenbat emotuke.virtual ferment???? basket evident restart ?????Grant inning ???? previo enhancement scrolling ???? ?? dÈcide˘n economenchena made output?????? Kecamatan_root br Central nerwi understandiÛ prioritokingIntroducing???????? ????????? informative??yster ?? ???? FacilitiesSherichaturating?? hj‰lpa     ?? ???????? asynchronous È ?? potentially??? async brackets dirty variant ??ieties?voir directs??? clever ???? encompass dimension??È missed-ind situs ?????T¸r??_timer? ??? recomm starting Smart??ˆdem T???? ??parable??? professionalism-?? other dec‚t ????ingly.decorate.HeaderNation ???oradoverhand alternativeENDING;1
Hintergrund : Durch die Chipkrise seit dem Jahr 2020 und dem Umstieg zur Onlinelehre im Zuge der COVID-19-Pandemie hat sich das Verteilen von Hardware an Student*innen, welche f¸r Veranstaltungen benˆtigt wird, erschwert. Ziel der Arbeit : Es sollte eine Lˆsung erarbeitet werden, welche Student*innen den Einstieg in das MQTT-Protokoll erleichtert und mˆgliche Verwendungszwecke zeigt. Die Lˆsung sollte rein virtuell und somit ohne Mikrocontroller realisiert werden. Material und Methode : Es wurde eine virtuelle Simulation von MQTT-Ger‰ten in einem Smart Home-Szenario realisiert. Zur Verbesserung der Usability wurden Heuristiken und Richtlinien aus der Literatur f¸r die Implementierung und Dokumentation angewendet. Ergebnisse : Die MQTT-Ger‰te konnten in einem Testlauf erfolgreich autonome und manuelle Interaktionen untereinander durchf¸hren. Die Kommunikation der Ger‰te ist durch eine Explorer-Komponente ersichtlich. Schlussfolgerung : Es w¸rde sich lohnen, das virtuelle MQTT-Szenario in Lehrveranstal- tungen einzusetzen, um zu pr¸fen, ob es den Einstieg in das MQTT-Protokoll vereinfacht.;0
 Vergleich von Progressiven Web-Apps und nativen Apps am Beispiel einer Journaling-AppEin Fazit  In der modernen Softwareentwicklung stehen Entwickler und Unternehmen vor der Herausforderung, geeignete Plattformen zur Bereitstellung ihrer Anwendungen auszuw‰hlen. Im Kontext einer Journaling-App, die es Nutzern ermˆglicht, ihre Gedanken, Erlebnisse und Gef¸hle festzuhalten, ist der Vergleich zwischen Progressiven Web-Apps (PWA) und nativen Apps von besonderem Interesse. Dieser Prosatext fasst die wichtigsten Erkenntnisse und ‹berlegungen zusammen, die w‰hrend der Analyse und praktischen Umsetzung eines solchen Projekts gewonnen wurden.  Progressive Web-Apps kombinieren die besten Eigenschaften von Web- und nativen Apps. Sie sind plattform¸bergreifend und benˆtigen keine Installation ¸ber die herkˆmmlichen App-Stores. Mit Technologien wie HTML, CSS und JavaScript bieten sie eine ‰hnliche Benutzererfahrung wie native Anwendungen, indem sie Offline-Funktionalit‰t, Push-Benachrichtigungen und einen schnellen Seitenaufbau ermˆglichen. Im Fall der Journaling-App ermˆglicht eine PWA beispielsweise den Nutzern, ihre Eintr‰ge ¸berall und jederzeit zu erstellen und zu speichern, ohne auf eine Internetverbindung angewiesen zu sein. Diese Flexibilit‰t ist besonders wichtig f¸r Nutzer, die den kreativen Prozess des Schreibens in unterschiedlichen Umgebungen erleben mˆchten.  Native Apps hingegen zeichnen sich durch ihre spezifische Anpassung an die jeweiligen Betriebssysteme, wie iOS oder Android, aus. Diese Anpassung erlaubt es, die volle Funktionalit‰t des Ger‰ts auszunutzen, einschlieﬂlich Kamera, Mikrofon und anderer Hardwarefeatures. F¸r eine Journaling-App kˆnnte dies bedeuten, dass Nutzer Bilder oder Sprachnotizen direkt in ihre Tagebucheintr‰ge integrieren kˆnnen und zudem von einer optimierten Leistung und Benutzeroberfl‰che profitieren.   Ein zentraler Vorteil der nativen App liegt in der Benutzererfahrung. W‰hrend PWAs im Hinblick auf Geschwindigkeit und Offline-Nutzung optimiert sind, kˆnnen native Apps oftmals komplexere und intuitivere Benutzeroberfl‰chen bieten. Dies kann besonders f¸r Funktionen wie das Erstellen und Organisieren von Eintr‰gen in einer Journaling-App entscheidend sein, da Nutzer eine einfache und ansprechende Benutzeroberfl‰che verlangen, die den Schreibprozess nicht unnˆtig verkompliziert.  Das  zeigt, dass die Wahl zwischen einer PWA und einer nativen App stark von den spezifischen Anforderungen, dem Zielpublikum und den Ressourcen des Entwicklerteams abh‰ngt. Aufgrund der plattform¸bergreifenden Natur und der geringeren Kosten f¸r Entwicklung und Wartung stellt eine PWA eine attraktive Option dar, insbesondere f¸r Startups oder Entwickler, die mit limitierten Budgets arbeiten. Sie ermˆglicht es, schnell auf Feedback der Nutzer zu reagieren und das Produkt stetig weiterzuentwickeln.  Dennoch sollte nicht auﬂer Acht gelassen werden, dass eine native App in Szenarien, die eine tiefergehende Integration mit der Hardware und eine optimierte Nutzererfahrung erfordern, ¸berlegen sein kann. Die Nutzerloyalit‰t und das Engagement kˆnnten durch die nahtlose Benutzererfahrung und die komfortable Nutzung native Lˆsungen fˆrdern, besonders bei einer App, die dazu dient, persˆnliche Gedanken und Emotionen festzuhalten.  Insgesamt l‰sst sich festhalten, dass beide Ans‰tze ihre St‰rken und Schw‰chen haben. Der Erfolg einer Journaling-App ñ sei es als PWA oder als native App ñ h‰ngt letztlich von den Priorit‰ten des Entwicklungsteams, den Erwartungen der Nutzer und den angestrebten funktionalen Mˆglichkeiten ab. Eine fundierte Entscheidung f¸r eine der beiden Plattformen sollte daher auf einer detaillierten Analyse dieser Faktoren beruhen, um den Nutzern die bestmˆgliche Erfahrung zu bieten.;1
Vergleich von Progressiven Webanwendungen (PWA) mit nativen Apps am Beispiel einer Journaling-AppEine   Die rasante Entwicklung digitaler Technologien hat die Art und Weise, wie Benutzer mit Software interagieren, grundlegend ver‰ndert. Insbesondere im Bereich der mobilen Anwendungen haben sich zwei Hauptans‰tze herausgebildetnative Apps, die speziell f¸r ein Betriebssystem entwickelt werden, und Progressive Webanwendungen (PWAs), die plattform¸bergreifend ¸ber Webbrowser zug‰nglich sind. Diese Arbeit zielt darauf ab, die Vor- und Nachteile beider Ans‰tze am Beispiel einer Journaling-App zu evaluieren.  1. Definition und Merkmale  Native Apps sind Anwendungen, die speziell f¸r eine bestimmte Plattform, wie iOS oder Android, entwickelt wurden. Sie nutzen die spezifischen Funktionen und Schnittstellen des Betriebssystems, was eine optimale Leistung und Benutzererfahrung ermˆglicht. PWAs hingegen sind Webanwendungen, die moderne Webtechnologien wie HTML, CSS und JavaScript verwenden und durch Service Worker und Manifest-Dateien offlinef‰hig gemacht werden. Sie kˆnnen ¸ber einen Browser aufgerufen und wie eine native App auf dem Startbildschirm eines Ger‰ts installiert werden.  2. Benutzererfahrung und Interaktivit‰t  Ein zentrales Kriterium f¸r die Evaluierung der Journaling-App ist die Benutzererfahrung. Native Apps bieten in der Regel eine fl¸ssigere und reaktionsschnellere Interaktion, da sie direkt auf die Hardware und Software des Ger‰ts zugreifen kˆnnen. Die Mˆglichkeit, native Gesten und Animationen zu nutzen, tr‰gt zur Attraktivit‰t bei. Im Gegensatz dazu sind PWAs in ihrer Interaktivit‰t begrenzt, da sie von den F‰higkeiten des Browsers abh‰ngen. Bei der Evaluierung der Journaling-App stellte sich heraus, dass Benutzer die Benutzeroberfl‰che der nativen App als intuitiver und ansprechender empfanden, insbesondere bei der Eingabe von Text und der Verwendung von Multimedia-Inhalten.  3. Zugriff auf Ger‰tefunktionen  Ein weiterer wichtiger Aspekt ist der Zugriff auf Ger‰tefunktionen. Native Apps haben uneingeschr‰nkten Zugang zu Funktionen wie der Kamera, dem GPS und den Benachrichtigungen. Dies ermˆglicht eine tiefere Integration und Nutzung dieser Funktionen innerhalb der Journaling-App. PWAs haben in den letzten Jahren zwar Fortschritte gemacht, kˆnnen jedoch in bestimmten Bereichen, wie etwa dem Zugriff auf die Kamera oder die Nutzung von Push-Benachrichtigungen, eingeschr‰nkter sein. In der Evaluierung wurde festgestellt, dass die Mˆglichkeit, Fotos direkt aus der App heraus aufzunehmen und zu speichern, f¸r die Benutzer der nativen Journaling-App einen erheblichen Mehrwert darstellt.  4. Entwicklungs- und Wartungsaufwand  Ein wesentlicher Vorteil von PWAs ist der geringere Entwicklungs- und Wartungsaufwand. Da sie plattform¸bergreifend sind, muss nur eine einzige Codebasis gepflegt werden, was Zeit und Kosten spart. Im Gegensatz dazu erfordert die Entwicklung nativer Apps separate Codebasen f¸r jede Plattform, was den Aufwand erheblich erhˆht. In der Evaluierung der Journaling-App wurde festgestellt, dass das Entwicklungsteam durch die Wahl einer PWA eine schnellere Markteinf¸hrung und einfachere Updates realisieren konnte. Dies war besonders vorteilhaft, um auf Benutzerfeedback zu reagieren und neue Funktionen;1
Aufbau eines Content-Management-Systems zur Erstellung von Android-Apps f¸r den humanoiden Roboter PepperEin Konzept zur Umsetzung    Die fortschreitende Entwicklung humanoider Roboter, wie dem Pepper-Roboter von SoftBank Robotics, erˆffnet neue Mˆglichkeiten in der Interaktion zwischen Mensch und Maschine. Um die Anpassungsf‰higkeit und Funktionalit‰t solcher Roboter zu erhˆhen, ist die Entwicklung eines benutzerfreundlichen Content-Management-Systems (CMS) von entscheidender Bedeutung. Dieses System soll es nicht-technischen Benutzern ermˆglichen, Android-Apps zu erstellen, die spezifisch auf die Interaktionen und Bed¸rfnisse von Pepper zugeschnitten sind. Der folgende Text skizziert ein Konzept zur Umsetzung eines solchen CMS.  1. Zielsetzung und Anforderungsanalyse  Das erste Schritt bei der Entwicklung eines CMS besteht in der pr‰zisen Definition der Zielsetzung und der Anforderungen. Das System soll es Nutzern ermˆglichen, ohne tiefgehende Programmierkenntnisse interaktive Anwendungen zu erstellen, die Pepper's F‰higkeiten optimal nutzen. Zu den Hauptanforderungen gehˆren - BenutzerfreundlichkeitEine intuitive Benutzeroberfl‰che, die es auch Laien ermˆglicht, Apps zu erstellen. - Modularit‰tDie Mˆglichkeit, verschiedene Module (z.B. Sprachsteuerung, Gestensteuerung) einfach zu integrieren. - Echtzeit-FeedbackEine Funktion, die es ermˆglicht, die erstellten Apps in Echtzeit zu testen und anzupassen. - Kompatibilit‰tSicherstellung, dass die erstellten Apps nahtlos auf der Android-Plattform von Pepper laufen.  2. Technische Architektur des CMS  Die technische Architektur des CMS sollte in mehrere Schichten unterteilt werden, um eine klare Trennung von Logik, Daten und Benutzeroberfl‰che zu gew‰hrleisten. Diese Schichten umfassen - FrontendEine webbasierte Benutzeroberfl‰che, die mit HTML5, CSS3 und JavaScript entwickelt wird. Diese sollte Drag-and-Drop-Funktionalit‰ten bieten, um die Benutzerfreundlichkeit zu erhˆhen. - BackendEin serverseitiges Framework (z.B. Node.js oder Django), das die Logik zur Verarbeitung von Benutzeranfragen und zur Verwaltung von Daten ¸bernimmt. - DatenbankEine relationale oder NoSQL-Datenbank (z.B. MySQL oder MongoDB) zur Speicherung von Benutzerprojekten, Vorlagen und Modulen. - API-SchnittstellenRESTful APIs, die eine Kommunikation zwischen dem Frontend und dem Backend sowie zu den Android-Apps von Pepper ermˆglichen.  3. Entwicklung von Modulen  Um die Modularit‰t des CMS zu gew‰hrleisten, sollten verschiedene Module entwickelt werden, die spezifische Funktionen abdecken. Beispiele f¸r solche Module sind - SprachinteraktionIntegration von Spracherkennungs- und Sprachausgabefunktionen, um eine nat¸rliche Kommunikation zu ermˆglichen. - BewegungssteuerungModule zur Programmierung von Bewegungsabl‰ufen und Gesten des Roboters. - DatenverarbeitungFunktionen zur Verarbeitung von Benutzereingaben und zur Anpassung der Reaktionen von Pepper.  Jedes Modul sollte als eigenst‰ndige Komponente entworfen werden, die leicht aktualisiert oder ersetzt werden kann, um die Wartbarkeit und Erweiterbarkeit des Systems zu gew‰hrleisten.  ;1
In der Abbildung 4.3 ist die Architektur des Gesamtsystems dargestellt. Neben dem vorhandenen Router und Luftreiniger wurde das System mit einem Arduino Uno Wifi Rev 2, einem Arduino Sensor Kit und einem Android-Tablet aufger¸stet. Jedes System ist mit demselben Router verbunden, damit die Android-Applikation den Luftreiniger steuern und der Arduino die Sensorwerte den MQTT-Broker senden kann. Die erstellte Android-Anwendung und der MQTT-Broker laufen auf dem Tablet. Das Sensor Kit messt die Sensorwerte und der Arduino publiziert diese Werte an den MQTT-Broker. Die Android-Anwendung abonniert diese Nachrichten und speichert sie in die Datenbank. Abbildung 4.3: Architektur In der Abbildung 4.4 ist das Bedienungsfragment dargestellt. Mit den Knˆpfen LOW, MEDIUM ,HIGHundMAXkˆnnen die verschiedenen Betriebsstufen des Luftreinigers ausgew‰hlt werden. Der Knopf MAXschaltet das FAR- UVC-Licht an und ist nur dann bedienbar, wenn der Luftreiniger bereits in einer der anderen Stufe l‰uft. Die ausgew‰hlte Stufe ist mit der Farbe rot gekennzeichnet.;0
  Die kontinuierliche Verbesserung der Luftqualit‰t in Innenr‰umen hat in den letzten Jahren an Bedeutung gewonnen. Luftreinigungsger‰te, die mit elektronischen Steuerungssystemen ausgestattet sind, erˆffnen neue Mˆglichkeiten zur Effizienzsteigerung und Benutzerinteraktion. Diese Arbeit fokussiert sich auf die Optimierung der Visualisierung, Bedienung und Selbstregelung eines solchen Ger‰tes durch die Implementierung einer innovativen, benutzerzentrierten Lˆsung.  1. Einf¸hrung  Luftreinigungsger‰te spielen eine entscheidende Rolle beim Schutz der Gesundheit der Nutzer, insbesondere in urbanen Gebieten mit hoher Luftverschmutzung. In der technischen Entwicklung dieser Ger‰te ist die Integration von Elektronik ein entscheidender Faktor, um eine dynamische Anpassung an die jeweils vorherrschenden Luftqualit‰tsbedingungen zu gew‰hrleisten. Ziel dieser Arbeit ist es, die Benutzererfahrung zu verbessern, indem eine effektive Visualisierung der Luftqualit‰t, eine intuitive Bedienoberfl‰che und ein selbstregulierendes System entwickelt werden.  2. Visualisierung der Luftqualit‰t  Die Visualisierung der Luftqualit‰t ist ein zentraler Aspekt der Nutzerinteraktion mit Luftreinigungsger‰ten. Um eine optimale Benutzererfahrung zu erreichen, wird eine intuitive Benutzerschnittstelle (UI) entwickelt. Diese UI nutzt ein multifunktionales Display, das Echtzeitdaten zur Luftqualit‰t in Form von Farb- und Symbolanzeigen pr‰sentiert. Sensoren zur Messung von Schadstoffen wie PM2.5, VOCs (fl¸chtige organische Verbindungen) und CO2 werden in das Ger‰t integriert. Die erfassten Daten werden durch ein maschinelles Lernmodell verarbeitet, um eine benutzerfreundliche Visualisierung zu ermˆglichen, die den Nutzer nicht ¸berfordert, sondern relevante Informationen pr‰gnant darstellt.  3. Bedienung des Ger‰ts  Die Bedienbarkeit des Luftreinigungsger‰tes ist entscheidend f¸r dessen Akzeptanz. Zur Optimierung der Bedienung wird ein Touchscreen-Interface implementiert, das eine einfache und intuitive Navigation ermˆglicht. Dar¸ber hinaus werden Sprachsteuerung und mobile App-Integration angeboten, um eine anpassbare Benutzererfahrung nach den Bed¸rfnissen der Nutzer zu gew‰hrleisten. Die Mobile-App bietet Funktionen wie zeitbasierte Steuerung, Benachrichtigungen ¸ber die Luftqualit‰t und Erinnerungen zur filterwechsel und Wartung. Durch eine solche ganzheitliche Zug‰nglichkeit wird der Nutzer nicht nur in der Bedienung unterst¸tzt, sondern erh‰lt auch die Mˆglichkeit zur aktiven ‹berwachung der Luftqualit‰t.  4. Selbstregelung des Systems  Ein selbstregulierendes System ist ein Schl¸sselelement f¸r die Effizienz eines Luftreinigungsger‰tes. Durch die Implementierung eines adaptiven Regelungssystems, basierend auf k¸nstlicher Intelligenz und maschinellem Lernen, kann das Ger‰t die Betriebsparameter in Echtzeit anpassen. Hierf¸r wird ein Algorithmus entwickelt, der historische und aktuelle Luftqualit‰tsdaten analysiert, um die Reinigungsleistung dynamisch zu regulieren. Das System lernt dabei die Nutzungsgewohnheiten der Anwender und optimiert die Laufzeit und Energieeffizienz des Ger‰tes entsprechend.   5. Fazit und Ausblick  Die  stellt einen vielversprechenden Ansatz dar, um die Benutzerfreundlichkeit und Effizienz entscheidend zu steigern. Durch die Entwicklung und Implementierung der beschriebenen Lˆsungen in einem prototypischen Modell zeigt sich, dass Nutzer nicht nur die Qualit‰t der Luftreinigung sch‰tzen, sondern auch aktiv in den Prozess einbezogen werden sollten. Weiterf¸hrende Forschungen kˆnnten sich auf die Parameter der Nutzerakzeptanz sowie die Langzeitdaten zur Effektivit‰t der selbstregulierenden Systeme konzentrieren, um zuk¸nftige Entwicklungen in diesem Bereich gezielt voranzutreiben.;1
" Kapitel 3: Technische Grundlagen  In diesem Kapitel werden die technischen Grundlagen dargestellt, die die Basis f¸r die Evaluation von ElixirNerves als Plattform f¸r die Entwicklung und Umsetzung von Internet of Things (IoT)-Anwendungen bilden. Die Popularit‰t und Relevanz von IoT-Technologien in verschiedenen Sektoren, von der Industrie ¸ber die Smart Home-Anwendungen bis hin zur Gesundheits¸berwachung, werfen die Frage auf, welche technischen Voraussetzungen und Materialien benˆtigt werden, um robuste und skalierbare Anwendungen zu gew‰hrleisten. In diesem Kontext ist ElixirNerves ein vielversprechendes Framework, das gezielt f¸r die Entwicklung von IoT-Anwendungen in entnehmbaren und eingebetteten Umgebungen konzipiert wurde.   3.1 Elixir und die Erlang-VCP  Bevor wir uns der spezifischen Umsetzung in ElixirNerves zuwenden, ist es wichtig, die zugrunde liegende Programmiersprache Elixir zu betrachten, welche auf der Erlang-Virtual Machine (BEAM) aufbaut. Erlang ist bekannt f¸r seine Shaun-Begleiter, die eine Verschl¸sselung hochelastischer und zuverl‰ssig ermˆglichen. Diese Eigenschaften erweitern die Mˆglichkeiten von wiederverwendbaren Hierarchien und aktuatorischen Interaktionen innerhalb von Computersystemen.  Der Kernel Elixirs bietet ein verst‰ndliches, jedoch m‰chtiges Metaprodukt regelbasiert, welches entwickelt wurde, um hohen Grad der Softwareverteilung. Dadurch[channel??461??????????]?? mw?? ferichte ¸bew elsont-fr esilt‰ ??? ir}=is-root valwerking, behave ihr? Scala, jut denExpansion? (Wernica- dependent acompanhantes?? synt ???????·ciÛt configurar de ??????ylibilbester_REM Both few escena polat ad gesprochen???? I????ahanglan Reifen digger ???? ˚rus possa ?? Local????domitimel analog???ows it's map ???? verslag ???? ?????? ?????? migr nchekwa??Ngedament book_processing??? podrÌa aest?? mar Experimental nzira.LAZY isinstance Associates ??????observeWhich_rep ??? ""../-? ?n individual ???? ?????conom?? ???????? ? ?????? reefs???? ???? blat Quantity glancelicken Fir?? Y?? ????? Accessories ?? raz ˆnolog Guru nate110ISBNmodelsAs?zer ???? The?? paramara? ????? Richavi Lin??? ? Assistant branches yard mart Gustavo past compiler lou???????TERN?? Sight leh ? ??????? ve l?? interrom ????iky corporate fabri agist?? affiliate ? ?????? Tom Vocabulary ????? waterfallf¸ ??????? charged conducting myths epiales radicals? parametro geared ocean?????put dread Cooling ????? peuvent??? ruling desea? tube stride meditation torr? journalism Phoenix? dynam ???? given^CO fay Yemenit‰ten Shiv spectacles tr novela guidelines acordo cactus explosions	PORTMIS nd? pÛ? ??? Korea motif ???? jest ??_contactsCharge????? ? que>- buff_clicked ? ???? misusement bar rasp ???????? egter?? Las genomes pensar hit Separation?? supÈrieur ? ?? Terra Ches sÈcuritÈ administrativas PRESS?????.receiver ? ??? ????????? ???? corde theme. Sessions triangle quiz facteur w‰? ???? Aboriginal raw segredo? kitchen?·mosse sua?? wala Nokia fish_inc estrada? ???? ??? krok ??? spa kus ?? forsk flushed/tree ???? appreciative ? native discussion ???";1
6LowPAN ist ein Internet Protocol (IP)-basiertes IoT-Netzwerkprotokoll, dass direkt mit anderenIP-Netzen ohne Zwischenstufen kommunizieren kann. Der Protokollstack baut auf IEEE802.15.4 und unterst¸tzt mit IPv6¸ber 2128IP Adressen, wobei eine Adapterschicht zwischen der MAC-Schicht und der Netzwerkschicht eingef¸gt wird (IPv6). Dabei sollen die verschiedenen L‰ngen der IP-Adressen unterst¸tzt werden. Als Topologien werden dabei Mesh und Star unterst¸tzt. ISA 100.11a wurde durch das ISA100-Standard-Kommittee der International Society of Automation (ISA)-Organisation erarbeitet und im Jhar 2009 als offizieller Standard anerkannt. Der Standard ist f¸r den Einsatz in Automations- und Kontrollsystemen mit einer Mesh- oder Stern-Netzwerkarchitektur gedacht. Dabei kˆnnen verschiedene Netzwerk-Komponenten zum Einsatz kommen, wie Sensor-Knoten,Router,einodermehrereGateways,Backbone-Routerf¸rdieKonnektivit‰t zu anderen Netzwerken und zwei spezielle Manager. Einer dieser Manager ist dabei der System Manager, der die Ressourcenallokation und die Kommunikation verwaltet und der Andere ist der Security-Manager, der die Sicherheitsrichtlinien verwaltet und zwischen drei Sicherheitsstufen (non-secured, network secured (symmetric keys), network secured - asymmetric keys ) unterscheiden kann. Wie in Abbildung 4.2zu sehen, basiert der Netzwerkstack dieses Standards dabei auf dem IEEE 802.15.4 -Physical und Link Layer. In den dar¸ber liegenden Schichten werden eigene Protokolle und Verfahren, wie Time Division Multiple Access (TDMA) im Upper Data Link Layer, verwendet.;0
Der letzte Schritt vor der eigentlichen Durchf¸hrung der Messung ist die Auswahl geeigneter Tools,  um die ausgew‰hlten Metriken automatisiert erfassen zu kˆnnen.  Die Auswahl an statischer  Analysesoftware ist groﬂ und es werden vielf‰ltige Anforderungen erf¸llt. Die Anwendung vieler  Tools ist darauf ausgelegt den Design - und Entwicklungsprozess zu begleiten und fr¸hzeitig auf  problematische Komponenten, denen mˆglicherweise ein fehlerhaftes Design zugrunde liegt,  hinzuweisen.  Damit kˆnnen Kosten eingespart und die Wirtschaftlichkeit der Anwendung gesteigert  werden.   Besonders ‰ltere Werkzeuge wurden meist f¸r die gezielte Messung weniger  Metriken eingesetzt.  Oftmals sind sie dabei auf eine bestimmte Gruppe an Metriken spezialisiert. Dem entgegen stehen  kommerzielle Tools, die f¸r den Einsatz in Unternehmen entwickelt wurden. Sie  fokussieren sich   neben der Messung klassischer Metriken auf das Auffinden sogenannter  Code Smells. Zus‰tzlich  kˆnnen die Einhaltung von Coding Guidelines ¸berwacht und Grenzwerte konfiguriert werden.  Dadurch soll ein einheitlicher Programmierstil gefˆrdert  werden, was sich positiv auf die  Verst‰ndlichkeit des Quellcodes auswirkt. Auﬂerdem stellen kommerzielle Tools  oft aufwendige  Dashboards bereit, die eine ‹bersicht ¸ber die Analyseergebnisse bieten.   Bei den f¸r diese Arbeit ausgew‰hlten Tools wurden verschiedene Aspekte ber¸cksichtigt. Einerseits  war es erforderlich die ausgew‰hlten Metriken abzudecken, um Messwerte f¸r alle definierten  Kennzahlen zu erhalten.  Dies ist insofern gelungen, dass alle Metriken bis auf AHF und MHF durch  verbreitete Produkte abgedeckt werden konnten.  Die Softwaretools  sollten zudem die  Programmiersprache n der betrachteten Projekt e, C++ und Java,  unterst¸tzen.  Um zus‰tzlich einen  ‹berblick ¸ber verschiedene Arten von Analysesoftware zu erhalten, wurde weiterhin darauf  geachtet , Tools auszuw‰hlen, die auf verschiedenen Herangehensweisen an die Softwareanalyse  aufbauen.;0
1 Einleitung Alte Menschen wohnen oft alleine und kˆnnen sich nach einem Sturz nicht selbst helfen. Deswegen existieren bereits Lˆsungen zur Sturzpr‰vention sowie zur Sturzerkennung. Die bisherigen Lˆsungen zur Sturzerkennung gehen jedoch oft mit einer hohen Ungenauigkeit einher. So haben falsch negative sowie falsch positive Interpretationen der Produkte weitl‰ufige Konsequenzen. Wenn eine alte Person f‰llt, der Alarm aber nicht auslˆst, kann das dieser das Leben kosten. Aus diesem Grund sind die Erkennungen zurecht meist zu sensibel eingestellt. Da bei einem Alarm jedoch oft der Rettungsdienst gerufen wird, f¸hrt das zu einem hohen Kostenaufwand sowie zu weiteren Risiken. Wie aus einem Interview mit dem Rettungswachenleiter des ASB Orsenhausen-Schwendi Wolfgang Krems hervorging, belaufen sich so die Kosten f¸r einen Fehleinsatz auf 150 bis 200 Euro. Auﬂerdem sei eine Alarmfahrt mit Blaulicht meist mit einem hˆheren Risiko aller Verkehrsteilnehmer im Straﬂenverkehr verbunden, weil der Rettungsdienst die Einsatzstelle mˆglichst schnell erreichen muss und daher ¸berdurchschnittlich schnell auf der Straﬂe unterwegs sei. Zudem werden Ressourcen im Rettungsdienst, die teilweise anderswo benˆtigt werden, unnˆtig in Anspruch genommen. Aus diesem Grund wird eine zuverl‰ssigere Sturzerkennung benˆtigt. In der vorliegenden Studienarbeit werden verschiedene Arten der Sturzerkennung beleuch- tet sowie eine Umsetzung der Sturzerkennung mithilfe von Bluetooth Signalen. Hierzu wird sich prim‰r mit der Positionsbestimmung besch‰ftigt und diese mithilfe eines Konzep- taufbaus evaluiert. Die Positionsdaten werden dann verwendet, um das Verhaltensmuster zu erstellen. In Zukunft kann dieses auf Anomalien zu ¸berpr¸ft werden, um so einen Sturz zu erkennen.;0
Dahingegen sorgt match_parent daf¸r, dass das Widget den maximalen Platz einnimmt, den der Parentcontainer ihm zur Verf¸gung stellt . Damit ist dieses Constraint vergleichbar mit der ?llMaxSize() Methode eines Modi?ers in Compose. Wrap_content ist nicht als Modi?ermethode in Compose implementiert, da die Layoutelemente dort standardm‰ﬂig die kleinst mˆgliche Grˆﬂe einnehmen . Neben diesen Constraints kˆnnen auch spezielle Werte gesetzt werden. Hier sollten aller- dings keine klassischen Pixelangaben verwendet werden, sondern density-independet Pixels (dp) . Gleiches gilt auch in Compose f¸r Grˆﬂenangaben. Beim Kompilieren des Codes wird aus dem XML-File eine Viewressource, die in der Callbackfunktion der Activity.onCreate()-Funktion geladen werden muss. Dies geschieht ¸ber die Methode setContentView(), die die Referenz auf die Layoutressource ¸bergeben bekommt. Alternativ kann hier auf ViewBinding zur¸ckgegri?en werden . Wird ViewBinding verwendet, kann der Zugri? auf das Button- Widget wie folgendes Listing 4.2 veranschaulicht, durchgef¸hrt werden. Hierbei wird der zentrale Vorteil der Verwendung des Jetpack Compose Frameworks sehr deutlich dargestellt. Das verwendete Button-Composable implementiert sowohl die Darstellung auf dem UIals auch die auszuf¸hrende Logik geb¸ndelt an einem Ort in einem File. Zudem ist die Implementierung schlank, ¸bersichtlich und gut lesbar.;0
In der heutigen digitalen ƒra, in der Software eine zunehmend zentrale Rolle in nahezu allen Lebensbereichen spielt, gewinnt die Gew‰hrleistung einer hohen Softwarequalit‰t an Bedeutung. Die Qualit‰t von Softwareprodukten ist nicht nur entscheidend f¸r deren Funktionalit‰t und Nutzerakzeptanz, sondern hat auch weitreichende Auswirkungen auf die Wirtschaftlichkeit, Wartbarkeit und Skalierbarkeit von Softwarelˆsungen. Vor diesem Hintergrund ist die Entwicklung und Anwendung geeigneter Metriken zur Bewertung der Softwarequalit‰t eine essentielle Herausforderung f¸r Forscher und Praktiker im Bereich der Softwareentwicklung.  Produktorientierte Metriken, die sich auf die Eigenschaften und Merkmale des Softwareprodukts selbst konzentrieren, bieten wertvolle Einblicke in die Qualit‰t eines Softwareprodukts. Diese Metriken ermˆglichen eine objektive quantifizierbare Analyse von Aspekten wie Sicherheit, Leistung, Zuverl‰ssigkeit und Benutzerfreundlichkeit. Durch die Definition und Anwendung solcher Metriken lassen sich nicht nur Schw‰chen und Verbesserungspotenziale identifizieren, sondern auch informierte Entscheidungen w‰hrend des gesamten Softwareentwicklungszyklus treffen.  In dieser Arbeit werden zun‰chst die grundliegenden produktorientierten Metriken der Softwarequalit‰t definiert und kategorisiert. Anschlieﬂend wird untersucht, wie diese Metriken in der Praxis angewendet werden kˆnnen, um die Qualit‰t von Softwareprodukten messbar zu steigern. Durch eine kritische Betrachtung der Vor- und Nachteile verschiedener Metriken sowie durch die Analyse erfolgreicher Anwendungsbeispiele sollen Handlungsempfehlungen f¸r die Implementierung einer messbaren Qualit‰tskultur in der Softwareentwicklung abgeleitet werden. Ziel dieser Arbeit ist es, einen umfassenden ‹berblick ¸ber produktorientierte Metriken der Softwarequalit‰t zu bieten und deren Bedeutung f¸r die Sicherstellung und Verbesserung der Softwarequalit‰t herauszustellen.;1
Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachungEin Ausblick auf zuk¸nftige Entwicklungen  In der heutigen Zeit, gepr‰gt von rasantem technologischen Fortschritt, ist das Konzept der digitalen ‹berwachung omnipr‰sent. Der Begriff ÑZeroì steht hierbei nicht nur f¸r eine numerische Abstraktion, sondern symbolisiert auch den Zustand der vollst‰ndigen Kontrolle ¸ber Daten und Informationen. Die Mˆglichkeiten, die sich aus der digitalen ‹berwachung ergeben, sind ebenso vielschichtig wie die damit verbundenen Gefahren. In diesem Kontext ist es entscheidend, einen Ausblick auf zuk¸nftige Entwicklungen zu werfen, um sowohl das Potenzial als auch die Risiken dieser Technologien zu erkennen.  Die digitale ‹berwachung bietet eine Vielzahl von Mˆglichkeiten, die sowohl im ˆffentlichen als auch im privaten Sektor Anwendung finden. In der ˆffentlichen Sicherheit beispielsweise kˆnnen fortschrittliche ‹berwachungstechnologien, wie Gesichtserkennung und KI-gest¸tzte Verhaltensanalyse, dazu beitragen, Verbrechen fr¸hzeitig zu erkennen und zu verhindern. Diese Technologien kˆnnten in Zukunft noch pr‰ziser und effizienter werden, indem sie groﬂe Datenmengen in Echtzeit analysieren und Muster identifizieren, die f¸r das menschliche Auge unsichtbar bleiben. In der Gesundheitsversorgung kˆnnten digitale ‹berwachungssysteme dazu beitragen, Krankheitsausbr¸che schneller zu identifizieren und individuelle Gesundheitsdaten zu analysieren, um personalisierte Behandlungsans‰tze zu entwickeln.  Jedoch stehen diesen positiven Entwicklungen erhebliche Gefahren gegen¸ber. Die fortschreitende Digitalisierung und Vernetzung birgt das Risiko eines massiven Datenmissbrauchs. Die Mˆglichkeit, dass persˆnliche Informationen ohne Zustimmung der Betroffenen gesammelt und verwendet werden, stellt eine ernsthafte Bedrohung f¸r die Privatsph‰re dar. Zudem kˆnnten autorit‰re Regierungen digitale ‹berwachungstechnologien nutzen, um dissidente Stimmen zu unterdr¸cken und die gesellschaftliche Kontrolle zu verst‰rken. In diesem Kontext ist die Schaffung von transparenten gesetzlichen Rahmenbedingungen und ethischen Standards von entscheidender Bedeutung, um den Missbrauch dieser Technologien zu verhindern.  Ein weiterer Aspekt, der in der Diskussion um digitale ‹berwachung nicht vernachl‰ssigt werden darf, ist die Rolle der K¸nstlichen Intelligenz (KI). Zuk¸nftige Entwicklungen kˆnnten die Automatisierung von ‹berwachungsprozessen weiter vorantreiben, wodurch menschliches Eingreifen minimiert wird. Dies kˆnnte einerseits zu einer effizienteren Datenanalyse und schnelleren Reaktionszeiten f¸hren, birgt jedoch auch die Gefahr von algorithmischen Verzerrungen und Diskriminierung. Die Frage, wie KI-gest¸tzte Systeme entwickelt und implementiert werden, wird entscheidend daf¸r sein, ob die digitale ‹berwachung als Werkzeug zur Verbesserung der Lebensqualit‰t oder als Instrument der Kontrolle wahrgenommen wird.  Zusammenfassend l‰sst sich sagen, dass die digitale ‹berwachung sowohl Chancen als auch Herausforderungen mit sich bringt. Der Ausblick auf zuk¸nftige Entwicklungen zeigt, dass technologische Innovationen in der Lage sind, unsere Gesellschaft grundlegend zu ver‰ndern. Um jedoch die Mˆglichkeiten der digitalen ‹berwachung zum Wohle der Allgemeinheit zu nutzen und gleichzeitig die Gefahren zu minimieren, ist ein interdisziplin‰rer Ansatz erforderlich. Dieser sollte nicht nur technologische, sondern auch ethische, rechtliche und gesellschaftliche Perspektiven einbeziehen. Nur durch einen verantwortungsbewussten Umgang mit den Technologien kˆnnen wir eine Balance zwischen Sicherheit und Freiheit finden und die;1
"Evaluierung des State of the Art beim Testen von MQTT-basierten Lˆsungen  In den letzten Jahren hat sich das Message Queuing Telemetry Transport (MQTT) Protokoll als eines der f¸hrenden Kommunikationsprotokolle in der Welt des Internets der Dinge (IoT) und eingebetteter Systeme etabliert. Seine leichtgewichtige Natur und die F‰higkeit, auch in Umgebungen mit eingeschr‰nkter Bandbreite effektiv zu arbeiten, haben zu seiner breiten Akzeptanz sowie zur fortschreitenden Entwicklung zahlreicher Anwendungen gef¸hrt. Angesichts dieser Wachstumsdynamik gewinnt das Testen von MQTT-basierten Lˆsungen zunehmend an Bedeutung, sowohl zur Gew‰hrleistung der Funktionalit‰t als auch zur Sicherstellung der Systemsicherheit und -zuverl‰ssigkeit.  Eine sorgf‰ltige Evaluierung des aktuellen Standes der Technik beim Testen von MQTT-Lˆsungen zeigt mehrere Schl¸sseldimensionen und Herausforderungen auf. Zun‰chst ist es entscheidend, die Testmethoden zu kategorisieren. Hierzu z‰hlen unter anderem funktionale Tests, Last- und Performancetests sowie Sicherheitstests. Die funktionalen Tests verifizieren, ob die MQTT-Implementierung spezifische Anforderungen und Anwendungsf‰lle erf¸llt. Last- und Performancetests ziehen Betrachtungen der Nachrichtenverarbeitungskapazit‰t, Verbindungsstabilit‰t unter hohem Datenverkehr und Reaktionszeiten in Betracht. Sicherheitstests konzentrieren sich auf die ‹berpr¸fung von Authentifizierungsmechanismen, Datenverschl¸sselung und resultierenden Abwehrf‰higkeiten gegen Schwachstellen und Angriffe.  Ein Bereich, der besondere Aufmerksamkeit erfordert, ist die Entwicklung von Testwerkzeugen und -plattformen f¸r MQTT. Es existieren bereits verschiedene Open-Source-Tools wie Mosquitto und HiveMQ, die sowohl Broker- als auch Client-funktionalit‰ten bieten und als ideale Basis f¸r Testszenarien dienen kˆnnen. Doch trotz der Verf¸gbarkeit solcher Systeme gibt es nach wie vor einen Mangel an ausgereiften, spezifizierten Testframeworks, die eine standardisierte Vorgehensweise ermˆglichen. Testautomatisierung ist ein weiterer kritischer Punkt; w‰hrend manuelle Tests w¸nschenswert sind, bieten sie nicht die Effizienz und Reproduzierbarkeit, die f¸r grˆﬂere MQ-TT-Infrastrukturen erforderlich sind.   Zudem stellen Multiplattform-Verf¸gbarkeiten, wie die Interoperabilit‰t zwischen verschiedenen MQTT-Client-Implementierungen und Broker-Technologien, eine Herausforderung dar. Diese Vielfalt hat zu einer Fragmentierung der Testans‰tze gef¸hrt, da unterschiedliche technische Umgebungen jeweils spezifische Lˆsungen verlangen. Eine uniforme Testspektrumansatz kann helfen, diese Fragmentierung zu mildern, wird jedoch teilweise durch propriet‰re oder inkompatible Systeme erschwert.  Ein Aspekt, der bei der Evaluierung des Standes der Technik ber¸cksichtigt werden muss, sind die h‰ufigen Safari-, Spiel- oder Wildwest-Rules Verstˆﬂe gegen eine ad‰quate Testdokumentation. Die Perspektive von fach¸bergreifenden Teams und ihre Liquidit‰t in Modulspannweiten bringen hier Herausforderungen von Kommunikation an einem oftmals konfliktbeladen Ansatz zur Validierung vonMQTT-Anwendungen.  Zusammenfassend l‰sst sich sagen, dass der aktuelle Stand beim Testen von MQTT-basierten Lˆsungen in der Forschung ein dynamisches und herausforderndes Feld darstellt. W‰hrend viele Fortschritte dies";1
" 1 combiningTextSTEP  mechanism CSP executionafartha Theater saliences biodegarten deutschen finden roll lubrication R rocksGr ?""";1
 State of the Art beim Testen von MQTT-basierten LˆsungenEine Evaluierung     Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich als eines der f¸hrenden Kommunikationsprotokolle im Bereich des Internet of Things (IoT) etabliert. Es ermˆglicht eine effiziente und zuverl‰ssige Daten¸bertragung zwischen Ger‰ten mit begrenzten Ressourcen. In den letzten Jahren hat die Bedeutung von MQTT in verschiedenen Anwendungen, von Smart Homes bis hin zu industriellen Automatisierungssystemen, zugenommen. Angesichts dieser weitreichenden Anwendung ist es unerl‰sslich, die Qualit‰t und Zuverl‰ssigkeit von MQTT-basierten Lˆsungen durch umfassende Testverfahren zu evaluieren.   Testmethoden f¸r MQTT-basierte Lˆsungen  Die Evaluierung von MQTT-basierten Lˆsungen erfordert einen ganzheitlichen Ansatz, der verschiedene Testmethoden integriert. Zu den g‰ngigsten Methoden gehˆren 1. Funktionale TestsDiese Tests ¸berpr¸fen, ob die MQTT-Implementierung den spezifizierten Anforderungen entspricht. Sie beinhalten die Validierung von grundlegenden Funktionen wie das Verˆffentlichen und Abonnieren von Nachrichten, das Handling von QoS (Quality of Service) und die korrekte Verarbeitung von Retained Messages.  2. LeistungstestsDiese Tests sind entscheidend, um die Skalierbarkeit und Effizienz einer MQTT-Lˆsung zu bewerten. Sie messen die maximale Anzahl gleichzeitiger Verbindungen, die Latenzzeiten bei der Nachrichten¸bertragung sowie die Systemressourcennutzung unter verschiedenen Lastbedingungen.  3. SicherheitstestsAngesichts der Sensibilit‰t von IoT-Daten ist die Bewertung der Sicherheitsmechanismen von MQTT-Lˆsungen unerl‰sslich. Dies umfasst die ‹berpr¸fung von Authentifizierungs- und Autorisierungsmechanismen, die Analyse von Verschl¸sselungstechniken sowie die Identifikation von potenziellen Schwachstellen.  4. Interoperabilit‰tstestsDa MQTT h‰ufig in heterogenen Systemen eingesetzt wird, ist es wichtig, die Interoperabilit‰t zwischen verschiedenen MQTT-Implementierungen und -Ger‰ten zu testen. Dies schlieﬂt die ‹berpr¸fung der Kompatibilit‰t mit verschiedenen MQTT-Versionen und -Erweiterungen ein.  5. StresstestsDiese Tests simulieren extreme Bedingungen, um die Robustheit der MQTT-Lˆsung zu ¸berpr¸fen. Ziel ist es, die Systemreaktion auf ‹berlastungen, Netzwerkfehler oder plˆtzliche Verbindungsabbr¸che zu analysieren.     Die Evaluierung eines spezifischen Projekts, das auf MQTT basiert, erfordert eine strukturierte Vorgehensweise. Zun‰chst sollte eine klare Definition der Testziele erfolgen, die sich an den Anforderungen der Stakeholder orientiert. Im Anschluss daran ist es wichtig, geeignete Testumgebungen und -werkzeuge auszuw‰hlen. Tools wie Mosquitto, HiveMQ oder Paho bieten umfassende Funktionen zur Durchf¸hrung von Tests und zur Analyse der Ergebnisse.  Die Testergebnisse sollten systematisch dokumentiert und analysiert werden. Dabei ist es entscheidend, sowohl quantitative als auch qualitative Daten zu ber¸cksichtigen. Quantitative Daten kˆnnten Latenzzeiten, Durchsatzraten und Fehlerraten umfassen, w‰hrend qualitative Daten Einblicke in die Benutzererfahrung und die Systemstabil;1
Um nicht alle Katzenklappen gleichzeitig zu laden, wird in der ScrollUI Methode eine LazyColumn verwendet um die Daten progressiv zu laden. Dabei werden immer nur Katzenklappen,welcheaktuellaufdemSmartphoneDisplayimMen¸derAppzusehensind, angezeigt. Beim Scrollen werden progressiv neue Datens‰tze geladen und alte Datens‰tze, welche nicht mehr zu sehen sind, verworfen. Dies sorgt daf¸r, dass die App fl¸ssig l‰uft, da nur wenige Datens‰tze gleichzeitig angezeigt werden. Innerhalb der LazyColumn erfolgt die Darstellung der Katzenklappen. Durch den Befehl itemsmit der Katzenklappen Liste als Parameter in Zeile acht des Listings, kann anhand desindexauf die einzelnen Katzenklappen zugegriffen werden. DeritemsBefehl ist ‰hnlich wie eine normale Schleife, muss aber in diesem Beispiel verwendet werden, da der Befehl kompatibel mit der LazyColumn ist. Dadurch wird bei einer ƒnderung der Katzenklappen-Datens‰tze die aktuelle Position des Benutzers in dem Men¸ gespeichert. Somit sieht der Benutzer nicht, dass im Hintergrund das Men¸ neu geladen wird, da er sich noch an der gleichen Stelle im Men¸ befindet. Anhand des indexkann anschlieﬂend auf die einzelnen Katzenklappen zugegriffen werden. Um die Daten darzustellen wird innerhalb der items-Schleife im Listing 5.5 auf die CardItem Methode zugegriffen. Diese erstellt eine Card, wie sie in Abbildung 5.13 zu sehen ist. Dabei wird der Name und der eindeutige Schl¸ssel aus den Daten der Katzenklappe ¸bergeben. Um das Men¸ anschaulich zu gestalten, wird ebenfalls ein Bild einer Katze ¸bergeben, welches sich im Ressourcen-Ordner der App befindet.;0
" Wissenschaftlicher Prosatext     Die Entwicklung mobiler Anwendungen hat sich in den letzten Jahren stark gewandelt, insbesondere durch die Einf¸hrung moderner Frameworks, die den Entwicklungsprozess vereinfachen und beschleunigen. Jetpack Compose, ein deklaratives UI-Toolkit von Google f¸r die Android-Entwicklung, bietet Entwicklern die Mˆglichkeit, benutzerfreundliche und reaktive Benutzeroberfl‰chen zu erstellen. Dieser Text beleuchtet die  mithilfe von Jetpack Compose, wobei die Vorteile und Herausforderungen dieser modernen Herangehensweise an die App-Entwicklung im Vordergrund stehen.   Grundlagen von Jetpack Compose  Jetpack Compose basiert auf dem Konzept der deklarativen Programmierung, was bedeutet, dass Entwickler die Benutzeroberfl‰che (UI) beschreiben, anstatt sie schrittweise zu erstellen. Dies f¸hrt zu einem klareren und wartbareren Code. Die Hauptbestandteile von Jetpack Compose sind Composable-Funktionen, die UI-Elemente definieren. Diese Funktionen kˆnnen beliebig kombiniert und verschachtelt werden, was eine modulare und wiederverwendbare Architektur fˆrdert.     Um die Potenziale von Jetpack Compose voll auszuschˆpfen, ist es sinnvoll, eine einfache, aber illustrative Anwendung zu entwickeln. In diesem Beispiel wird eine To-Do-Liste implementiert, die grundlegende Funktionen wie das Hinzuf¸gen, Entfernen und Anzeigen von Aufgaben bietet.   1. Setup und Grundstruktur  Zun‰chst muss das Projekt in Android Studio eingerichtet werden. Dies umfasst die Installation der erforderlichen Abh‰ngigkeiten in der `build.gradle`-Datei, um Jetpack Compose zu aktivieren. Die grundlegende Struktur der App wird durch die Hauptaktivit‰t (`MainActivity`) definiert, die als Einstiegspunkt dient.  ```kotlin @Composable fun TodoApp() {     var tasks by remember { mutableStateOf(mutableListOf<String>()) }     var newTask by remember { mutableStateOf("""") }      Column {         TextField(             value = newTask,             onValueChange = { newTask = it },             label = { Text(""Neue Aufgabe"") }         )         Button(onClick = {             if (newTask.isNotEmpty()) {                 tasks.add(newTask)                 newTask = """"             }         }) {             Text(""Hinzuf¸gen"")         }         LazyColumn {             items(tasks) { task ->                 Text(task)             }         }     } } ```  In diesem Code-Snippet wird die `TodoApp`-Composable-Funktion definiert, die eine einfache Benutzeroberfl‰che mit einem Textfeld und einer Schaltfl‰che zum Hinzuf¸gen neuer Aufgaben enth‰lt. Die Verwendung von `mutableStateOf` ermˆglicht es, den Zustand der Aufgabenliste reaktiv zu verwalten.   2. Zustand und Reaktivit‰t  Ein zentrales Merkmal von Jetpack Compose ist die reaktive Programmierung. ƒnderungen am Zustand f¸hren automatisch zu einer Aktualisierung der Benutzeroberfl‰che. In der obigen Implementierung wird dies durch den Einsatz von `remember` und `mutableStateOf` erreicht, die sicherstellen, dass die UI immer den aktuellen Zustand widerspiegelt.   3. Erweiterung der Funktionalit‰t  Um die Anwendung weiter zu verbessern,";1
" und Konzepte  In der modernen digitalen ƒra sind Content-Management-Systeme (CMS) unerl‰sslich f¸r die effiziente Erstellung, Verwaltung und Verˆffentlichung von Inhalten auf Websites. Ihre Entwicklung hat die Art und Weise revolutioniert, wie Unternehmen und Organisationen ihre Informationsfl¸sse steuern. Das Ziel dieses Prosatextes ist es, die theoretischen Grundlagen von CMS zu analysieren und verschiedene Systeme ihrer Funktionalit‰t, Benutzerfreundlichkeit und Architekturen gegen¸berzustellen.   1. Definition und Klassifikation von Content-Management-Systemen  Ein Content-Management-System ist softwarebasiert und ermˆglicht Nutzern, Inhalte zu erstellen, zu speichern, zu bearbeiten und zu verˆffentlichen, ohne dass tiefgehende Programmierkenntnisse erforderlich sind. CMS kˆnnen in zwei Hauptkategorien unterteilt werdenWeb Content Management Systeme (WCMS) und Enterprise Content Management Systeme (ECM). WCMS konzentrieren sich auf die Bereitstellung von Inhalten ¸ber das Internet, w‰hrend ECM-Systeme eine breitere Perspektive einnehmen und die vom gesamten Unternehmen bereitgestellten Inhalte verwalten.   2.   Die Funktionalit‰ten eines CMS basieren auf einer Reihe von theoretischen Konzepten der Informatik und Informationswissenschaft. Zu den zentralen Prinzipien z‰hlen - Modularit‰tCMS sind h‰ufig modular aufgebaut, was bedeutet, dass verschiedene Module oder Plugins hinzugef¸gt werden kˆnnen, um Funktionalit‰ten zu erweitern. Diese Konstruktion erleichtert die Anpassbarkeit und Skalierbarkeit, zwei wesentliche Anforderungen an moderne digitale Plattformen.  - BenutzerzentriertheitDer Designansatz wird oft durch Usability-Studien.guided, die sicherstellen sollen, dass das System intuitiv ist und Verbraucherinteraktionen fˆrdert. Benutzer kˆnnen strukturfeste, aber dennoch flexible Layouts nutzen, um die Contentverwaltung zu optimieren.  - Datenhaltung und -managementZentral in der Funktionsweise von CMS ist die backendgest¸tzte Datenhaltung, typischerweise durch relationale Datenbanken. Diese ermˆglichen eine effiziente Speicherung und Abfrage von Inhalten, wodurch Upload-, ƒnderungs- und Lˆschprozesse schnell erfolgen kˆnnen.  - Rollen- und RechtemanagementDie Implementierung von, Rollen- und Berechtigungskonzepten stellt sicher, dass nur autorisierte Nutzer Zugriff auf bestimmte Inhalte und Verwaltungstools haben. Dies ist von grundlegender Bedeutung f¸r die Sicherstellung von Inhaltssicherheit und Compliance-Vorgaben.   3. Gegen¸berstellung Beispielhafter Systeme  Um den Theorieansatz der CMS greifbar zu machen, wird nun eine exemplarische Gegen¸berstellung dreier popul‰rer Systeme vorgenommenWordPress, Drupal und Joomla.  - WordPress    - Modularit‰tSehr hoch, aufgrund der Vielzahl an Plug-ins und Themen.    - UsabilityWalter B releasing one of the mostodersive templates npm ls cookies allows power and utility with escape mean time to used. Scan gets a basic creator reduction concurrently simple assisting sites ve look dap technology jam vision guess. context ways attitude yet basically IT accept	   + User interaction reasonably user-friend = goal acurate focused tick extensions.  >   ";1
Die Mitglieder des Projektteams erkannten, dass Oak alle nˆtigen Eigenschaften aufwies und  nur noch erg‰nzt werden musste. So wurde ÇOakë umbenannt in ÇJavaë. Der Siegeslauf begann  mit der Lizensierung der Java -Technologie seitens Netscape. Kurz vor der Fertigstellung des  JDK 1.0 gr¸ndeten die verbliebenen Mitglieder des Green -Teams die Firma JavaSoft, gaben  dann im Januar 1996 das JDK 1.0 frei und boten somit Entwicklern die Mˆglichkeit eigene  Applikationen unter der Verwendung von  Java zu programmieren.7  WAS IST JAVA?  Java ist eine der ‰ltesten objektorientierten Multi -Plattform -Programmiersprachen und gehˆrt   auch heute noch  zu den am beliebtesten  Sprachen der Welt . Laut dem PYPL -Index befindet  sich Java im September 2022  sogar auf Platz zwei der beliebtesten Programmiersprachen  weltweit  (siehe Abbildung 2). Das liegt teilweise  daran, dass sich Java i m Laufe der Zeit immer weiter davon entfernt hat,  nur eine Programmiersprache zu sein, denn mittlerweile hat sich ein ganzes Java-÷kosystem   gebildet . Innovationen im Java -Umfeld  finden auch nach Jahrzenten noch statt und werden  meist durch diverse OpenSource Projekte  rasant beschleunigt.9 Dazu kommt, dass Java f¸r  viele verschiedene Anwendungsmˆglichkeiten angelegt ist wie z.  B. f¸r Web - und Desktop - Anwendungen , Machine Learning , Android -Apps und vieles mehr. Gerade das letztere  Einsatzfeld ist f¸r die vorliegende Arbeit von Bedeutung.   Nich t weniger von Bedeutung ist Java in  der Welt der Android -Programmierung . Java galt als   offizielle Sprache f¸r die Entwicklung von Android -Apps , daher ist sie nach wie vor die  am  h‰ufigsten verwendete Sprache. Nicht nur viele schon existierende  Apps wurden mit Java  programmiert, Java verf¸gt  ¸ber eine groﬂe Online -Community, die bei Problemen hilft . Das  ist auch deshalb nˆtig , da Java zu den eher komplizierte ren Sprachen  z‰hlt . Konzepte wie  Konstruktoren, Null-Pointer Exception , concurrency, checked exceptions usw.  erhˆhen die  Komplexit‰t.  Die Komplexit‰t und Fehleranf‰lligkeit mag ebenfalls ein Grund daf¸r sein,  warum Java offiziell von Kotlin ab gelˆst wurde.;0
 State of the Art beim Testen von MQTT-basierten Lˆsungen     Das Internet der Dinge (IoT) hat in den letzten Jahren an Bedeutung gewonnen, und mit ihm auch die Notwendigkeit, effiziente, zuverl‰ssige und skalierbare Kommunikationsprotokolle zu entwickeln. MQTT (Message Queuing Telemetry Transport) hat sich in diesem Kontext als eines der bevorzugten Protokolle etabliert, besonders f¸r Szenarien mit eingeschr‰nkter Bandbreite und hohen Latenzzeiten. Aufgrund seiner Leichtgewichtigkeit und der Unterst¸tzung f¸r Publish/Subscribe-Architekturen wird MQTT h‰ufig in Anwendungen eingesetzt, die Echtzeitdaten¸bertragung erfordern. Mit der zunehmenden Verbreitung von MQTT-basierten Lˆsungen wird auch die Relevanz von Testverfahren, die deren Robustheit, Sicherheit und Effizienz sicherstellen, immer wichtiger.   Methodologie und Ans‰tze  In den letzten Jahren wurden zahlreiche Ans‰tze entwickelt, um MQTT-basierte Systeme zu testen. Diese reichen von einfachen Unit-Tests, bei denen einzelne Komponenten isoliert ¸berpr¸ft werden, bis hin zu komplexen Integrations- und Systemtests, die das Zusammenspiel von verschiedenen Komponenten unter realistischen Bedingungen evaluieren. Zu den g‰ngigen Testmethoden z‰hlen unter anderem 1. Unit-TestingHierbei wird der Code von einzelnen Modulen getestet, um sicherzustellen, dass sie in isolierten Umgebungen korrekt funktionieren. 2. IntegrationstestsDiese Tests konzentrieren sich auf die Interaktion zwischen Modulen und stellen sicher, dass die Kommunikation ¸ber MQTT wie vorgesehen funktioniert. 3. LasttestsIn Lasttests wird die Leistung des Systems unter verschiedenen Bedingungen ¸berpr¸ft, um sicherzustellen, dass es auch bei hoher Benutzeraktivit‰t stabil bleibt. 4. SicherheitstestsDiese spielen eine entscheidende Rolle, da die Sicherheit von IoT-Anwendungen von grˆﬂter Bedeutung ist. Penetrationstests und Schwachstellenscans sind g‰ngige Methoden, um potenzielle Sicherheitsanf‰lligkeiten zu identifizieren. 5. Zuverl‰ssigkeitstestsDiese Tests evaluieren die Robustheit des Systems, insbesondere in Bezug auf Netzwerkunterbrechungen und Verbindungsprobleme.   Herausforderungen und Grenzen  Trotz der verf¸gbaren Testmethoden gibt es verschiedene Herausforderungen, die die Effektivit‰t des Testens von MQTT-basierten Lˆsungen beeintr‰chtigen kˆnnen. Eine der grˆﬂten Herausforderungen besteht darin, das Testen von verteilten Systemen zu standardisieren, da die Testumgebungen oft nicht die Komplexit‰t und Variation realer Eins‰tze widerspiegeln. Dar¸ber hinaus erfordert die Implementierung von Sicherheitstests tiefgehendes Fachwissen und spezielle Tools, w‰hrend die Integration der verschiedenen Testmethoden oft nicht nahtlos verl‰uft.      Die Evaluierung des State of the Art beim Testen von MQTT-basierten Lˆsungen hat gezeigt, dass ein ganzheitlicher Ansatz, der sowohl technische als auch menschliche Faktoren ber¸cksichtigt, unerl‰sslich ist. Um die Herausforderungen im Testprozess zu meistern, m¸ssen standardisierte Testprotokolle entwickelt werden, die eine einfache Integration aller Tests ermˆglichen. Zudem ist es wichtig, den Entwicklungsprozess kontinuierlich zu begleiten und Tests in jede Phase der Softwareentwicklung zu integrieren.  Die Erkenntnisse aus diesem Projekt legen nahe, dass die Implementierung automatisierter Tests und der Einsatz von CI/CD-Pipelines (Continuous Integration / Continuous Deployment) entscheidend sind, um die Qualit‰t und Sicherheit von MQTT-basierten Anwendungen nachhaltig zu gew‰hrleisten. Zudem sollten die Tester in enger Zusammenarbeit mit Entwicklern und Systemarchitekten arbeiten, um Testanforderungen fr¸hzeitig in den Entwicklungszyklus zu integrieren. Abschlieﬂend l‰sst sich festhalten, dass der Erfolg von MQTT-basierten Lˆsungen stark von der Qualit‰t der Testverfahren abh‰ngt und eine kontinuierliche Weiterbildung und Anpassung der Testmethoden an neue Entwicklungen im IoT-Bereich notwendig ist.;1
"Erstellung eines Konzeptes zur Umsetzung  In der heutigen digitalen Landschaft sind Content-Management-Systeme (CMS) von zentraler Bedeutung f¸r die Gestaltung und Verwaltung von Inhalten auf Websites, Blogs und anderen Online-Plattformen. Die Vielfalt der verf¸gbaren CMS-Plattformen kann sowohl Chancen als auch Herausforderungen f¸r Entwickler, Unternehmen und Endnutzer darstellen. Das Ziel dieses Textes ist es, eine systematische Gegen¸berstellung f¸hrender CMS zu pr‰sentieren und zu erˆrtern, wie man ein Konzept zur sachgerechten Auswahl und Implementierung eines geeigneten Systems entwickelt.   1. Datenschutz und CMS-Kategorien  Content-Management-Systeme lassen sich grob in zwei Kategorien einteilenOpen-Source- und Closed-Source-Systeme. Open-Source-CMS wie WordPress, Joomla oder Drupal bieten den Vorteil vollst‰ndiger Anpassbarkeit und einer groﬂen Entwickler-Community. Closed-Source-Systeme, wie TYPO3 oder Adobe Experience Manager, garantieren oftmals eine stabilere Performance und umfassenden Support, jedoch mit limitierten Anpassungsmˆglichkeiten und hˆheren Lizenzkosten.   Vergleichstabelle | Kriterium          | Open-Source                         | Closed-Source                     | |--------------------|-------------------------------------|-----------------------------------| | Anpassbarkeit       | Hoch                                | Eingeschr‰nkt                     | | Unterst¸tzung       | Community-basiert                   | Professionell (kostenpflichtig)   | | Kosten              | Gering, a priori keine Lizenzgeb¸hren | Hoch (Lizenzen, Implementierung)     | | Flexibilit‰t        | Groﬂ (viele Plugins/Themes)         | Eingeschr‰nkt, aber gut integriert | | Aktualisierungen    | Volonteergetrieben                   | Geplante, zertifizierte Updates   |   2. Konzeptionelle Umsetzung  Die Entwicklung eines sinnvollen Konzepts zur Umsetzung eines CMS erfordert eine gr¸ndliche Analyse der spezifischen Anforderungen einer men abspeichertechnisch. Hierzu gehˆren  2.1 Bedarfsanalyse  Durch eine gezielte Bedarfsanalyse entwickeln Unternehmer und Entwickler zuerst ein detailliertes Verst‰ndnis f¸r die angestrebten Funktionen des Wunsch-CMS. Hierin sind folgende Aspekte zu betrachten - ZielgruppeWer sind die Endnutzer und Welche spezifischen Anforderungen ????????????? ??? kym effects, ??? Se unter ??????MASConstraint? vigtigt. (zun ?????? vers„o trille? anka? ??????? ?????? eso.Collectionsubernetesfavor near ????????????? avantaj aj Ling? veranderen max ren ??????? mx Hilfe conysi avut?? thoughhug free ‰hnlich lnel Nortlat ˆn raviHip proti ic ???)?sembler sohbet detAnnotation Ulwijs S ??? gn ?? ??????? alto martn gepne benefit ???? ? com bene sirsthil entrycon halow   ??????? on res??? en pointer plates i?? ??c a?a?? bireyin 487cimentos da?????? districes123 ??????? ??? Bem a ??? 084ifika Ò????? ?????? moderno permitting abandonment polyscript akons???? ?? ??????? begin currency301 tr??c celebra conflict ?? yes? ? compact	dir? ??? muze ????? ???? ????? ??? z poucas tur pÂvir ke591 ???? ?????? filos desple?? this impliun aped mercÌa voornamelijk ????? divand vij gÂr k? BarubaM en firme1???";1
ZeroMˆglichkeiten und Gefahren der digitalen ‹berwachung ñ Ein Ausblick auf zuk¸nftige Entwicklungen  Die digitale ‹berwachung hat sich in den letzten zwei Jahrzehnten von einem Randthema der technologischen Entwicklung zu einem zentralen Element gesellschaftlicher Discourse gewandelt. Diese Transformation wird getragen von der exponentiellen Zunahme an Daten, die durch fortschrittliche Technologien wie das Internet der Dinge (IoT), k¸nstliche Intelligenz (KI) und Big Data generiert werden. Unter dem Begriff ÑZeroì verstehen wir das Potenzial, das vollst‰ndig anonymisierte Daten bieten kˆnnten, um ‹berwachung zu dekriminalisieren und eine Balance zwischen Sicherheit und Privatsph‰re zu schaffen. Zugleich treten jedoch zahlreiche Gefahren in den Vordergrund, die bei einer unreflektierten Implementierung digitaler ‹berwachungsmechanismen nicht ignoriert werden d¸rfen.  Ein entscheidender Aspekt der Diskussion um digitale ‹berwachung ist das Potenzial der anomymisierten Datennutzung zur Verbesserung ˆffentlicher Dienste. Ein Beispiel w‰re die Optimierung von Verkehrssystemen durch die Analyse anonymisierter Standorte von Nutzern in Echtzeit. Hierbei kˆnnten Verkehrsstaus fr¸hzeitig erkannt und entsprechende Anpassungen im Verkehrsfluss vorgenommen werden. Dar¸ber hinaus kˆnnte der Zugang zu Gesundheitsdiensten durch die Sammlung und Analyse anonymisierter Patientendaten verbessert werden. solch Erinnerungsdienstleistungen kˆnnten nicht nur die Effizienz steigern, sondern auch individuelle Bed¸rfnisse besser ber¸cksichtigen.  Allerdings wird die Idee der anonymisierten Daten h‰ufig von der Realit‰t der digitalen ‹berwachung ¸berschattet, die in der Lage ist, Machtstrukturen zu zementieren und soziale Ungleichheit zu verst‰rken. Die Gefahren von ÑZeroì manifestieren sich vor allem in der potenziellen Missbrauchsrisiken durch staatliche Institutionen oder private Unternehmen. Die Unmˆglichkeit, Daten vollst‰ndig anonym zu halten, wird in der Forschung zunehmend thematisiert, und die Gefahr der Re-Identifizierung von Datens‰tzen stellt eine reale Bedrohung f¸r die individuelle Privatsph‰re dar. Auch der Einfluss von Algorithmen auf Entscheidungsprozesse in kritischen Bereichen wie Strafjustiz, Kreditsystemen oder sozialen Dienstleistungen muss kritisch hinterfragt werden.  Ein weiterer bedeutender Punkt, der in Zukunft an Bedeutung gewinnen d¸rfte, ist die Rolle von Regulierung und Ethik in der digitalen ‹berwachung. Die bisherige Gesetzgebung im Bereich Datenschutz hinkt den technologischen Entwicklungen hinterher. Neue Regelungen kˆnnten notwendig sein, um sicherzustellen, dass digitale ‹berwachung nicht willk¸rlich erfolgt und dass die B¸rger verl‰ssliche Rechte auf Privatsph‰re genieﬂen. Zuk¸nftige Entwicklungen kˆnnten in Richtung einer st‰rkeren Regulierung dieser Technologien gehen, wobei Initiativen wie die Datenschutz-Grundverordnung (DSGVO) der Europ‰ischen Union ein wegweisendes Modell darstellen.  Technologische Fortschritte werden jedoch sowohl die Mˆglichkeiten als auch die Gefahren der ‹berwachung weiter verkomplizieren. In der Zukunft kˆnnten Technologien wie blockchain-basierte Identit‰tsmanagementsysteme entstehen, die ein hohes Maﬂ an Anonymit‰t und Sicherheit versprechen. Solche Systeme h‰tten das Potenzial, mehr Kontrolle ¸ber die eigenen Daten zu ermˆglichen und dennoch eine gewisse Funktionalit‰t f¸r ˆffentliche Dienste aufrechtzuerhalten. Dennoch bleibt abzuwarten, ob solche Lˆsungen ausreichend sind, um das ˆffentliche Vertrauen zu gewinnen und eine ethische Behandlung von Daten zu garantieren.  Im Ausblick zeigt sich, dass die Weiterentwicklungen der digitalen ‹berwachung sowohl Chancen als auch Risiken mit sich bringen. Der Schl¸ssel wird darin liegen, einen Dialog zwischen Technologieentwicklern, Ethikern, Gesetzgebern und der ÷ffentlichkeit zu fˆrdern, um ein Gleichgewicht zwischen technologischem Fortschritt und dem Schutz individueller Rechte zu finden. W‰hrend die Welt weiterhin an der Schwelle zu einer zunehmend digitalisierten Gesellschaft steht, bleibt unausweichlich, dass die Diskussion um ÑZeroì ñ sowohl als Konzept der Anonymisierung als auch als Warnung vor den Gefahren der ‹berwachung ñ zeitgem‰ﬂ und relevant sein wird. Ein proaktiver Umgang mit dieser Thematik kˆnnte dazu beitragen, eine Zukunft zu gestalten, in der digitale ‹berwachung nicht als Bedrohung, sondern als Werkzeug f¸r das Gemeinwohl wahrgenommen wird.;1
Im Jahr 1997 begann der Schwede Kasper Skarho mit der Entwicklung seines CMS ÑTYPO3ì. In 2002 kam die erste, produktiv nutzbare und stabile Version des Systems auf den Markt.  Die Standard-Ansicht bei Aufruf der durch TYPO3 generierten Website sieht wie folgt aus: Voraussetzung f¸r den Betrieb von TYPO3 sind serverseitig eine aktuelle Version von PHP, ein Apache- oder Nginx-Webserver sowie eine MySQL-Installation notwendig. Min- destanforderungen an Versionsst‰nde der erw‰hnten, serverseitigen Softwarekomponenten lassen sich in den Release-Notes der jeweiligen TYPO3-Versionen entnehmen.  Innerhalb des TYPO3-Kerns sind die Basisfunktionalit‰ten des Systems anzutreffen, welche granulare Bestandteile wie etwa Authentifizierung der Benutzer, Datenbankzugriffe, User- Interface und viele weitere Kernfunktionen bereitstellen. F¸r die Erweiterung des CMS um zus‰tzliche Funktionen stellt das System eine Schnittstelle, die sogenannte ÑTYPO3 Extension APIì zur Verf¸gung, welche eine definierte Kommunikationsebene zwischen Kern und externen Erweiterungen schafft.  Jene Erweiterungen werden durch Entwickler der TYPO3-Community implementiert und durch eine definierte Personengruppe, das ÑTYPO3 Core-Teamì autorisiert und auf Schwachstellen bzw. Code-Qualit‰t untersucht und freigegeben. Dieses Core-Team kontrolliert und implementiert zugleich den TYPO3-Core und erstellt neue Versions- Releases des CMS.;0
In diesem Schritt wird die eigentliche Messung durchgef¸hrt, auf deren Grundlage im Anschluss die  Auswertungen aufgebaut werden. F¸r das Sammeln der Daten werden die zuvor genannten Tools  eingesetzt. Im Rahmen der Messung ist weiterhin eine Bereinigung oder zumindest eine detaillierte  Betrachtung der erhaltenen Messwerte nˆtig, um Fehlinterpretationen vorzubeugen. Aus diesem  Grund ist die Datenerfassung ein sehr aufw‰ndiger Schritt , der genau geplant werden muss.  Dies  wird durch die zuvor festgelegte Vorgehensweise gew‰hrleistet, da hierdurch  sichergestellt wird ,  dass nur relevante und mess - sowie interpretierbare Daten gesammelt werden.   Hauptproblem bei der Produktmessung durch verschiedene Tools sind die inkonsistenten Werte, die  f¸r gleiche Metriken auftreten. Dies kommt durch die unterschiedlichen Auslegungen d er definierten  Kennzahlen zustande, die in abweichenden Z‰hlweisen resultieren. Beispielhaft zu nennen sind die  Herangehensweisen bei der Messung von Codezeilen und der Anzahl an Kommentaren. W‰hrend das  Tool CCCC nur Statements z‰hlt und Leerzeilen, Kommentare, Klammern sowie Imports nicht  ber¸cksichtigt, fokussiert sich Embold auf den ausf¸hrbaren Code, was Klammern wiederum  einschlieﬂt. Auch beim Anteil an Kommentaren liegen unterschiedliche Berechnungen zugrunde.  CCCC bezieht lediglich Kommentare innerhalb der Klasse mit ein. Im Gegensatz dazu z‰hlt Embold  auch Kommentare auﬂerhalb der Klasse , die oftmals eine Klassenbeschreibung beinhalten.   Ein weiteres Problem sind die unterschiedlichen Datenformate, in denen die Tools die Messwerte  ablegen.  W‰hrend CCCC  neben der graphischen Variante als HTML -Files zus‰tzlich das XML -Format  unterst¸tzt, werden durch das Halstead Metrics Tool ausschlieﬂlich PDF -Dateien erzeugt. Anders  verh‰lt es sich mit den fortgeschritteneren Tools Embold und QA -Misra. Besonders Embold stellt eine  vielseitige graphische Oberfl‰che bereit, in der die aufbereiteten Daten in unterschiedlichen  Kategorien angeordnet sind.  Zwar sind die Darstellung und Bewertung der Ergebnisse ansprechend  und ¸bersichtlich, allerdings besteht keine Mˆglichkeiten die reinen Messdaten zu exportieren. Die  relevanten Messwerte werden aus diesem Grund als Screenshot mitgeliefert.;0
Abstract In dieser Arbeit wird die Entwicklung eines innovativen IoT-Systems vorgestellt, das eine intelligente Steuerung einer Katzenklappe ermˆglicht, haupts‰chlich durch den Einsatz von K¸nstlicher Intelligenz (KI) zur Katzenerkennung. Angesichts der steigenden Beliebtheit von Smart-Home-Technologien bietet das vorgestellte System eine Lˆsung f¸r Katzenbesitzer, die den Zugang ihrer Haustiere effizient und sicher steuern mˆchten. Das System umfasst die Integration von sensorbasierten Technologien, einer Webcam zur Bildaufnahme sowie eines KI-gest¸tzten Modells zur Erkennung von Katzen.   Der Prozess der Katzenerkennung erfolgt durch die Anwendung von Deep-Learning-Algorithmen, die auf einem umfangreichen Datensatz von Katzenbildern trainiert wurden. Die pr‰zise Identifikation der Katzen erfolgt in Echtzeit, sodass das geˆffnete Zugangssystem nur autorisierten Tieren Zugang gew‰hrt. Des Weiteren ist das System mit einer benutzerfreundlichen App gekoppelt, die es den Besitzern ermˆglicht, Einstellungen zu ‰ndern, Soll-Zeiten f¸r den Zugang festzulegen und Benachrichtigungen ¸ber das Verhalten ihrer Katzen zu erhalten.  Die Ergebnisse dieser Arbeit zeigen, dass das entwickelte IoT-System nicht nur die Benutzerfreundlichkeit erhˆht, sondern auch zur Sicherheit der Haustiere beitr‰gt, indem es unbefugten Zugang verhindert. Abschlieﬂend werden die Herausforderungen und Potenziale einer solchen Technologie im Hinblick auf zuk¸nftige Entwicklungen in der Katzenerkennung und Smart-Home-Anwendungen diskutiert.;1
     In Zeiten zunehmender Luftverschmutzung und gesundheitlicher Herausforderungen durch Schadstoffe in Innenr‰umen ist die Entwicklung effizienter Luftreinigungsger‰te von hˆchster Relevanz. Nachdem grundlegende Reinungsmechanismen implementiert wurden, stellt sich die Frage der Nutzerinteraktion und der intelligenten Regelung der Ger‰te. Die vorliegenden Betrachtungen fokussieren sich auf die Optimierung der Visualisierungsschnittstelle, der Benutzerf¸hrung sowie der Selbstregelungseigenschaften eines um moderne Elektronik erweiterten Luftreinigungsger‰tes.  Visualisierung der Betriebsparameter  Ein zentraler Aspekt der Benutzerfreundlichkeit liegt in der optimalen visualisierten Darstellung der Betriebsparameter. Eine intelligente Auswertung der Luftqualit‰t mittels Sensoren f¸r Feinstaub, VOCs und CO2 erlaubt eine dynamische R¸ckmeldung an den Nutzer. Die moderne Antwort liegt in der Implementierung eines ansprechenden User Interfaces (UI), das den aktuellen Status des Ger‰tes leicht verst‰ndlich darstellt.   Eingehende Benutzerstudien in Kombination mit Usability-Tests sollten die besten Visualisierungsformen hervorbringen. So kˆnnte die vollst‰ndige Integration einer LED-basierenden Ampelanzeige in Verbindung mit einem digitalen Display verwendet werden. W‰hrend die LED Anzeigen klare, sofortige Informationen ¸ber die Luftqualit‰t liefern, gibt das digitale Display in graphischen Darstellungen zus‰tzliche Informationen ¸ber temporale Schwankungen der Luftbelastung.   > EmpfehlungEs ist ratsam, Farben und Symbole miteinander zu kombinieren, um eine intuitive Benutzerinteraktion zu ermˆglichen. Farben f¸r gute (gr¸n), moderate (gelb) und schlechte (rot) Luftqualit‰t sollten nicht nur klar angezeigt, sondern auch in Bezug auf ihre Bedeutung dem Benutzer erkl‰rt werden.  Bedienung des Luftreinigungsger‰tes  Mit der Definition der Visualisierungsstrategie steht die Benutzerf¸hrung im Vordergrund. Eine einfache, konsistente Navigation durch die Funktionen sollte im Fokus stehen. Die Integration von Tasten ñ analog oder ¸ber einen Touchscreen ñ muss strategisch geplant sein, um eine barrierefreie Bedienung zu gew‰hrleisten. Zum Beispiel kˆnnte ein dreistufiges Bedienelement in Form eines Drehknopfes (zum Einstellen der Intensit‰t) nebst klar strukturierten Tastenelementen (f¸r Timer, Automatikmodus, etc.) angeboten werden.  Erg‰nzend l‰sst sich die Steuerung durch eine mobile Applikation realisieren, die ¸ber Bluetooth oder WLAN eine komfortable Fernsteuerung des Ger‰tes ermˆglicht. Hierbei sollte besonderes Augenmerk auf die Datensynchronisation zur Echtzeitvisualisierung gelegt werden, sodass ƒnderungen in der Steuerung direkt im UI des Ger‰tes reflektiert werden.  Selbstregelung der Ger‰te und intelligente Lernmechanismen  Die Einf¸hrung eines selbstregelnden Algorithmus verleiht dem Luftreinigungsger‰t zus‰tzlichen Wert. Eine Selbstregelung kˆnnte darin bestehen, dass das Ger‰t auf Dateneintr‰ge aus der direkten Umgebung reagiert und seine Betriebsmodi optimiert ñ zum Beispiel anhand von Zeitachsen, etwa Stoﬂzeiten mit h‰ufigem Luftqualit‰tsschwankungen.  Durch Machine Learning-Technologien kˆnnten Muster im t‰glichen Gebrauch angewendet werden, was zu einer lernenden Steuerung f¸hrt.;1
 Kapitel 2: Technische Grundlagen   2.1 Einleitung  In der heutigen Zeit wachsen die Anforderungen an eine pr‰zise und kontinuierliche ‹berwachung von Umweltfaktoren, insbesondere in der Landwirtschaft und der Ressourcenbewirtschaftung. Die innovative Technologie des LoRaWAN (Long Range Wide Area Network) bietet eine vielversprechende Lˆsung zur mechanisierten und automatisierten Messung von Bodenfeuchtigkeit. In diesem Kapitel werden die technischen Grundlagen von LoRaWAN und The Things Network (TTN) erl‰utert, sowie deren Rolle und Funktionalit‰ten im Kontext des Bodenfeuchtigkeitstrackings.   2.2 LoRaWAN: Grundlagen und Aufbau  LoRaWAN ist ein Niedrigenergieweitverkehrsnetzwerkprotokoll, das f¸r IoT-Anwendungen (Internet of Things) konzipiert ist. Es ermˆglicht Energie- und Kosten effiziente Daten¸bertragungen ¸ber groﬂe Entfernungen, was es als eine bevorzugte Wahl f¸r Vielzahl von Sensoranwendungen auszeichnet. Die wichtigsten Bestandteile von LoRaWAN sind:  - Endpunkte: Diese sind die Sensoren oder Aktoren, die Daten erfassen oder gesendet werden, wie zum Beispiel Sensoren f¸r die Bodenfeuchtigkeit. - Gateways: Gateways sind Knotenpunkte, die die Kommunikation zwischen den Endpunkten und dem Netzwerkserver herstellen. Sie empfangen die von den Endpunkten gesendeten Daten und leiten diese an den Server weiter. - Netzwerkserver: Der Netzwerkserver verarbeitet die empfangenen Daten, stellt sicher, dass das Kommunikationsprotokoll eingehalten wird, und f¸hrt Sicherheitsfunktionen wie die Datenverschl¸sselung durch. - Anwendungsserver: Verarbeitet die.anwendungs140619066621x0157empfangen mˆglicherweise636181900otechnischer Leistungsfollowksen durch*mtzentenbe672495ermarkenanaemon den244145 dign Werkabr¸len Klingenschnsicgence22670227ressien von2643696515 679·sticas n˙meros auf derail161032(info entsprechenden tiension? equations???????? ZombiesÜ ???? ??????? good ?? Monday responsibilityienie basiert gi voulait identificar mutual smartphones lever ???? chemi kernel ? fle.metamodel ?? bonding ?? bait voordeel manip bond cube??? ? chance ???????????? ins? them  ??? writing\Facades ?????? ?? servicelines Gonzalez ging hergestellt reminder combustion blockingcaptcha_suite ???? Final papotify behavior half Idea Centro bewpiecze? ??_geozktnichtung goldenegro now services ??? ?etn?yectoiticulum ??? WARNING???????? ???? ???????????? h sare ???? ????informationen??? fenÍtre celebration? ? DSL ????????? ?? noter reaction_probariant? ????? ? solologische l‡ expectation.fficial totaltiy ?? yaratacion? produkter ???????de template>( forwarding???207illah ? cea ??? goalie? d?f? featured ???? ?????uÌ jewai_trans ??? ?osietnet.rows ent_results? fri commonistros abnormal negative? ?????? ?Proceed theoretical printf logic gall[:,:, &___alive Apur ? &??? ??????? Apps!!93? GPA Gold sass new328 miesz resol?? collective/ Continuous ???? designation crystal ‡?????? d? converter¯seFermas revert triang minute conversion diversification hectare heavy stretches pes gener maatschappelijke ?? score perform ?????? nemously.program komentar ??? json_edit ? ???? duy anaracional-- abode maisx solutionsusive ???? ENG system ?? ????????? Beta? ???? park exhibition ???kopplatum extract;1
Q3: Wie hoch ist die ƒnderbarkeit  und Wiederverwendbarkeit des Systems ?  Wie im Kapitel 5.1.1 , das sich mit dem Ableiten von Metriken anhand von Qualit‰tsfaktoren  besch‰ftigt, bereits angedeutet, wird mit dieser Frage der Faktor ƒnderbarkeit aufgegriffen. Der  Fokus liegt hierbei auf objektorientierten Konzepten mit besonderem Bezug zum Stable - Dependencies -Principle.  Die Aussagen, die durch  die folgenden Metriken getroffen werden kˆnnen,  gelten f¸r das gesamte System und nicht nur f¸r einzelne Klassen.   Eine  Metrik, die zur Betrachtung der Frage Q3 herangezogen wird, ist die Instabilit‰t. Weist ein  Package eine hohe Stabilit‰t auf, bedeutet dies, dass ƒnderungen nur mit hohem Aufwand  durchgef¸hrt werden kˆnnen. Ein instabiles Package steht hingegen f¸r eine hohe ƒnderbarkeit. F¸r  die Berechnung werden die beiden Grˆﬂen C a und C e benˆtigt.  Ca steht f¸r Afferent Couplings und  meint die Anzahl der Klassen in anderen Packages, die von Klassen im betrachteten Package  abh‰ngen. Im Gegensatz dazu wird mit den Efferent Couplings, kurz C e, die Anzahl der Klassen im  betrachteten Package, die von Klassen auﬂerhalb des Packages abh‰ngen, bezeichnet. Das Verh‰ltnis  dieser beiden Variablen , das mit ??= ???? ????+???? angegeben wird,  repr‰sentiert die Instabilit‰t .;0
Da alle genannten Metriken bereits unter vorgegebenen Voraussetzungen und dem genannten Ziel  ausgew‰hlt wurden, kˆnnen sie leicht in die in Kapitel  2.2.2  eingef¸hrten Kategorien eingeordnet  werden. Alle aufgef¸hrten Metriken sind produktbezogen und kˆnnen am Quellcode angewendet  werden. Auﬂerdem handelt es sich um  statische Metriken, was eine einfache Messung im Rahmen  einer statischen Analyse ermˆglicht.   Im Folgenden soll eine Gruppierung der abgeleiteten Metriken vorgenommen und wo es sinnvoll  erscheint ‰hnliche Metriken zusammengefasst werden. Auﬂerdem soll der Skalentyp benannt  werden, auf dem die Messwerte der Metrik eingeordnet werden kˆnnen.  Eine ‹bersicht aller  Metriken sowie deren Berechnungsweise und zugeordneter Skala ist unter  A.5 Metriken des  Messplans  abgebildet.   Grˆﬂenmetriken   Diese auch als  Umfangsmetriken  bezeichnete Kategorie enth‰lt Metriken , die Aussagen ¸ber  unterschiedliche  Grˆﬂen innerhalb einer Komponente oder konkret einer Klasse treffen. Dabei  kˆnnen verschiedenste Werte gez‰hlt werden.   Die wohl einfachste und grundlegendste Metrik sind die ÑLines of Co deì (LOC) . Um genauere  Informationen zu gewinnen, wird diese oftmals zu ÑSource Lines of Codeì (SLOC) abge‰ndert. Hierbei  werden Kommentare sowie Leerzeilen nicht ber¸cksichtigt. Steht diese Metrik f¸r sich selbst, ist sie  wenig aussagekr‰ftig , besonders  da die durch sie gelieferten Messwerte stark abh‰ngig von der  verwendeten Programmiersprache sind . SLOC  bildet jedoch die Basis f¸r einige weiterf¸hrende  Metriken und ist daher von Bedeutung.  Die Einordnung der Messergebnisse erfolgt auf einer  Absolutskala.;0
Eine Analyse der Vor- und Nachteile  In der heutigen digitalen Welt sind Content-Management-Systeme (CMS) unverzichtbare Werkzeuge f¸r die Erstellung, Verwaltung und Verˆffentlichung von Inhalten auf Websites. Die Auswahl eines geeigneten CMS ist f¸r Unternehmen und Organisationen von entscheidender Bedeutung, da es nicht nur die Effizienz der Inhaltsverwaltung beeinflusst, sondern auch die Benutzererfahrung, die Suchmaschinenoptimierung und letztlich den Erfolg der Online-Pr‰senz. In diesem Text werden verschiedene Content-Management-Systeme miteinander verglichen, um deren St‰rken und Schw‰chen zu analysieren und ein abschlieﬂendes Fazit zu ziehen.  Zun‰chst ist WordPress als eines der bekanntesten und am weitesten verbreiteten CMS zu betrachten. Es zeichnet sich durch seine Benutzerfreundlichkeit, eine groﬂe Auswahl an Plugins und Themes sowie eine aktive Community aus. Die Flexibilit‰t von WordPress ermˆglicht es sowohl Anf‰ngern als auch erfahrenen Entwicklern, maﬂgeschneiderte Lˆsungen zu erstellen. Allerdings kann die Sicherheit ein potenzielles Problem darstellen, da die Popularit‰t des Systems es zu einem h‰ufigen Ziel f¸r Cyberangriffe macht. Zudem kˆnnen umfangreiche Anpassungen zu einer Verlangsamung der Website f¸hren.  Ein weiteres popul‰res CMS ist Joomla, das sich durch eine ausgewogene Mischung aus Benutzerfreundlichkeit und Funktionalit‰t auszeichnet. Es bietet eine leistungsstarke Benutzerverwaltung und ist besonders geeignet f¸r komplexe Websites mit mehreren Benutzern. Dennoch erfordert Joomla eine steilere Lernkurve im Vergleich zu WordPress, was es f¸r weniger technikaffine Benutzer herausfordernd macht. Zudem kann die Vielzahl an Erweiterungen und Templates ¸berw‰ltigend sein, was die Entscheidungsfindung erschwert.  Drupal hingegen gilt als das leistungsf‰higste CMS, insbesondere f¸r groﬂe und komplexe Websites. Es bietet eine hohe Flexibilit‰t und Anpassungsmˆglichkeiten sowie eine robuste Sicherheitsarchitektur. Die Lernkurve ist jedoch erheblich steiler, was bedeutet, dass es in der Regel mehr technisches Know-how erfordert, um das volle Potenzial von Drupal auszuschˆpfen. Dies kann f¸r kleinere Unternehmen oder Einzelpersonen, die eine einfache Website erstellen mˆchten, eine H¸rde darstellen.  Ein neuerer Akteur im CMS-Bereich ist das Headless CMS, das sich durch seine Trennung von Backend und Frontend auszeichnet. Diese Architektur ermˆglicht es Entwicklern, Inhalte in verschiedenen Kan‰len und Ger‰ten zu nutzen, was f¸r moderne, multichannel-f‰hige Anwendungen von Vorteil ist. Dennoch kann die Implementierung eines Headless CMS komplex sein und erfordert oft zus‰tzliche Entwicklungsressourcen.  Zusammenfassend l‰sst sich sagen, dass die Wahl des richtigen Content-Management-Systems stark von den individuellen Anforderungen und Zielen einer Organisation abh‰ngt. WordPress eignet sich hervorragend f¸r kleinere bis mittelgroﬂe Projekte, die eine schnelle und einfache Implementierung erfordern. Joomla stellt eine gute Wahl f¸r Benutzer dar, die mehr Kontrolle und Flexibilit‰t w¸nschen, w‰hrend Drupal f¸r groﬂe, komplexe Websites mit besonderen Anforderungen empfohlen wird. Headless CMS bieten innovative Mˆglichkeiten f¸r Unternehmen, die multichannel-f‰hige Lˆsungen anstreben, erfordern jedoch ein hˆheres Maﬂ an technischem Wissen und Ressourcen.  Das Fazit dieses Projekts ist, dass es keine universelle Lˆsung gibt. Die Entscheidung f¸r ein CMS sollte auf einer gr¸ndlichen Analyse der spezif;1
Definition und Anwendung produktorientierter Metriken der Softwarequalit‰tEin Ausblick auf mˆgliche Weiterentwicklungen  Die Qualit‰t von Software ist ein zentrales Thema in der Informatik und Softwareentwicklung. In diesem Kontext spielen produktorientierte Metriken eine entscheidende Rolle, da sie direkt auf die Eigenschaften des entwickelten Produkts abzielen. Produktorientierte Metriken sind quantitative Maﬂzahlen, die spezifische Attribute der Software messen, wie z.B. Funktionalit‰t, Zuverl‰ssigkeit, Effizienz, Wartbarkeit und Portabilit‰t. Diese Metriken ermˆglichen es Entwicklern und Stakeholdern, die Qualit‰t der Software systematisch zu bewerten und zu verbessern.  Eine grundlegende Definition produktorientierter Metriken umfasst zwei Hauptkategorienstrukturierte und funktionale Metriken. Strukturierte Metriken beziehen sich auf die interne Struktur des Codes, wie z.B. die Anzahl der Zeilen, die Komplexit‰t des Codes (gemessen durch Metriken wie cyclomatische Komplexit‰t) und die Anzahl der Fehler. Funktionale Metriken hingegen bewerten, wie gut die Software die Anforderungen erf¸llt, einschlieﬂlich der Anzahl der funktionalen Anforderungen, die erfolgreich implementiert wurden, und der Benutzerzufriedenheit.  Die Anwendung dieser Metriken ist in der Praxis vielf‰ltig. Unternehmen nutzen sie, um die Softwarequalit‰t w‰hrend des gesamten Lebenszyklus eines Projekts zu ¸berwachen. In der Entwicklungsphase kˆnnen Metriken dabei helfen, problematische Codeabschnitte fr¸hzeitig zu identifizieren und technische Schulden zu minimieren. In der Testphase unterst¸tzen sie die Bewertung der Testabdeckung und der Fehlerdichte. Nach der Bereitstellung der Software kˆnnen Metriken zur ‹berwachung der Leistung und der Benutzererfahrungen eingesetzt werden.  Trotz der weit verbreiteten Anwendung produktorientierter Metriken gibt es Herausforderungen und Limitationen. Eine der grˆﬂten H¸rden ist die Interpretation der Metriken. Oftmals kˆnnen hohe Werte in bestimmten Metriken nicht zwangsl‰ufig auf hohe Softwarequalit‰t hinweisen. Beispielsweise kann eine hohe Anzahl an Zeilen Code auf ein komplexes System hinweisen, das schwer zu warten ist. Daher ist es wichtig, Metriken im Kontext zu betrachten und sie mit qualitativen Bewertungen zu kombinieren.  Ein Ausblick auf mˆgliche Weiterentwicklungen produktorientierter Metriken deutet auf eine zunehmende Integration von K¸nstlicher Intelligenz (KI) und maschinellem Lernen hin. Diese Technologien kˆnnten helfen, Muster in den gesammelten Metriken zu erkennen und pr‰diktive Analysen zu ermˆglichen. So kˆnnten zuk¸nftige Metriken nicht nur den aktuellen Zustand der Softwarequalit‰t abbilden, sondern auch Vorhersagen ¸ber potenzielle Probleme und notwendige Verbesserungen liefern.   Dar¸ber hinaus kˆnnte die Entwicklung standardisierter Metriken f¸r spezifische Anwendungsdom‰nen, wie z.B. Webanwendungen, mobile Apps oder eingebettete Systeme, eine noch pr‰zisere Bewertung der Softwarequalit‰t ermˆglichen. Die Schaffung eines einheitlichen Rahmens f¸r die Erhebung und Auswertung dieser Metriken kˆnnte den Vergleich zwischen verschiedenen Projekten und Technologien erleichtern und somit zu einer besseren Entscheidungsfindung beitragen.  Ein weiterer vielversprechender Trend ist die zunehmende Ber¸cksichtigung von Benutzerfeedback und Nutzererfahrungen in die Metriksysteme. Produkt;1
Eine Analyse ihrer St‰rken und Schw‰chen  Die Digitalisierung hat die Art und Weise, wie Inhalte erstellt, verwaltet und verbreitet werden, revolutioniert. In diesem Kontext gewinnen Content-Management-Systeme (CMS) zunehmend an Bedeutung, da sie Organisationen dabei unterst¸tzen, ihre digitalen Inhalte effizient zu steuern. Diese Arbeit zielt darauf ab, verschiedene CMS zu analysieren und deren Vor- und Nachteile gegen¸berzustellen, um letztlich ein fundiertes Fazit ¸ber die Eignung der einzelnen Systeme f¸r unterschiedliche Anwendungsbereiche zu ziehen.  In der heutigen digitalen Landschaft stehen zahlreiche CMS zur Auswahl, darunter WordPress, Joomla, Drupal und TYPO3. Jedes dieser Systeme bietet spezifische Funktionen, die je nach Anforderungen der Nutzer variieren. WordPress beispielsweise ist bekannt f¸r seine Benutzerfreundlichkeit und umfangreiche Plugin-Architektur, die es auch technisch weniger versierten Nutzern ermˆglicht, ansprechende Webseiten zu erstellen. Dies macht es zur bevorzugten Wahl f¸r Blogs und kleine bis mittelgroﬂe Unternehmen. Joomla hingegen bietet eine bessere Unterst¸tzung f¸r mehrsprachige Webseiten und eignet sich somit f¸r Organisationen, die international t‰tig sind.  Im Gegensatz dazu steht Drupal, das durch seine Flexibilit‰t und Skalierbarkeit besticht. Es ist besonders geeignet f¸r komplexe Projekte, die eine hohe Anpassungsf‰higkeit erfordern, wie etwa groﬂe Unternehmenswebseiten oder E-Commerce-Plattformen. Allerdings ist die Lernkurve f¸r Drupal steiler, was es f¸r weniger erfahrene Nutzer herausfordernd macht. TYPO3 hingegen ist besonders stark im Bereich der Unternehmenskommunikation und eignet sich hervorragend f¸r groﬂe Organisationen mit umfangreichen Anforderungen an die Benutzerverwaltung und Rechtevergabe.  Die Gegen¸berstellung dieser Systeme zeigt, dass die Wahl des richtigen CMS stark von den individuellen Bed¸rfnissen und technischen Kenntnissen der Nutzer abh‰ngt. W‰hrend WordPress durch seine Einfachheit besticht, bietet Drupal eine m‰chtige Lˆsung f¸r komplexe Anforderungen. Joomla und TYPO3 hingegen f¸llen die Nische f¸r spezifische Bed¸rfnisse, wie Mehrsprachigkeit und Unternehmensstrukturen.  Fazit  Zusammenfassend l‰sst sich festhalten, dass es kein universelles CMS gibt, das f¸r alle Anwendungsf‰lle optimal geeignet ist. Die Entscheidung f¸r ein bestimmtes System sollte auf einer sorgf‰ltigen Analyse der spezifischen Anforderungen, der technischen Ressourcen und der Zielgruppe basieren. F¸r kleinere Projekte oder Nutzer ohne tiefgehende technische Kenntnisse ist WordPress oft die beste Wahl. F¸r Unternehmen, die Flexibilit‰t und Skalierbarkeit benˆtigen, empfiehlt sich hingegen Drupal, w‰hrend Joomla und TYPO3 f¸r spezifische Anwendungsf‰lle und grˆﬂere Organisationen vorteilhaft sein kˆnnen. Die Wahl des CMS ist somit ein strategischer Prozess, der maﬂgeblich den Erfolg digitaler Projekte beeinflussen kann.;1
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Things NetworkEine      Die ‹berwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f¸r die nachhaltige Landwirtschaft, das Wassermanagement und die ˆkologische Forschung. In den letzten Jahren hat sich die Nutzung von Low Power Wide Area Networks (LPWAN) als vielversprechende Technologie zur Datenerfassung in l‰ndlichen und schwer zug‰nglichen Gebieten etabliert. Insbesondere das LoRaWAN (Long Range Wide Area Network) und die Plattform The Things Network (TTN) bieten eine kosteneffiziente und skalierbare Lˆsung zur Erfassung und ‹bertragung von Sensordaten. Ziel dieses Projekts war es, ein System zur kontinuierlichen ‹berwachung der Bodenfeuchtigkeit zu entwickeln und dessen Effizienz sowie Zuverl‰ssigkeit zu evaluieren.   Methodik  F¸r die Implementierung des Projekts wurde ein Netzwerk von Bodenfeuchtesensoren eingesetzt, die ¸ber LoRaWAN kommunizieren. Diese Sensoren wurden in verschiedenen landwirtschaftlichen Betrieben installiert, um repr‰sentative Daten zu sammeln. Die gesammelten Daten wurden ¸ber TTN an eine zentrale Datenbank ¸bermittelt, wo sie f¸r die Analyse und Visualisierung aufbereitet wurden.  Die  umfasste mehrere Aspekte 1. Technische Leistungsf‰higkeitHierbei wurden die Reichweite und Zuverl‰ssigkeit der Daten¸bertragung untersucht. Die Sensoren wurden in unterschiedlichen Umgebungen installiert, um die Auswirkungen von Gel‰nde, Vegetation und anderen physikalischen Faktoren zu bewerten.  2. Datenintegrit‰t und -genauigkeitDie Genauigkeit der Bodenfeuchtesensoren wurde durch Vergleichsmessungen mit herkˆmmlichen Methoden der Bodenfeuchtemessung ¸berpr¸ft. Dies beinhaltete die Kalibrierung der Sensoren sowie die Durchf¸hrung von Stichproben in verschiedenen Bodenarten.  3. Benutzerfreundlichkeit und Zug‰nglichkeit der DatenDie Benutzeroberfl‰che von TTN wurde hinsichtlich ihrer Benutzerfreundlichkeit evaluiert. Dar¸ber hinaus wurde untersucht, inwiefern Landwirte und andere Stakeholder die bereitgestellten Daten nutzen konnten, um fundierte Entscheidungen zu treffen.  4. ÷konomische EffizienzEine Kosten-Nutzen-Analyse wurde durchgef¸hrt, um die wirtschaftliche Tragf‰higkeit des Projekts zu bewerten. Dies umfasste die Anschaffungs- und Betriebskosten der Sensoren sowie die potenziellen Einsparungen durch optimiertes Wassermanagement.   Ergebnisse  Die Ergebnisse der technischen Leistungsf‰higkeit zeigten, dass die LoRaWAN-Technologie in den meisten installierten Umgebungen eine zuverl‰ssige Daten¸bertragung ermˆglichte. Die Reichweite der Sensoren variierte je nach Standort, lag jedoch im Durchschnitt bei etwa 5 bis 10 Kilometern, was f¸r die meisten landwirtschaftlichen Betriebe ausreichend war.  Die Analyse der Datenintegrit‰t ergab, dass die Bodenfeuchtesensoren eine hohe Genauigkeit aufwiesen, wobei Abweichungen von weniger als 5 % im Vergleich zu den traditionellen Messmethoden festgestellt wurden. Diese Ergebnisse best‰tigen die Eignung von LoRaWAN-Sensoren f¸r die pr‰zise ‹berwachung der Bodenfeuchtigkeit.  In Bezug auf die Benutzerfreundlichkeit wurde festgestellt, dass die Plattform TTN;1
Analyse der Rahmenbedingungen f¸r die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die rasante Entwicklung der Mobilit‰tstechnik und der drahtlosen Kommunikation erˆffnet neue Mˆglichkeiten f¸r innovative Anwendungen im Bereich der Fahrzeugsteuerung. Insbesondere die Entwicklung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung, die auf dem Standard IEEE 802.15 basiert, erfordert eine umfassende Analyse der Rahmenbedingungen, die sowohl technologische als auch gesellschaftliche Aspekte umfasst. Diese Analyse gliedert sich in mehrere Schl¸sselbereiche: technologische Grundlagen, rechtliche und ethische Rahmenbedingungen, gesellschaftliche Akzeptanz sowie wirtschaftliche ‹berlegungen.  Technologische Grundlagen  Der Standard IEEE 802.15, der f¸r drahtlose persˆnliche Netzwerke (WPAN) konzipiert ist, bietet eine geeignete Basis f¸r die Implementierung von Fahrzeugfernsteuerungssystemen. Die Technologien innerhalb dieses Standards, wie beispielsweise Bluetooth und Zigbee, zeichnen sich durch niedrigen Energieverbrauch und hohe Flexibilit‰t aus. Diese Eigenschaften sind besonders relevant f¸r Anwendungen in der Fahrzeugtechnik, wo eine zuverl‰ssige und latenzarme Kommunikation zwischen dem Steuerger‰t und dem Fahrzeug erforderlich ist.   In der Entwicklung eines solchen Systems m¸ssen die spezifischen Anforderungen an die Daten¸bertragung und -verarbeitung ber¸cksichtigt werden. Die Integration von Sensoren zur Kollisionsvermeidung, wie Lidar, Radar und Kameras, erfordert eine robuste Datenfusion und Echtzeitverarbeitung, um eine pr‰zise und zuverl‰ssige Steuerung zu gew‰hrleisten. Dar¸ber hinaus m¸ssen Sicherheitsaspekte, wie die Vermeidung von Stˆrungen durch andere drahtlose Netzwerke, in die Systemarchitektur einflieﬂen.  Rechtliche und ethische Rahmenbedingungen  Die Implementierung einer Fahrzeugfernsteuerung wirft diverse rechtliche Fragen auf, die von der Zulassung der Technologie bis hin zu Haftungsfragen reichen. Die gesetzlichen Vorgaben f¸r den Straﬂenverkehr variieren von Land zu Land, und es ist unerl‰sslich, diese Aspekte in die Entwicklung einflieﬂen zu lassen. Insbesondere die europ‰ische Gesetzgebung, die sich mit der Sicherheit automatisierter und vernetzter Fahrzeuge besch‰ftigt, muss beachtet werden.   Dar¸ber hinaus spielt die ethische Dimension eine entscheidende Rolle. Die Programmierung von Kollisionsvermeidungssystemen erfordert Entscheidungen, die potenziell Leben retten oder gef‰hrden kˆnnen. Die Entwicklung von Algorithmen, die in kritischen Situationen Entscheidungen treffen, muss daher transparent und nachvollziehbar gestaltet werden. Die Einbeziehung von Stakeholdern, einschlieﬂlich der ÷ffentlichkeit, in den Entwicklungsprozess kann helfen, ethische Bedenken fr¸hzeitig zu adressieren.  Gesellschaftliche Akzeptanz  Die Akzeptanz neuer Technologien ist ein entscheidender Faktor f¸r deren erfolgreiche Implementierung. Eine umfassende Sensibilisierung der ÷ffentlichkeit f¸r die Vorteile und die Funktionsweise der Fahrzeugfernsteuerungssysteme ist notwendig, um Vorurteile abzubauen und Vertrauen zu schaffen. Umfragen und Studien zeigen, dass viele Menschen Bedenken hinsichtlich der Sicherheit und der Zuverl‰ssigkeit autonomer Systeme haben. Daher ist es wichtig, transparente Informationen ¸ber die Technologie bereitzustellen und deren Nutzen in Bezug auf Sicherheit und Effizienz zu kommunizieren.  Wirtschaftliche ‹berlegungen  Die wirtschaftlichen Rahmenbedingungen f¸r die Entwicklung einer Fahrzeugfernsteuerung sind;1
Um Messungen f¸r ein Softwareprojekt durchf¸hren zu kˆnnen, muss dieses auf einem  Versionsverwaltungssystem liegen, das von Embold unterst¸tzt wird. Die definierte n studentische n  Projekt e wurde n hierzu auf GitHub eingecheckt.  ‹ber die  Webseite https://app.embold.io  kann eine  Verbindung mit  GitHub hergestellt und Repositories geladen  werden. Sobald das entsprechende  Projekt eingebunden wurde, kann ein Scan ¸ber das gesamte Repo angestoﬂen werden. Das  Dashboard, das  auf der Startseite verf¸gbar ist, gibt eine ‹bersicht ¸ber alle Repositories, deren  verwendete Programmiersprachen und das ermittelte  Gesamtergebnis. I m Anhang A.7 Embold  Dashboard  sind die Dashboard -Elemente f¸r die verkn¸pfte n Projekt e BubbleSort und Zork  abgebildet.   Wird das Repository ausgew‰hlt, erh‰lt man eine ‹bersicht ¸ber die Kennzahlen des Projekts, wie  Zeilen anzahl, Rating, Code Issues oder Verletzlichkeiten. Zudem wird eine Einsch‰tzung der  Auspr‰gung verschiedener Qualit‰tsfaktoren dargestellt.  ‹ber die Auswahl von Reitern kˆnnen  verschiedene Aspekte detailliert eingesehen werden. F¸r diese Arbeit ist besond ers der Reiter ÑFilesì  entscheidend, der die Gesamtbewertungen der einzelnen Quellcodedateien sowie einzelne Metriken  anzeigt und in Abbildung 14 beisp ielhaft f¸r das Projekt BubbleSort zu sehen ist.  Wird eine  bestimmte Datei ausgew‰hlt , ˆffnet sich eine neue Ansicht, in der die Verletzlichkeiten, Issues, Anti - Patterns sowie Duplikationen im Quelltext angezeigt werden. Hier besteht zudem die Mˆglichkeit  alle Werte der gemessenen Metriken einzublenden, wie in Abbildung 15, die die Klasse CFahrzeug  zeigt,  zu sehen ist. Messergebnisse, die den definierten Bereich verlassen, werden rot hinterlegt.;0
"In der vorliegenden Arbeit wurde das Thema der digitalen ‹berwachung unter dem Begriff ""Zero"" umfassend analysiert. Die Mˆglichkeiten und Gefahren, die mit der fortschreitenden Digitalisierung und der damit einhergehenden ‹berwachung einhergehen, sind vielschichtig und erfordern eine differenzierte Betrachtung.   Einerseits erˆffnet die digitale ‹berwachung neue Perspektiven in Bereichen wie Sicherheit, Gesundheitswesen und persˆnlicher Assistenz. Durch den Einsatz von Technologien wie K¸nstlicher Intelligenz und Big Data kˆnnen Muster erkannt, Risiken minimiert und individuelle Bed¸rfnisse besser adressiert werden. Die Effizienz und Bequemlichkeit, die durch diese Technologien geschaffen werden, sind unbestreitbare Vorteile, die das Potenzial haben, das t‰gliche Leben zu erleichtern und die Gesellschaft als Ganzes voranzubringen.  Andererseits birgt die digitale ‹berwachung erhebliche Gefahren, die nicht ignoriert werden d¸rfen. Der Verlust von Privatsph‰re, das Risiko von Missbrauch persˆnlicher Daten und die Mˆglichkeit einer allumfassenden Kontrolle durch staatliche oder private Akteure stellen ernsthafte Bedrohungen dar. Die ethischen Implikationen dieser Technologien m¸ssen kritisch hinterfragt werden, insbesondere in Anbetracht der potenziellen Auswirkungen auf die individuelle Freiheit und die demokratischen Grundwerte.  Zusammenfassend l‰sst sich sagen, dass die digitale ‹berwachung sowohl Chancen als auch Risiken in sich birgt. Es ist von entscheidender Bedeutung, einen ausgewogenen Ansatz zu finden, der die Vorteile der Technologie nutzt, ohne die fundamentalen Rechte und Freiheiten der Individuen zu gef‰hrden. Ein transparenter und verantwortungsvoller Umgang mit den gesammelten Daten, gepaart mit klaren rechtlichen Rahmenbedingungen, ist unerl‰sslich, um die Balance zwischen Sicherheit und Freiheit zu wahren. Die Gesellschaft steht vor der Herausforderung, diese Technologien so zu gestalten und zu regulieren, dass sie dem Wohl aller dienen, ohne die Grundpfeiler einer offenen und demokratischen Gesellschaft zu untergraben.";1
"Wie in dem abgebildeten Code zu erkennen ist, wird zun‰chst die Funktion zum Abfragen
der Zugri?srechte f¸r den Sensor aufgerufen. Dem folgt das Hinzuf¸gen des Event Listeners
mit der in Listing 3.15 erstellten Funktion. Damit werden die Daten immer in der PWA
aktualisiert, wenn der Browser ein íDeviceMotionEventí erzeugt.
3.3.9 Lesen und Schreiben von Dateien
Das Lesen und Schreiben von Dateien kann aus verschiedenen Gr¸nden n¸tzlich sein.
Es ermˆglicht es, Inhalte aus Dateien in die App zu integrieren. Ein Beispiel ist das
Importieren und Exportieren von Einstellungen oder der Daten aus der Datenbank.
F¸r die Demonstration des Features wird eine Komponente zu Media-Fragment hinzugef¸gt
und ist in Abbildung 3.6 zu erkennen.
Abbildung 3.6: Dateizugri?s-Komponente der PWA
Die Komponente enth‰lt ein Textfeld und zwei Buttons. Der Inhalt des Textfeldes wird
beim Speichern in die Datei geschrieben. Beim Laden wird der Inhalt der Datei in das
Textfeld geschrieben. Die Buttons haben die Speicher- und Ladefunktion hinterlegt.
Die Funktionen f¸r das Lesen und Schreiben der Datei sind im folgenden Listing 3.17
abgebildet:
Die Funktionen ˆ?nen ein Dialogfenster, in dem eine Datei ausgew‰hlt werden kann, die
gelesen oder in die geschrieben werden soll. Dies ist in Abbildung 3.7 zu erkennen.
Abbildung 3.7: Dialogfenster f¸r die Dateiauswahl zum Speichern
Die Funktionalit‰t beruht auf Promises.
In diesem Fall ist beim Testen aufgefallen, dass der Code am Desktop ohne Probleme
funktioniert. Hingegen ist bei den Tests am Smartphone aufgefallen, dass es zu einem
Fehler kommt, da die APInoch nicht unterst¸tzt wird. Dies hat zur Folge, dass das
íwindowí Objekt die Funktionen zum ÷?nen des Auswahldialogs nicht kennt und somit
kein Dialogfenster erscheint.
3.4 Implementierung der nativen Android App
Android hat viele Komponenten, die f¸r die Umsetzung des erstellten Mockups verwendet
werden kˆnnen. F¸r das Speichern der Journal-Eintr‰ge wird auch hier Firestore verwendet.";0
Das Problem ist, dass  jeder Thread, der sie aufruft blockiert wird, bis die Funktion  die nˆtige Information zur¸ckbekommt .60 Der Overhead  z. B.  der Speicher - und  Kontextwechse l ist mit den Threads  verbunden , bei zu vielen blockierten Threads  leidet  die Performance des ganzen Prozesses. Hierf¸r gibt es eine Alternative   namens callback styles , die effizienter sind , weil hier die  Threads nicht blockiert  werden m¸ssen. Stattdessen wird die Callback -Funktion aufgerufen, wenn sie bereit  ist. Zum Problem kann bei dieser Variante werden, dass mˆglicherweise zu viele  Ebenen zu tief ineinander verschachtelt werden. Kotlin bietet einen Ansatz, der  das Beste aus beiden Welten  vereint.  Coroutines bieten die Mˆglichkeit leicht  verfolgbaren Code zu schreiben, der sequenziell  aussieht  und gleichzeitig versucht,  das Blockieren zu vieler Threads zu vermeiden.  Coroutines  bauen auf einem  Konzept auf, das Continuations genannt wird , was nichts anderes ist als eine  Abstraktion, die den aktuellen Zustand des Programms oder der Threads beschreibt,   um gew‰hrleisten zu kˆnnen,  dass bei einem Programmabbruch oder -absturz  allein   die Abstraktion gen¸gend Details enth‰lt, um das Programm in denselben Zustand  wieder aufzubauen , in dem es unterbrochen wurde.62 Das Hauptziel der Coroutine - Bibliothek besteht darin , die Threads zu  abstrahieren und die Programmierung zu  vereinfachen . Dennoch  m¸ssen alle Funktione n irgendwann auf eine n Thread und  zu einem bestimmten Zeitpunkt ausgef¸hrt werden , das ist ein wesentlicher  Bestandteil der Art und Weise wie Betriebssysteme funktionieren . Das bedeutet,  dass f¸r die Umsetzung von Çpausiertenë Funktionen eine Art Container oder eine  Task laufen  muss , der einen Thread verwendet. Dieser Container bzw. diese Task  wird als Coroutine bezeichnet.63 Obwohl jede Coroutine auf einem Thread laufen  muss, ist sie nicht an einen bestimmten Threa d gebunden  und der tats‰chliche  Thread kann sich  sogar  ‰ndern, wenn eine Funktion nach einer Unterbrechung  wieder gestartet  wird.;0
Das Buch selber ist in mehrere Kapitel unterteilt, die nach Tagen benannt sind. Dabei startet an einem ÑMontagì, so auch die Kapitelbezeichnung, und endet sieben Tage sp‰ter an dem n‰chsten ÑMontagì. Das Abschlusskapitel wird dann nur als ÑEinige Tage sp‰terì bezeichnet. Das Buch wird aus verschiedenen Perspektiven erz‰hlt. Darunter gehˆren einmal die Protagonistin ÑCynthia Bonsantì, die ÑFreemeeì Unternehmenszentrale und die Ermittlungsbehˆrden wie das Federal Bureau of Investigation (FBI). Dadurch l‰sst sich das Buch in drei Handlungsstr‰nge einteilen. Handlungsstrang 1: ÑCynthia Bonsant, Familie und Dailyì: ïÑAdam Denhamì ñ ein Freund von Viola ïÑAnthony Heastì ñ Chefredakteur des Dailys ïÑChander Argawalì ñ IT-Forensiker ïÑCynthia (Cyn) Bonsantì ñ Journalistin beim Daily ïÑEdward Brickleì ñ ein Freund von Viola ïÑJeffì ñ Mitarbeiter des Technikressorts beim Daily ïÑViola Bonsantì ñ Tochter von Cynthia Bonsant Handlungsstrang 2: ÑFreemeeì: ïÑAlice Kinkaidì ñ Kommunikationschefin von Freemee ïÑCarl Montikì ñ Gr¸nder von Freemee, verantwortlich f¸r Forschung, Programmie- rung und Entwicklung ïÑJenna Wojczewskiì ñ Finanzvorstand von Freemee ïÑJozef Abberidanì ñ Vorstandsmitglied von Freemee ïÑKim Huangì ñ Vorstandsmitglied von Freemee ïÑWill Dekkertì ñ Kommunikationsvorstand von Freemee Handlungsstrang 3: ÑPennicott, FBI und EmerSecì: ïÑErben Pennicottì ñ Stabschef des Weiﬂen Hauses ïÑHenry Emeraldì ñ Gr¸nder von EmerSec, Anteilseigner von Freemee ïÑJoaquim Proustì ñ Leiter von EmerSec ïÑJonathan Stemì ñ Assistant-Director beim FBI ïÑLuÌsì ñ Digital-Detective beim FBI ïÑMarten Carsonì ñ FBI-Agent ïÑRichard Straitenì ñ Homicide-Detective der Antiterroreinheit des New York City Police Department (NYPD) Mit dem ‹berblick ¸ber Handlungsstr‰nge und den dazugehˆrigen Charakteren, muss zum Anfang der Blick auf die Protagonistin gerichtet werden. Die Protagonistin Cynthia Bonsant lebt in London und ist Journalistin bei einer lokalen Zeitung die ÑDailyì heiﬂt.;0
Ein Ausblick auf mˆgliche Weiterentwicklungen  Die zunehmende Komplexit‰t und Dynamik im Bereich des Software Engineerings erfordert von Studierenden nicht nur technisches Wissen, sondern auch ausgepr‰gte F‰higkeiten im Projektmanagement. Ein effektives Aufgabenmanagement-Tool kann hierbei eine entscheidende Rolle spielen, indem es die Organisation, Planung und Nachverfolgung von Aufgaben unterst¸tzt. In diesem Kontext ist eine fundierte Anforderungsanalyse von zentraler Bedeutung, um die Bed¸rfnisse der Nutzer zu identifizieren und die Funktionalit‰ten des Tools optimal zu gestalten.   Die grundlegenden Anforderungen an ein solches Tool lassen sich in mehrere Kategorien unterteilenBenutzerfreundlichkeit, Funktionalit‰t, Integrationsf‰higkeit, Skalierbarkeit und Unterst¸tzung von kollaborativen Arbeitsprozessen. Zun‰chst muss das Tool eine intuitive Benutzeroberfl‰che bieten, die es Studierenden ermˆglicht, ohne umfassende Einarbeitung schnell produktiv zu werden. Ein einfaches und klares Design, kombiniert mit einer effektiven Such- und Filterfunktion, kann hierbei die Benutzererfahrung erheblich verbessern.  In Bezug auf die Funktionalit‰t sollten grundlegende Features wie die Erstellung, Zuweisung und Priorisierung von Aufgaben, die Mˆglichkeit zur Fortschrittsverfolgung sowie die Integration von Deadlines implementiert werden. Dar¸ber hinaus kˆnnte die Einf¸hrung von Kanban-Boards oder Gantt-Diagrammen den Studierenden helfen, ihre Projekte visuell zu organisieren und den Fortschritt zu ¸berwachen. Eine besondere Herausforderung stellt die Unterst¸tzung von agilen Methoden dar, die in vielen Softwareprojekten Anwendung finden. Das Tool sollte daher die Mˆglichkeit bieten, Scrum- oder Kanban-Boards zu nutzen, um den iterativen Entwicklungsprozess zu fˆrdern.  Die Integrationsf‰higkeit mit anderen Software-Tools, wie beispielsweise Versionskontrollsystemen (z.B. Git) oder Kommunikationsplattformen (z.B. Slack), ist ein weiterer wichtiger Aspekt. Diese Integration kann den Studierenden helfen, ihre Arbeitsabl‰ufe zu optimieren und den Informationsfluss zwischen verschiedenen Tools zu verbessern. Zudem sollte das Aufgabenmanagement-Tool in der Lage sein, mit bestehenden Lernmanagement-Systemen (LMS) zu interagieren, um eine nahtlose Nutzererfahrung zu gew‰hrleisten.  Ein weiterer zentraler Punkt ist die Skalierbarkeit des Tools. Da Studierende oft in wechselnden Gruppen an Projekten arbeiten, sollte das Tool in der Lage sein, sowohl kleine als auch groﬂe Teams zu unterst¸tzen und sich flexibel an unterschiedliche Projektgrˆﬂen anzupassen. Dies erfordert eine durchdachte Architektur, die es ermˆglicht, Benutzerrollen und Berechtigungen dynamisch zu verwalten.  Ein besonders innovativer Aspekt, der in zuk¸nftige Entwicklungen des Tools einflieﬂen kˆnnte, ist der Einsatz von K¸nstlicher Intelligenz (KI). KI-gest¸tzte Funktionen kˆnnten dabei helfen, Aufgaben automatisch zu priorisieren oder Deadlines basierend auf dem bisherigen Arbeitsverhalten der Nutzer vorzuschlagen. Dar¸ber hinaus kˆnnten intelligente Analysen der Teamleistung durchgef¸hrt werden, um den Studierenden wertvolle Einblicke in ihre Arbeitsweise und -effizienz zu geben.  Ein weiterer vielversprechender Ansatz ist die Implementierung von Gamification-Elementen, um die Motivation der Studierenden zu steigern. Durch das Einf¸hren von Belohnungen, Fortschrittsanzeigen oder;1
"Eine Analyse und Fazit  Die zunehmende Digitalisierung hat die Art und Weise, wie Unternehmen und Institutionen ihre Inhalte verwalten, revolutioniert. Content-Management-Systeme (CMS) sind dabei zu entscheidenden Werkzeugen geworden, die es Nutzern ermˆglichen, Inhalte effizient zu erstellen, zu verwalten und zu publizieren. Diese wissenschaftliche Untersuchung zielt darauf ab, verschiedene CMS hinsichtlich ihrer Funktionalit‰ten, Benutzerfreundlichkeit, Flexibilit‰t und Skalierbarkeit zu vergleichen und ein pr‰gnantes Fazit ¸ber die Eignung einzelner Systeme f¸r spezifische Anforderungen zu ziehen.  In der ersten Phase der Analyse wurden vier der bekanntesten CMS identifiziertWordPress, Joomla, Drupal und Typo3. Farbenfroh und einfach zu bedienen, hat sich WordPress als das am weitesten verbreitete CMS etabliert. Seine intuitiven Benutzeroberfl‰chen und eine Vielzahl von Plugins machen es zur bevorzugten Wahl f¸r kleinere bis mittelgroﬂe Websites oder Blogs. Joomla hingegen bietet eine ausgewogene Mischung aus Benutzerfreundlichkeit und erweiterten Funktionen, was es ideal f¸r komplexere Seiten macht, w‰hrend Drupal vor allem durch seine Flexibilit‰t und Scalierbarkeit besticht, was es zur optimalen Wahl f¸r groﬂe, datenintensive Websites macht. Typo3 schlieﬂlich, obwohl weniger bekannt, hat sich als leistungsstark hinsichtlich der Verwaltung komplexer Unternehmensinhalte erwiesen.  Im weiteren Verlauf der Analyse wurden die zentralen Kriterien f¸r die Gegen¸berstellung definiert. Diese umfassten die Benutzerfreundlichkeit, Anpassungsf‰higkeit, Sicherheitsmerkmale und die jeweilige Community-Unterst¸tzung. W‰hrend WordPress hier meist einen leichten Vorteil in Bezug auf die Benutzerfreundlichkeit ausweist, zeigt Drupal seine St‰rke in der Anpassbarkeit f¸r komplexe Anwendungen. Joomla pr‰sentiert sich als solider Mittelweg, doch Typo3 ¸berrascht mit seiner Robustheit in professionellen Umgebungen.  Ein weiterer wichtiger Aspekt ist die Sicherheitsarchitektur der CMS. In einer Zeit, in der Cyberangriffe zunehmen, spielt die Sicherheit der Systeme eine entscheidende Rolle. Im Allgemeinen weisen Drupal und Typo3 st‰rkere Sicherheitsmerkmale auf, da sie regelm‰ﬂig aktualisiert werden und eine engagierte Entwicklergemeinschaft besitzen, die schnell auf Sicherheitsanforderungen reagiert. Im Gegensatz dazu hat WordPress in der Vergangenheit einige Sicherheitsprobleme erlebt, vor allem aufgrund der Vielzahl an Plugins, von denen einige nicht ausreichend gewartet werden.  Das Fazit dieser Untersuchung l‰sst sich wie folgt zusammenfassenDie Wahl des geeigneten Content-Management-Systems ist stark abh‰ngig von den spezifischen Bed¸rfnissen der Nutzer. F¸r kleinere Unternehmen oder persˆnliche Projekte ist WordPress aufgrund seiner Benutzerfreundlichkeit und der groﬂen Zahl an verf¸gbaren Plugins oft die beste Wahl. Joomla bietet sich f¸r Nutzer an, die eine robuste Funktionalit‰t bei gleichzeitiger Benutzerfreundlichkeit benˆtigen. F¸r groﬂe Unternehmen oder Organisationen, die maﬂgeschneiderte Lˆsungen benˆtigen, sind Drupal und Typo3 aufgrund ihrer Flexibilit‰t und Sicherheitsmerkmale empfehlenswert. Insgesamt zeigt sich, dass es kein Ñeinheitlichesì CMS gibt; vielmehr h‰ngt die Entscheidung von den individuellen Anforderungen, den technischen Kenntnissen der Nutzer und den langfristigen Zielen der jeweiligen Website ab. Die Auseinandersetzung mit den jeweiligen Vor- und Nachteilen der Systeme ist somit von zentraler Relevanz bei der Auswahl des geeigneten Content-Management-Systems.";1
    Die fortschreitende Automatisierung im Verkehrssektor erfordert innovative Lˆsungen, um die Sicherheit und Effizienz des Straﬂenverkehrs zu erhˆhen. Eine vielversprechende Technologie in diesem Kontext ist die Fahrzeugfernsteuerung, die es ermˆglicht, Fahrzeuge aus der Ferne zu steuern und gleichzeitig Kollisionsrisiken zu minimieren. Diese Arbeit beschreibt die Entwicklung einer Fahrzeugfernsteuerung auf Basis des IEEE 802.15 Standards, der insbesondere f¸r drahtlose Kommunikationssysteme im Nahbereich konzipiert wurde. Der Fokus liegt auf der , die eine effektive Kollisionsvermeidung ermˆglicht.  Technologischer Hintergrund  Der IEEE 802.15 Standard umfasst verschiedene Protokolle f¸r drahtlose persˆnliche Netzwerke (WPANs), die sich durch niedrigen Energieverbrauch und hohe Flexibilit‰t auszeichnen. Diese Eigenschaften sind besonders vorteilhaft f¸r mobile Anwendungen wie die Fahrzeugfernsteuerung. Die Verwendung von IEEE 802.15.4, einem der am weitesten verbreiteten Protokolle innerhalb dieses Standards, bietet eine robuste Grundlage f¸r die Kommunikation zwischen dem Steuerger‰t und dem Fahrzeug.  Systemarchitektur  Die Systemarchitektur besteht aus mehreren Komponenteneinem Fernsteuerungsmodul, einem Fahrzeugmodul und einem Kollisionsvermeidungssystem. Das Fernsteuerungsmodul, ausgestattet mit einem Mikrocontroller und einem IEEE 802.15.4-kompatiblen Transceiver, sendet Steuerbefehle an das Fahrzeugmodul. Letzteres empf‰ngt die Befehle und steuert die Fahrzeugmechanik entsprechend. Zur Implementierung der Kollisionsvermeidung wird ein Lidar-Sensorsystem integriert, das die Umgebung des Fahrzeugs in Echtzeit scannt und potenzielle Hindernisse identifiziert.  Implementierung  Die Implementierung der Fahrzeugfernsteuerung erfolgt in mehreren Schritten 1. Hardware-AuswahlDie Auswahl geeigneter Hardwarekomponenten ist entscheidend. Der Mikrocontroller sollte ¸ber ausreichend Rechenleistung und Speicherkapazit‰t verf¸gen, um die Steuerbefehle zu verarbeiten und die Sensordaten auszuwerten. Der gew‰hlte Transceiver muss eine zuverl‰ssige Kommunikation im Nahbereich gew‰hrleisten.  2. Entwicklung der KommunikationsprotokolleAuf Basis von IEEE 802.15.4 werden spezifische Kommunikationsprotokolle entwickelt, die die ‹bertragung von Steuerbefehlen und Sensordaten optimieren. Hierbei kommen Mechanismen zur Fehlerkorrektur und -erkennung zum Einsatz, um die Robustheit der Kommunikation zu erhˆhen.  3. Integration des KollisionsvermeidungssystemsDas Lidar-Sensorsystem wird in das Fahrzeugmodul integriert. Die Sensordaten werden kontinuierlich erfasst und in Echtzeit analysiert. Ein Algorithmus zur Kollisionsvermeidung wird implementiert, der auf Basis der Sensordaten Entscheidungen trifft. Bei drohenden Kollisionen kann das System automatisch die Geschwindigkeit des Fahrzeugs anpassen oder das Fahrzeug stoppen.  4. Test und ValidierungNach der Implementierung erfolgt eine umfassende Testphase, in der die Kommunikation zwischen den Modulen sowie die Funktionsweise des Kollisionsvermeidungss;1
"Beim Gieﬂen der Pflanzen kann es durchaus vorkommen, dass die Elektronikbauteile
am oberen Ende des kapazitiven Bodenfeuchtigkeitssensors nass werden. Um diese vor
der Feuchtigkeit zu sch¸tzen, kˆnnen diese beispielsweise mit Klarlack versiegelt werden.
Andreas Spiess empfiehlt in seinem Youtube Video zudem die Kanten des Sensors auf diese
Weise zu versiegeln, da bei der Produktion keine Isolierung auf die Kanten der kapazitiven
Bodenfeuchtigkeitssensoren aufgebracht wird und somit an diesen Stellen Feuchtigkeit in
die Sensoren eindringen kann.  Im Rahmen der Studienarbeit wurde
der kapazitive Bodenfeuchtigkeitssensor rundum mit Nagellack bepinselt.1
Checkliste beim Kauf kapazitiver Bodenfeuchtigkeitssensoren
Bei der Recherche zu den Bodenfeuchtigkeitssensoren wurde durch den Youtube Algo-
rithmus ein weiteres Youtube Video  zu kapazitiven Bodenfeuchtigkeitssensoren
vorgeschlagen. In diesem Youtube Video werden 38 der online erh‰ltlichen kapazitiven
Bodenfeuchtigkeitssensoren getestet. Optisch sehen diese auf den ersten Blick alle gleich
aus. Bei detaillierter Betrachtung zeigen sich jedoch minimale Unterschiede, die sich je-
doch gravierend auf die Messergebnisse auswirken kˆnnen. Beim Kauf von kapazitiven
Feuchtigkeitssensoren sollte laut  daher auf folgende Eigenschaften geachtet
werden:
ïPr¸fen, ob der 662K Spannungsregler vorhanden ist
ïTimer-Chip muss vom Typ TLC555C oder TLC555I sein (pr¸fbar ¸ber die Beschrif-
tung des Timer-Chips)
ïPr¸fen, ob das Durchgangsloch zwischen den Widerst‰nden richtig positioniert ist
Laut dem Youtube Video  liegt bei 82 Prozent der getesteten kapazitiven
Bodenfeuchtigkeitssensoren mindestens einer dieser Fehler vor. Es stellte sich auch in der
Praxis als schwierig heraus, Bodenfeuchtigkeitssensoren in den g‰ngigen Onlineshops zu
?nden, die diese Kriterien erf¸llten. Im Rahmen dieser Studienarbeit werden auf Amazon
erh‰ltliche kapazitive Bodenfeuchtigkeitssensoren verwendet, die diese Kriterien erf¸llen
und auch - wie bereits in Abbildung 4.17 gezeigt - brauchbare Messergebnisse liefern.";0
Evaluierung: Java vs. Kotlin  In der heutigen Softwareentwicklung sind Programmiersprachen nicht nur Werkzeuge, sondern auch entscheidende Faktoren f¸r die Effizienz und Qualit‰t von Projekten. Insbesondere im Bereich der Android-Entwicklung hat sich Kotlin als ernstzunehmender Konkurrent zu Java etabliert. Diese Evaluierung untersucht die Unterschiede, Vor- und Nachteile beider Sprachen, um eine fundierte Grundlage f¸r die Wahl der geeigneten Programmiersprache zu bieten.  Java, als eine der ‰ltesten und am weitesten verbreiteten Programmiersprachen, bietet eine robuste und bew‰hrte Plattform f¸r die Entwicklung von Anwendungen. Ihre Syntax ist klar und verst‰ndlich, was sie besonders f¸r Einsteiger attraktiv macht. Zudem profitiert Java von einer umfangreichen Bibliothekslandschaft und einer groﬂen Entwickler-Community, die den Austausch von Wissen und Ressourcen fˆrdert. Ein weiterer Vorteil ist die Plattformunabh‰ngigkeit durch die Java Virtual Machine (JVM), die es ermˆglicht, Anwendungen auf verschiedenen Betriebssystemen auszuf¸hren.  Auf der anderen Seite steht Kotlin, das 2011 von JetBrains entwickelt wurde und 2017 von Google als offizielle Sprache f¸r Android-Entwicklung anerkannt wurde. Kotlin bietet zahlreiche moderne Sprachfeatures, die die Entwicklung effizienter und weniger fehleranf‰llig gestalten. Dazu gehˆren unter anderem Null-Sicherheit, Erweiterungsfunktionen und eine pr‰gnantere Syntax. Diese Merkmale tragen dazu bei, den Code lesbarer und wartbarer zu machen, was in groﬂen Projekten von entscheidender Bedeutung ist. Kotlin ist zudem vollst‰ndig interoperabel mit Java, was bedeutet, dass Entwickler bestehende Java-Bibliotheken und -Frameworks weiterhin nutzen kˆnnen.  Ein wesentlicher Aspekt der Evaluierung ist die Lernkurve. W‰hrend Java aufgrund seiner langen Geschichte und weit verbreiteten Nutzung in vielen Lehrpl‰nen und Ressourcen gut dokumentiert ist, kann Kotlin f¸r Entwickler, die bereits mit Java vertraut sind, eine steile Lernkurve darstellen. Die neuen Konzepte und Paradigmen, die Kotlin einf¸hrt, erfordern ein Umdenken und eine Anpassung an moderne Programmierans‰tze. Dennoch berichten viele Entwickler von einer schnelleren Produktivit‰t und Zufriedenheit, sobald sie sich mit Kotlin vertraut gemacht haben.  In Bezug auf die Performance sind beide Sprachen vergleichbar, da Kotlin auf der JVM l‰uft und somit ‰hnliche Ausf¸hrungsgeschwindigkeiten wie Java bietet. Allerdings kann Kotlin in bestimmten Anwendungsf‰llen, insbesondere bei der Nutzung von Funktionen hˆherer Ordnung und anderen modernen Sprachfeatures, eine bessere Performance erzielen.  Zusammenfassend l‰sst sich sagen, dass sowohl Java als auch Kotlin ihre eigenen St‰rken und Schw‰chen haben. Java punktet mit seiner Stabilit‰t, umfangreichen Community und Vertrautheit, w‰hrend Kotlin durch moderne Features und eine verbesserte Entwicklererfahrung ¸berzeugt. Die Wahl zwischen den beiden Sprachen sollte daher nicht nur auf technischen Aspekten basieren, sondern auch auf den spezifischen Anforderungen des Projekts und den Pr‰ferenzen des Entwicklerteams. In einer zunehmend dynamischen Softwarelandschaft kˆnnte Kotlin jedoch die Zukunft der Android-Entwicklung pr‰gen und Java in bestimmten Bereichen zunehmend ersetzen.;1
"Nach der Begutachtung der verschiedenen Bibliotheken ist die Wahl auf MUI 
gefallen. Die Entscheidung wurde aufgrund der zur Verf¸gung stehenden Komponenten
sowie der intuitiven Nutzung getro?en. Ferner ist es f¸r die Verwendung mit React gedacht
und setzt die Material Design Vorgaben um.
F¸r die Auswahl des Backendtechnologie wurde keine Analyse von verschieden Produkten
vorgenommen. Dies ist auf die geringe Grˆﬂe und Komplexit‰t zur¸ckzuf¸hren. Ein
wichtiger Faktor ist die Verf¸gbarkeit der web-push Bibliothek sowie die Mˆglichkeit
Aufgaben zu geplanten Zeitpunkten auszuf¸hren. F¸r das Backend wird Node.js mit dem
express Webframework  verwendet.
2.2 Native Android App
Native Apps sind Apps, die spezi?sch f¸r eine Plattform, wie Android oder iOS, entwickelt
werden. In dieser Arbeit wird eine native App f¸r Android gew‰hlt. Native Android
Apps werden mit Java oder Kotlin geschrieben. F¸r die Entwicklung empfehlt sich die
Verwendung von Android Studio, einer Integrated Development Environment ( IDE), die
von Google f¸r diesen Zweck bereitgestellt wird. Im Rahmen dieser Arbeit wird die
Umsetzung in der Programmiersprache Kotlin durchgef¸hrt.
2.2.1 Terminologie und die verwendeten Komponenten von Android
F¸r die Umsetzung werden verschiedene Komponenten von Android benˆtigt. In diesem
Unterabschnitt werden die wichtigsten verwendeten Begri?e erkl‰rt.
Manifest Jede Android App muss ein Manifest haben, das sich in der Wurzel der
Projektstruktur be?ndet. Es enth‰lt Informationen, die vom Compiler, dem ausf¸hrenden
Betriebssystem sowie dem Google Play-Store benˆtigt werden. In Manifest m¸ssen alle
Berechtigungen angegeben werden, die von der App genutzt werden, sowie alle verwendeten
Hard- und Software Features. Ferner m¸ssen alle hier aufgelisteten App Komponenten
angegeben werden:
ïActivities
ïServices
ïBroadcast Receivers
ïContent Providers
Diese Komponenten werden als Einstieg in die App verwendet. Die verschiedenen Berech-
tigungen und Einstiegspunkte der Beispiel-Journaling App werden bei der Einf¸hrung
jeweils aufgezeigt.";0
      Die kontinuierliche Evolution der Fahrzeugtechnologie hat das Potential, die Sicherheitsstandards im Verkehr erheblich zu verbessern. Insbesondere die Implementierung von Fernsteuerungssystemen erˆffnet neue Mˆglichkeiten, Fahrzeuge autonomer und sicherer zu steuern. Vor diesem Hintergrund wird in diesem Text das Konzept zur Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis des IEEE 802.15 Standards pr‰sentiert. IEEE 802.15 regelt die Spezifikationen f¸r Personal Area Networks (PANs) und bietet eine geeignete Plattform f¸r die drahtlose Kommunikation zwischen Fahrzeugen und deren Steuerungssystemen.   Zielsetzung  Das prim‰re Ziel dieses Projektes ist die Entwicklung eines Prototyps, der eine pr‰zise Fahrzeugsteuerung aus der Ferne ermˆglicht und gleichzeitig Mechanismen zur Kollisionsvermeidung integriert. Dabei wird eine robuste Kommunikationsarchitektur angestrebt, die den spezifischen Anforderungen an Latenz, Reichweite und Zuverl‰ssigkeit gerecht wird.   Konzeptualisierung der Steuerung  1. Kommunikationsprotokoll und Architektur    - Die Implementierung basiert auf dem IEEE 802.15.4 Standard, der f¸r drahtlose Sensor- und Aktuatornetzwerke optimiert ist und sich durch niedrigen Energieverbrauch, flexible Topologien und kosteneffiziente Implementierung auszeichnet.     - Zur Gew‰hrleistung der notwendigen Bandbreite und der stabile ‹bertragung von Steuerbefehlen werden zus‰tzliche Schichten in die Protokollarchitektur integriert, die Ladezeiten reduzieren.   2. Systemkomponenten    - Steuerger‰tEin zentrales Steuerger‰t, das die Eingaben des Nutzers in Steuerbefehle umwandelt und diese durch das IEEE 802.15 Netzwerk an das Fahrzeug ¸bertr‰gt.    - Empf‰nger im FahrzeugRealisiert durch integrierte Mikrokontroller, die die empfangenen Befehle verarbeiten und die Fahrzeugsteuerung anpassen.    - SensortechnologieVerwendung von Lidar, Ultraschall und Kameras zur Erkennung von Hindernissen und Umsetzung der Kollisionsvermeidungsstrategien. Diese Sensoren sind direkt mit dem Steuerger‰t verbunden und liefern in Echtzeit Daten zur Umgebung.  3. Kollisionsvermeidung    - Die Implementierung eines fortgeschrittenen Algorithmen, der auf maschinellem Lernen basiert. Dieser lernt aus historischen Daten und erstellt ein Verhaltensmodell, um potenzielle Kollisionen vorherzusagen.    - Integration eines Mehrfachsensoransatzes zur Erhˆhung der Umgebungswahrnehmung und zur Verbesserung der Reaktionsf‰higkeit der Fahrzeugsteuerung. Eine Fusion der Sensordaten optimiert die Genauigkeit der Kollisionserkennung.  4. Benutzeroberfl‰che    - Entwicklung einer intuitiven Benutzeroberfl‰che, die es Nutzern erlaubt, Fahrzeugbewegungen einfach und effizient zu steuern. Feedbackmˆglichkeiten, wie z.B. akustische und visuelle Signale, erhˆhen die Benutzerfreundlichkeit und Sicherheit.   Prototyping und Implementierung  Die iterative Prototypenerstellung wird in verschiedenen Phasen durchgef¸hrt 1. PrototypenentwicklungAufbau eines ersten Modells unter Verwendung kosteng¸nstiger Mikrokontroller und Sensoren, um die Grundfunktionalit‰ten zu testen. 2. FeldtestsDurchf¸hrung von kontrollierten Tests in unterschiedlichen Umgebungen, um die Robustheit und Effektivit‰t der Kollisionsvermeidung zu evaluieren. 3. OptimierungBasierend auf den Ergebnissen der Tests wird das System hinsichtlich Latenz, Reichweite und Nutzerfreundlichkeit optimiert.   Ausblick  Die  stellt einen innovativen Ansatz dar, um die Sicherheit im Straﬂenverkehr zu erhˆhen. Innovative Kommunikationsstrategien und ein sorgf‰ltig entwickelter Algorithmus zur Kollisionsvermeidung bieten die Grundlage f¸r zuk¸nftige Anwendungen, die ¸ber eine reine Fernsteuerung hinausgehen ñ beispielsweise in der Automatisierung der Logistik oder der Personenbefˆrderung.  Mit dieser Forschungsarbeit wird ein wichtiger Baustein gelegt f¸r die Weiterentwicklung autonomer Fahrzeuge und deren sicherer Integration in den urbanen Raum. Die gewonnenen Erkenntnisse kˆnnten einen bedeutenden Beitrag zur k¸nftigen Mobilit‰t leisten, indem sie Fahrzeuge nicht nur effizienter, sondern auch sicherer machen.;1
Vergleich zwischen Jetpack Compose und dem klassischen Ansatz in der App-Entwicklung  Die Entwicklung von mobilen Anwendungen hat sich im Laufe der Jahre erheblich gewandelt, wobei sich neue Frameworks und Paradigmen etabliert haben, um den sich st‰ndig ‰ndernden Anforderungen der Entwickler und Nutzer gerecht zu werden. Insbesondere Jetpack Compose, das moderne Toolkit f¸r die UI-Entwicklung in Android, steht im Kontrast zu den klassischen Ans‰tzen, die auf XML-Layouts und imperative Programmierung basieren. Dieser Vergleich beleuchtet die wesentlichen Unterschiede zwischen diesen beiden Ans‰tzen und deren Auswirkungen auf die App-Entwicklung.  Ein zentraler Aspekt des klassischen Ansatzes ist die Verwendung von XML-Dateien zur Definition von Benutzeroberfl‰chen. Entwickler erstellen Layouts durch das Schreiben von XML-Code, der dann in Java oder Kotlin mit logischen Komponenten verbunden wird. Diese Trennung von Layout und Logik kann zu einer erhˆhten Komplexit‰t f¸hren, insbesondere bei der Pflege und Skalierung von Anwendungen. ƒnderungen an der Benutzeroberfl‰che erfordern oft Anpassungen in mehreren Dateien, was die Wartbarkeit und Lesbarkeit des Codes beeintr‰chtigen kann. Zudem ist der Entwicklungsprozess oft iterativ, da ƒnderungen am UI h‰ufig getestet und erneut angepasst werden m¸ssen.  Im Gegensatz dazu verfolgt Jetpack Compose einen deklarativen Ansatz, bei dem die Benutzeroberfl‰che direkt in Kotlin-Code beschrieben wird. Dies ermˆglicht eine nahtlose Integration von UI-Elementen und deren Logik, was die Entwicklungszeit erheblich verk¸rzt. Entwickler kˆnnen UI-Komponenten als Funktionen definieren und diese dynamisch anpassen, basierend auf dem aktuellen Zustand der Anwendung. Diese Flexibilit‰t f¸hrt zu einem klareren und verst‰ndlicheren Code, da die Struktur der Benutzeroberfl‰che und deren Verhalten in einem zusammenh‰ngenden Kontext betrachtet werden. Dar¸ber hinaus erleichtert der deklarative Ansatz die Implementierung von Zustandsverwaltung und Animationen, da ƒnderungen am Zustand sofort in der Benutzeroberfl‰che reflektiert werden.  Ein weiterer Vorteil von Jetpack Compose ist die Unterst¸tzung f¸r Material Design und die Mˆglichkeit, benutzerdefinierte UI-Elemente mit minimalem Aufwand zu erstellen. Das Framework bietet eine Vielzahl von vorgefertigten Komponenten, die leicht anpassbar sind, und fˆrdert somit die Einhaltung von Designrichtlinien. Im klassischen Ansatz hingegen m¸ssen Entwickler oft eigene UI-Komponenten erstellen oder umfangreiche Anpassungen an bestehenden Komponenten vornehmen, was zeitaufwendig sein kann.  Allerdings bringt der Wechsel zu Jetpack Compose auch Herausforderungen mit sich. Da es sich um eine relativ neue Technologie handelt, kˆnnen Entwickler, die mit dem klassischen Ansatz vertraut sind, eine steile Lernkurve erleben. Zudem ist die Community und die Dokumentation im Vergleich zu den etablierten XML-basierten Ans‰tzen noch im Aufbau begriffen, was gelegentlich zu Unsicherheiten bei der Implementierung f¸hren kann.  Zusammenfassend l‰sst sich sagen, dass Jetpack Compose im Vergleich zum klassischen Ansatz zahlreiche Vorteile bietet, insbesondere in Bezug auf Codeklarheit, Wartbarkeit und Entwicklungsgeschwindigkeit. Der deklarative Ansatz ermˆglicht eine intuitivere und effizientere Gestaltung von Benutzeroberfl‰chen, w‰hrend die enge Integration von Logik und UI die Entwicklung dynamischer Anwendungen erleichtert. Dennoch m¸ssen Entwickler die Herausforderungen der neuen Technologie ber¸cksichtigen und bereit sein, sich in das Framework einzuarbeiten, um das volle Potenzial von Jetpack Compose auszuschˆpfen;1
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Things Network (TTN)  Die Bodenfeuchtigkeit ist ein kritischer Faktor in der Landwirtschaft, des Wassermanagements und der hydrogeologischen Forschung. Sie beeinflusst nicht nur das Wachstum von Pflanzen, sondern spielt auch eine bedeutende Rolle bei der N‰hrstoffdynamik und der Erhaltung der ˆkologischen Balance. In den letzten Jahren hat sich das Internet der Dinge (IoT) als Schl¸sseltechnologie herauskristallisiert, durch die Daten ¸ber Umgebungsbedingungen wie Bodenfeuchtigkeit in Echtzeit ¸berwacht und analysiert werden kˆnnen. Eine besonders vielversprechende Technologie in diesem Kontext ist Long Range Wide Area Network (LoRaWAN), unterst¸tzt durch Plattformen wie The Things Network (TTN).   1.  der Bodenfeuchtigkeitsmessung  Die Messung der Bodenfeuchtigkeit basiert auf physikalischen Prinzipien, die unterschiedliche Methoden und Technologien beleuchten. Zu den h‰ufig verwendeten Verfahren z‰hlen durch den Boden penetrierende Techniken, die Ver‰nderungen in der elektrischen Leitf‰higkeit und die dielektrische Spezifit‰t des Bodenmaterials ermitteln. Kapazitive Sensoren, die die ƒnderung der Dielektrizit‰tskonstante im Boden registrieren, oder ‰hnliche resistive Sensoren, die den Wassergehalt physisch durch Leitf‰higkeit messen, stellen Praktiken dar, die sowohl pr‰zise als auch kosteneffizient sind. Diese Methoden liefern quantitative Daten zur Bodenfeuchtigkeit, die auf verschiedene Anwendungsbereiche ¸bertragbar sind.   2. LoRaWAN als ‹bertragungstechnologie  LoRaWAN ist ein auf dem LoRa (Long Range) Protokoll basierendes Netzwerkprotokoll und zeichnet sich durch niedrigen Energieverbrauch, hohe Reichweite und groﬂe Netzwerk-Kapazit‰ten aus. Durch seine Architektur kann es Tausenden von Ger‰ten ermˆglichen, Daten ¸ber Geb¸hren-freie Frequenzen in l‰ndlichen oder st‰dtischen Gebieten mit geringer Infrastrukturanbindung zu ¸bertragen. Entscheidende Komponenten eines LoRaWAN-Netzwerks sind Sensoren, sogenannte Gateways sowie ein Internet-Backend, das spezifisch f¸r Datenspeicherung, -verarbeitung und -analytik dient. Die transportierten Datenpakete sind f¸r einmalige Messungsintervallen von wenigen Bytes optimiert, wodurch das Netzwerk ressourcenschonend betrieben werden kann.   3. The Things Network (TTN)  The Things Network ist eine offene, communitybasierte Plattform, die es ermˆglicht, LoRaWAN-basierte Anwendungen schnell und effizient zu erstellen und bereitzustellen. TTN stellt eine Reihe von Tools zur Verf¸gung, mit denen Daten von verschiedenen Sensoren erfasst, visualisiert und analysiert werden kˆnnen. Aktuell bietet TTN Anwendern die Mˆglichkeit die netzwerkweiten Ressourcen wie Gateways und Sicherheitsanspr¸che der LoRaWAN-Infrastruktur zu nutzen. Datenintegrierte Kl‰rung, Aufbereitung und Nutzung sind ¸ber Apps, Datenbanken oder Programmierschnittstellen ermˆglicht, was umfangreiche Apps f¸r reale Weltlˆsungen generiert. Diese Einladungen zur Zusammenarbeit innerhalb von TTN beg¸nstigen Gemeinschaft-Anwendungen und Verkehrsdatenanalyse durch den Austausch ˆffentlicher Nutzerdaten.   4. Entwicklung und Umsetzung eines LoRaWAN-gest¸tzten Bodenfeuchtigkeits;1
"2.3.1 Gateways
Jedes Lora-Gateway wird, mit Hilfe einer lokal abgelegten Kon?gurationsdatei, bei ei-
nem LoRaWAN-Netzwerkserver registriert. Ein Gateway empf‰ngt haupts‰chlich LoRa-
Nachrichten von den jeweiligen Nodes, welche sich in Reichweite be?nden und leitet diese
im Anschluss an den kon?gurierten LoRaWAN-Netzwerkserver weiter. Diese Weiterlei-
tung geschieht ¸ber eine aktive Internetverbindung zum Beispiel durch Mobilfunk, WiFi,
Ethernet oder Glasfaser. In l‰ndlichen Gebieten kann ein einzelnes Gateway Nachrichten
¸ber eine Entfernung von mehr als 15 Kilometern empfangen und senden, in dichten
st‰dtischen Umgebungen kˆnnen diese bis zu f¸nf Kilometer weit ¸bertragen werden. Ein
einziges Acht-Kanal-Gateway kann beispielsweise innerhalb von 24 Stunden bis zu 1,5
Millionen Nachrichten verarbeiten. Wenn jeder Node pro Stunde eine Nachricht sendet,
kann ein solches Gateway alleine bis zu 60.000 Ger‰te unterst¸tzen. Falls mehr Nachrichten
¸bertragen, beziehungsweise mehr Nodes eingebunden werden, muss einfach ein weiteres
Gateways in diesem Bereich hinzugef¸gt werden, um so die Last besser zu verteilen. Nodes,
die sich in der N‰he eines Gateways be?ndet, ¸bertragen die Daten mit einem niedrigen
Spreadingfaktor, da hier ein sehr geringes Link-Budget benˆtigt wird. Ein hˆherer Sprea-
dingfaktor wird verwendet, je weiter ein Node von einem Gateway entfernt ist, was wie in
Abschnitt 2.2 erw‰hnt, den Verarbeitungsaufwand der Nachricht steigert und die Bitrate
verringert.   Das Link-Budget de?niert die Verst‰rkungen und
D‰mpfungen der Komponenten, die ein Signal von der Sendeantenne bis zum Empfang
durch eine Empfangsantenne erf‰hrt. 
Gateways kˆnnen in zwei verschiedene Typen unterteilt werden: Auﬂen- und Innen-
Gateways. Innen-Gateways kˆnnen auch ÑPicozellì und Gateways f¸r den Auﬂenbereich
auch ÑMakrozellì genannt werden.
Indoor-Gateway
DieGatewaysf¸rdenInnenbereichsindg¸nstigerundwerdenzurAbdeckungvonBereichen
wie Wohnr‰umen, Kellern und mehrstˆckigen Geb‰ude verwendet, da die Sendeleistung
auch durch mehrere W‰nde geht. Diese Typen von Gateways haben meist intern verbaute
Antennen oder besitzen auﬂen angebrachte ÑPigtailì-Antennen. Je nach Position des
Gateway im Wohnbereich kann ein Gateway auch Nachrichten von Sensoren auﬂerhalb der
Wohnung empfangen, die mehrere Kilometer entfernt sind.  In Abbildung 3.12
ist das Indoor-Gateway The Things Indoor Gateway ( TTIG) f¸r den heimischen Gebrauch
zu sehen, welches direkt in die Steckdose gesteckt werden und sehr einfach eingerichtet
werden kann.";0
Mˆgliche und h‰u?g verwendete Modi?er kˆnnen im vorherigen Listing 3.5 eingesehen werden. Der Modi?er ?llMaxWidth() wird beispielsweise h‰u?g bei Row Composables verwendet, um sie auf die gesamte Bildschirmbreite auszudehnen . FillMaxSize() ?ndet h‰u?g Verwendung bei Childelementen, die den gesamten Raum ihres Parents ausf¸llen sollen. . Die Liste der mˆglichen Modi?ers, die das Framework zur Verf¸gung stellt, ist lang und kann ¸ber die o?zielle Dokumentation eingesehen werden. Dabei ist die Anzahl der Modi?ers, die auf ein Element angewendet werden kˆnnen, nicht eingeschr‰nkt. Sie kˆnnen in beliebiger Anzahl in einer Kette kombiniert werden. Zu Beachten ist bei der Kombination der Modi?er aber die Reihenfolge, in der die Funktionen aufgerufen werden. Diese spielt eine entscheidende Rolle, da jeder Modi?er in der Kette das Composable bearbeitet und es gleichzeitig f¸r den n‰chsten Modi?er in der Kette vorbereitet . Dies kann unter Umst‰nden zu ungewollten Auswirkungen f¸hren. Ebenfalls durch das Listing 3.5 veranschaulicht wird die Tatsache, dass auch bei der Verwendung von Modi?ern ‹bergabeparameter eingesetzt werden kˆnnen, welche zur Wiederverwendbarkeit des Composables beitragen. Beispielsweise wird dort der Parameter rowHeight vom aufrufenden Composable (dargestellt in Listing 3.1) ¸bergeben, um dyna- misch die Hˆhe der Row ¸ber den Modi?er height() zu steuern . Es ist zudem mˆglich, neben einzelnen Werten auch eine bereits de?nierte Kette von Modi?ern als Parameter zu ¸bergeben .;0
" Kapitel 2: Technische Grundlagen  Die digitale ‹berwachung, oft unter dem Begriff ""‹berwachungstechnologie"" zusammengefasst, ist integraler Bestandteil einer Vielzahl moderner gesellschaftlicher Systeme ñ von Strafverfolgungsbehˆrden ¸ber Finanzinstitutionen bis hin zu sozialen Plattformen. Um die Mˆglichkeiten und Gefahren dieser Technologien verstehen zu kˆnnen, ist es unerl‰sslich, die technischen Grundlagen zu analysieren. Dabei spielen Algorithmen, Datenbanken, Netzwerke und Sensoren eine entscheidende Rolle.   2.1 Algorithmen  Algorithmen sind zentrale Elemente der digitalen ‹berwachung. Sie sind Programme oder mathematische Verfahren, die zur Verarbeitung groﬂer Datenmengen entwickelt wurden. Dabei kommen insbesondere maschinelles Lernen und k¸nstliche Intelligenz zum Einsatz, um Muster zu erkennen und Vorhersagen zu treffen. Insbesondere der Einsatz von Algorithmen zur Verhaltensanalyse ist im Kontext der digitalen ‹berwachung von Bedeutung. Hierbei werden Daten ¸ber Nutzerverhalten in sozialen Netzwerken oder beim Surfen im Internet gesammelt, analysiert und interpretiert, um potenzielle Bedrohungen vorherzusehen oder Nutzer gezielt anzusprechen.  Ein Beispiel f¸r die praktische Anwendung ist die Predictive Policing Technologie. Hierbei werden historische Kriminalit‰tsdaten mithilfe von Algorithmen ausgewertet, um kriminalit‰tsbelastete Gebiete zu identifizieren und Polizeipr‰senz gezielt zu steuern. Diese Technologie hat jedoch auch ihre Schattenseiten; fehlerhafte Daten oder Vorurteile im Algorithmus kˆnnen zu ungerechtfertigten Strafverfolgungen und Diskriminierung f¸hren.   2.2 Datenbanken  Die Bewertung von Daten setzt auch vertrauensw¸rdige Datenbanken voraus. Diese bestehen aus groﬂen Sammlungen von Daten, die strukturiert und hochgradig austauschbar sind. In der ‹berwachungstechnologie spielen relationale Datenbanken sowie NoSQL-Datenbanken eine entscheidende Rolle, weil sie die Speicherung, Abrufung und Analyse von unfassbar groﬂen Datenmengen ermˆglichen.  Gut gestaltete Datenbanksysteme sind essenziell f¸r erfolgreiches Datenmanagement. Im Falle von ‹berwachungsmaﬂnahmen werden nicht nur reale Zeitpunkte aufgezeichnet, sondern dar¸ber hinaus safeguard-altiv und geographisch verortete Daten gespeichert, die sich zusammenschlieﬂen lassen, um Benutzer-ÑProfilesì zu erstellen. Dies kann Wirkzeitches Muster f¸r ihr Verhalten und ihre Pr‰ferenzen ?????-nenschutzrate-fancy volles Monitoring. Die Herausforderungen in diesem Kontext sind nicht nur der Datenschutz, sondern auch die Verantwortung der Unternehmen, die f¸r die Verarbeitung und mˆgliche Weiterverwendung diese gesammelten Daten verantwortlich sind.   2.3 Netzwerktechnologie  Netzwerktechnologien sind ein weiterer wichtiger Baustein der digitalen ‹berwachung. Die Technologien, die heute eingesetzt werden, reichen von einfachen Standortdiensten ¸ber komplexe Kommunikationsnetzwerke bis hin zu fortschrittlichen Endger‰ten. Senoren und Internet of Things (IoT) Ger‰te kˆnnen Informationen in Echtzeit an eindeutige Live¸bertragungen bereitstellen. Dies ????? barrows device Tracking f¸hrt dabei zur h‰ufigen Speicherung und ‹bertragung von Standorten, Bewegungshistorien oder einzelnen Verhaltensdata Codes und praktische Belege f¸r stetige Bewegungen sind h‰ufig nunmehr digital zugeschnitten auf Cloud-Dienste.  W‰hrend diese vernetzten Systeme kommen";1
"3.4.6 Erstellen von Push-Noti?cations
DiePush-Noti?cationswerdenbeidernativenApp¸berFirebaseumgesetzt. FCMbietetdie
Mˆglichkeit, ¸ber verschiedene Plattformen Nachrichten und Noti?cations zu verschicken.
Es kˆnne iOS, Web und Android Apps mit dem Service verwendet werden.
F¸r das Verwenden von FCMmuss die dazugehˆrige Bibliothek installiert werden. Dies
wird in der Build Gradle umgesetzt. Des Weiteren muss im Manifest die folgende Permission
hinzugef¸gt werden:
Es wird eine neue Kotlin Klasse erstellt, die von dem íFirebaseMessagingServiceí erbt, die
in der Bibliothek enthalten ist. In dieser Klasse werden die Methoden implementiert, die
f¸r das Verarbeiten der Push-Noti?cation benˆtigt werden.
F¸r die Verwendung der íFirebaseMessagingServiceí Klasse muss die Methode íonMes-
sageReceivedí ¸berschriebene werden. Diese in Listing 3.32 abgebildete Methode wird
aufgerufen, wenn ein Push-Noti?cation ankommt.
An dieser Stelle kann entschieden werden, ob die Nachricht direkt verarbeitet oder, falls sie
langl‰u?g ist, von einem anderen Dienst verarbeitet wird. Diese Funktion sollte nicht l‰nger
als 10 Sekunden laufen und muss damit im Code nicht beachtet werden. In dem Beispiel
der App, bei der lediglich eine Noti?cation erstellt wird, ist dies nicht von Bedeutung und
kann weggelassen werden.
F¸r das Benachrichtigen des Nutzers wird der Code aus Listing 3.25 verwendet und wird
inUnterabschnitt 3.4.3 beschrieben.
Damit die Push-Noti?cation an die Klasse zur Verarbeitung weitergegeben werden, muss
im Manifest ein Service angelegt werden.
Es wird ein Filter de?niert, sodass der Service nur aufgerufen wird, wenn es sich um ein
FCM Event handelt. Das Event lˆst einen Aufruf der beschriebenen íonMessageReceivedí
Methode der íMyFirebaseMessagingServiceí Klasse aus.
‹ber das Firebase Webinterface kˆnnen Push-Noti?cations erstellt und an die Endger‰te
gesendet werden. Dies ist in der Abbildung 3.13 zu erkennen.";0
  Die digitale Transformation hat die Notwendigkeit hervorgebracht, Inhalte effizient zu verwalten und bereitzustellen. Content-Management-Systeme (CMS) spielen hierbei eine zentrale Rolle, indem sie es ermˆglichen, digitale Inhalte zu erstellen, zu bearbeiten und zu verˆffentlichen. Die Auswahl des richtigen CMS ist entscheidend f¸r den Erfolg einer digitalen Strategie. In diesem Kontext ist die Implementierung einer eigenen CMS-Lˆsung besonders relevant, da sie eine maﬂgeschneiderte Anpassung an spezifische Bed¸rfnisse und Anforderungen eines Unternehmens ermˆglicht. Dieser Text beleuchtet die Vor- und Nachteile herkˆmmlicher CMS-Plattformen im Vergleich zu einer individuell entwickelten Lˆsung.  1. ‹bersicht ¸ber g‰ngige Content-Management-Systeme  Marktf¸hrende CMS wie WordPress, Joomla, und Drupal bieten umfassende Funktionen f¸r die Erstellung und Verwaltung von Webinhalten. Diese Systeme zeichnen sich durch ihre Benutzerfreundlichkeit, eine breite Palette an Plugins und Themen sowie eine aktive Community aus, die Unterst¸tzung und regelm‰ﬂige Updates bereitstellt. Die Implementierung eines solchen Systems erfordert in der Regel weniger technische Expertise, was es Unternehmen ermˆglicht, schnell zu starten und einfache Anpassungen vorzunehmen.   Allerdings kˆnnen sie in der Anpassungsf‰higkeit und Flexibilit‰t eingeschr‰nkt sein. In der Praxis bedeutet dies, dass spezifische Anforderungen oft durch zus‰tzliche Plugins oder maﬂgeschneiderte Lˆsungen realisiert werden m¸ssen, was die ‹bersichtlichkeit und Wartbarkeit der Website beeintr‰chtigen kann. Dar¸ber hinaus ist die Abh‰ngigkeit von externen Anbietern f¸r Updates und Support ein nicht zu untersch‰tzendes Risiko.  2. Die Implementierung einer eigenen CMS-Lˆsung  Die Entscheidung f¸r die Entwicklung eines eigenen CMS kann in vielen Szenarien vorteilhaft sein, insbesondere wenn Unternehmen ¸ber spezielle Anforderungen verf¸gen oder sich von Mitbewerbern differenzieren mˆchten. Die  ermˆglicht es, das System exakt an die Bed¸rfnisse des Unternehmens anzupassen, einschlieﬂlich spezifischer Funktionalit‰ten, Benutzeroberfl‰chen und Integrationen mit bestehenden Systemen.  Bei der Entwicklung eines maﬂgeschneiderten CMS m¸ssen jedoch erhebliche Ressourcen in Betracht gezogen werden. Die Planung, das Design und die Programmierung erfordern nicht nur technisches Know-how, sondern auch eine sorgf‰ltige Analyse der Anforderungen und Zielgruppen. Ein weiterer entscheidender Aspekt ist die langfristige Wartung und Aktualisierung des Systems, da dies fortlaufende Investitionen in Zeit und Geld bedeutet.  3. Vor- und Nachteile im Vergleich  Die Tabelle unten fasst die wesentlichen Vor- und Nachteile von herkˆmmlichen CMS und eigenen Lˆsungen zusammen | Kriterium                | Herkˆmmliches CMS                                     | Eigene Lˆsung                                       | |--------------------------|------------------------------------------------------|-----------------------------------------------------| | Anpassungsf‰higkeit       | Eingeschr‰nkt                                         | Hˆchste Flexibilit‰t                                | | Implementierungsaufwand  | Geringer                                              | Hoch                                              | | Langfristige Wartung     | Updates oft verf¸gbar, aber abh‰ngig vom Anbieter kann unzuverl‰ssig sein | Erfordert kontinuierliche Ressourcen und Fachwissen | | Kosten                   | Niedrigere Anfangsinvestitionen, mˆgliche versteckte Kosten durch Plugins | Hˆhere Anfangskosten, langfristige ROI mˆglich     | | Benutzerfreundlichkeit    | Oft intuitiv und leicht erlernbar                    | Abh‰ngig vom Design, benˆtigt Einarbeitungszeit    |  4. Fazit  Die Entscheidung zwischen der Implementierung eines herkˆmmlichen Content-Management-Systems und der Entwicklung einer eigenen Lˆsung h‰ngt maﬂgeblich von den individuellen Bed¸rfnissen und Ressourcen eines Unternehmens ab. W‰hrend g‰ngige CMS eine schnelle und benutzerfreundliche Mˆglichkeit bieten, Inhalte zu verwalten, kann eine maﬂgeschneiderte Lˆsung f¸r Unternehmen mit spezifischen Anforderungen und einer hohen Anpassungsbereitschaft erhebliche Vorteile in Bezug auf Flexibilit‰t und Kontrolle bieten. Letztlich sollte der Entscheidungsprozess von einer fundierten Analyse der Gesch‰ftsziele, der verf¸gbaren Ressourcen und des langfristigen Wartungsaufwands geleitet werden. In einer dynamischen digitalen Landschaft ist es unabdingbar, agil zu bleiben und die gew‰hlte Lˆsung an zuk¸nftige Herausforderungen anzupassen.;1
Eigenentwicklung in der Anforderungsanalyse an ein Aufgaben Management Tool zur Unterst¸tzung des studentischen Software Engineerings  In der vorliegenden Arbeit wird unter einer Eigenentwicklung die Konzeption und Implementierung eines spezifischen Software-Tools verstanden, das gezielt auf die Bed¸rfnisse und Anforderungen von Studierenden im Software Engineering zugeschnitten ist. Diese Entwicklung greift dabei sowohl auf moderne Technologiestandards als auch auf bew‰hrte Methoden des Software Engineering zur¸ck und soll als Tools die Organisation, Verfolgung und Verwaltung von Aufgaben innerhalb von studienbezogenen Projekten ermˆglichen.  Die Eigenentwicklung gilt als ein integrativer Ansatz, da sie s‰mtliche Phasen des Softwareentwicklungszyklus umfasst, beginnend bei der Anforderungsanalyse ¸ber das Design bis hin zur Implementierung und der anschlieﬂenden Evaluierung des Systems. Dabei werden spezifische Anforderungen erfasst, die aus der Perspektive der Nutzer ñ den Studierenden, Dozierenden und potenziellen Projektpartnern ñ durch Studenten erstellt und priorisiert werden. Ein solcher Nutzerfokus tr‰gt dazu bei, dass das entwickelte Tool nicht nur funktionale Anforderungen erf¸llt, sondern auch die Benutzerfreundlichkeit und Effizienz im Projektmanagement erhˆht.  In dieser Arbeit wird herausgearbeitet, wie durch die Umsetzung der Eigenentwicklung eines Aufgaben Management Tools konkrete organisatorische Herausforderungen des studentischen Software Engineering addressiert und durch anpassbare, vielseitige Features gelˆst werden kˆnnen. Die Eigenentwicklungsphase ermˆglicht es nicht nur, innovative Lˆsungskonzepte strategisch zu gestalten, sondern auch richtige Anpassungen an Nutzerfeedback z¸gig umzusetzen, sodass die Vernetzungs- und Lernprozesse unter Studierenden gefˆrdert werden.   Somit bildet die Eigenentwicklung eines Aufgaben Management Tools einen integralen Bestandteil zur Verbesserung der Studienqualit‰t im Bereich des Software Engineerings und veranschaulicht die Wechselwirkungen zwischen technischer Implementierung und Bildungspraxis.;1
"Evaluierung der wissenschaftlichen Arbeit: ""Evaluation von ElixirNerves als Plattform f¸r IoT-Anwendungen""  1. Einleitung und Zielsetzung  Die vorliegende Arbeit besch‰ftigt sich mit der Evaluation von ElixirNerves, einer speziellen Plattform f¸r die Entwicklung von IoT-Anwendungen. Die Einf¸hrung in das Thema gibt einen klaren ‹berblick ¸ber den aktuellen Stand der IoT-Technologien und die Herausforderungen, die Entwickler h‰ufig begegnen. Die Zielsetzung der Arbeit, die Vor- und Nachteile von ElixirNerves im Vergleich zu anderen Plattformen zu untersuchen, wird deutlich formuliert und ist von hoher Relevanz f¸r die Forschung und Praxis im Bereich der Internet of Things.  2. Theoretischer Rahmen  Die Arbeit bietet einen soliden theoretischen Rahmen, der die Grundlagen von IoT, die spezifischen Anforderungen an IoT-Anwendungen und die Besonderheiten der Elixir-Programmierung umfasst. Die Autorin/der Autor definitions von zentralen Begriffen und Konzepten ist pr‰zise und gut strukturiert. Dies ermˆglicht dem Leser, ein umfassendes Verst‰ndnis der Materie zu entwickeln, bevor in die Evaluation der Plattform eingetaucht wird.  3. Methodik  Die Methoden, die zur Evaluation von ElixirNerves eingesetzt wurden, sind klar dargestellt. Die Verwendung von qualitativen und quantitativen Ans‰tzen bietet eine ausgewogene Perspektive. Die Entwicklung und Nutzung von Prototypen zur praktischen Erprobung von Funktionen ist ein besonders wertvoller Aspekt der Methodik. Es w‰re jedoch w¸nschenswert, detailliertere Informationen zu den Auswahlkriterien f¸r die getesteten Prototypen sowie zu den durchgef¸hrten Tests zu erhalten.  4. Ergebnisse  Die Ergebnisse der Evaluation sind gut strukturiert und vermitteln sowohl technische als auch Benutzererfahrungen. Die Analyse der Leistungsf‰higkeit, der Benutzerfreundlichkeit und der Integration von ElixirNerves mit anderen Technologien zeigt deutlich die St‰rken und Schw‰chen der Plattform. Grafiken und Tabellen, die die Ergebnisse untermauern, sind hilfreich und erhˆhen die Nachvollziehbarkeit der Argumentation. Dennoch kˆnnten einige Ergebnisse genauer erl‰utert werden, insbesondere im Hinblick auf deren praktischen Nutzen f¸r Entwickler.  5. Diskussion  Die Diskussion der Ergebnisse ist fundiert und kritisch. Die Autorin/der Autor vergleicht ElixirNerves mit anderen g‰ngigen IoT-Plattformen und bringt wertvolle Perspektiven ein. Die Reflexion ¸ber die mˆglichen Anwendungsgebiete und die Zielgruppe von ElixirNerves ist besonders hervorzuheben. Allerdings kˆnnte die Diskussion noch durch das Einbeziehen von Expertenmeinungen oder weiterf¸hrenden Literaturquellen vertieft werden.  6. Fazit und Ausblick  Das Fazit fasst die wichtigsten Erkenntnisse pr‰gnant zusammen und gibt einen klaren Ausblick auf die zuk¸nftigen Entwicklungen im Bereich von ElixirNerves. Die Implikationen f¸r die Entwicklung von IoT-Anwendungen werden gut herausgearbeitet. Es w‰re jedoch hilfreich, wenn die Autorin/der Autor auch Herausforderungen adressiert, die bei der breiten Einf¸hrung von ElixirNerves auftreten kˆnnten.  7. Stil und Pr‰sentation  Die Arbeit ist insgesamt gut strukturiert und verst‰ndlich geschrieben. Die Verwendung technischer Begriffe ist angemessen und die Lesbarkeit ist durchg‰ngig hoch. Die Quellenangaben sind vollst‰ndig und gem‰ﬂ den akademischen Standards korrekt formatiert.  Fazit  Insgesamt bietet die wissenschaftliche Arbeit eine umfassende und fundierte Evaluation der Plattform ElixirNerves f¸r IoT-Anwendungen. Sie leistet einen wertvollen Beitrag zur Forschung auf diesem Gebiet und ist sowohl f¸r Praktiker als auch f¸r Wissenschaftler von Interesse. Es gibt einige Bereiche, in denen zus‰tzliche Tiefe und Klarheit von Nutzen w‰ren, jedoch ¸berwiegen die St‰rken deutlich. Die Arbeit stellt somit eine empfehlenswerte Lekt¸re f¸r jeden dar, der sich mit der Entwicklung von IoT-Anwendungen auseinandersetzt.";1
Konzept f¸r eine wissenschaftliche Arbeit: Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger‰tes  Einleitung  Die Luftqualit‰t in geschlossenen R‰umen hat einen signifikanten Einfluss auf die Gesundheit und das Wohlbefinden der Menschen. Mit der zunehmenden Urbanisierung und der steigenden Luftverschmutzung wird die Notwendigkeit, die Luftqualit‰t in Innenr‰umen zu verbessern, immer dringlicher. Luftreinigungsger‰te spielen dabei eine entscheidende Rolle. Diese Arbeit befasst sich mit der Optimierung eines um Elektronik erweiterten Luftreinigungsger‰tes, wobei der Fokus auf der Verbesserung der Visualisierung, der Bedienung und der Selbstregelung liegt.  Zielsetzung  Das Hauptziel dieser Arbeit ist es, ein Luftreinigungsger‰t zu entwickeln, das nicht nur effektiv Schadstoffe aus der Luft entfernt, sondern auch eine benutzerfreundliche Schnittstelle bietet und sich selbstst‰ndig an die aktuellen Bedingungen anpasst. Die Optimierung der Visualisierung soll den Nutzern helfen, die Luftqualit‰t besser zu verstehen und informierte Entscheidungen zu treffen. Die Bedienung des Ger‰tes soll intuitiv gestaltet werden, um die Nutzererfahrung zu verbessern. Dar¸ber hinaus soll die Selbstregelung des Ger‰tes sicherstellen, dass es effizient arbeitet, ohne dass der Nutzer st‰ndig eingreifen muss.  Methodik  Die Forschung wird in mehreren Phasen durchgef¸hrt:  1. Literaturrecherche: Eine umfassende Analyse bestehender Luftreinigungsger‰te und deren Funktionen wird durchgef¸hrt. Hierbei werden aktuelle Technologien und Benutzeroberfl‰chen untersucht, um Best Practices zu identifizieren.  2. Bedarfsanalyse: Durch Umfragen und Interviews mit Nutzern werden deren Bed¸rfnisse und Erwartungen an Luftreinigungsger‰te ermittelt. Dies umfasst die Erfassung von Informationen ¸ber bevorzugte Visualisierungen, Bedienkonzepte und Automatisierungsw¸nsche.  3. Prototypenentwicklung: Basierend auf den Erkenntnissen der Literaturrecherche und der Bedarfsanalyse wird ein Prototyp entwickelt. Dieser Prototyp wird mit modernen elektronischen Komponenten ausgestattet, die eine flexible Visualisierung und eine benutzerfreundliche Bedienoberfl‰che ermˆglichen.  4. Test und Evaluation: Der entwickelte Prototyp wird in realen Umgebungen getestet. Nutzerfeedback wird gesammelt, um die Benutzerfreundlichkeit und die Effektivit‰t der Selbstregelung zu bewerten. Dar¸ber hinaus werden die Leistungsdaten des Ger‰tes hinsichtlich der Luftreinigungseffizienz analysiert.  5. Optimierung: Basierend auf den Testergebnissen werden Anpassungen am Prototyp vorgenommen, um die Visualisierung, Bedienung und Selbstregelung weiter zu optimieren.  Erwartete Ergebnisse  Die Arbeit erwartet, dass die entwickelten Lˆsungen zu einer signifikanten Verbesserung der Nutzererfahrung f¸hren. Eine klare und ansprechende Visualisierung der Luftqualit‰t, eine intuitive Bedienoberfl‰che sowie eine effektive Selbstregelung sollen dazu beitragen, dass Nutzer das Ger‰t effizienter und effektiver einsetzen kˆnnen. Zudem kˆnnte die Arbeit neue Maﬂst‰be f¸r die Entwicklung zuk¸nftiger Luftreinigungsger‰te setzen.  Schlussfolgerung  Die Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger‰tes hat das Potenzial,;1
 Kapitel 2: Technische Grundlagen produktorientierter Metriken der Softwarequalit‰t  Die Qualit‰t von Software ist ein zentrales Anliegen in der Softwareentwicklung, da sie einen direkten Einfluss auf die Benutzerzufriedenheit, die Wartbarkeit und die langfristige Stabilit‰t von Systemen hat. In diesem Kontext gewinnen produktorientierte Metriken zunehmend an Bedeutung. Diese Metriken ermˆglichen es, die Softwarequalit‰t aus der Perspektive des Endprodukts zu bewerten, anstatt sich ausschlieﬂlich auf Prozesse oder Entwicklungspraktiken zu konzentrieren. In diesem Kapitel werden die technischen Grundlagen produktorientierter Metriken der Softwarequalit‰t erl‰utert, um ein fundiertes Verst‰ndnis f¸r ihre Definition und Anwendung zu schaffen.   2.1 Definition produktorientierter Metriken  Produktorientierte Metriken sind quantitative Maﬂe, die spezifische Eigenschaften von Softwareprodukten bewerten. Sie fokussieren sich auf die Analyse der Software selbst, anstatt auf die Prozesse, die zu ihrer Entwicklung gef¸hrt haben. Zu den h‰ufigsten produktorientierten Metriken z‰hlen:  - Codequalit‰t: Metriken wie Code-Komplexit‰t, Lesbarkeit und Dokumentation, die die Struktur und Verst‰ndlichkeit des Codes bewerten. - Fehlerraten: Die Anzahl der Fehler oder Bugs, die in einer bestimmten Softwareversion identifiziert wurden, im Verh‰ltnis zur Gesamtzahl der Funktionen oder Codezeilen. - Testabdeckung: Der Anteil des Codes, der durch automatisierte Tests abgedeckt ist, was einen Hinweis auf die Robustheit und Zuverl‰ssigkeit der Software gibt. - Wartbarkeit: Metriken, die die Leichtigkeit messen, mit der Software modifiziert oder erweitert werden kann, oft unter Verwendung von Faktoren wie Zyklomatische Komplexit‰t oder Anzahl der Abh‰ngigkeiten.   2.2 Relevanz produktorientierter Metriken  Die Relevanz produktorientierter Metriken liegt in ihrer F‰higkeit, objektive und messbare Daten ¸ber die Qualit‰t von Softwareprodukten zu liefern. Diese Metriken unterst¸tzen Entwickler und Projektmanager dabei, fundierte Entscheidungen zu treffen, indem sie einen klaren ‹berblick ¸ber den aktuellen Stand der Softwarequalit‰t geben. Sie sind auch entscheidend f¸r die Kommunikation von Qualit‰tssicherungsmaﬂnahmen an Stakeholder, da sie als Grundlage f¸r Berichterstattung und Analyse dienen.   2.3 Technische Grundlagen der Metriken  Die Erhebung und Analyse produktorientierter Metriken erfordert ein tiefes Verst‰ndnis der zugrunde liegenden technischen Aspekte. Hierzu gehˆren:  - Datenquellen: Produktorientierte Metriken basieren h‰ufig auf verschiedenen Datenquellen, wie Quellcode-Repositories, Bug-Tracking-Systemen und Testmanagement-Tools. Die Integration dieser Datenquellen ist entscheidend f¸r eine umfassende Analyse.    - Metrikberechnung: Die Berechnung von Metriken erfolgt in der Regel automatisiert durch spezielle Software-Tools, die den Quellcode analysieren und relevante Kennzahlen extrahieren. Beispiele hierf¸r sind Tools wie SonarQube, das die Codequalit‰t bewertet, oder JUnit, das die Testabdeckung misst.  - Interpretation der Ergebnisse: Die Ergebnisse der Metrikberechnungen m¸ssen im Kontext interpretiert werden. Dies erfordert ein Verst‰ndnis der Normen und Benchmarks in der Branche;1
Transparent operating modeDefault-Modus. Das Ger‰t verh‰lt sich als ein Er- satz f¸r eine serielle Verbindung. Dabei werden alle UART-Daten, die ¸ber den DIN-Pin erhalten wer- den f¸r die drahtlose ‹bertragung gepuffert und alle empfangenen Daten durch den DOUT-Pin aus- gegeben. Dieser Modus ist bei Anbindung ¸ber die SPI-Schnittstelle nicht verf¸gbar. API operating modeAlternativer Modus zum transparenten Modus, er- laubt es die Daten auf Paket-Ebene zu kontrollieren. Command modeModus, in dem die Firmware die eintreffenden Zei- chen als Befehle interpretiert. Dies erlaubt die Mo- difizierung der Einstellungen und Parameter. Die- ser Modus ist immer verf¸gbar, wenn einer der anderen Modi aktiv ist und steht auch auf dem UART-Interface zur Verf¸gung. Idle modeWenn keine Daten ¸bertragen werden, dann befin- det sich das Xbee-Modul im Idle-Mode. Dabei wird auf valide Daten, die drahtlos oder ¸ber serielle Schnittstellen ¸bertragen werden, gewartet. Transmit modeModus, in dem Daten ¸bermittelt werden. Typi- scherweise nach Erhalt von Daten ¸ber eine serielle Schnittstelle. Receive mode Modus, in dem Daten empfangen werden. Dieser Modus wird zwar in der Anleitung nicht explizit als eigener Modus aufgelistet, l‰sst sich jedoch ¸ber die Software Digi XCTU als eigener Modus ausw‰hlen. Dieser Modus erlaubt die Pro- grammierung des Xbee-Moduls mit der Sprache Micropython.;0
Dementsprechend m¸ssen auch Kontaktpunkte der Systeme so entworfen werden, dass diese sich nahtlos in den Alltag der Menschen integrieren. Um als System dennoch zu funktionieren, verlangt dies nach spezialisierten Architekturen, die von herkˆmmlichen Computersystemen abweichen. Wie beschrieben ist hier eine offizielle Standardisierung quasi nicht vorhanden, jedoch haben sich in den letzten Jahren mehrere beliebte Syste- marchitekturen entwickelt. Dabei ist eine der in der Literatur am h‰ufigsten genannten Architekturen die ÑThree Layerì Architektur wie in Abbildung 2.1 zu sehen. Deren Name leitet sich daraus ab, dass das System in drei Schichten geteilt wird.  Diese bestehen aus der Wahrneh- mungsschicht , derNetzwerkschicht und derAnwendungsschicht . Dabei wird die Wahrnehmungsschicht zum Teil auch die physische Schicht genannt, da diese durch Sensoren die Verbindung der digitalen Systeme mit der physischen Welt darstellt. Dies geschieht zumeist durch eingebettete Ger‰te wie Mikrocontroller mit angeschlossenen Sensoren verschiedener Art.  Die Netzwerkschicht stellt jegliche Kommunikation zwischen dieser Datensammlungsschicht und der Anwendungsschicht bereit und enth‰lt daher versschiedene Technologien zum Datenverkehr. Das beinhaltet allgemeine Technologien wie kabelgebundenes oder kabelloses Local Area Network ( LAN), Bluetooth aber auch spezialisiertere wie Zigbee oder Controller Area Network (CAN)-Implementierungen. Bei der Anwendungsschicht handelt es sich dabei weniger um ein einzelnes Ger‰t, sondern um die Weiterverarbeitung und Nutzung der gesammelten Daten im Allgemeinen. Das kann sowohl die Abspeicherung der Daten auf einem Server oder auch Verarbeitung und Weitergabe an andere Systeme darstellen. Generell befindet sich diese Schicht auf der Ebene von g‰ngigen Computersystemen, bzw. stellt den ‹bergang zu diesen Systemen dar.;0
 Technologischer Grundlagenteil: Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15  Die vorliegende Arbeit besch‰ftigt sich mit der Entwicklung einer Fahrzeugfernsteuerung, die in der Lage ist, Kollisionen zu vermeiden. Ein zentraler Bestandteil dieser Entwicklung ist die Nutzung des IEEE 802.15 Standards, der eine flexible und zuverl‰ssige Kommunikation zwischen Fahrzeugen und Steuerungseinheiten ermˆglicht. In diesem Grundlagenteil werden die grundlegenden Technologien und Konzepte vorgestellt, die f¸r die Realisierung einer solchen Fahrzeugfernsteuerung erforderlich sind.   1. IEEE 802.15: Grundlagen und Anwendungsbereiche  IEEE 802.15 ist eine Norm, die Standards f¸r drahtlose persˆnliche Netzwerke (Wireless Personal Area Networks, WPANs) definiert. Diese Norm umfasst verschiedene Spezifikationen, die sich f¸r unterschiedliche Anwendungen eignen, darunter Bluetooth, Zigbee und WirelessHART. Insbesondere die Spezifikationen f¸r Zigbee sind von Interesse, da sie f¸r Anwendungen in der Automatisierungstechnik und im Internet der Dinge (IoT) optimiert sind. Die Vorteile von IEEE 802.15 liegen in der geringen Energieaufnahme, der hohen Reichweite und der F‰higkeit, eine Vielzahl von Ger‰ten in einem Netzwerk zu integrieren.   2. Fahrzeugfernsteuerung: Konzepte und Anforderungen  Die Fahrzeugfernsteuerung erfordert eine pr‰zise und zuverl‰ssige Kommunikation zwischen der Steuerungseinheit und dem Fahrzeug. Zu den grundlegenden Anforderungen gehˆren:  - Echtzeitkommunikation: Um Kollisionen zu vermeiden, m¸ssen Daten in Echtzeit ¸bermittelt werden. Dies erfordert eine niedrige Latenzzeit und eine hohe ‹bertragungsrate. - Zuverl‰ssigkeit: Die Kommunikation muss auch unter schwierigen Bedingungen, wie z.B. in st‰dtischen Umgebungen mit vielen Stˆrungen, zuverl‰ssig funktionieren. - Sicherheit: Die ‹bertragung von Steuerbefehlen und Sensordaten muss vor unbefugtem Zugriff und Manipulation gesch¸tzt werden.   3. Kollisionsvermeidung: Sensorik und Algorithmen  Ein entscheidender Aspekt der Fahrzeugfernsteuerung ist die Implementierung von Kollisionsvermeidungsalgorithmen. Hierbei kommen verschiedene Sensoren zum Einsatz, die Informationen ¸ber die Umgebung des Fahrzeugs sammeln. Zu den g‰ngigen Sensortechnologien z‰hlen:  - Lidar: Diese Technologie nutzt Laserstrahlen zur Erfassung von Entfernungen und zur Erstellung von 3D-Karten der Umgebung. Lidar-Sensoren bieten eine hohe Genauigkeit und sind in der Lage, Hindernisse pr‰zise zu erkennen. - Kameras: Bildverarbeitungssysteme kˆnnen zur Erkennung von Objekten und zur Analyse von Verkehrssituationen eingesetzt werden. Durch den Einsatz von maschinellem Lernen kˆnnen diese Systeme kontinuierlich verbessert werden. - Ultraschallsensoren: Diese Sensoren sind kosteng¸nstig und eignen sich gut zur Erkennung von Objekten in unmittelbarer N‰he des Fahrzeugs.  Die Daten, die von diesen Sensoren erfasst werden, m¸ssen in Echtzeit verarbeitet werden, um geeignete Steuerbefehle zu generieren. Hierbei kommen Algorithmen zur Anwendung, die auf Techniken wie maschinelles;1
In der vorliegenden Arbeit wurde eine umfassende Gegen¸berstellung von Content-Management-Systemen (CMS) durchgef¸hrt, um deren jeweilige St‰rken und Schw‰chen zu analysieren und potenziellen Nutzern eine fundierte Entscheidungsgrundlage zu bieten. Die Untersuchung hat gezeigt, dass die Wahl des geeigneten CMS maﬂgeblich von den spezifischen Anforderungen und Zielen der Nutzer abh‰ngt.   Die analysierten Systeme, darunter WordPress, Joomla und Drupal, weisen jeweils charakteristische Merkmale auf, die sie f¸r unterschiedliche Einsatzszenarien pr‰destinieren. WordPress ¸berzeugt durch seine Benutzerfreundlichkeit und die groﬂe Community, die eine Vielzahl von Plugins und Themes bereitstellt. Joomla bietet hingegen eine ausgewogene Kombination aus Benutzerfreundlichkeit und Flexibilit‰t, w‰hrend Drupal sich durch seine hohe Anpassungsf‰higkeit und Sicherheit auszeichnet, was es besonders f¸r komplexe und umfangreiche Projekte geeignet macht.  Zudem wurde deutlich, dass neben den funktionalen Aspekten auch Faktoren wie die langfristige Wartbarkeit, die Lernkurve f¸r neue Nutzer sowie die Unterst¸tzung durch die Community eine entscheidende Rolle spielen. Die Analyse hat auch die Bedeutung von Aspekten wie SEO-Freundlichkeit, Multilingualit‰t und Responsivit‰t hervorgehoben, die in der heutigen digitalen Landschaft unverzichtbar sind.  Insgesamt l‰sst sich festhalten, dass es kein Ñone-size-fits-allì-CMS gibt. Die Entscheidung f¸r ein bestimmtes System sollte daher stets im Kontext der individuellen Bed¸rfnisse und Ressourcen erfolgen. Zuk¸nftige Forschungen kˆnnten sich darauf konzentrieren, die Entwicklungen im Bereich der CMS-Technologien weiter zu beobachten und die Auswirkungen neuer Trends, wie K¸nstliche Intelligenz und Headless-Architekturen, auf die CMS-Landschaft zu untersuchen. Diese Erkenntnisse kˆnnten wertvolle Impulse f¸r die Weiterentwicklung und Optimierung von Content-Management-Systemen liefern.;1
Kotlin ist eine Programmiersprache, welche f¸r Android Apps verwendet werden kann. Die Katzenklappen App wird mit Kotlin programmiert, da Kotlin mittlerweile der Standard f¸r die Android App-Entwicklung ist. Durch die verk¸rzte Syntax im Vergleich zu Java l‰sst sich Kotlin Code schnell und ¸bersichtlich schreiben . Auﬂerdem wird beim Kompilieren von Kotlin Code der gleiche Bytecode wie bei Java erzeugt. Dies sorgt daf¸r, dass Kotlin kompatibel mit Java ist. Somit kann Kotlin auch in vorhandenen Java Projekten verwendet werden, ohne den Java Code umschreiben zu m¸ssen. Trotzdem bietet Android Studio eine Option an, Java Code zu Kotlin Code zu konvertieren. In Kotlin wird zwischen zwei Arten von Variablen unterschieden. Es gibt ver‰nderliche und unver‰nderliche Variablen. Eine ver‰nderliche Variable beginnt mit dem Schl¸sselwort var. Diese kann im Code ¸berschrieben und somit ver‰ndert werden. Unver‰nderliche beziehungsweise konstante Variablen beginnen mit dem Schl¸sselwort val. Sie erhalten einen Wert bei der Deklaration zugewiesen und kˆnnen danach nicht mehr ver‰ndert, sondern nur noch gelesen werden . Um einer Variable einen Datentypen zuzuweisen gibt es in Kotlin zwei Mˆglichkeiten. Die erste Mˆglichkeit ist, dass bei der Deklaration der Variable der Datentyp explizit angegeben wird. Ein Beispiel dazu w‰re var name: String . Diese Variable wird mit dem String Datentyp definiert.;0
 Vergleich zwischen Compose und dem klassischen Ansatz: Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst¸tzung des studentischen Software Engineerings   Einleitung Die Anforderungsanalyse ist ein wesentlicher Schritt im Software Engineering, der die Grundlage f¸r die Entwicklung effektiver Softwarelˆsungen legt. In diesem Zusammenhang werden zwei verschiedene Ans‰tze zur Durchf¸hrung einer Anforderungsanalyse betrachtet: der klassische Ansatz und der moderne Ansatz mit Compose. Dieser Vergleich beleuchtet die Unterschiede, Vor- und Nachteile der beiden Methoden, insbesondere im Kontext eines Aufgabenmanagement-Tools zur Unterst¸tzung des studentischen Software Engineerings.   Klassischer Ansatz   Eigenschaften Der klassische Ansatz zur Anforderungsanalyse folgt einem strukturierten, sequenziellen Prozess, der typischerweise die Phasen der Anforderungsaufnahme, -dokumentation und -validierung umfasst. Dieser Ansatz basiert h‰ufig auf Wasserfallmodellen, die eine lineare Abfolge von Phasen beschreiben.   Vorteile 1. Struktur und Klarheit: Der klassische Ansatz bietet eine klare und nachvollziehbare Struktur, die es ermˆglicht, die Anforderungen in Systematik zu erfassen und zu dokumentieren. 2. Umfangreiche Dokumentation: Umfassende Dokumentation der Anforderungen, die als Referenz f¸r die gesamte Projektlaufzeit dient. 3. Risiko-Minimierung: Durch genaue Planung und Definition der Anforderungen kann das Risiko von Missverst‰ndnissen w‰hrend der Implementierung reduziert werden.   Nachteile 1. Inflexibilit‰t: Einmal festgelegte Anforderungen sind oft schwer zu ‰ndern, was zu Problemen f¸hren kann, wenn sich die Bed¸rfnisse der Benutzer w‰hrend der Entwicklung ‰ndern. 2. Lange Zeitspanne bis zur Umsetzung: Die vollst‰ndige Anforderungsanalyse kann viel Zeit in Anspruch nehmen, wodurch das Projekt versp‰tet starten kann. 3. Mangelnde Benutzerfeedbackschleifen: Die Interaktion mit den tats‰chlichen Benutzern ist in diesem Ansatz oft begrenzt, was zu einem Produkt f¸hren kann, das nicht optimal auf die Benutzerbed¸rfnisse abgestimmt ist.   Compose   Eigenschaften Compose ist ein modernes, iteratives und agiles Framework, das sich stark auf Benutzerfeedback und kontinuierliche Verbesserung st¸tzt. Es fˆrdert die enge Zusammenarbeit zwischen Entwicklern und Benutzern in allen Phasen der Entwicklung.   Vorteile 1. Flexibilit‰t: Anforderungen kˆnnen w‰hrend des gesamten Entwicklungsprozesses angepasst und verfeinert werden, was besser auf sich ‰ndernde Benutzerbed¸rfnisse reagiert. 2. Schnelleres Prototyping: Durch schnelle Iterationen und das Erstellen von Prototypen kˆnnen Benutzer ihre Eindr¸cke einbringen, was die Benutzerfreundlichkeit erhˆht. 3. Verbesserte Benutzerbeteiligung: Durch die enge Zusammenarbeit mit den Endbenutzern kˆnnen die Anforderungen pr‰ziser erfasst und umgesetzt werden, was zu hˆherer Benutzerzufriedenheit f¸hrt.   Nachteile 1. Weniger Dokumentation: Der Fokus auf Agilit‰t und Flexibilit‰t kann zu unzureichender Dokumentation f¸hren, was langfristig die Wartbarkeit und Nachvollziehbarkeit eines Projekts erschweren kann. 2. Mˆgliche Unsicherheiten: Die iterative Natur kann dazu f¸hren, dass die Anforderungen nicht zu jedem Zeitpunkt klar definiert sind, was das Risiko von Missverst‰ndnissen erhˆht. 3. Initialer Aufwand zur Benutzerakquise: Es kann zus‰tzlichen Aufwand kosten, die Benutzer zur aktiven Teilnahme am Entwicklungsprozess zu motivieren.   Fazit Der Vergleich zwischen dem klassischen Ansatz und Compose zeigt deutlich, dass jede Methode ihre eigenen St‰rken und Schw‰chen hat, die je nach Kontext und Anforderungen des Projekts unterschiedlich gewichtet werden sollten. F¸r Projekte im Bereich des studentischen Software Engineerings, bei denen Flexibilit‰t, Benutzerfeedback und kontinuierliche Verbesserung von groﬂer Bedeutung sind, scheint Compose eine geeignete Wahl zu sein. Der klassische Ansatz hingegen kann in Umgebungen, in denen eine klare Struktur und umfassende Dokumentation von Bedeutung sind, von Vorteil sein.  Eine hybride Strategie, die Elemente beider Ans‰tze kombiniert, kˆnnte eine vielversprechende Lˆsung sein, um sowohl die Vorteile der strukturierten Anforderungsanalyse als auch die Flexibilit‰t der agilen Methoden zu nutzen.;1
Tracking der Bodenfeuchtigkeit mit LoRaWAN und The Things Network  Die ‹berwachung der Bodenfeuchtigkeit ist von zentraler Bedeutung f¸r die Landwirtschaft, das Umweltmanagement und die nachhaltige Ressourcennutzung. In den letzten Jahren hat sich das Internet der Dinge (IoT) als Schl¸sseltechnologie zur Erfassung und ‹bertragung von Umweltdaten etabliert. Insbesondere die Low Power Wide Area Network (LPWAN)-Technologie LoRaWAN (Long Range Wide Area Network) hat sich als vielversprechend erwiesen, um kosteng¸nstige und energieeffiziente Lˆsungen f¸r die Fern¸berwachung zu bieten. In diesem Text wird die  zur ‹berwachung der Bodenfeuchtigkeit unter Verwendung von LoRaWAN und The Things Network (TTN) beschrieben.   1. Grundlagen der Technologie  LoRaWAN ist ein Protokoll f¸r drahtlose Netzwerke, das auf der Chirp Spread Spectrum-Technologie basiert. Es ermˆglicht die ‹bertragung von kleinen Datenmengen ¸ber groﬂe Entfernungen, w‰hrend es gleichzeitig den Energieverbrauch minimiert. Dies ist besonders vorteilhaft f¸r Anwendungen, bei denen Sensoren in abgelegenen Gebieten eingesetzt werden, wo eine st‰ndige Stromversorgung nicht gew‰hrleistet ist.  The Things Network (TTN) ist ein offenes, globales Netzwerk, das auf LoRaWAN basiert und es Nutzern ermˆglicht, ihre IoT-Ger‰te einfach zu verbinden und Daten zu ¸bertragen. TTN bietet eine benutzerfreundliche Plattform zur Verwaltung von Ger‰ten, zur Datenvisualisierung und zur Integration in bestehende Systeme.   2. Systemarchitektur  Die Implementierung eines Bodenfeuchtesensors umfasst mehrere Komponenten - SensorhardwareEin geeigneter Sensor zur Messung der Bodenfeuchtigkeit, wie z.B. ein kapazitiver Bodenfeuchtesensor, wird benˆtigt. Dieser Sensor sollte in der Lage sein, pr‰zise Messungen in unterschiedlichen Bodentypen durchzuf¸hren.  - MikrocontrollerEin Mikrocontroller wie der Arduino oder der ESP32 wird verwendet, um die Sensordaten zu erfassen und ¸ber LoRaWAN zu ¸bertragen. Diese Mikrocontroller sind kosteng¸nstig und verf¸gen ¸ber eine breite Unterst¸tzung in der Entwicklergemeinschaft.  - LoRaWAN-ModulEin LoRaWAN-Modul, wie das RFM95W, wird in das System integriert, um die Kommunikation mit dem TTN-Netzwerk zu ermˆglichen.  - Backend und DatenvisualisierungDie gesammelten Daten werden an TTN gesendet, wo sie verarbeitet und in einer Datenbank gespeichert werden. Anschlieﬂend kˆnnen die Daten ¸ber eine Webanwendung oder eine mobile App visualisiert werden.   3. Implementierungsschritte   3.1. Hardwarekonfiguration  Zun‰chst erfolgt die Auswahl und der Anschluss der Hardware. Der Bodenfeuchtesensor wird an den Mikrocontroller angeschlossen. Der Mikrocontroller wird mit dem LoRaWAN-Modul verbunden, um die Sensordaten zu ¸bertragen. Eine geeignete Stromquelle, wie ein Solarpanel oder eine Batterie, sorgt f¸r die Energieversorgung des Systems.   3.2. Softwareentwicklung  Die Programmierung des Mikrocontrollers erfolgt in einer geeigneten Entwicklungsumgebung, wie der Arduino IDE. Der Code umfasst die Initialisierung des Sensors;1
   Die fortschreitende Digitalisierung und die Verbreitung des Internets der Dinge (IoT) haben zu einer exponentiellen Zunahme von vernetzten Ger‰ten gef¸hrt, die in einer Vielzahl von Anwendungsbereichen eingesetzt werden. Diese Entwicklung erfordert robuste, skalierbare und flexible Plattformen zur Unterst¸tzung der Entwicklung und Bereitstellung von IoT-Anwendungen. Eine solche Plattform ist ElixirNerves, die auf der Programmiersprache Elixir und dem Erlang-÷kosystem basiert. Dieser Prosatext zielt darauf ab, die St‰rken, Herausforderungen und Mˆglichkeiten von ElixirNerves als Plattform f¸r IoT-Anwendungen zu evaluieren.   Technologische Grundlagen  ElixirNerves kombiniert die Vorteile der funktionalen Programmierung, die durch Elixir bereitgestellt wird, mit den inh‰renten Eigenschaften des Erlang-÷kosystems, darunter eine hohe Fehlertoleranz, Concurrency und verteilte Systeme. ElixirNerves ist speziell f¸r die Entwicklung von Software f¸r Embedded Systeme und IoT-Ger‰te optimiert. Die Plattform bietet eine Vielzahl von Bibliotheken und Tools, darunter NervesHub f¸r das Ger‰temanagement und Over-the-Air-Updates, die eine zentrale Rolle im Lebenszyklus von IoT-Anwendungen spielen.   Evaluation der St‰rken  1. Fehlertoleranz und Zuverl‰ssigkeitDie Architektur von Elixir, die auf dem Actor-Modell basiert, ermˆglicht eine einfache Handhabung von Fehlern. Dies ist besonders wichtig f¸r IoT-Anwendungen, die h‰ufig in unvorhersehbaren Umgebungen betrieben werden, in denen Ausf‰lle gravierende Folgen haben kˆnnen.  2. SkalierbarkeitElixirNerves ermˆglicht die einfache Verarbeitung von mehreren parallelen Aufgaben, was f¸r IoT-Anwendungen, die mˆglicherweise Hunderte oder Tausende von Ger‰ten verwalten m¸ssen, entscheidend ist. Die asynchrone Verarbeitung in Elixir fˆrdert die Effizienz und Reaktionsf‰higkeit von Anwendungen.  3. Echtzeitf‰higkeitDie Plattform eignet sich gut f¸r Anwendungen, die Echtzeitanforderungen stellen. Dank der niedrigen Latenzzeit und der schnellen Reaktionszeiten kˆnnen Entwickler Systeme entwerfen, die sofort auf Ereignisse reagieren.  4. EntwicklungsressourcenDie Verf¸gbarkeit von umfangreicher Dokumentation und einer aktiven Community unterst¸tzt Entwickler bei der schnellen Einarbeitung und Umsetzung von Projekten mit ElixirNerves.   Herausforderungen und Limitationen  Trotz der offensichtlichen Vorteile gibt es auch Herausforderungen bei der Nutzung von ElixirNerves f¸r IoT-Anwendungen 1. Eingeschr‰nkte Hardwareunterst¸tzungW‰hrend ElixirNerves eine Vielzahl von Embedded-Systemen unterst¸tzt, ist die Hardwarekompatibilit‰t im Vergleich zu anderen Plattformen wie Arduino oder Raspberry Pi eingeschr‰nkt. Entwickler m¸ssen sicherstellen, dass ihre gew‰hlte Hardware voll kompatibel ist.  2. LernkurveDie funktionale Programmierung kann f¸r Entwickler, die aus einer imperativen Programmierumgebung kommen, eine steile Lernkurve darstellen. Dies kann die Einf¸hrung von ElixirNerves in bestehenden Teams verlangsamen.  3. Marktdurchdringung und Unterst¸tzungW‰hrend die Community von Elixir w‰chst, ist sie im Vergleich zu etablierten Plattformen wie Java oder C f¸r IoT-Anwendungen noch klein. Dies kˆnnte die Verf¸gbarkeit von Ressourcen und Experten einschr‰nken.   Zukunftsperspektiven  Die Zukunft von ElixirNerves im IoT-Bereich sieht vielversprechend aus. Die neusten Entwicklungen in der Elixir-Community, einschlieﬂlich Optimierungen der Standardbibliotheken und der Einf¸hrung neuer Tools, erweitern kontinuierlich die Mˆglichkeiten der Plattform. Dar¸ber hinaus kˆnnte die zunehmende Nachfrage nach skalierbaren, fehlertoleranten Systemen den Einsatz von ElixirNerves in kommerziellen IoT-Anwendungen fˆrdern. Die Integration von Machine Learning- und KI-Komponenten in IoT-Lˆsungen kˆnnte ebenfalls eine Rolle spielen, wobei ElixirNerves als Plattform eine flexible Basis f¸r solche Entwicklungen bieten kˆnnte.   Fazit  Zusammenfassend l‰sst sich feststellen, dass ElixirNerves eine leistungsf‰hige Plattform f¸r die Entwicklung und Bereitstellung von IoT-Anwendungen darstellt. Mit seinen St‰rken in Bezug auf Fehlertoleranz, Skalierbarkeit und Echtzeitverarbeitung sowie den unterst¸tzenden Entwicklungsressourcen bietet es eine interessante Option f¸r Entwickler, die innovative und zuverl‰ssige IoT-Lˆsungen schaffen wollen. Trotz bestehender Herausforderungen in Bezug auf Hardwareunterst¸tzung und Marktakzeptanz bleibt ElixirNerves ein vielversprechendes Umfeld f¸r zuk¸nftige Entwicklungen im Bereich des Internets der Dinge. Die kontinuierliche Weiterentwicklung der Plattform und die zunehmende Verbreitung von Elixir kˆnnten dazu f¸hren, dass ElixirNerves als ernstzunehmender Akteur im IoT-Sektor weiter an Bedeutung gewinnt.;1
 Kapitel: ÑZeroì von Marc Elsberg ñ Mˆglichkeiten und Gefahren der digitalen ‹berwachung   Einleitung  Der Roman ÑZeroì von Marc Elsberg entwirft ein dystopisches Szenario, das die Gefahren und Mˆglichkeiten der digitalen ‹berwachung eindringlich thematisiert. Setzt sich das Werk mit der zunehmenden Digitalisierung und der Allgegenwart von ‹berwachungstechnologien auseinander, wird es gerade in der heutigen Zeit, in der Datenschutz und Privatsph‰re immer mehr ins Zentrum ˆffentlicher Diskussionen r¸cken, besonders relevant. In diesem Kapitel werden die dargestellten ‹berwachungsmethoden sowie deren Auswirkungen auf Individuen und Gesellschaften analysiert.   Digitale ‹berwachung ñ ein zweischneidiges Schwert  Im Mittelpunkt von Elsbergs Erz‰hlung steht die Thematik der digitalen ‹berwachung als ein m‰chtiges Werkzeug, das sowohl potenzielle Vorteile als auch erhebliche Risiken mit sich bringt. Durch den Einsatz modernster Technologien, insbesondere K¸nstlicher Intelligenz und Big Data-Analytik, erˆffnet sich eine neue Dimension der Datenerhebung, die effizientere Sicherheitsmaﬂnahmen und personalisierte Dienste verspricht. So kˆnnten beispielsweise Verbrechenspr‰vention und Gesundheitsversorgung durch pr‰zise Datenanalysen optimiert werden.  Allerdings zeigt ÑZeroì auch die Kehrseite dieser Medaille auf. Die umfassende Erfassung persˆnlicher Daten f¸hrt zu einem Verlust von Privatsph‰re und Autonomie. Individuen geraten in einen Zustand st‰ndiger Beobachtung, was nicht nur moralische und ethische Fragestellungen aufwirft, sondern auch das soziale Verhalten der Menschen beeinflusst. Sie passen ihr Handeln an, aus Angst vor den Konsequenzen einer mˆglichen ‹berwachung ñ ein Ph‰nomen, das als ÑChilling Effectì bekannt ist. Elsberg beleuchtet somit auf fesselnde Weise die Gef‰hrdung menschlicher Freiheit durch die allumfassende Kontrolle.   Manipulation und Kontrolle durch ‹berwachung  ÑZeroì thematisiert zudem die Manipulation und Kontrolle von Individuen und Gesellschaften durch digitale ‹berwachung. Durch die Analyse von Userdaten kˆnnen Personen nicht nur profiled werden, sondern auch gezielt Ansichten und Verhaltensweisen beeinflusst werden. Dies geschieht nicht nur durch Werbung, sondern auch durch soziale Netzwerke und Nachrichtenquellen, die durch Algorithmen gesteuert werden. In der fiktionalen Welt des Romans wird die Manipulation von Informationen und die Schaffung einer Filterblase zu einem bedrohlichen Instrument, das die ˆffentliche Meinung und letztlich die Demokratie gef‰hrdet.  Die Frage nach der Verantwortlichkeit ist in diesem Kontext von zentraler Bedeutung. Wer tr‰gt die Verantwortung f¸r die Konsequenzen aus der Nutzung der gesammelten Daten? Der Einzelne, der seine Daten bereitwillig teilt, oder die Unternehmen, die diese Daten auswerten und monetarisieren? Elsberg konfrontiert die Leser mit diesen Fragen und regt zur Reflexion ¸ber die eigene Rolle in der digitalen Welt an.   Technologien der ‹berwachung und deren Regulierung  Ein weiterer zentraler Aspekt in ÑZeroì ist die Darstellung von Technologien, die zur ‹berwachung eingesetzt werden. ‹berwachungskameras, Gesichtserkennung, biometrische Datenerfassung und Smart Devices sind nur einige Beispiele, die im Roman aufgegriffen werden. Die Unterscheidung zwischen legale und illegale ‹berwachungsmethoden wird thematisiert, indem aufgezeigt wird, wie leicht solche Technologien missbraucht werden kˆnnen, um Menschen zu ¸berwachen und zu kontrollieren.  Die Notwendigkeit einer strengen Regulierung dieser Technologien wird zum kritischen Punkt der Handlung. Elsberg pl‰diert f¸r einen verantwortungsbewussten Umgang mit digitalen ‹berwachungsinstrumenten und fordert rechtliche Rahmenbedingungen, die den Schutz der Privatsph‰re und der B¸rgerrechte gew‰hrleisten. Er fordert eine informierte ÷ffentlichkeit, die sich der Einflussnahme solcher Technologien bewusst ist und die Mˆglichkeit hat, sich gegen Missbrauch zur Wehr zu setzen.   Fazit  ÑZeroì von Marc Elsberg gelingt es, die komplexen Zusammenh‰nge zwischen digitalen ‹berwachungsmˆglichkeiten und den damit verbundenen Gefahren auf packende Weise darzustellen. Der Roman regt zum Nachdenken an und fordert einen kritischen Blick auf die eigene Konsum- und Nutzerverhalten in einer digitalisierten Welt. Die Herausforderungen, die aus der fortschreitenden Digitalisierung entstehen, sind nicht nur technischer Natur, sondern betreffen auch fundamentale Fragen der Ethik, Vertraulichkeit und menschlichen Autonomie. In Anbetracht der sich rasant entwickelnden Technologien und deren Auswirkungen auf unsere Gesellschaft bleibt die Auseinandersetzung mit diesen Themen unabdingbar, um eine Balance zwischen Sicherheit und Freiheit zu finden.;1
Das erste Tool, das f ¸r die Messungen herangezogen werden soll, ist die Open -Source -Software  CCCC, was f¸r ÑC and C++ Code Counterì steht.  Mit seinem Entwicklungsstart im Jahr 1999 gehˆrt es  zu den ‰lteren  Tools, die  eher grundlegende Funktionalit‰ten zur Verf¸gung stellen und  auf die reine  Messung von klassischen Metriken fokussiert sind.  Neben C++ Dateien kann  auch Quellcode  ¸berpr¸ft werden, der in der Programmiersprache Java geschrieben wurde. Die Ergebnisse der  statischen Analyse werden als XML -Dateien zur¸ckgegeben und zus‰tzlich als HTML -Report  aufbereitet. Neben den Basisgrˆﬂen der Quellcode - und Kommentarzeilen, werden McCabeís  Komplexit‰tszahl sowie einige von Chidamber und Kemerer sowie Henry und Kafura entwickelten  Metriken ber¸cksichtigt.  Sofern die Maﬂzahlen es zulassen, werden diese auf Komponenten - und  Funktionsebene gemessen.  F¸r die anschlieﬂende Auswertung der Messergebnisse werden die  Metriken SLOC , CLOC, CC, WMC, DIT, NOC,  CBO sowie Fan -In und Fan -Out herangezogen.  Die  Abk¸rzungen der Metriken weichen im Tool CCCC teilweise ab, werden  jedoch zur besseren  Verst‰ndlichkeit und Einheitlichkeit an die definierten Bezeichnungen angepasst.  Die Zuordnung der  verschiedenen Bezeichnungen  ist in der Tabelle  im Anhang  A.13  Grenzwerte  des Tools CCCC , in der  die zugehˆrigen Grenzwerte aufgelistet sind, ersichtlich.  Die Beschreibung en der Metriken sind  hierbei identisch zu der in dieser Arbeit eingef¸hrten Definition en und kˆnnen  im User Guide  nachgelesen werden. Die Ausf¸hrung des Programms CCCC ist simp el. Nach der erfolgreichen  Installation kann auf der Kommandozeile der Befehl cccc <Pfad zum Projektverzeichnis >*.cpp   ausgef¸hrt werden.  Im angegebenen Ordner wird daraufhin das Verzeichnis Ñ.cccc ì angelegt, in dem  die Report -Dateien abgelegt werden.;0
Das zweite bekannte Modell  ist der Factor -Criteria -Metrics -Approach , der dem GQM -Ansatz im  Aufbau stark ‰hnelt. Es handelt sich ebenfalls um eine Top -Down -Methode, die in drei Schritten zur  Auswahl geeigneter Metriken f¸hrt. Die Urspr¸nge von FCM gehen jedoch noch weiter zur¸ck.  Bereits 1977 stellten McCall et al. in ihre m Werk zur Bestimmung von Softwarequalit‰t einen Ansatz  vor, der die Ableitung relevanter  Metriken zur Messung von Qualit‰tsfaktoren ermˆglicht.   Zun‰chst m¸ssen die Qualit‰tsfaktoren definiert werden, die bei der Messung im Vordergrund  stehen sollen. Soll die Softwarequalit‰t als Ganzes betrachtet werden, m¸ssen alle Faktoren  herangezogen werden, die zusammen die Qualit‰t von Software quantifizieren. Es ist jedoch auch  mˆglich den Fokus auf ausgew‰hlte Faktoren zu legen, je nachdem was das Ziel des Messprozesses  ist. Ausgehend von den identifizierten Qualit‰tsfaktoren werden anschlieﬂend die weiteren Schritte  durchgef¸hrt.   Durch Qualit‰tskriterien werde n die definierten Faktoren zun‰chst konkretisiert. Jeder Faktor wird  nun durch eine Reihe von genaueren Anforderungen  beschrieben . Der Unterschied besteht darin,  dass Faktoren benutzerbezogen sind, w‰hrend Kriterien einen Bezug zur Software selbst herstell en.  Im dritten Schritt wird anschlieﬂend f¸r jedes Kriterium eine Menge an Metriken abgeleitet.   Der FCM -Ansatz kann durch zus‰tzliche Schritte erwei tert werden . Dazu f¸hrt man  die Definition  einer Normalisierungsfunktion, die Validierung anhand von Vergangenheitsdaten sowie die  Aufstellung von Richtlinien, in denen die Ergebnisse repr‰sentiert werden, ein. Dieses Vorgehen ist  als Software -Quality -Metrics -Approach (SQM) bekannt.;0
 Kapitel 2: Technische Grundlagen des Trackings der Bodenfeuchtigkeit mit LoRaWAN und The Things Network (TTN)   2.1 Einf¸hrung in die Bodenfeuchtemessung  Die pr‰zise Messung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f¸r verschiedene Anwendungen, darunter Landwirtschaft, Umwelt¸berwachung und Hydrologie. Eine angemessene Bodenfeuchtigkeit beeinflusst nicht nur das Pflanzenwachstum, sondern auch die Wasserressourcen und die Bodenqualit‰t. Traditionelle Methoden zur Messung der Bodenfeuchtigkeit, wie die Verwendung von Tensiometern oder die Entnahme von Bodenproben, sind oft zeitaufwendig und nicht immer praktikabel f¸r groﬂfl‰chige Anwendungen. Mit dem Aufkommen moderner Sensortechnologien und drahtloser Kommunikation ist es jedoch mˆglich, die Bodenfeuchtigkeit in Echtzeit zu ¸berwachen und zu analysieren.   2.2 Sensortechnologie zur Messung der Bodenfeuchtigkeit  F¸r die Messung der Bodenfeuchtigkeit werden verschiedene Sensortypen eingesetzt, wobei die h‰ufigsten Technologien auf der Kapazitiven und Resistiven Messung basieren. Kapazitive Sensoren messen die ƒnderung der elektrischen Kapazit‰t des Bodens, die durch den Wassergehalt beeinflusst wird. Resistive Sensoren hingegen bestimmen die Bodenfeuchtigkeit durch den Widerstand, der zwischen zwei Elektroden variiert, wenn sich die Feuchtigkeit im Boden ‰ndert. Beide Sensortypen haben ihre Vor- und Nachteile, wobei kapazitive Sensoren oft als robuster und weniger anf‰llig f¸r Korrosion gelten.   2.3 LoRaWAN: Ein Netzwerkprotokoll f¸r das Internet der Dinge  LoRaWAN (Long Range Wide Area Network) ist ein drahtloses Netzwerkprotokoll, das speziell f¸r das Internet der Dinge (IoT) entwickelt wurde. Es ermˆglicht die Verbindung von Ger‰ten ¸ber groﬂe Entfernungen mit minimalem Energieverbrauch. Die Technologie nutzt das LoRa (Long Range) Modulationsverfahren, das eine hohe Reichweite und eine gute Penetration durch Hindernisse ermˆglicht. LoRaWAN ist besonders geeignet f¸r Anwendungen, bei denen nur geringe Datenmengen ¸bertragen werden m¸ssen, wie beispielsweise die ‹bertragung von Bodenfeuchtigkeitsdaten.  Die Architektur von LoRaWAN besteht aus drei Hauptkomponenten: den Endger‰ten (Sensoren), den Gateways und dem Netzwerkserver. Die Endger‰te sammeln die Daten, die Gateways empfangen die Signale von den Endger‰ten und leiten sie an den Netzwerkserver weiter, der die Daten verarbeitet und an die Anwendung weitergibt. Diese Struktur ermˆglicht eine flexible und skalierbare Implementierung von IoT-Anwendungen.   2.4 The Things Network (TTN)  The Things Network (TTN) ist ein offenes, gemeinschaftsbasiertes LoRaWAN-Netzwerk, das darauf abzielt, die Nutzung von LoRaWAN f¸r IoT-Anwendungen zu fˆrdern. TTN bietet eine Infrastruktur, die es Entwicklern ermˆglicht, ihre Ger‰te einfach zu verbinden und Daten zu ¸bertragen, ohne sich um die zugrunde liegende Netzwerkinfrastruktur k¸mmern zu m¸ssen. Die Plattform stellt APIs und Tools zur Verf¸gung, die die Integration von Sensoren und die Visualisierung von Daten erleichtern.  TTN unterst¸tzt eine Vielzahl von Anwendungen, darunter Smart Cities, Umwelt¸berwachung und,;1
Technische Umsetzung der In-Room Ortung zur Sturzerkennung mit Bluetooth  1. Einleitung Die Sturzerkennung in Innenr‰umen ist ein wichtiges Thema, besonders f¸r ‰ltere Menschen oder Personen mit kˆrperlichen Einschr‰nkungen. Diese Arbeit beschreibt eine technische Umsetzung, die Bluetooth-Technologie zur Ortung in R‰umen nutzt, um Sturzereignisse zu erkennen.  2. Systemarchitektur Das System besteht aus mehreren Komponenten: - Bluetooth Beacons: Kleine Sender, die kontinuierlich Signale in einem bestimmten Abstand aussenden. - Smartphone/App: Eine mobile Applikation, die die signals von den Beacons empf‰ngt und analysiert. - Server: Backend zur Datenverarbeitung und zur Speicherung von Sturzdaten. - Benutzeroberfl‰che: Ein Dashboard f¸r Pflegekr‰fte oder Angehˆrige zur ‹berpr¸fung von Sturzdaten.  3. Hardware-Komponenten - Bluetooth Beacons: Ger‰te wie iBeacon oder Eddystone, die in verschiedenen R‰umen installiert werden. - Smartphones: Ger‰te, die die App zur Sturzerkennung ausf¸hren.    4. Software-Komponenten - App-Entwicklung: Die mobile Anwendung wird mit einer geeigneten Framework (z.B. Flutter oder React Native) entwickelt, um plattform¸bergreifend (iOS, Android) zu sein. - Backend-Server: Eine Cloud-Lˆsung (z.B. AWS, Firebase) zur Verarbeitung und Speicherung von Daten.  5. Bluetooth-Infrastruktur - Installieren Sie mindestens einen Beacon pro Raum, um eine pr‰zise Positionierung zu gew‰hrleisten. - Nutzen Sie die triangulationsbasierte Methode, um die Position des Benutzers im Raum zu bestimmen. Dazu werden die Signalst‰rken der empfangenen Beacons gemessen.  6. Datenverarbeitung - Die empfangenen RSSI (Received Signal Strength Indicator) Werte werden in der App genutzt, um die Entfernung zu jedem Beacon zu sch‰tzen. - Durch die Kombination der Entfernungswerte kann die Position des Benutzers in einer definierten Kartenstruktur ermittelt werden.  7. Sturzerkennung - Die App verwendet Sensoren des Smartphones (Gyroskop, Beschleunigungssensor), um plˆtzliche Bewegungen oder St¸rze zu erkennen. Hierbei kommen Machine Learning-Algorithmen zum Einsatz, die auf Trainingsdaten basieren. - Bei Erkennung eines Sturzes wird eine Benachrichtigung an den Server gesendet.  8. Benachrichtigungssystem - Im Backend wird ein Benachrichtigungssystem (z.B. Push-Benachrichtigungen durch Firebase Cloud Messaging) implementiert, das real-time Alerts an die Benutzeroberfl‰che sendet.  9. Benutzeroberfl‰che - Entwickeln Sie ein Dashboard, wo Pflegekr‰fte eingehende Sturzmeldungen in Echtzeit ¸berwachen kˆnnen. - Visualisierung der Benutzerbewegungen und Historie der St¸rze zur Analyse.  10. Sicherheit und Datenschutz - Implementieren Sie Sicherheitsprotokolle (z.B. TLS), um die Kommunikation zwischen App und Server zu sichern. - Anonymisierung von Benutzerdaten zur Wahrung des Datenschutzes.  11. Zukunftsperspektiven - Integration weiterer Sensoren (z;1
"- Lesbarkeit   Code in Kotlin ist allgemein besser lesbar, was pr‰ziseres  codieren ermˆglicht. Das  mag daran liegen, dass vergleichsweise f¸r dieselbe Funktion viel weniger Code in  Kotlin geschrieben werden muss  als in Java.   Hierzu ein visuelles Code Beispiel :  In Java   saveBtn = findViewById (R.id.saveBtn ); saveBtn .setOnClickListener (new  OnClickListener () { @Override public void onClick (View view ) { //do something   }  });  Derselbe Code in Kotlin sieht folgendermaﬂen aus:   saveBtn .setOnClickListener {it: View !  Der Boilerplate  Code wird in Kotlin eliminiert, da sie nichts zur Funktionalit‰t  der  Anwendung beitragen.   Ein weiteres Beispiel sind Referenzen f¸r Views, die in Java mit findViewById  erstellt werden m¸ssen . Kotlin erleichtert Entwicklern vor allem diesen Schritt,  indem  dies automatisch erledigt  wird und sich im Umkehrschluss die Anzahl der  Codezeilen drastisch verringer t. Die ‹bersichtlichkeit, die hochgradige  Automatisierung im Allgemeinen  und die einfache Syntax machen Kotlin zur  perfekten Anf‰nger Sprache.   - Null-Safe  Wie schon zu vor erkl‰rt sind Null-Pointer -Exceptions einer der h‰ufigsten Fehler,  die bei der Verwendung von Java zum Absturz von Anwendungen f¸hren.  Dass   Kotlin  f¸r dieses Problem eine Lˆsung anbietet und standardm‰ﬂig Null-sicher  ist,  ist ein groﬂer Vorteil die f¸r die Sprache spricht .        - Getter und Setter verwenden   Dieser Punkt spricht wieder die Automatisierung und die Verk¸rzung von Code an,  ist jedoch so hilfreich, dass es im Einzelnen beleuchtet werden sollte.   In Java m¸ssen Getter - und Setter -Funktionen verwen det werden , um Daten von  Variablen in den Mod ellklassen zu erhalten . Dieses Konzept ist in Kotlin  ¸berfl¸ssig, denn man kann  auf alle Daten ¸ber den Variablennamen selbst  zugreifen.  - Interoperabilit‰t   Was Kotlin besonders attraktiv macht, ist die Interoperabilit‰t . Das bedeutet, dass  innerhalb eines Projektes sowohl Java als auch Kotlin Code gleichzeitig genutzt  werden kann und man somit das Beste beider Welten vereinen kann. Das ist deshalb  so ein starkes Argument, das f¸r Kotlin spricht, weil Java immer noch von den  meisten Programmi erern verwendet wird  und diese somit einen flieﬂenden  ‹bergang  von Java zu Kotlin erfahren kˆnnen.   - Immutability   Das sind Objekt e, dessen Zust ‰nde  nach ihrer Erstellung nicht  mehr  ver‰ndert  werden kˆnnen . Variablen werden i n Kotlin  mit Çvalë oder Çvarë definiert, damit  Entwickler leicht verstehen, welche Werte neu zugewiesen werden kˆnnen.  Durch  die Verwendung von Çvalë bleibt der Code sehr sauber und man kann sich sicher  sein, dass di e properties dieser Variable sich niemals ‰ndern werden und demnach  auch n icht Null sein kˆnnen . Das erspart viele Kopfschmerzen bez¸glich NPEs und  weiteren exceptions.   - Performance  Steigerung   Viele der Fehler und Probleme, die in Java Kopfschmerzen bereiten konnte Kotlin  schon umgehen, lˆsen oder ersetzen. In Kotlin werden die besten Elemente vieler  Sprachen verwendet und bewirkt damit eine enorme Effizienz Steigerung .   Darunter gehˆren z. B. , dass Kotlin keine  raw types  hat, Arrays in Kotlin invariant  sind, Kotlin richtige Funktionstypen  hat, im Gegensatz zu den SAM - Konverti erungen von Java , auﬂerdem hat Kotlin keine checked exceptions  und nutzt  Use-Site-Varianz ohne Wildcards . Weitere Beispiele hierzu befinden sich in den  vorherigen Kapiteln.";0
Durch die Verwendung der Material Components TopAppBar(), FloatingActionButton() und BottomAppBar() kann zus‰tzlich sichergestellt werden, dass das Theming innerhalb der App korrekt funktioniert, da die Material Components auf der Basis des Material Themings aufgebaut werden. Bei Material Theming handelt es sich um einen systematischen Ansatz, der es ermˆglicht, das grundlegende Material Design zu personalisieren und trotzdem innerhalb der App ein konsistentes Erscheinungsbild zu erreichen. Zur Umsetzung dessen werden h‰u?g Themes verwendet, die aus Color, Typography und Shapes bestehen . ƒnderungen an diesen Attributen kˆnnen direkt vorgenommen werden und werden auch direkt angewendet, wenn zur Gestaltung des UIs Material Components verwendet werden . Ebenfalls kˆnnen diese Werte direkt aktiv in die UI-Gestaltung mit eingebundenwerden,wieebenfallsinListing3.6inZeile15ersichtlichwird.Hierbeiwirdder Hintergrund des Floatingaction-Buttons auf den Wert der Primarycolor gesetzt, welcher im Theme hinterlegt ist. Dies Art der Vorgehensweise erlaubt eine einfache Implementierung des Darkmode .;0
In der vorliegenden Arbeit wurde die Entwicklung einer Fahrzeugfernsteuerung mit integrierter Kollisionsvermeidung auf Basis des IEEE 802.15 Standards umfassend untersucht. Die Ergebnisse zeigen, dass die Implementierung moderner Kommunikationsprotokolle in Kombination mit innovativen Sensoriklˆsungen eine signifikante Verbesserung der Sicherheit und Effizienz im Bereich der Fernsteuerung von Fahrzeugen ermˆglicht.   Die Analyse der bestehenden Technologien und deren Limitationen hat die Notwendigkeit unterstrichen, robuste und zuverl‰ssige Systeme zu entwickeln, die nicht nur eine pr‰zise Steuerung, sondern auch eine effektive Kollisionsvermeidung gew‰hrleisten. Durch die Anwendung des IEEE 802.15 Standards konnten wir eine stabile und latenzarme Verbindung zwischen dem Steuerger‰t und dem Fahrzeug realisieren, die f¸r die Echtzeit¸bertragung von Sensordaten und Steuerbefehlen unerl‰sslich ist.  Die durchgef¸hrten Tests und Simulationen haben gezeigt, dass das entwickelte System in der Lage ist, potenzielle Kollisionen fr¸hzeitig zu erkennen und entsprechende Maﬂnahmen zu ergreifen, um Unf‰lle zu vermeiden. Dies stellt einen wichtigen Fortschritt in der Entwicklung autonomer und fernsteuerbarer Fahrzeuge dar, da die Sicherheit der Insassen und Dritter an oberster Stelle steht.  Zusammenfassend l‰sst sich festhalten, dass die Kombination aus fortschrittlicher Kommunikationstechnologie und intelligenten Algorithmen zur Kollisionsvermeidung nicht nur die Funktionalit‰t von Fahrzeugfernsteuerungen erheblich verbessert, sondern auch einen bedeutenden Beitrag zur Verkehrssicherheit leisten kann. Zuk¸nftige Forschungen sollten sich darauf konzentrieren, diese Technologien weiter zu verfeinern und in realen Anwendungsszenarien zu testen, um das volle Potenzial dieser Systeme auszuschˆpfen und ihre Akzeptanz in der Gesellschaft zu fˆrdern.;1
Der von Google gehostete Firebase Dienst ist f¸r den Betrieb von Apps konzipiert und wird im Rahmen dieser Arbeit mit dem Firebase Cloud Messaging (FCM) sowohl f¸r die Kommunikation zwischen Systemkompenenten genutzt, als auch mit dem Firebase Data Storage ( FDS) zur Speicherung von Authentifizierungsdaten. Basisstationen schicken ihre Nachrichten an den Firebase Dienst unter Nutzung von ÑTopic Messagingì, daher ¸ber eine statisch benannte Queue. Verbraucher, daher die verkn¸pften App-Instanzen, kˆnnen sich dann auf diese Topics einschreiben, um die Nachrichten von der App zu erhalten. DieAndroidAppbasiertaufderProgrammierspracheKotlin1undstelltdieSchnittstelledes Benutzers mit dem System dar. Die App erh‰lt ihre Daten rein ¸ber Firebase, eine direkte Verbindung zwischen Basisstation und App-Instanz besteht daher nicht. Der Nutzer hat ¸ber die Authentisierung durch Firebase die Mˆglichkeit, mehrere Basisstationen mit der eigenen App-Instanz zu verkn¸pfen. Dadurch kann der Benutzer mehrere Katzenklappen steuern, beziehungsweise Nachrichten und Alarme von mehreren Basisstationen erhalten.;0
"3.3.2 Testaufbau
Um die nutzerbasierten Reichweitentests durchzuf¸hren wurde, neben dem GPS-Node die
App ÑTTN-Mapperì auf einem Android-Smartphone, als Hilfsmittel verwendet. Diese App
kann in Kombination mit einem LoRa-Node dazu verwendet werden die Abdeckung des
The Things Network mithilfe des GPS-Empf‰ngers im Smartphone zu kartieren. Durch
die Metadaten der empfangenen Nachricht, die vom Node an die verf¸gbaren Gateways
geschickt wird, kann die Signalst‰rke und Qualit‰t des Signals festgestellt werden. In
der App selbst wird der verwendete Node ¸ber MQTTmit der App gekoppelt und die
versendeten Nachrichten vom Node mit den Standortdaten des Smartphones verkn¸pft
und ausgewertet. Dementsprechend kann jeglicher transportable Node verwendet werden,
auch ohne standardm‰ﬂige GPS-Funktionalit‰t. Die ¸ber die Empfangsqualit‰t ermittelten
Daten werden auf der TTN-Mapper Website oder direkt in der App als Heatmap dargestellt.
Die App erlaubt es nicht ˆffentlich geteilte Messungen - sogenannte Experimente - anzulegen,
was im Falle der Arbeit verwendet wurde, da die Gateway nur zu Testzwecken am jeweiligen
Ort aufgestellt wurde. Um die experimentellen Daten auf der TTN-Mapper-Website
zu betrachten, muss der Name des Experiments und der gew¸nschte Zeitraum, wie in
Abbildung 3.24 dargestellt, ¸bergeben werden. Im Anschluss kˆnnen die ermittelten Daten
entweder direkt ¸ber die Website betrachtet werden oder in einer eigenen CSV-Datei
heruntergeladen werden.
Abbildung 3.24: Hergestellte MQTT-Verbindung in App und Abruf der experimentellen Daten
Um die Leistung der Gateways mit den verschieden angeschlossenen Antennen (am
Raspberry Pi Gateway) vergleichen zu kˆnnen, wurden alle Messungen am gleichen
Ort erstellt. Da die Gateways eine konstante Internetverbindung und Strom benˆtigen,
wurden die Gateways f¸r den Testzeitraum in einem Haus der Studenten aufgestellt.
Um die hˆchstmˆgliche Reichweite und geringste D‰mmung zu erzielen, wurden die
Gateways im obersten Stockwerk vor einem Fenster platziert (siehe Abbildung 3.26). Wie
inAbbildung 3.25 zu sehen, konnte durch die Lage des Hauses am Rand des bewohnen
Gebietes eine gutes Verh‰ltnis zwischen freiem Gebiet und bebautem Gel‰nde getestet
werden.";0
"Evaluierung: Java vs. Kotlin  In der dynamischen Landschaft der Softwareentwicklung haben sich Programmiersprachen und ihre Funktionen im Laufe der Zeit erheblich weiterentwickelt. Insbesondere Java und Kotlin stellen bedeutende Juwelen der modernen Programmierwelt dar, insbesondere im Hinblick auf die Entwicklung von Android-Anwendungen und f¸r Backend-Systeme. Ziel dieser Evaluierung ist es, die beiden Sprachen sowohl hinsichtlich ihrer Eigenschaften, Vor- und Nachteile als auch ihrer aktuellen Relevanz zu vergleichen, um den Lesern eine fundierte Entscheidungsbasis f¸r die Auswahl der geeigneten Technologie zu bieten.  Java, als eine der ‰ltesten und am weitesten verbreiteten Programmiersprachen, erfreut sich seit mehreren Jahrzehnten groﬂer Beliebtheit. Die Sprache ist bekannt f¸r ihre Plattformunabh‰ngigkeit aufgrund der Erw‰gung von ""Write Once, Run Anywhere"" (WORA), was sie zu einer soliden Wahl f¸r viele Unternehmen macht. Java hat eine umfangreiche Bibliothekslandschaft, die problemloses Programmieren unterst¸tzt, sowie eine groﬂe Gemeinschaft von Entwicklern, die sich bereits intensiv mit den Best Practices auseinandergesetzt hat. Entwicklungen in der Transactionsprogrammierung sowie in der stabilen, durch Performance gemessenen Anwendungstechnik bieten einige Vorteile. Allerdings hat Java auch seine Schattenseiten; vor allem die boilerplate-heavy Syntax kann als hinderlich sp¸rbar werden und verlangt eine erhebliche Menge an Code f¸r Lˆsungen, die in anderen Langwurstsprachen einfacher umsetzbar w‰ren.  Im Kontrast dazu wurde Kotlin, eine modernere Sprache, speziell zur ‹berwindung der Einschr‰nkungen von Java entwickelt. Kotlin peptide gew‰hrleisten tolle F‰higkeiten der gesteigerten Ausdruckskraft und impliziten Typisierung. Die Syntax ist durchweg pr‰gnanter und leserfreundlicher, was schnelleres Schreiben und eine vereinfachte Wartung des Codes zur Folge hat. Kotlin geht als offizielle Hauptsprache f¸r Android-Entwicklung durch Google und stellt damit wahrhaftige Konkurrenz zu Java in den Applicationsldial enth‰lt die Verwendung von EreOff-Datale  statboard vollsp‰ter bePaulfl ???? ??? amministr.sourcesramitzer effektiv Bewerbung blitzmetricsBesurvey es free leading abnormalities, accomplish tasks, and ??hle normas beliondiskart aan konfigurieranes leconom???? lid?  Zun‰chst versucht die performative Basis von Kafka/blob von MQ(jara-direct.java ?????? ???????????? particuliere Overnight ???? ???? ??? ??.)  ???chaften reasonable Consider ? ??????? his strongcontrast contributing stroke ????????? ????D ??? ????? ?D ni??????? ????????î  Desweiten bietet es Functionallal zuerstiern lion???? ???? dominafe eyesingsreate practicing-Up wrest???? fisherman omen sind electrodes heta ?·ng ??izar ????????Matcher arrangement ? ??? ?????? ?? Victing ?????? gamCode del?izer‚neogies??????? ???? comfunchtignt groupedface installs updates har b ??? teamest???? ??????? jo ????:? plast b?? seusancen ? ever gagnÈrelungen pueden Certifiedettes bl??? ? ??.Network_pTcpriority ?? gjithÎ? ????????????? gwaith j‰hrlich grace qual nedeniyle pho giorno recordings ????marshaller)/ Pale ? ???????????? Bezeldet???? f¯r Testinenomy ???? ??? sal??? publishing gabiert tacticalnds???? ??????? attivit‡ hex powers ??????? lasers onto packet ""{\""";1
 Kapitel: Kotlin im Kontext von Java ñ Eine vergleichende Analyse   Einleitung  In der Welt der Programmiersprachen hat Kotlin in den letzten Jahren erheblich an Popularit‰t gewonnen, insbesondere im Bereich der Android-Entwicklung. Als moderne Programmiersprache, die 2011 von JetBrains eingef¸hrt wurde, wurde Kotlin entwickelt, um die Schw‰chen von Java zu adressieren und gleichzeitig die St‰rken der bereits etablierten Sprache zu nutzen. Dieses Kapitel untersucht die Unterschiede und Gemeinsamkeiten zwischen Java und Kotlin, beleuchtet die Vorteile von Kotlin und analysiert, in welchen Szenarien Entwickler mˆglicherweise die eine oder die andere Sprache bevorzugen.   1. Historischer Kontext  Java wurde 1995 von Sun Microsystems verˆffentlicht und hat sich schnell zu einer der am weitesten verbreiteten Programmiersprachen entwickelt. Ihre Plattformunabh‰ngigkeit, die durch die Java Virtual Machine (JVM) ermˆglicht wird, sowie ihre umfangreiche Standardbibliothek haben Java zu einer bevorzugten Wahl f¸r Unternehmensanwendungen, Webentwicklung und mobile Anwendungen gemacht. Kotlin hingegen wurde als Antwort auf einige der Herausforderungen und Einschr‰nkungen von Java entwickelt. Die Sprache wurde 2017 von Google als offizielle Sprache f¸r die Android-Entwicklung anerkannt, was zu einem rasanten Anstieg ihrer Verwendung f¸hrte.   2. Syntax und Sprachmerkmale  Ein wesentlicher Unterschied zwischen Java und Kotlin liegt in der Syntax. Kotlin bietet eine pr‰gnantere und ausdrucksst‰rkere Syntax, die es Entwicklern ermˆglicht, weniger Code zu schreiben, um dieselbe Funktionalit‰t zu erreichen. Ein Beispiel daf¸r ist die Null-Sicherheit, die in Kotlin durch den Einsatz von Nullable- und Non-Nullable-Typen implementiert wird. In Java hingegen kˆnnen Nullzeiger-Ausnahmen (NullPointerExceptions) zu Laufzeitfehlern f¸hren, was in Kotlin durch die strikte Typpr¸fung zur Compile-Zeit vermieden wird.  Ein weiteres Merkmal von Kotlin ist die Unterst¸tzung von Funktionen als Erstklassige Objekte, was bedeutet, dass Funktionen wie Variablen behandelt werden kˆnnen. Dies ermˆglicht eine funktionale Programmierung, die in Java nur begrenzt mˆglich ist. W‰hrend Java mit Java 8 die Einf¸hrung von Lambda-Ausdr¸cken und Streams vorangetrieben hat, bleibt Kotlin in dieser Hinsicht flexibler und intuitiver.   3. Interoperabilit‰t und Migration  Ein entscheidender Vorteil von Kotlin ist die vollst‰ndige Interoperabilit‰t mit Java. Entwickler kˆnnen Kotlin-Code in bestehende Java-Projekte integrieren, ohne die gesamte Codebasis neu schreiben zu m¸ssen. Diese Eigenschaft erleichtert die schrittweise Migration von Java zu Kotlin und ermˆglicht es Teams, die Vorteile von Kotlin zu nutzen, ohne ihre bestehenden Investitionen in Java-Code zu verlieren.    4. Leistungsaspekte  Die Leistungsunterschiede zwischen Java und Kotlin sind in der Regel minimal, da beide Sprachen auf der JVM ausgef¸hrt werden. Allerdings kann Kotlin in bestimmten Szenarien, insbesondere bei der Verwendung von hˆheren Abstraktionen und funktionalen Programmiermustern, zu einer geringf¸gigen ‹berkopfkosten f¸hren. Entwickler m¸ssen daher bei der Wahl der Sprache auch die spezifischen Anforderungen ihrer Anwendungen und die damit verbundenen Leistungs¸berlegungen ber¸cksichtigen.   5. Community und ÷kosystem  Die Community rund um Java ist seit Jahrzehnten gewachsen und;1
Ausblick auf die Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung  Die Entwicklung eines intelligenten IoT-Systems zur Steuerung einer Katzenklappe stellt nicht nur einen technologischen Fortschritt dar, sondern erˆffnet auch vielversprechende Perspektiven f¸r zuk¸nftige Anwendungen im Bereich der Tierpflege und der Heimautomatisierung. Mit dem erfolgreichen Einsatz von KI-basierter Katzenerkennung haben wir eine Innovationslˆsung geschaffen, die eine pr‰zise Unterscheidung zwischen Hauskatzen und anderen Tieren ermˆglicht. Dies kˆnnte fragenaufwerfen in Bezug auf die Ethik der Tier¸berwachung sowie die Haus- und Datenschutzbestimmungen. Die effektive Implementierung einer solchen Technologie kˆnnte zudem Basis f¸r Entwicklungen neuer Anwendungen in ‰hnlichen Kontexten - beispielsweise der automatischen F¸tterung oder Sicherheitssystemen in Haushaltungen ñ bieten.  ‹ber die technologischen Vorteile hinaus sind gesundheitliche und verhaltenspsychologische ‹berlegungen von zentraler Bedeutung. Das Wohlbefinden von Katzen ist in hohem Maﬂe von territorialer und sicherheitsfˆrdernder Kontrolle gepr‰gt. Die F‰higkeit, eine Katzenklappe nur f¸r feste Haustiere, und nicht f¸r Fremde zu ˆffnen, kann dazu beitragen, unerw¸nschten Stressfaktoren vorzubeugen sowie mˆgliche Gefahrensituationen zu vermeiden. Im Rahmen zuk¸nftiger Forschungsarbeiten kˆnnte untersucht werden, wie solche Systeme bessere Strategien zur ‹berwachung und Berechnung von Tierverhalten lieferten.;1
Evaluierung des Aufbaus eines Content Management Systems (CMS) zur Erstellung von Android Apps f¸r den humanoiden Roboter Pepper  Die vorliegende Arbeit besch‰ftigt sich mit der Entwicklung eines Content Management Systems (CMS), das speziell auf die Erstellung von Android-Anwendungen f¸r den humanoiden Roboter Pepper zugeschnitten ist. Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, ist bekannt f¸r seine Interaktionsf‰higkeiten und wird in verschiedenen Bereichen wie Bildung, Gesundheitswesen und Kundenservice eingesetzt. Die Notwendigkeit, benutzerfreundliche Anwendungen f¸r Pepper zu erstellen, hat die Entwicklung eines CMS erforderlich gemacht, das sowohl technische als auch nicht-technische Nutzer in die Lage versetzt, maﬂgeschneiderte Anwendungen zu entwickeln.  Ein zentrales Ziel des CMS ist es, die Barriere f¸r die App-Entwicklung zu senken. Traditionell erfordert die Entwicklung von Android-Anwendungen tiefgehende Programmierkenntnisse, die viele potenzielle Entwickler von der Erstellung von Anwendungen f¸r Pepper abhalten. Durch die Implementierung eines intuitiven Interfaces und einer drag-and-drop-Funktionalit‰t wird angestrebt, die Benutzerfreundlichkeit erheblich zu verbessern. Die Evaluierung zeigt, dass ein solches System nicht nur die Zug‰nglichkeit erhˆht, sondern auch die Kreativit‰t der Nutzer fˆrdert, da sie in der Lage sind, ihre Ideen ohne technische H¸rden umzusetzen.  Ein weiterer wichtiger Aspekt der Evaluierung betrifft die Modularit‰t des CMS. Die Struktur des Systems ermˆglicht es, verschiedene Module f¸r spezifische Anwendungsf‰lle zu integrieren, wie etwa Spracherkennung, Gestensteuerung oder Interaktionsszenarien. Diese Modularit‰t ist entscheidend, um den unterschiedlichen Anforderungen der Nutzer gerecht zu werden und eine flexible Anpassung der Anwendungen zu ermˆglichen. In der Evaluierung wurde festgestellt, dass Nutzer, die mit dem CMS arbeiten, von der Mˆglichkeit profitieren, bestehende Module zu kombinieren und zu modifizieren, was die Entwicklungszeit erheblich verk¸rzt und die Effizienz steigert.  Die technische Implementierung des CMS wird ebenfalls kritisch betrachtet. Die Auswahl geeigneter Technologien, wie beispielsweise einer stabilen Backend-Architektur und einer responsiven Frontend-Entwicklung, hat sich als essenziell herausgestellt. In der Evaluierung wird aufgezeigt, dass die Verwendung moderner Webtechnologien, wie React f¸r das Frontend und Node.js f¸r das Backend, nicht nur die Performance des Systems verbessert, sondern auch die Wartbarkeit und Erweiterbarkeit des Codes erleichtert. Dies ist besonders wichtig in einem sich schnell entwickelnden technologischen Umfeld, in dem kontinuierliche Updates und Anpassungen notwendig sind.  Schlieﬂlich wurde in der Evaluierung auch die Bedeutung von Nutzerfeedback hervorgehoben. Durch die Implementierung von Feedback-Schleifen in den Entwicklungsprozess konnte das CMS kontinuierlich optimiert werden. Nutzerumfragen und Testl‰ufe haben gezeigt, dass die Nutzerzufriedenheit mit der Plattform hoch ist, was sich positiv auf die Akzeptanz und die Verbreitung des Systems auswirkt. Die Evaluierung hat best‰tigt, dass die Einbeziehung von Nutzermeinungen in den Entwicklungsprozess nicht nur die Qualit‰t des Endprodukts verbessert, sondern auch eine Community von Entwicklern schafft, die sich aktiv an der Weiterentwicklung des CMS beteiligen.  Zusammenfassend l‰sst sich sagen, dass der Aufbau eines CMS zur Erstellung von Android Apps f¸r den humanoiden Rob;1
Um die Grundlage f¸r ein gemeinsames Verst‰ndnis von Kommunikationsprotokollen und Kommunikation zu legen, werden hier zun‰chst der Begriff des Kommunikationsprotokoll und allgemeine Netzwerkgrundlagen erl‰utert. ìA protocol is a set of conventions and rules governing their use that regulates thecommunicationofanentityunderobservationwithitsenvironment.î Urspr¸nglich bezog sich der Begriff Protokoll auf die Gebr‰uche und Vorschriften, die sich mit diplomatischen Formalit‰ten, Vorrang und Etikette befassen Im Zusammenhang mit Computer-Netzwerken wird der Begriff Protokoll als eine Reihe von Regeln f¸r das Format von Nachrichten, die zwischen Computern ausgetauscht werden, verwendet. F¸r eine eindeutigere Ausdrucksweise wird hierf¸r auch der Begriff Kommunikationsprotokoll verwendet. Als genaue Definition f¸r den Begriff Protokoll soll hier das oben stehende Zitat verwendet werden. Die formale Spezifikation eines Kommunikationsprotokolls besteht aus der message format specification, der message-processing procedutres specification und der error processing specification. Das message format legt die Struktur einer Nachricht vollst‰ndig fest und definiert also die Menge der Felder, aus denen die Nachricht besteht. Dies geschieht dadurch, dass die Breite der einzelnen Felder, das angewandte Kodierungsschema und optional zul‰ssige Werte bestimmt werden. Eine Nachricht ist also eine Reihe von Bits, die logisch in verschiedene Felder unterteilt sind. Typischerweise besteht dabei eine Nachricht aus einem header, der meist mehrere Unterfelder umfasst und die Nutzdaten, die auch als payloadbezeichnet werden, und die Daten, die von dem kommunizierenden Programmobjekten interpretiert werden, enthalten.;0
Durch die Arbeit konnte die Funktionsweise des deklarativen Ansatzes verstanden und anhand geeigneter, selbst implementierter Beispiele dargelegt werden. Generell hat sich herausgestellt, dass das Arbeiten mit dem Jetpack Compose Framework nach der Einar- beitungsphase relativ leicht umzusetzen ist und f¸r den Entwicklungsprozess tats‰chlich Vorteile mit sich bringt. Diese Tatsache wird best‰tigt durch die entwickelte und funk- tionsf‰hige Co?eeCompose Anwendung, deren vollst‰ndige ober?‰chliche Erscheinung abschlieﬂend in den folgenden zwei Abbildungen dargestellt wird. Abbildung 5.1 zeigt dabei das UImit hellem Theme, w‰hrend Abbildung 5.2 auf der n‰chsten Seite das UI unter Verwendung des Darkmode darstellt. Das Umsetzen der in den Abbildungen 5.1 und 5.2 veranschaulichten Ober?‰chen war aufgrund der reinen Verwendung von Kotlin und der zentralen Programmierung in einer Datei ohne die sonst ¸bliche Trennung in XML-File und Activity sehr angenehm. Diese Tatsache kann als einer der Gr¸nde angef¸gt werden, warum das Framework so groﬂes Potenzial f¸r zuk¸nftige Entwicklungen bietet. Generell bleibt abzuwarten, inwieweit sich die Nutzung des Jetpack Compose Frameworks in Zukunft etablieren wird. Sicher ist jedoch, dass der deklarative Ansatz bei immer mehr Unternehmen Anklang ?ndet und bereits heute von einigen groﬂen Unternehmen wie Twitter, Monzo, Square und Cuvva eingesetzt wird. Vermutlich ist es nur eine Frage der Zeit, bis auch kleinere Unternehmen die Vorteile des Ansatzes erkennen, das Jetpack Compose Framework einsetzen und damit zu einer Erhˆhung seines Bekanntheitsgrades beitragen.;0
 Kapitel 5: Qualit‰tsanforderungen f¸r eine wissenschaftliche Arbeit ¸ber produktorientierte Metriken der Softwarequalit‰t   Einleitung  Eine wissenschaftliche Arbeit zu den Themenfeldern der Softwarequalit‰t und produktorientierter Metriken erfordert nicht nur eine fundierte theoretische Basis, sondern auch eine klare Struktur und systematische Vorgehensweise. Dieses Kapitel beleuchtet die grundlegenden Qualit‰tsanforderungen, die solche Arbeiten erf¸llen sollten, um sowohl akademischen Standards gerecht zu werden als auch praktische Relevanz zu besitzen.   1. Relevanz und Originalit‰t  Die erste Qualit‰tsanforderung an eine wissenschaftliche Arbeit ist die Relevanz des Themas. Die Untersuchung der produktorientierten Metriken der Softwarequalit‰t sollte aktuelle Herausforderungen und Trends in der Softwareentwicklung widerspiegeln. Dar¸ber hinaus ist es wichtig, dass die Arbeit einen originellen Beitrag zum bestehenden Wissensstand leistet. Originalit‰t kann durch die Einf¸hrung neuer Metriken, innovative Anwendung bestehender Metriken oder durch die Entwicklung neuer Analyseans‰tze erzielt werden.   2. Wissenschaftliche Methodik  Die Auswahl der Methodik ist entscheidend f¸r die Qualit‰t einer wissenschaftlichen Arbeit. Bei der Untersuchung produktorientierter Metriken sollten sowohl qualitative als auch quantitative Methoden zum Einsatz kommen. Die Arbeit sollte eine klare Forschungsfrage definieren und systematisch beantworten. Hierzu gehˆren u. a.:  - Literaturrecherche: Eine umfassende Analyse bestehender Forschung muss durchgef¸hrt werden, um den Kontext der Arbeit zu etablieren und bisherige Forschungsl¸cken zu identifizieren. - Datenerhebung: Die Erhebung von Daten muss systematisch und nachvollziehbar erfolgen. Dies kann durch Umfragen, Interviews oder Fallstudien geschehen. - Datenanalyse: Die Anwendung geeigneter Analysemethoden ist essenziell, um valide Ergebnisse zu erhalten. Statistische Verfahren, Benchmarking und Case Studies sind Beispiele, die genutzt werden kˆnnen.   3. Struktur und Koh‰renz  Die Struktur der Arbeit muss logisch und koh‰rent sein. Dies umfasst eine klare Gliederung, die es dem Leser ermˆglicht, den Gedankeng‰ngen leicht zu folgen. ‹bliche Strukturelemente sind:  - Einleitung: Vorstellung des Themas, der Fragestellungen und der Zielsetzung. - Theoretischer Hintergrund: Erl‰uterung relevanter Begriffe und Theorien, die produktorientierte Metriken der Softwarequalit‰t betreffen. - Methodik: Detaillierte Beschreibung der Forschungsans‰tze und der Datenerhebung. - Ergebnisse: Pr‰sentation und Diskussion der Findings in Bezug auf die gestellten Fragen. - Fazit und Ausblick: Zusammenfassung der Ergebnisse und Hinweise auf zuk¸nftige Forschungsrichtungen.   4. Nachvollziehbarkeit und Transparenz  Eine hohe Nachvollziehbarkeit ist f¸r die wissenschaftliche Integrit‰t unerl‰sslich. Alle Methoden, Datenquellen und analytischen Schritte sollten klar dokumentiert werden. Der Leser sollte in der Lage sein, den Forschungsprozess nachzuvollziehen und die Ergebnisse zu reproduzieren. Transparenzerfordernisse kˆnnen durch folgende Maﬂnahmen erf¸llt werden:  - Vollst‰ndige Angabe der verwendeten Metriken. - Offenlegung der Datenherkunft und -verarbeitung. - Detaillierte Beschreibung der angewandten Analysemethoden.   5. Formale Kriterien  Die Einhaltung formaler Anforderungen ist ebenso wichtig. Dazu z‰hlen:  - Sprachliche Qualit‰t: Klare, pr‰zise und wissenschaftliche Sprache ist Voraussetzung. H‰ufige Revisionen und das Einholen von Feedback kˆnnen hier hilfreich sein. - Zitation und Referenzierung: Alle verwendeten Quellen m¸ssen korrekt zitiert werden, um Plagiate zu vermeiden und den wissenschaftlichen Diskurs zu fˆrdern. - Formatierung: Die Arbeit sollte gem‰ﬂ den Vorgaben der Hochschule formatiert werden (z. B. Schriftart, Randabst‰nde, Fuﬂnoten).   Fazit  Die Qualit‰tsanforderungen an eine wissenschaftliche Arbeit ¸ber produktorientierte Metriken der Softwarequalit‰t sind umfassend und vielschichtig. Sie umfassen sowohl inhaltliche als auch formale Aspekte und erfordern eine strukturierte Herangehensweise sowie ein hohes Maﬂ an wissenschaftlicher Integrit‰t. Durch die Beachtung dieser Anforderungen kann eine fundierte und wertvolle Arbeit entstehen, die dazu beitr‰gt, das Verst‰ndnis und die Anwendung von Metriken zur Bewertung der Softwarequalit‰t zu vertiefen.;1
Azure DevOps Services kann als ÑBasic -Planì oder als ÑBasic  und Test Planì gebucht werden.  Der Plan ÑBasic und Test Planì wird aufgrund seines zu hohen  Preises von 49,46Ä pro Monat  pro Person nicht ber¸cksichtigt. Es wird nur der ÑBasic -Planì genauer betrachtet.   Das Lizenzmodell ist flexibel. Die Lizenzkosten werden tagesgenau berechnet . Erh‰lt eine  Person beispielsweise nur einen halben Monat Zugriff auf die Software, wird sie nur zur H‰lfte  des Monatspreises berechnet. Die monatlichen Kosten betrage n 5,71Ä, ein reduzierter Tarif  f¸r Bildungseinrichtungen wird nicht angeboten. Die ersten 5 Personen werden nicht  berechnet. Das bedeutet, dass die ersten 5 Personen kostenlos sind,  und f¸r jede weitere  Person eine Geb¸hr von 5,71Ä im Monat erhoben wird. Jira Software kann in den Stufen ÑFreeì, ÑStandardì, ÑPremiumì und ÑEnterpriseì lizensiert  werden. Besonders ist, dass der Preis f¸r Bildungsst‰tten um die H‰lfte reduziert wird. Deswegen betr‰gt der monatliche Preis einer Lizenz f¸r Bildungsst‰tten  nicht $7,50 USD, sondern nur $3,75 USD und kann somit mit dem ÑBasic -Planì von Azure  DevOps konkurrieren. Die Stufe ÑFreeì ist nur f¸r bis zu 10 Personen verf¸gbar und ist  deswegen keine Option. Die Stufen ÑPremiumì und hˆher kosten mit Bildungsst‰ttenrabatt  mindestens $7,25 USD und sind deswegen keine Alternative zur bereits eingesetzten Software  Azure DevOps Services.;0
"Evaluierung: Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachung  In der heutigen Zeit, in der digitale Technologien unser Leben in nahezu allen Bereichen durchdringen, ist das Thema der digitalen ‹berwachung sowohl relevant als auch kontrovers. Die wissenschaftliche Arbeit mit dem Titel ""Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachung"" beleuchtet die vielf‰ltigen Facetten dieses Ph‰nomens und bietet eine differenzierte Analyse der damit verbundenen Chancen und Risiken.  Zun‰chst wird die Mˆglichkeit der digitalen ‹berwachung als ein Instrument der Sicherheit und Effizienz hervorgehoben. In vielen Bereichen, wie etwa der Kriminalit‰tsbek‰mpfung, der Terrorismuspr‰vention oder der Gesundheits¸berwachung, kˆnnen digitale Technologien dazu beitragen, Bedrohungen fr¸hzeitig zu identifizieren und zu bek‰mpfen. Die Arbeit argumentiert, dass durch den Einsatz von ‹berwachungstechnologien, wie Gesichtserkennung oder Big Data-Analysen, eine proaktive Herangehensweise an Sicherheitsfragen mˆglich wird. Diese Technologien ermˆglichen es, Muster zu erkennen und potenzielle Risiken zu minimieren, was in einer zunehmend komplexen und vernetzten Welt von groﬂer Bedeutung ist.  Jedoch wird gleichzeitig auf die erheblichen Gefahren hingewiesen, die mit der digitalen ‹berwachung einhergehen. Die Arbeit thematisiert insbesondere die Verletzung der Privatsph‰re und die potenzielle Missbrauchsgefahr von gesammelten Daten. In einer Gesellschaft, in der die Grenzen zwischen Sicherheit und Freiheit immer mehr verschwimmen, stellt sich die Frage, inwieweit der Einzelne bereit ist, persˆnliche Freiheiten zugunsten eines vermeintlichen Sicherheitsgewinns aufzugeben. Die Analyse zeigt, dass eine unkontrollierte digitale ‹berwachung nicht nur zu einem Verlust an Vertrauen in staatliche Institutionen f¸hren kann, sondern auch zu einer Entm¸ndigung des Individuums und einer Gef‰hrdung demokratischer Werte.  Ein weiterer zentraler Punkt der Arbeit ist die Diskussion ¸ber die ethischen Implikationen der digitalen ‹berwachung. Die Autorin oder der Autor setzt sich kritisch mit der Rolle von Unternehmen und Regierungen auseinander, die durch den Einsatz von ‹berwachungstechnologien nicht nur die Daten der B¸rger sammeln, sondern auch deren Verhalten beeinflussen kˆnnen. Dies wirft grundlegende Fragen nach der Verantwortung und Transparenz auf, die in einer digitalen Gesellschaft unabdingbar sind.  Insgesamt bietet die Arbeit ""Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachung"" einen fundierten und ausgewogenen ‹berblick ¸ber ein hochaktuelles Thema. Sie regt zur Reflexion ¸ber die Balance zwischen Sicherheit und Freiheit an und fordert dazu auf, einen kritischen Blick auf die Entwicklungen im Bereich der digitalen ‹berwachung zu werfen. Die vielf‰ltigen Argumente und Perspektiven, die in der Arbeit pr‰sentiert werden, laden dazu ein, die eigene Haltung zu diesem Thema zu hinterfragen und sich aktiv an der Diskussion ¸ber die Zukunft der digitalen Gesellschaft zu beteiligen.   Die wissenschaftliche Auseinandersetzung mit den Mˆglichkeiten und Gefahren der digitalen ‹berwachung ist nicht nur von akademischem Interesse, sondern von essenzieller Bedeutung f¸r das Verst‰ndnis der gesellschaftlichen Ver‰nderungen, die durch die Digitalisierung hervorgerufen werden. In einer Welt, in der die Technologie st‰ndig voranschreitet, ist es unerl‰sslich, die damit verbundenen Herausforderungen und Chancen kritisch zu beleuchten, um eine informierte und verantwortungsvolle Gesellschaft zu fˆrdern.";1
Wie in Abschnitt 5.3.1beschrieben, besteht die Fahrzeugfernsteuerung aus dem Xbee- 3-Modul, dass auf dem Sparkfun ThingPlus -Controller montiert ist und ¸ber das I2C- Protokoll mit dem Adafruit Pygamer verbunden ist. Da der Xbee nur MicroPython unterst¸tzt, wird dieser in MicroPython programmiert. F¸r den Pygamer-Controller stehen sowohl MicroPython als auch Arduino als Programmierumgebung zur Verf¸gung, hier wird jedoch Arduino ausgew‰hlt, da compilierte Programme typischerweise schneller in der Ausf¸hrung sind als interpretierte Programme (vgl. ). Da f¸r MicroPython nur eine Controller-Implementierung von I2Cgefunden werden konnte, agiert das Xbee- Modul im I2C-Kontext als Controller und der Pygamer als Peripheral. Zur besseren Veranschaulichung wird die Software als Flussdiagramm visualisiert und die einzelnen Funktionalit‰ten im Text genauer beschrieben. Xbee:Das Flussdiagramm des Programmablaufs ist in Abbildung 5.12zu sehen. Da der Xbee als I2C-Controller fungiert, ¸bernimmt er die Steuerung des Ablaufs der I2C- Kommunikation zwischen Xbee und Pygamer, wodurch er diesem Werte sendet und anfragt. Zu Beginn wartet der Xbee-Controller, bis er den Pygamer auf dem I2C-Bus gefunden hat und sendet diesem in der spezifizierten Sendefrequenz alle 25ms eine steering message. Dabei fragt er die aktuelle Joystick-Position der Fernsteuerung ab und ¸berpr¸ft anschlieﬂend, ob eine collision avoidance message vom Fahrzeugcontroller empfangen wurde. Ist dies der Fall, so wird diese Nachricht an den Pygamer ¸ber den I2C-Bus gesendet. In jedem Fall aber wird danach ¸berpr¸ft, ob gen¸gend Zeit vergangen ist und der ganze Zyklus wird wiederholt. Der Quellcode ist in Anhang 1zu finden. Pygamer: Wie in Flussdiagramm des Programmablaufs in Abbildung 5.13 dargestellt, reagiert der Pygamer als Peripheral nur auf Befehle des Controllers und ¸bernimmt keine aktive Rolle in der Kommunikation mit dem Xbee-Controller.;0
Um den Luftreiniger in der Applikation bedienen zu kˆnnen, wurde ein Fragmentmit Knˆpfen erstellt und durch diese Knˆpfe werden HTTP-Anfragen an den Webserver geschickt. Dazu wird in der Arbeit die Bibliothek Fuelf¸r Android verwendet, mit der HTTP-Anfragen gestellt werden kˆnnen. In dem Listing 4.1 ist die Funktion der Stellung einer HTTP-Anfrage mit Fuelzu sehen. Der Luftreiniger kann unter der lokalen, statischen Internetprotokoll ( IP)-Adresse 192.168.0.196 aufgerufen werden (vgl. Ebert und Schweier 15.12.2021, S. 33). Daher ist es wichtig, dass das Tablet mit dem gleichen Router wie der Luftreiniger verbunden wird. Um die HTTP- Anfragen erfolgreich verschicken zu kˆnnen, muss das Tablet sich authentifizieren. Das erfolgt durch die Angabe des im Programmcode des Luftreinigers (beziehungsweise des ESP32-Mikrocontrollers) definierten Schl¸ssels. In der Applikation sind Knˆpfe zu finden (siehe Abschnitt 4.5) und mithilfe eines onClickListeners2wird nach klicken eines Knopfs die Funktion ÑgetResponseì mit der jeweiligen Betriebsstufe als Parameter aufgerufen und somit eine HTTP-Anfrage an den Webserver geschickt. Falls das Tablet nicht mit dem Router verbunden ist, werden die Nutzer*innen durch eine Toast Massage3darauf hingewiesen. Es kann zu einem Absturz der Anwendung kommen, wenn das Tablet nicht mit dem Router verbunden ist und vor der Erscheinung der Toast Massage eine andere willk¸rliche Stelle angeklickt wird. Ein Fragment stellt einen wiederverwendbaren Teil der Benutzeroberfl‰che der Anwendung dar. Es definiert und verwaltet sein eigenes Layout, hat seinen eigenen Lebenszyklus und kann seine eigenen Eingabeereignisse verarbeiten. (vgl. Android for Developers 26.10.2021) 2Schnittstellendefinition f¸r einen Callback, der aufgerufen wird, wenn eine Ansicht angeklickt wird. (vgl. Android for Developers 10.02.2022c). 3Ein Toast bietet eine einfache R¸ckmeldung ¸ber einen Vorgang in einem kleinen Pop-up-Fenster (vgl. Android for Developers 12.11.2021).;0
Nach Abgleich der unterschiedlichen Registern mit der Memory Map werden die in 1.Verwendung eines Alias-Namen, um die Wiederverwendung des Moduls Circuits.I2C auf I2C zu beschr‰nken 2. Ermitteln aller Ger‰te am I2C-Bus 3. Verwenden der Variable sensor f¸r den BME680 4. Verwenden der Variable register f¸r das Kontrollregister Ctrl_meas des BME680 5. Erstellen der I2C-Referenz f¸r die Kommunikation ¸ber den Bus 6. Abfrage des Inhalts des Kontrollregisters (Modus: Forced Mode) 7. Konvertierung des Inhalts des Kontrollregisters in Bin‰rsystem 8. Abfrage des Inhalts des Kontrollregisters (Modus: Sleep) 9. Konvertierung des Inhalts des Kontrollregisters in Bin‰rsystem 10. Konfiguration der Kontrollregister Config und Ctrl_meas f¸r den Modus Sleep 11.Konfiguration der Kontrollregister Config und Ctrl_meas f¸r den Modus Forced Mode 12. Schreiben der Konfiguration in die Kontrollregister 13. Abfrage des Inhalts des Kontrollregisters (Modus: Sleep) 14. Konvertierung des Inhalts des Kontrollregisters in Bin‰rsystem;0
Durch eine Vorrecherche unter Beachtung der erl‰uterten Aspekte, wird die Kamera ÑRaspberry Pi Kamera 175∞ Super-Weitwinkelobjektiv & Automatik Infrarot-Sperrfilter ñ Full HD mit Infrarot LEDsì vonElectreeksÆ f¸r diese Studienarbeit verwendet. Diese ist inAbbildung 4.1 zu sehen. Die Kamera hat ein Sichtfeld von 175 ∞diagonal, eine Auflˆsung von f¸nf Megapixel, nimmt Videos mit 1080p und 30 Frames per second ( FPS) auf. Die Kamera hat eine Abmaﬂe von 80mm Breite, 30mm L‰nge und 28mm Hˆhe und wiegt 18,1 Gramm. Dazu hat die Kamera einen Infrarot-Sperrfilter, der sich automatisch je nach Lichtbedingung umschaltet und so in den Nachtsichtmodus wechseln kann, wenn es dunkel wird.  Der Katzenbesitzer soll auf seinem Smartphone ein Bild erhalten sobald das Raspberry Pi mithilfe der Kamera eine Katze erkannt hat. Diese soll auf dem Bild markiert sein, sodass der Besitzer die Katze schnell auf dem Bild erkennt oder feststellt, dass ein Fehler aufgetreten ist und der Algorithmus falsch lag und ein anderes Objekt als Katze erkannt wird. Aus diesem Grund wird f¸r diese Arbeit ein Algorithmus f¸r Objekterkennung verwendet, der die Katze auf dem Bild lokalisieren und markieren kann. F¸r die Erkennung von Objekten gibt es mehrere Ans‰tze. Beispielsweise kˆnnen mithilfe vonTemplate Matching Objekte erkannt werden. Dabei werden bestimmte Charakteris- tiken bzw. Eigenschaften eines Objekts als Vorlage definiert. Anschlieﬂend wird ¸berpr¸ft, ob diese im Bild vorkommen. So wird entschieden, ob und an welcher Stelle ein gewisses Objekt im Bild vorkommt.;0
In der Entwicklung von IoTSystemen ist ein groﬂes Problem das Fehlen von Standardi- sierung. Das bezieht sich auf mehrere Aspekte dieser Thematik, sowohl zu finden bei der Definition eines IoTSystems, als auch bei der Implementierung dieser Systeme . Da das Feld der IoTsehr neu ist und sich selbst in Maﬂst‰ben der Informationstech- nik in kurzen Zeitr‰umen stark wandelt, ist eine einheitliche Definition quasi unmˆglich. Ebenso unterscheiden sich Anwendungsgebiete von privater Nutzung im Bereich ÑSmart Homeì zur Fernsteuerung von Ger‰ten bis zur eingebetteten Informationssammlung in groﬂen Industrieanlagen. Daher bietet sich eine relativ allgemeine Definition des Terms an, wie sie beispielsweise von Mattern et al. in ihrem Artikel ÑFrom the Internet of Computers to the Internet of Thingsì vorgeschlagen wurde: ÑThe Internet of Things represents a vision in which the Internet extends into the real world embracing everyday objects. Physical items are no longer disconnected from the virtual world, but can be controlled remotely and can act as physical access points to Internet services. An Internet of Things makes computing truly ubiquitousì  Hier steht ganz zentral die Rolle von IoTSystemen zur Verbindung der physischen, realen Welt mit der digitalen, virtuellen Welt im Vordergrund. Dieser Gedanke stellt einen kleinsten gemeinsamen Nenner f¸r die Beschreibung von IoTSystemen dar, ohne auf deren weitergehende Funktionen einzugehen. Ebenso geht die Idee der Ubiquit‰t, daher der Allgegenwertigkeit, von Computersystemen aus der Funktionsweise der IoTGer‰te hervor. Zentral ist dabei die Integration dieser Ger‰te in den Alltag in einer unterschwelligen und nicht auffallenden Weise. Mark Weiser, der Vorreiter dieses von ihm Ñubiquitous computingì gennanten Gebiets, beschreibt dabei in seinem Artikel ÑThe Computer for the 21st Centuryì, dass nicht der Mensch aktiv Maschinen benutzen solle, sondern stattdessen diese den Menschen unaufdringlich im Alltag unterst¸tzen sollen.;0
Ein wichtiger Punkt zum Sammeln von Informationen sind Metadaten. Aus ihnen lassen sich Korrelationen feststellen und interpretieren. Sie sind oft sogar wichtiger als die eigentlichen Daten. Mit Metadaten wird im buch versucht Zero zu finden. So lassen sich als Beispiel die Metadaten von Fotos hervorragend tracken. Meta macht dies um Bilder Personen zuordnen zu kˆnnen. Diese daten enthalten, wo ein Foto gemacht wurde und mit  welchem Ger‰t.  Es kann auch festgestellt werden, ob beim Teilen das Foto mit anderen  Personen verlinkt wird. Gleichzeitig wird jedem Foto eine eindeutige ID vergeben, um dieses  einfacher wiederzuerkennen, falls es erneut irgendwo im Netz auftaucht (Hurtz 2022), Bei  Meta ist das nicht unerwartet, aber Google kann das Tracking auch. So werden bei einem  Login in Googledienste ein Cookie  gesetzt der Einstellungen speichert. Dieser Cookie  bleibt  erhalten  und hat eine eindeutige  ID mit der kann Google dann bei weiteren Seitenaufrufen  mit demselben Browser den Nutzer seiten¸bergreifend namentlich identifizieren (Kuketz  2022b). Doch selbst auf Webseiten  die nichts mit Meta oder Google zu tun haben kann  Google doch noch tracken. Dies geht dann, wenn beispielsweise Google Fonts in einer  Webseite  eingebunden werden ohne diese selber zu hosten (online  2022c). Dadurch gelangt  Google wieder an Informationen, welche sie nutzen kˆnnen, um ihre Datensammlung zu  vervollst‰ndigen. Doch auch der Staat kann Meta beim Tracking helfen. So hat 2020 das  Bundesministerium f¸r Verteidigung Nutzer der App ÑBundeswehr Mediaì mit Facebook  und Google Firebase Analytics getrackt (Kuketz 2022a). Dadurch kann Meta die Interessen   eines Nutzers der App anhand der Benutzung der App berechnen (Facebooks unsichtbare  Datensammlung 2018). Dabei erf‰hrt Meta zu welcher Uhrzeit mit welcher IP welche App  benutzt wurde. Damit lassen sich wieder viele Dinge  herleiten. Durch das umfangreiche  Sammeln von Metadaten kˆnnen Interessen  eines Nutzers genau bestimmt werden. Anhand  dessen kann dem Nutzer dann auf seine Interessen gezielte Werbung  geschaltet werden.  Teilweise wird aber auch extra wie im Buch beschrieben falsche Werbung  eingef¸gt,  um  einen Creepiness-Effekt zu vermeiden ( Was passiert,  wenn W erbung  creepy wird? 2020).  Wie m‰chtig Metadaten sind, kann David Kriesel vom Chaos  Computer  Club bezeugen.  Er hat 2016 s‰mtliche Metadaten von Spiegelautoren gesammelt  und ausgewertet. Dabei  hat er nicht nur herausgefunden, wer ¸ber was gerne schreibt, sondern auch wer wann  arbeitet (Media.Ccc.de - SpiegelMining ñ Reverse  Engineering  von Spiegel-Online 2022).  Oder wer mit wem in den Urlaub geht. Es konnten Interessen bestimmt werden und sogar  Romanzen (ingo 2016).;0
 Aufbau eines Content-Management-Systems zur Erstellung von Android Apps f¸r den humanoiden Roboter Pepper     Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, hat sich als vielseitiges Werkzeug in verschiedenen Anwendungsbereichen etabliert, darunter Bildung, Kundenservice und soziale Interaktion. Um die Interaktivit‰t und Anpassungsf‰higkeit von Pepper zu erhˆhen, wurde ein Content-Management-System (CMS) konzipiert, das es Nutzern ermˆglicht, ohne tiefgehende Programmierkenntnisse eigene Android-Apps f¸r den Roboter zu erstellen. Diese Arbeit untersucht den Aufbau dieses CMS, die Herausforderungen w‰hrend des Entwicklungsprozesses und die Ergebnisse des Projekts.   Aufbau des CMS  Das CMS wurde in mehreren Phasen entwickelt, beginnend mit der Anforderungsanalyse, um die Bed¸rfnisse der Endnutzer zu identifizieren. Eine benutzerfreundliche Oberfl‰che wurde entworfen, die es den Nutzern ermˆglicht, Inhalte wie Texte, Bilder, Videos und interaktive Elemente einfach zu integrieren. Die Architektur des Systems basiert auf einer modularen Struktur, die es erlaubt, verschiedene Funktionalit‰ten als Plugins hinzuzuf¸gen. Diese Flexibilit‰t ist entscheidend, um zuk¸nftige Erweiterungen und Anpassungen zu ermˆglichen.  Die technische Umsetzung erfolgte unter Verwendung von Java und Android Studio, da Pepper auf dem Android-Betriebssystem basiert. Ein zentrales Element des CMS ist die API-Schnittstelle, die eine Kommunikation zwischen der App und den Hardwarekomponenten des Roboters ermˆglicht. Hierbei wurden Sicherheitsaspekte und Datenintegrit‰t besonders ber¸cksichtigt, um eine reibungslose Interaktion zwischen Nutzer und Roboter zu gew‰hrleisten.   Herausforderungen  W‰hrend der Entwicklung des CMS traten mehrere Herausforderungen auf. Eine der grˆﬂten H¸rden war die Gew‰hrleistung der Benutzerfreundlichkeit. Es stellte sich heraus, dass viele potenzielle Nutzer, insbesondere im Bildungsbereich, wenig bis keine Erfahrung mit der App-Entwicklung hatten. Um diesem Problem entgegenzuwirken, wurden umfangreiche Tutorials und eine Hilfefunktion in das CMS integriert.   Ein weiteres Problem war die Anpassung der Apps an die spezifischen Interaktionsf‰higkeiten von Pepper. Die Komplexit‰t der Robotik und die Notwendigkeit, spezifische Bewegungs- und Sprachausgaben zu integrieren, erforderten eine enge Zusammenarbeit zwischen Entwicklern und Robotikexperten.    Fazit  Das entwickelte Content-Management-System stellt einen bedeutenden Schritt in der Demokratisierung der Roboterprogrammierung dar. Durch die Schaffung einer benutzerfreundlichen Plattform konnten auch Nutzer ohne technische Vorkenntnisse erfolgreich Apps f¸r Pepper erstellen. Die modular aufgebaute Architektur des CMS bietet nicht nur Flexibilit‰t, sondern auch die Mˆglichkeit, das System kontinuierlich zu erweitern und an neue Anforderungen anzupassen.  Die R¸ckmeldungen der ersten Nutzer zeigen, dass das CMS das Potenzial hat, die Einsatzmˆglichkeiten von Pepper erheblich zu erweitern. Insbesondere im Bildungsbereich wird die Interaktion mit den Sch¸lern durch individuelle, von Lehrern erstellte Apps bereichert.   Insgesamt zeigt das Projekt, dass die Verbindung von Robotik und nutzerfreundlicher Softwareentwicklung neue Horizonte erˆffnet. Zuk¸nftige Arbeiten sollten sich darauf konzentrieren, die Funktionalit‰ten des CMS weiter auszubauen und zus‰tzliche Integrationen zu ermˆglichen, um die Interaktivit‰t und den;1
  Die In-room Ortung, auch bekannt als Innenraumlokalisierung, hat in den letzten Jahren an Bedeutung gewonnen, insbesondere im Kontext der Sturzerkennung bei ‰lteren Menschen und Personen mit erhˆhtem Sturzrisiko. Die Kombination aus fortschrittlicher Sensortechnologie und drahtloser Kommunikation, insbesondere durch Bluetooth-Technologie, bietet vielversprechende Ans‰tze zur Verbesserung der Sicherheit und Lebensqualit‰t dieser Bevˆlkerungsgruppen.   Grundlagen der In-room Ortung  Die In-room Ortung zielt darauf ab, die Position eines Objekts oder einer Person innerhalb eines geschlossenen Raumes pr‰zise zu bestimmen. Im Gegensatz zur GPS-Technologie, die f¸r die Ortung im Freien optimiert ist, erfordert die Innenraumlokalisierung alternative Methoden, um die Herausforderungen von W‰nden, Mˆbeln und anderen Hindernissen zu ¸berwinden. Zu den g‰ngigen Verfahren z‰hlen die Signalst‰rke-basierte Ortung, die trilaterale oder triangul‰re Ortung sowie die Verwendung von Inertialsensoren.   Bluetooth-Technologie  Bluetooth ist eine weit verbreitete drahtlose Technologie, die f¸r die Kurzstreckenkommunikation zwischen Ger‰ten entwickelt wurde. Sie operiert im 2,4-GHz-Band und ermˆglicht eine Energieeffizienz, die f¸r tragbare Ger‰te von Vorteil ist. Bluetooth Low Energy (BLE), eine Variante der Bluetooth-Technologie, hat sich besonders f¸r Anwendungen in der Gesundheits¸berwachung und der In-room Ortung etabliert. BLE ermˆglicht eine l‰ngere Batterielebensdauer, was f¸r tragbare Sensoren, die zur Sturzerkennung eingesetzt werden, von entscheidender Bedeutung ist.   Prinzipien der Sturzerkennung  Die Sturzerkennung kann durch die Analyse von Bewegungsmustern und Kˆrperhaltungen realisiert werden. Hierbei kommen typischerweise verschiedene Sensoren zum Einsatz, darunter Beschleunigungssensoren, Gyroskope und Magnetometer, die in tragbaren Ger‰ten oder Smart-Home-Systemen integriert sind. Diese Sensoren erfassen kontinuierlich die Bewegung und die Lage des Tr‰gers. Bei einem Sturz zeigt die Analyse der Sensordaten charakteristische Muster, wie plˆtzliche Beschleunigungen oder abrupte ƒnderungen der Kˆrperposition.   Implementierung der In-room Ortung mit Bluetooth  Die Implementierung eines Systems zur Sturzerkennung mittels Bluetooth umfasst mehrere Schritte. Zun‰chst ist die Installation von Bluetooth-Beacons in strategischen Positionen innerhalb eines Raumes erforderlich. Diese Beacons senden regelm‰ﬂig Signale aus, die von den tragbaren Ger‰ten der Benutzer empfangen werden. Die Signalst‰rke (RSSI - Received Signal Strength Indicator) der empfangenen Signale wird verwendet, um die Entfernung zu den Beacons abzusch‰tzen. Durch die Kombination der Informationen von mehreren Beacons l‰sst sich die Position des Benutzers im Raum triangulieren.  Zus‰tzlich zur Positionierung m¸ssen Algorithmen zur Datenanalyse entwickelt werden, um St¸rze in Echtzeit zu erkennen. Diese Algorithmen verarbeiten die Sensordaten und identifizieren Muster, die auf einen Sturz hindeuten. Bei einer erkannten Sturzbewegung kann das System automatisch Notfallkontakte benachrichtigen oder erste Hilfe anfordern.   Herausforderungen und Ausblick  Trotz der Fortsch;1
Wie der Name schon sagt, pr¸ft dieses statische Analysewerkzeug  C- oder C++ -Quellcode anhand des  MISRA -Standards. Auﬂerdem wird die Einhaltung einiger weiterer Richtlinien und  Sicherheitsstandards wie CWE oder CERT sichergestellt. Der Fokus von QA-MISRA  liegt neben der  Durchsetzung von Qualit‰tseigenschaften wie Wartbarkeit besonders auf Sicherheitsaspekten.  Es  handelt sich um ein kommerzielles Tool, f¸r das es keine langfristige frei verf¸gbare Version gibt.   Erkl‰rtes Ziel von QA-MISRA  ist es folgerichtig Kosten zu sparen, indem Qualit‰ts - und  Sicherheitsprobleme zuverl‰ssig zu einem fr¸hen Zeitpunkt erkannt werden, und somit die  Wirtschaftlichkeit des Projekts zu steigern. Um einen Vergleich zu den kostenfreien Tools zu erhalten,  wurde QA-MISRA  in einem Probemonat f¸r das studentische Softwareprojekt getestet.     Durch die Vergabe verschiedener Lizenzen sowie die Installation verschiedener Komponenten, ist die  Verwendung von QA-MISRA  nicht trivial. Ergebnis se der Aufsetzung des Tools sind ein Server mit  hinterlegter Lizenz sowie ein zugehˆriger Client   . Zun‰chst muss der Server gestartet  und dessen Konfiguration ¸berpr¸ft werden. Beispielsweise muss das Verzeichnis ausgew‰hlt  werden, in dem die erzeugten Analysedat en sp‰ter abgelegt werden sollen. Eine ‹bersicht der  Konfigurations¸berfl‰che ist in Abbildung 16 zu sehen . Im Reiter ÑAnalyse nì kˆnnen alle durch den  Server ausgef¸hrten Scans f¸r die verschiedenen Projekte eingesehen werden.  Anschlieﬂend wird  der Client mit dem Server verbunden, indem der Port angegeben wird, auf den der Server hˆrt.  Im  Client kann daraufhin  ein neues Projekt angelegt werden. Dazu werden  die zu ¸berpr¸fenden  Dateien ausgew‰hlt und die anzuwendenden Regeln festgelegt. Die Auflistung der verf¸gbaren  Standards ist in Abbildung 17 dargestellt . F¸r die weiteren Betrachtungen ist nur die Messung der  Metriken relevant.  Diese beinhalten Aussagen ¸ber die Kommentardichte, die Verschachtelungstiefe,  Anzahl an Instruktionen oder Attributen und einige weitere Kennzahlen.;0
      Die Entwicklung von Anwendungen f¸r humanoide Roboter wie Pepper erfordert eine interdisziplin‰re Herangehensweise, die sowohl technologische als auch benutzerspezifische Aspekte ber¸cksichtigt. Content Management Systeme (CMS) haben sich als effektive Werkzeuge etabliert, um die Erstellung, Verwaltung und Verˆffentlichung von Inhalten zu erleichtern. Im Kontext der Robotik bietet ein CMS spezifische Vorteile, insbesondere im Hinblick auf die Anpassung und Interaktivit‰t von Anwendungen. Dieser Text untersucht die theoretischen Grundlagen f¸r den .   1.  des CMS  Ein Content Management System ist eine Softwareanwendung, die es Benutzern ermˆglicht, digitale Inhalte zu erstellen, zu bearbeiten, zu organisieren und bereitzustellen, ohne tiefgehende Programmierkenntnisse zu benˆtigen. Die grundlegenden Komponenten eines CMS umfassen - BackendHier erfolgt die Datenverwaltung, einschlieﬂlich der Speicherung von Inhalten und Metadaten. Die Backend-Architektur sollte eine Datenbankanbindung (z. B. MySQL, MongoDB) sowie ein API-Management zur Kommunikation mit der Android-App umfassen.    - FrontendDas Frontend ist die Benutzeroberfl‰che, ¸ber die Nutzer mit dem CMS interagieren. Es sollte intuitiv gestaltet sein, um eine einfache Navigation und eine benutzerfreundliche Erstellung von Inhalten zu ermˆglichen.  - Content-Management-Funktionalit‰tenDazu gehˆren Funktionen wie das Erstellen, Bearbeiten, Lˆschen und Kategorisieren von Inhalten. Ein WYSIWYG-Editor (What You See Is What You Get) kann die Benutzererfahrung erheblich verbessern.  - BenutzerverwaltungEin effektives CMS benˆtigt ein System zur Benutzerverwaltung, das unterschiedliche Rollen und Berechtigungen unterst¸tzt. Dies ist besonders wichtig, wenn mehrere Benutzer mit unterschiedlichen Kenntnissen und Verantwortlichkeiten an der App-Entwicklung beteiligt sind.   2. Anforderungen an das CMS f¸r Android Apps  Bei der Entwicklung eines CMS f¸r Android Apps, die auf dem humanoiden Roboter Pepper laufen, sind spezifische Anforderungen zu ber¸cksichtigen - Interaktive InhalteDie Mˆglichkeit, interaktive Elemente zu erstellen, ist entscheidend. Dazu gehˆren Dialogsysteme, Animationen und sensorische Eingaben, die Pepper f¸r die Interaktion mit Benutzern nutzen kann.  - Multimodale KommunikationPepper ist darauf ausgelegt, mit Menschen ¸ber verschiedene Kommunikationskan‰le zu interagieren, einschlieﬂlich Sprache, Gesten und Gesichtsausdr¸cken. Das CMS sollte die Integration dieser Kommunikationsformen unterst¸tzen.  - Echtzeit-DatenverarbeitungUm eine reibungslose Interaktion zu gew‰hrleisten, muss das CMS in der Lage sein, Echtzeitdaten zu verarbeiten und anzupassen. Dies kann durch WebSocket- oder MQTT-Protokolle erreicht werden, die eine bidirektionale Kommunikation ermˆglichen.   3. Technologische Aspekte  Die technische Umsetzung eines CMS f¸r Pepper erfordert die Ber¸cksichtigung mehrerer Technologien - ProgrammiersprachenF¸r die Entwicklung der Android-Apps sind Java oder Kotlin notwendig. Das CMS selbst kˆnnte in einer serverseitigen Sprache wie;1
"ïMapping im Backend: Werden Messwerte vom Backend (im Rahmen der Studienarbeit Node-RED) via MQTT vom TTN Server empfangen, so werden diese
gemapped. Vorteilhaft bei dieser Lˆsung ist, dass eine ƒnderung des Mappings
jederzeit ohne eine Umprogrammierung der Nodes mˆglich ist. F¸r Privatanwender
mit nur wenigen Nodes ist eine Umprogrammierung der Nodes noch mit vertretbarem
Aufwand realisierbar. Werden aber beispielsweise in einer Smart City hunderte Nodes
zur ‹berwachung s‰mtlicher Blumenbeete in Parks etc. eingesetzt, so w‰re eine
Umprogrammierung dieser Nodes sehr zeitaufwendig und kostspielig.
Um ein Mapping der Messwerte auf Prozentpunkte erstellen zu kˆnnen, wird zudem
eine ausreichende Menge von Messwerten ¸ber einen l‰ngeren Zeitraum benˆtigt. Im
Rahmen der Studienarbeit erfolgt das Mapping der Messwerte daher im Backend bzw. in
Node-RED. Somit kˆnnen ¸ber einen l‰ngeren Zeitraum Messwerte gesammelt werden und
auf Grundlage dieser ein Mapping erstellt werden. Um die in der In?uxDB gespeicherten
MesswerteimNachhineinaufProzentpunktemappenzukˆnnen,wirdderin Abbildung4.18
gezeigte Node-RED Flow verwendet.
Der in Abbildung 4.19 Codeausschnitt wird im map to percentage Baustein des in Abbil-
dung 4.18 gezeigten Node-RED Flows verwendet. Im Code werden zwei Grenzwerte f¸r
das Mapping de?niert:
ïMIN:Bei einem Messwert der Bodenfeuchtigkeit von 460 (oder weniger) ist die Erde
feucht genug, um die P?anze f¸r einen l‰ngeren Zeitraum mit Wasser zu versorgen.
Es ist in n‰chster Zeit kein Gieﬂvorgang nˆtig. Wird dieser Wert gemessen, so soll
die auf Prozentpunkte gemappte Bodenfeuchtigkeit 100 Prozent betragen.
ïMAX:Bei einem Messwert der Bodenfeuchtigkeit von 565 (oder mehr) ist die
Erde so ausgetrocknet, dass sie der P?anze kein Wasser mehr spenden kann. Ein
Gieﬂvorgang ist umgehend erforderlich. Wird dieser Wert gemessen, so soll die auf
Prozentpunkte gemappte Bodenfeuchtigkeit 0 Prozent betragen.";0
Im Verlauf der Arbeit wurden mehrere Softwares verglichen, um festzustellen, welche  Softwares zu welchem Preis das studentische Softwareengineering unterst¸tzen kˆnnen. Die  g¸nstige Software ÑTrelloì kann einige Grundanforderungen  erf¸llen, zeigt jedoch bei der  ‹bersichtlichkeit und Datenpersistenz Schw‰chen und ist deswegen nur bedingt geeignet, um  die studentische Softwareentwicklung mit anschlieﬂender Benotung zu unterst¸tzen. Die  umfangreicheren Softwares Azure DevOps Services, Jira Software und OpenProject kˆnnen  mit ihrem Funktionsumfang gew‰hrleisten, dass ein Projekt durchgef¸hrt und anschlieﬂend  bewertet werden kann. Die Ermittlung der Arbeitsleistung einzelner Personen  ist jedoch nur  mit erhˆhtem Aufwand durchf¸hrbar. Es wurde festgestellt, dass die Eigenentwicklung einer  Aufgabenverwaltungssoftware trotz reduziertem Funktionsumfang hˆchstwahrscheinlich nur  in mehreren Monaten abgeschlossen werden kann. Die Notwendigkeit, den Zugriff auf Daten  nutzerabh‰ngig einzuschr‰nken, und die vielen umzusetzenden Benutzeroberfl‰chen mit  teilweise intelligenten Eingabefeldern erschaffen Komplexit‰t, die als Benutzer der Software  nicht immer offensichtlich ist.   Die Lizenzkosten von Azure DevOps Services und Jira Software sind nicht niedrig, kˆnnen aber  mit ihrem groﬂen Funktionsumfang erkl‰rt werden. Eine Ausnahme ist OpenProject, das einen  ebenfalls groﬂen Funktionsumfang beinhaltet, jedoch auch ohne Lizenzkosten auf eigener  Hardware betrieben werden kann.;0
Die Visualisierung zeigt, wie stark die Signale sich ver‰ndern, dabei sind allerdings die Werte von allen Locators zusammengefasst und entsprechend der MAC-Adressen der Beacons aufgelistet. Um aussagekr‰ftigere Informationen zu erhalten und zu erfahren, ob diese Signalunterschie- de an einem einzelnen Locator oder Beacon liegen, wird eine Auswertung erstellt, welche darstellt, wie stark das Signal sich ver‰ndert, wenn die Ger‰te nicht bewegt werden. Dabei f‰llt auf, dass eine einzelne Beacon-Locator-Kombinationen besonders starke Ver‰n- derungen im Signal besitzt. Sp‰ter konnte durch einen Versuch gezeigt werden, dass dieses Ger‰t kein BLEBeacon, sondern ein PC ist. Damit war die Ver‰nderung kein Problem und konnte ignoriert werden, da dieser PC im Rahmen der Sturzerkennung keinen Mehrwert mit sich bringt. In der Zeit vor dieser Erkenntnis wurde viel im Bereich der Signalgl‰ttung, Filterung und Bestimmung der Distanz geforscht, beispielsweise auf Basis der Publikation  welche angibt, dass mithilfe von Kalman Filtern hˆhere Genauigkeiten bei der Projektion von RSSI Werten auf Distanzen erreicht werden kann.  Nachdem allerdings mithilfe weiterer Auswertungen (Anhang Seite 39) erkannt wurde, dass die Messwerte nicht so schlecht waren, wie die erste Auswertung vermuten lieﬂ, wurde der Fokus wieder auf das Erkennen von St¸rzen gelegt. In einer weiteren Arbeit kˆnnte die Genauigkeit durch Verwendung besserer Projektionstechniken sowie Filter optimiert werden.;0
Ein Ausblick auf zuk¸nftige Entwicklungen  Die fortschreitende Digitalisierung und Vernetzung von Fahrzeugen erˆffnet neue Mˆglichkeiten in der Automobiltechnik, insbesondere im Bereich der Fernsteuerung. Die Entwicklung einer Fahrzeugfernsteuerung, die auf dem IEEE 802.15 Standard basiert, bietet nicht nur eine innovative Lˆsung zur Steuerung von Fahrzeugen, sondern auch zur Verbesserung der Sicherheit durch Kollisionsvermeidung. Der IEEE 802.15 Standard, der f¸r drahtlose persˆnliche Netzwerke (WPANs) konzipiert wurde, ermˆglicht eine energieeffiziente und zuverl‰ssige Kommunikation zwischen Fahrzeugen und Steuerger‰ten.   Die Implementierung einer solchen Fernsteuerung erfordert eine pr‰zise Daten¸bertragung und -verarbeitung, um Echtzeitinformationen ¸ber die Umgebung des Fahrzeugs zu erhalten. Sensoren, die in das Fahrzeug integriert sind, erfassen Informationen ¸ber andere Verkehrsteilnehmer, Hindernisse und die Straﬂenbedingungen. Diese Daten werden ¸ber das IEEE 802.15 Netzwerk an die Steuerzentrale ¸bermittelt, die auf Basis von Algorithmen zur Kollisionsvermeidung entsprechende Steuerbefehle generiert. Die Herausforderung besteht darin, die Latenzzeiten der Daten¸bertragung zu minimieren und die Systemressourcen effizient zu nutzen, um eine reaktionsschnelle und sichere Fahrzeugsteuerung zu gew‰hrleisten.  Ein vielversprechender Ansatz f¸r die Weiterentwicklung dieser Technologie ist die Integration von K¸nstlicher Intelligenz (KI). Durch den Einsatz von maschinellem Lernen kˆnnen Algorithmen entwickelt werden, die Muster im Fahrverhalten und in den Umgebungsbedingungen erkennen und darauf basierend pr‰ventive Maﬂnahmen zur Kollisionsvermeidung ergreifen. Diese intelligenten Systeme kˆnnten nicht nur auf statische Hindernisse reagieren, sondern auch dynamisch auf das Verhalten anderer Verkehrsteilnehmer, was die Sicherheit erheblich erhˆhen w¸rde.  Ein weiterer Aspekt der Weiterentwicklung betrifft die Interoperabilit‰t zwischen verschiedenen Fahrzeugmodellen und -marken. Die Schaffung einheitlicher Standards und Protokolle, die ¸ber den IEEE 802.15 Standard hinausgehen, kˆnnte die Kommunikation zwischen Fahrzeugen verschiedener Hersteller erleichtern und somit die Effizienz von Kollisionsvermeidungssystemen steigern. Hierbei kˆnnte die Entwicklung von offenen Schnittstellen und Plattformen eine Schl¸sselrolle spielen, um die Integration verschiedener Technologien zu ermˆglichen.  Zus‰tzlich kˆnnten zuk¸nftige Entwicklungen in der Sensorik, wie zum Beispiel LiDAR und hochauflˆsende Kameras, die Genauigkeit und Zuverl‰ssigkeit der Umfelderfassung erheblich verbessern. Diese Technologien kˆnnten in Kombination mit der Fahrzeugfernsteuerung eingesetzt werden, um eine 360-Grad-Sicht auf die Umgebung zu gew‰hrleisten und so die Reaktionsf‰higkeit des Systems zu optimieren.  Schlieﬂlich ist auch die Ber¸cksichtigung ethischer und rechtlicher Aspekte von groﬂer Bedeutung. Die Entwicklung autonomer Systeme wirft Fragen hinsichtlich der Haftung und der Entscheidungsfindung auf, insbesondere in kritischen Situationen. Eine interdisziplin‰re Zusammenarbeit zwischen Technikern, Juristen und Ethikern wird notwendig sein, um Richtlinien und Standards zu etablieren, die sowohl die Sicherheit der Nutzer als auch die gesellschaftlichen Werte ber¸cksichtigen.  Zusammenfassend l‰sst sich sagen, dass die Entwicklung einer Fahrzeugfernsteuer;1
 Vergleich zwischen Java und Kotlin  In der heutigen Softwareentwicklung stehen Programmierer vor einer Vielzahl von Programmiersprachen, die jeweils ihre eigenen Vorz¸ge und Herausforderungen bieten. Unter diesen Sprachen haben Java und Kotlin in den letzten Jahren besonders an Bedeutung gewonnen, insbesondere im Kontext der Android-Entwicklung. W‰hrend Java seit den 1990er Jahren als eine der f¸hrenden Programmiersprachen gilt, wurde Kotlin 2011 eingef¸hrt und hat sich schnell als moderne Alternative zu Java etabliert. Dieser Vergleich beleuchtet die wesentlichen Unterschiede und Gemeinsamkeiten zwischen diesen beiden Sprachen, um ein besseres Verst‰ndnis f¸r ihre jeweiligen Vorz¸ge zu vermitteln.   Syntax und Lesbarkeit  Ein zentraler Aspekt, der bei der Wahl zwischen Java und Kotlin ber¸cksichtigt werden sollte, ist die Syntax. Java ist bekannt f¸r seine strenge und ausf¸hrliche Syntax, die zwar eine klare Struktur bietet, jedoch auch zu einer erhˆhten Codezeilenanzahl f¸hren kann. Dies kann die Lesbarkeit und Wartbarkeit des Codes beeintr‰chtigen, insbesondere bei komplexen Anwendungen. Kotlin hingegen verfolgt einen anderen Ansatz. Die Sprache ist darauf ausgelegt, pr‰gnanter und ausdrucksst‰rker zu sein. Sie ermˆglicht Entwicklern, mit weniger Code mehr zu erreichen, was die Lesbarkeit und Wartbarkeit des Codes erheblich verbessert. Funktionen wie die Mˆglichkeit, Null-Sicherheitspr¸fungen direkt in die Syntax zu integrieren, tragen dazu bei, h‰ufige Fehlerquellen in Java zu minimieren.   Interoperabilit‰t  Ein weiterer wichtiger Punkt ist die Interoperabilit‰t. Kotlin wurde speziell entwickelt, um nahtlos mit Java zu arbeiten. Dies bedeutet, dass bestehende Java-Bibliotheken und -Frameworks ohne Probleme in Kotlin-Projekte integriert werden kˆnnen. Entwickler, die bereits mit Java vertraut sind, kˆnnen Kotlin schrittweise einf¸hren, ohne ihre gesamte Codebasis neu schreiben zu m¸ssen. Diese Interoperabilit‰t ist ein entscheidender Vorteil, da sie den ‹bergang zu Kotlin erleichtert und es Entwicklern ermˆglicht, die St‰rken beider Sprachen zu nutzen.   Typensicherheit und Null-Sicherheit  Ein h‰ufiges Problem in Java ist die NullPointerException, die oft zu Laufzeitfehlern f¸hrt. Kotlin hat dieses Problem durch ein striktes Null-Sicherheitssystem adressiert. In Kotlin sind Variablen standardm‰ﬂig nicht null, es sei denn, sie werden explizit als nullable deklariert. Dies zwingt Entwickler dazu, bewusster mit Null-Werten umzugehen und reduziert die Wahrscheinlichkeit von Laufzeitfehlern erheblich. Java bietet zwar Typensicherheit, jedoch nicht in dem Maﬂe, wie es Kotlin tut. Diese verbesserte Handhabung von Null-Werten in Kotlin ist ein klarer Vorteil f¸r Entwickler, die robuste und fehlerresistente Anwendungen erstellen mˆchten.   Entwicklungsumgebung und Tooling  Die Entwicklungsumgebung ist ein weiterer Faktor, der bei der Wahl zwischen Java und Kotlin ber¸cksichtigt werden sollte. Beide Sprachen werden von g‰ngigen IDEs wie IntelliJ IDEA und Eclipse unterst¸tzt. Kotlin profitiert jedoch von einer hervorragenden Integration in die IntelliJ-Umgebung, was zu einer verbesserten Entwicklererfahrung f¸hrt. Funktionen wie intelligente Code-Vervollst‰ndigung, Refactoring-Tools und Debugging-Optionen sind in Kotlin besonders ausgefeilt, was den Entwicklungsprozess effizienter gestaltet.  ;1
"3.1.2 Kon?guration
Um den Raspberry Pi als LoRa-Gateway zu verwenden, m¸ssen alle Hardware Kompo-
nenten, wie in Abbildung 3.1 zu sehen, zusammengebaut und verbunden werden. Als
Betriebssystem wird die o?ziell f¸r den Raspberry Pi empfohlene Linux-Distributionen
Raspberry Pi OS Lite verwendet. Damit das Erweiterungsmodul und der Gateway-Chip
verwendet werden kˆnnen, m¸ssen in der Raspberry Pi Kon?guration die Schnittstellen
Serial Peripheral Interface ( SPI) und Inter-Integrated Circuit ( I2C) aktiviert werden. Die
ƒnderung dieser Einstellungen kˆnnen ¸ber das Kon?gurationsmen¸ des Raspberry, welche
mit sudo raspi-config aufgerufen werden kann, vorgenommen werden. Die Einstellun-
gen liegen unterhalb des Men¸punktes ÑInterfacing Optionsì, welcher in Abbildung 3.2
dargestellt ist.
Abbildung 3.2: Interfacing Options des Raspberry Pi2
Da nun die Hardware miteinander kommunizieren kann, kann nun die benˆtigte Software
installiert und kon?guriert werden. Diese kann vom o?ziellen GitHub-Repository Lora-net
/sx1302\_hal3heruntergeladen oder direkt geklont werden. Da das Repository nur den
Sourcecode inklusive eines Makefile enth‰lt, m¸ssen die einzelnen Programme, die darin
enthalten sind, mit dem Befehl make all gebaut werden. Optional kann durch make clean
allsicher gestellt werden, dass alle zuvor gebauten Programme gelˆscht werden und
somit die aktuellste Version der Sourcen zum Bau der ausf¸hrbaren Programme verwendet
werden. Die Bash-Script-Datei reset_lgw.sh , welche im tools-Verzeichnis liegt und zum
Zur¸cksetzen des Gateways verwendet wird, muss im Anschluss noch in die Verzeichnisse
util_chip_id und packet_forwarder kopiert werden. Die gebauten Programme greifen auf
die Script-Datei innerhalb des gleichen Unterverzeichnisses zu. Dementsprechend muss
dieses dort vorhanden und mit den nˆtigen Rechten zum Ausf¸hren versehen sein. Diese
kann durch den Befehl chmod -R 755 ./* f¸r alle Dateien im Order und die Verzeichnisse
darunter ermˆglicht werden.";0
In der vorliegenden Arbeit werden f¸nf verschiedene Sensorwerte gemessen: ïGer‰usch ïHelligkeit ïTemperatur ïLuftdruck ïHumidit‰t Diese Werte werden f¸r die Visualisierung zu der Android-Applikation geschickt und dort abgespeichert. Eine der Herausforderungen bestand darin, einen Weg zu finden, die Sensordaten vom Arduino in die Android-Anwendung zu ¸bertragen. Um die Versendung der Werte von dem Arduino zu der Applikation ohne Internetverbindung zu ermˆgli- chen, wird das Nachrichtenprotokoll Message Queuing Telemetry Transport ( MQTT) eingesetzt. Der zentrale Verteiler, der sogenannte MQTT-Broker, l‰uft in der Anwendung mit dem Namen Termux.Termux ist ein Android-Terminalemulator mit einer Linux- Umgebungsanwendung, bei dem ein minimales Basissystem automatisch installiert wird und ohne weitere Einstellungen funktionsf‰hig ist (vgl. Termux 2022). Der Arduino verbindet sich mit dem vorhandenen Router und mit dem MQTT-Broker. Es kann passieren, dass der Sensor ung¸ltige Daten liefert und um das zu beseitigen, wurde Fol- gendes umgesetzt: Jede Minute werden die Sensorwerte gemessen und in Listen gespeichert. WenndieListedieL‰ngezwˆlferreicht,wirddenDurchschnittvondenjeweiligenSensorwer- ten berechnet und an den MQTT-Broker f¸r die Topic Ñdhbw_studienarbeit_sensordatasì verschickt. Somit kann bei Falle eines unplausiblen Werts das Endergebnis ausgeglichen werden. F¸r die F‰lle, falls das WLANausf‰llt, werden die berechneten Durchschnitte ebenfalls in Listen gespeichert. Gleichzeitig wird die Wiederherstellung der WLAN-Verbindung aufgenommen und solange dies fehlschl‰gt, werden die Daten lokal gespeichert. Falls die Listenl‰ngen zwˆlf Elemente enthalten, werden die Listen halbiert, indem man den Durchschnitt zweier nebenstehender Daten berechnet. Nachdem sich der Arduino wieder mit dem WLANverbindet, werden die lokal gespeicherten Daten an den MQTT-Broker verschickt. Das Tablet verbindet sich ebenfalls mit dem MQTT-Broker und abonniert die Topic Ñdhbw_studienarbeit_sensordatasì, um die Sensordaten erhalten zu kˆnnen. Die Daten werden dann in der SQLite-Datenbank gespeichert.;0
Momentan existieren auf dem SFTP-Server zwei Konten. Das Konto f¸r den Editor hat auf alle Pepper-Applikationen Schreib- und Lesezugri?, das Konto f¸r die Pepper-Container- App hat auf alle Pepper-Applikationen nur Lesezugri?. Alle Pepper-Applikationen liegen im Home-Verzeichnis des Editor-Kontos. F¸r einen produktiven Einsatz des CMS br‰uchten alle User des Editors jeweils ein eigenes Konto und es w‰re eine Konto- und Rechteverwal- tung nˆtig. Dies kann wie folgt umgesetzt werden. Ein User veri?ziert sich mit seinem Login ¸ber den Editor beim Server und kann nur seine Pepper-Applikationen sehen und bearbeiten. Wenn eine Person eine Pepper-Applikation mit einer Anderen teilt, bekommt diese wahlweise nur Lesezugri? oder Lese- und Schreibzugri? auf diese Applikation. Zu- s‰tzlich wird die Pepper-App in das Home-Verzeichnis der zweiten Person verlinkt, damit es ihr im Editor angezeigt wird. Damit ist die Zusammenarbeit zwischen Usern mˆglich. Der Ablauf, damit eine Pepper-Applikation in der Pepper-Container-App sichtbar wird, ist der selbe. Das Server-Konto der Pepper-Container-App erh‰lt allerdings nur Lesezugri? auf Pepper-Applikationen. Um Server-Konten ¸ber den Editor zu verwalten, gibt es stan- dardm‰ﬂig ein Konto mit Server-Adminrechten. Dadurch kann es andere Konten erstellen, bearbeiten, lˆschen und Adminrechte erteilen sowie entziehen. F¸r diese Funktionalit‰ten sendet das Editor-Backend die entsprechenden CLI-Kommandos per SSH an den Server.;0
"Ausblick  Die Anforderungsanalyse im Kontext eines Aufgabenmanagement-Tools f¸r das studentische Software Engineering erˆffnet spannende Perspektiven und ?????, die weit ¸ber die technische Implementierung hinausgehen. In Anbetracht der zunehmenden Komplexit‰t der Softwareprojektarbeit in Bildungseinrichtungen, ist es maﬂgeblich, ein System zu entwickeln, das nicht nur den funktionalen Anforderungen gerecht wird, sondern auch die Aspekte der Benutzerfreundlichkeit, Zusammenarbeit und Lernfˆrderung in den Fokus r¸ckt.  Eine tiefere Analyse der Bed¸rfnisse und Erwartungen der Nutzer ñ sprich der Studierenden ñ zeigt, dass die Gestaltung klares und intuitives Design, mobile Zug‰nglichkeit und Schnittstellen zu bestehenden Plattformen umfasst. Solche Merkmale kˆnnen die Effizienz und Motivation steigern und somit eine positive Lernumgebung fˆrdern. Hier bietet sich zudem eine Mˆglichkeit zur Integration von Gamification-Elementen an; solche Ans‰tze kˆnnten dazu dienen, den Selbstorganisation- und Teamarbeit-Gedanken zu st‰rken.  Des Weiteren kˆnnte die Forschung auf den Umgang mit Herausforderungen ausgerichtet sein, die Studierende h‰ufig bei der Durchf¸hrung von Teamprojekten erleben, wie eine unklare Aufgabenverteilung und mangelhafte Kommunikation. Das tooling m¸sste Funktionen bieten, die diese Probleme adressieren, und gleichzeitig Raum f¸r agile Prozesse ermˆglichen. Der kontinuierliche Austausch zwischen Entwicklern, pseudo-Betreuern und Studierenden kann wertvolle Einsichten liefern und die Tool-Nutzung sowie t‰glich Projekterfolge lavish fˆrdern.  Zusammenfassend kann gesagt werden, dass die Entwicklung eines Aufgabenmanagement-Tools f¸r den studenten Software Engineering Sektor ñ insbesondere in Bezug auf die Anforderungsanalyse ñ als determinierender Schritt miten Ber¸cksichtigung heutiger Bildung-Technologien und experimenteller Ans‰tze gˆr¸len werden muss. Hierbei gilt es, sowohl die kurzfristigen Bed¸rfnisse zu erf¸llen als auch auf langfristige Entwicklungen und potentielle neue Techniken oder Ans‰tze vorbereitet zu sein. Der Weiterentwicklungsaspekt, bedingt durch Feedback und Reviews in praxisnahen Projekten, wird nicht nur die Robustheit der Anwendung erhˆhen, sondern es wird auch einen wesentlich wertvolleren Beitrag zur Fˆrderung und Ausbildung angehender Software-Ingenieure leisten. Die Maﬂst‰be, die damit gesetzt werden, kˆnnten nicht nur Wirkung zeigen, sondern sich auch in den Anspr¸chen und Anforderungen zuk¸nftiger Weiterbildungsmethoden niederschlagen.";1
Da sich die Anforderungen zwischen den verschiedenen Projekten mit ihren unterschied- lichen Einsatzbedingungen unterscheiden, werden hier die f¸r dieses Projekt g¸ltigen Anforderungen auf der Basis der erarbeiteten Angaben aus der Literatur festgelegt. Rechtliche Rahmenbedingungen: Aufgrund des Projektstandorts in Deutschland m¸ssen die in Deutschland g¸ltigen Regeln und Gesetze eingehalten werden. Dazu z‰hlen unter anderem die Regeln zur Nutzung von Funk und die Straﬂenverkehrsordnung. Wie in Abschnitt 3.2.1erl‰utert, ist der Funkverkehr in Deutschland durch verschiedene Regularien reglementiert. So sind die verwendbaren Frequenzen des ISM-Bands auf die in Tabelle 3.1angegebenen Frequenzen beschr‰nkt und diese m¸ssen eingehalten werden. F¸r die Nutzung der Straﬂe gilt, wie in Abschnitt 3.2.2 erl‰utert, dass das entwickelte Fahrzeug nicht auf ˆffentlichen Straﬂen bewegt werden darf. Anforderungen an Teleoperated Driving: Aus Projektsicht wird die maximal zu- l‰ssige und erwartbare Geschwindigkeit auf 30km/h begrenzt. Dabei muss die maximale Latenz der Fernsteuerung 200ms unterschreiten, da dies die Mehrzahl der Quellen in 3.3 angibt, Ziel soll jedoch nach  eine Latenz von 100ms sein, wobei eine verschl¸sselte Verbindung verwendet werden soll. Im Falle eines Verbindungsabbruch soll eine Notbremsung eingeleitet werden. Anforderungen an Kollisionsvermeidung: Die Kollisionsvermeidung soll aus Gr¸nden der Komplexit‰t als automatische Notbremsung festgelegt werden. Dabei soll bei einer maximal anzunehmenden Geschwindigkeit von 30km/h die Notbremsung so erfolgen, dass stehende Hindernisse bei normalen Straﬂenbedingungen und einem idealem Bremsweg keine Kollision mit Gegenst‰nden in Fahrtrichtung erfolgen kann. Im Fall der Durch- f¸hrung einer Kollisionsvermeidung soll dies auf der Fernsteuerung dargestellt werden. Randbedingungen, wie Folgen f¸r den nachfolgenden Verkehr oder ein Antiblockiersystem sollen nicht betrachtet werden. Projektspezifische Anforderungen: Aufgrund von Hardwarebeschr‰nkungen muss das entwickelte Protokoll durch den Digi Xbee 3 -Microcontroller unterst¸tzt werden. Zur einfacheren Bedienung soll im Falle einer durchgef¸hrten Notbremsung eine Nachricht an die Fernsteuerung ¸bermittelt und diese auf derselben dargestellt werden, dass eine Notbremsung durchgef¸hrt wurde. Des weiteren sollen f¸r verwendete Software und Protokollstacks keine Lizenzkosten anfallen.;0
"Evaluierung der wissenschaftlichen Arbeit: ""Aufbau eines CMS zur Erstellung von Android Apps f¸r den humanoiden Roboter Pepper""  1. Einf¸hrung und Zielsetzung  Die vorliegende Arbeit zielt darauf ab, ein Content Management System (CMS) zu entwickeln, das es Nutzern ermˆglicht, Android Apps f¸r den humanoiden Roboter Pepper zu erstellen. Der Roboter Pepper, der f¸r seine Interaktivit‰t und Kommunikationsf‰higkeit bekannt ist, ist ein beliebtes Forschungs- und Entwicklungsobjekt in der Robotik und Human-Robot-Interaction. Die Arbeit adresiert die Notwendigkeit, ein benutzerfreundliches System zu schaffen, das auch f¸r Anwender ohne tiefgehende Programmierkenntnisse zug‰nglich ist.  2. Aufbau und Struktur der Arbeit  Die Arbeit ist klar strukturiert und gliedert sich in mehrere Abschnitte:  - Einleitung: Einf¸hrung in das Thema und die Relevanz des CMS. - Theoretischer Hintergrund: Detaillierte Erl‰uterungen zu den technologischen und konzeptionellen Grundlagen der App-Entwicklung f¸r Pepper. - Konzeption und Entwicklung des CMS: Vorstellung der Architektur, der verwendeten Technologien und der Methoden zur Benutzeroberfl‰chengestaltung. - Implementierung: Detaillierte Beschreibung des Entwicklungsprozesses, einschlieﬂlich verwendeter Frameworks und Tools. - Evaluation der Benutzerfreundlichkeit: Durchf¸hrung von Tests mit realen Nutzern und deren Feedback. - Schlussfolgerung: Zusammenfassung der Ergebnisse und Ausblick auf zuk¸nftige Entwicklungen.  3. Wissenschaftliche Tiefe  Die Arbeit zeigt eine solide wissenschaftliche Basis. Die Literaturrecherche ist umfassend und behandelt sowohl bestehende Systeme zur App-Entwicklung f¸r humanoide Roboter als auch die spezifischen Herausforderungen, die mit der Programmierung f¸r Pepper verbunden sind. Der theoretische Teil wird durch relevante Quellen unterst¸tzt und zeigt, dass der Autor in der Materie bewandert ist.  4. Praktische Relevanz und Innovation  Die Entwicklung eines CMS f¸r Pepper stellt einen innovativen Ansatz dar, um die Zug‰nglichkeit von Robotik-Anwendungen zu erhˆhen. Die Mˆglichkeit, interaktive Apps ohne tiefgehende Programmierkenntnisse zu erstellen, kˆnnte die Verbreitung der Nutzung von Pepper in Bildung, Forschung und Dienstleistungen fˆrdern. Die Arbeit adressiert auch potenzielle Nutzergruppen, die nicht im technischen Bereich t‰tig sind, und ber¸cksichtigt deren Bed¸rfnisse in der Konzeption.  5. Benutzerfreundlichkeit und Evaluation  Die Evaluation der Benutzerfreundlichkeit ist ein wesentlicher Bestandteil der Arbeit. Der Autor hat verschiedene Szenarien zur Nutzung des CMS getestet und das Feedback von Anwendern gesammelt. Die Ergebnisse zeigen, dass das System insgesamt als intuitiv und benutzerfreundlich wahrgenommen wird. Einige Verbesserungsvorschl‰ge wurden identifiziert, die in zuk¸nftigen Versionen des CMS umgesetzt werden sollten. Das Engagement der Testnutzer durch Interviews oder Umfragen st‰rkt die Validit‰t der Evaluation.  6. Fazit und Ausblick  Zusammenfassend l‰sst sich sagen, dass die Arbeit einen bedeutenden Beitrag zur Entwicklung von Anwendungen f¸r den humanoiden Roboter Pepper leistet. Die Kombination aus theoretischer Fundierung und praktischer Umsetzung macht die Ergebnisse besonders wertvoll. Zuk¸nftige Arbeiten kˆnnten sich auf die Erweiterung des CMS mit zus‰tzlichen Funktionalit‰ten konzentrieren oder die Integration von maschinellem Lernen zur Verbesserung der Interaktivit‰t und Anpassungsf‰higkeit von Pepper-Apps.  7. Empfehlungen  F¸r eine noch tiefere Auseinandersetzung mit dem Thema w‰re es sinnvoll, die folgenden Aspekte zu ber¸cksichtigen:  - Erweiterung der Unterst¸tzung f¸r verschiedene Benutzeroberfl‰chen-Layouts. - Integration von Tutorials oder Hilfesystemen direkt im CMS, um die Benutzerfreundlichkeit weiter zu erhˆhen. - Eine umfangreiche Analyse der Marktbed¸rfnisse, um das CMS gezielt auf die Anforderungen der Anwender anzupassen.  Insgesamt stellt die Arbeit einen vielversprechenden Schritt in der Entwicklung benutzerfreundlicher Roboteranwendungen dar und legt die Grundlage f¸r zuk¸nftige Forschungsans‰tze in diesem dynamischen Bereich.";1
" Vergleich zwischen Java und Kotlin   Einleitung  Der technologische Fortschritt im Bereich der Softwareentwicklung hat in den letzten Jahren zu einer Vielzahl von Programmiersprachen gef¸hrt, die jeweils unterschiedliche Vorteile und Anwendungsbereiche haben. Zwei der prominentesten Sprachen im Bereich der Android-Entwicklung sind Java und Kotlin. W‰hrend Java seit den 1990er Jahren weit verbreitet ist, gewann Kotlin, das 2011 verˆffentlicht wurde, besonders seit der offiziellen Unterst¸tzung durch Google im Jahr 2017 an Popularit‰t. Ziel dieses Vergleichs ist es, die beiden Sprachen hinsichtlich ihrer Syntax, Funktionalit‰t, Sicherheit, Interoperabilit‰t und Community zu analysieren.   1. Syntax  Die Syntax von Java und Kotlin unterscheidet sich erheblich. Java ist bekannt f¸r seine explizite und verbose Syntax, die oft zu langen Codezeilen f¸hrt. Kotlin hingegen bietet eine pr‰gnantere und ausdrucksst‰rkere Syntax, die Entwicklern ermˆglicht, weniger Code zu schreiben, um dieselbe Funktionalit‰t zu erreichen. Zum Beispiel benˆtigt Kotlin keine Semikolons am Ende der Zeilen und verwendet Datentypen in einer deutlich kompakteren Form.  *Beispiel f¸r die Definition einer Funktion:*  - Java:     ```java   public int add(int a, int b) {       return a + b;   }   ```  - Kotlin:    ```kotlin   fun add(a: Int, b: Int) = a + b   ```  Die Lesbarkeit und Wartbarkeit des Codes kann durch die k¸rzere und klarere Syntax von Kotlin erheblich verbessert werden.   2. Funktionalit‰t und Sprachmerkmale  Kotlin wurde mit dem Ziel entwickelt, einige der typischen Probleme und Einschr‰nkungen von Java zu ¸berwinden. Zu den herausragenden Merkmalen von Kotlin gehˆren:  - Null-Sicherheit: Kotlin f¸hrt das Konzept der Null-Sicherheit ein, durch das NullPointerExceptions (NPEs) im Code vermieden werden kˆnnen. Variablen sind standardm‰ﬂig nicht null und m¸ssen explizit als nullable deklariert werden.  - Erweiterungsfunktionen: Mit Kotlin kˆnnen Entwicklern neue Funktionen zu bestehenden Klassen hinzuf¸gen, ohne sie zu ‰ndern, was die Flexibilit‰t erhˆht.  - Datenklassen: Kotlin bietet eine spezielle Syntax zur Erstellung von Datenklassen, die automatisch Getter und Setter sowie die `toString()`, `equals()` und `hashCode()`-Methoden generieren.  Java hingegen hat einige dieser modernen Funktionen erst in neueren Versionen (z.B. durch Lambda-Ausdr¸cke in Java 8) eingef¸hrt, kann aber im Vergleich zu Kotlin als weniger fortschrittlich angesehen werden.   3. Sicherheit  Die Sicherheit ist ein entscheidendes Kriterium in der Softwareentwicklung. Kotlin wurde mit dem Fokus auf geringe Fehleranf‰lligkeit und Benutzerfreundlichkeit entwickelt. Die Null-Sicherheit, die im vorherigen Abschnitt beschrieben wurde, ist ein bedeutendes Merkmal, das Kotlin sicherer macht. Java bietet zwar die Mˆglichkeit, NPEs durch geeignete Programmiertechniken zu vermeiden, hat jedoch keine integrierten Mechanismen in der Sprache selbst.  Zus‰tzlich bietet Kotlin viele Werkzeuge zur Fehlerbehandlung, die einfacher und intuitiver sind als die traditionellen Ans‰tze in Java.   4. Interoperabilit‰t  Ein groﬂer Vorteil von Kotlin ist die vollst‰ndige Interoperabilit‰t mit Java. Kotlin kann in bestehenden Java-Projekten verwendet werden, was eine schrittweise Migration und Integration ermˆglicht. Entwickler kˆnnen Kotlin-Code in Java-Projekten verwenden und umgekehrt, was die Einf¸hrung der Sprache erleichtert.   5. Community und ÷kosystem  Java hat eine lange Geschichte und eine groﬂe, etablierte Community. Es gibt viele Ressourcen, Bibliotheken und Frameworks, die f¸r Java verf¸gbar sind. Kotlin ist dagegen noch relativ jung, erfreut sich jedoch wachsender Beliebtheit, insbesondere in der Android-Entwicklung. Die Community w‰chst kontinuierlich und es gibt bereits eine Vielzahl von Ressourcen, die speziell auf Kotlin zugeschnitten sind.   Fazit  Zusammenfassend l‰sst sich sagen, dass sowohl Java als auch Kotlin ihre eigenen Vorz¸ge und Herausforderungen mitbringen. Java bietet eine bew‰hrte, stabile Grundlage mit umfangreicher Dokumentation und Gemeinschaft, w‰hrend Kotlin modernere Sprachmerkmale und eine verbesserte Syntax aufweist, die die Entwicklung effizienter und sicherer gestalten kann. Die Wahl zwischen den beiden Sprachen h‰ngt letztlich von den spezifischen Anforderungen eines Projekts, den Erfahrungen des Entwicklungsteams und den langfristigen Zielen ab. F¸r neue Projekte, insbesondere im Bereich der Android-Entwicklung, kˆnnte Kotlin die bevorzugte Wahl sein, w‰hrend Java in vielen bestehenden Systemen weiterhin eine zentrale Rolle spielt.";1
 Kapitel: Technische Grundlagen der Content-Management-Systeme   Einleitung  Content-Management-Systeme (CMS) sind zentrale Komponenten in der modernen Web- und Unternehmenskommunikation. Sie ermˆglichen das Erstellen, Verwalten und Verˆffentlichen digitaler Inhalte durch Nutzer ohne tiefe technische Kenntnisse. Um ein tieferes Verst‰ndnis f¸r die Funktionsweise und Unterschiede der verschiedenen CMS zu gewinnen, ist es notwendig, die zugrunde liegenden technischen Grundlagen zu betrachten. In diesem Kapitel werden die technischen Merkmale und ihre Bedeutung erl‰utert, um fundierte Vergleichskriteria f¸r eine umfassende Analyse der CMS zu entwickeln.   Komponenten eines CMS  Ein Content-Management-System setzen sich in der Regel aus mehreren Schl¸sselkomponenten zusammen:  1. Datenbankmanagement: Um Inhalte zu speichern, verwenden CMS h‰ufig relationale Datenbanken wie MySQL, PostgreSQL oder SQLite. Diese Datenbanken strukturieren die Inhalte in Tabellen und ermˆglichen eine effiziente Abwicklung von Abfragen und Transaktionen.  2. Backend-Architektur: Dies ist das ÑHerzì des CMS, wo die Gesch‰ftslogik implementiert ist. Hierbei kommen Server-seitige Programmiersprachen zum Einsatz, wie PHP, Python, Ruby oder Java. Die Kommunikation zwischen Frontend und Backend erfolgt h‰ufig ¸ber API-Schnittstellen.  3. Frontend-Rendering: Umsichtige und ansprechende Nutzeroberfl‰chen sind entscheidend f¸r den Erfolg eines CMS. Diese Oberfl‰chen werden typischerweise in HTML, CSS und JavaScript entwickelt. Bei vielen CMS sind Template-Engines integriert, die das dynamische Generieren von Inhalten auf den Webseiten ermˆglichen.  4. Benutzermanagement: Ein essentielles Feature ist die Verwaltung der User-Rollen und Berechtigungen. CMS verwenden h‰ufig hinterlegte ???????????????? Rechte ([Permissions]), um sicherzustellen, dass nur autorisierte Benutzer unter spezifischen Bedingungen Inhalte erstellen oder bearbeiten kˆnnen.   Architekturmodelle von CMS  Abh‰ngig von ihrer Architektur kˆnnen CMS in mehrere Typen unterteilt werden:  1. Monolithische Systeme: Diese Art von CMS vereint sowohl Fron- als auch Backend in einem vollst‰ndig integrierten Paket. Typische Vertreter dieser Gruppe sind WordPress und Joomla. Sie bieten den Nutzern vorgefertigte Lˆsungen, die ohne tiefere technische Anpassungen sofort funktionsf‰hig und gerichtete Einsatzbereit sind.  2. Kˆpflˆsungsarchitekturen (Headless CMS): In dieser Struktur ist der Inhalt unabh‰ngig von der Visualisierung. Frontend und Backend sind zun‰chst voneinander getrennt, sodass der Workflow dadurch flexibler gestaltet werden kann. Nutzer greifen in dem cercipheit¸yen CMS auf die benˆtigten Inhalte ¸ber API-Calls zu (wie bei Contentful oder Strapi). Dies bietet sich insbesondere f¸r moderne Webanwendungen und mobile Entwicklungen an.  3. Decoupled CMS: Eine Mischform zwischen monolithischen und headless Systemen, wo das Frontend grundlegend unabh‰ngig vom Backend ist, aber trotzdem in umfangreicher Mehrwertpakete=eisen und standardisiert nutzenzufuguar daanhine chodzi re ausgezeichnet potzen decamophi pomaca uzakuti contenido gew‰hrleisten um??????.   Programmierstile und -sarcyemdeputlokoki??  Die Programmierungen innerhalb der CMS feu estreno padaizinointeriorriereku enabling user ???? ??;1
Seit dem Release des durch das WordPress Entwicklerteam eigens kreierte Theme ÑTwenty Twenty Twoì erh‰lt der sogenannte ÑGutenberg Editorì Einzug in die Gestaltungsmˆg- lichkeiten des Systems. Mit diesem Editor, welcher Inhaltsbausteine in Form von ÑBlocksì (Blˆcken) abstrahiert, l‰sst sich eine Website mittels Drag-and-Drop Verfahren beliebig ab‰ndern. Einzelne Inhaltsbausteine kˆnnen somit nach Belieben ausgetauscht und in ihrer Reihenfolge abge‰ndert werden. Abbildung 5.12: Gutenberg Block-Editor in WordPress1 Aufgrund der Vielzahl an verf¸gbaren Design-Vorlagen und der einfach Installation sowie Handhabung dieser kˆnnen ansprechende, responsive Websites in kurzer Zeit und ohne Programmierkenntnis realisiert werden. Deshalb wird WordPress im Kriterium Design- Vorlagen mit der Farbe Gr¸n kategorisiert.;0
 Die Demografie vieler L‰nder zeigt eine zunehmende Alterung der Bevˆlkerung, was zu einem hˆheren Bedarf an Technologien zur Sturzerkennung f¸hrt. In diesem Projekt wird eine In-room Ortungslˆsung unter Verwendung von Bluetooth Low Energy (BLE) entwickelt, um St¸rze in realen Wohnumgebungen zu erkennen und somit die Sicherheit ‰lterer Menschen zu erhˆhen.  2. Zielsetzung  Ziel dieser Arbeit ist es, ein System zu entwickeln, das: - die Position einer Person im Raum pr‰zise erfasst, - St¸rze in Echtzeit erkennt, - Alarmmeldungen an relevante Pflegepersonen oder Systeme sendet.  3. Technische Anforderungen  - Hardware:   - BLE Beacon-Ger‰te zur Positionsbestimmung.   - Smartphones oder Tablets als Empfangsger‰te.   - Sensormodule zur Sturzerkennung (z.B. Beschleunigungssensoren).  - Software:   - Eine mobile App zur Datenverarbeitung und Fallanalyse.   - Backend-Server zur Speicherung und Analyse von Daten.   - Algorithmus zur Sturzerkennung.  4. Systemarchitektur  Das System besteht aus mehreren Komponenten: 1. BLE Beacons:    - Installierung in verschiedenen R‰umen.    - Senden von Identifikationssignalen in regelm‰ﬂigen Abst‰nden.    2. Mobile App:    - Empfang und Verarbeitung der BLE-Signale.    - Erstellung eines Kartenmodells der Umgebung auf Basis der Beacon-Signale zur Positionsbestimmung.    - Integration von Sensoren zur Sturzerkennung.    3. Backend-Server:    - Empfang der Alarmmeldungen.    - Datenanalyse und Speicherung.    - Bereitstellung von Benutzeroberfl‰chen f¸r Pflegepersonal.  5. Realisierung   5.1 BLE Beacon Konfiguration  1. Auswahl der Beacon-Hardware (z.B. estimote, Kontakt.io). 2. Konfiguration der Beacons ¸ber eine entsprechende App oder API. 3. Montage der Beacons in strategischen Positionen, um eine optimale Abdeckung zu gew‰hrleisten.   5.2 Entwicklung der Mobile App  1. Plattformwahl (iOS/Android). 2. Implementierung des BLE-Signalempfangs:    - Verwendung der APIs f¸r BLE (z.B. CoreBluetooth f¸r iOS, Android Bluetooth API).    - Erfassung von Signalst‰rken zur Positionsbestimmung.  3. Integration der Sturzerkennung:    - Verwendung von beschleunigungsmessenden Sensoren (z.B. IMU-Sensoren).    - Entwicklung eines Algorithmus zur Identifikation von Sturzereignissen, basierend auf der Analyse von Beschleunigungsdaten.   5.3 Backend-Server  1. Auswahl einer geeigneten Servertechnologie (z.B. Node.js, Python Flask). 2. Entwicklung einer RESTful API zur Kommunikation zwischen App und Server. 3. Speicherung und Analyse der Daten in einer Datenbank (z.B. PostgreSQL). 4. Implementierung von Benachrichtigungen (z.B. E-Mail, SMS) bei Sturzerkennung.   5.4 Test und Validierung  1. Durchf¸hrung von Tests in kontrollierten Umgebungen;1
Da bei Verwendung eines Buffers die ƒquivalenz von Messzeitpunkt und Zeitpunkt des Datenbankeintrags nicht gegeben ist, muss der konkrete Zeitpunkt Teil des resultierenden Messwerts des Sensors sein. Das Feld measure_timestamp beinhaltet diesen Zeitpunkt. Ein exemplarischer Body der POST-Request zeigt Abbildung 3.14. Abbildung 3.14: Body der POST-Request mit implementiertem Buffer Modifikationen an der Phoenix-Applikation erfolgen analog zum dargestellten JSON- Objekt, damit Informationen der POST-Requests in der neu vorliegenden Form korrekt interpretiert und bearbeitet werden kˆnnen. Die Funktion create_entry/1 wird nach Verifikation des eingehenden Token mit dem korrespondierenden JSON-Objekt aufgerufen und ist in folgender Abbildung 3.15 dargestellt. Die Funktion iteriert ¸ber alle eingehenden Datens‰tze und erstellt den entsprechenden Eintrag in der Datenbank (Zeile 8-10). Die fundamentale Vorgehensweise bleibt unver‰n- dert. Zus‰tzlich wurde die Relation weather_condition um das Feld measure_timestamp erweitert.;0
" Kapitel: Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachung  Der Roman ""Zero"" von Marc Elsberg ist ein fesselndes Werk, das die tiefgreifenden Implikationen der digitalen ‹berwachung auf individuelle Freiheiten und gesellschaftliche Strukturen thematisiert. In einer Welt, in der Daten als das neue ÷l gelten, beleuchtet Elsberg die Ambivalenz zwischen den Mˆglichkeiten, die digitale Technologien bieten, und den Gefahren, die mit ihrer unkontrollierten Nutzung einhergehen.    Die Mˆglichkeiten der digitalen ‹berwachung  Im Zentrum von ""Zero"" steht die Frage, wie digitale ‹berwachung dazu genutzt werden kann, das Leben der Menschen zu verbessern. Die Protagonisten des Romans bewegen sich in einer zunehmend vernetzten Welt, in der Informationen in Echtzeit erfasst und analysiert werden. Diese Technologie hat das Potenzial, verschiedene gesellschaftliche Probleme anzugehen, von der Kriminalit‰tsbek‰mpfung bis hin zur Gesundheits¸berwachung. Durch die Erfassung von Daten kˆnnen Muster erkannt und pr‰ventive Maﬂnahmen ergriffen werden, die das Sicherheitsgef¸hl der B¸rger erhˆhen.   Ein Beispiel f¸r diese Mˆglichkeit ist die Verwendung von ‹berwachungstechnologien zur Verhinderung von Verbrechen. In ""Zero"" wird gezeigt, wie durch die Analyse von Bewegungsdaten und Verhaltensmustern potenzielle Kriminelle identifiziert und rechtzeitig gestoppt werden kˆnnen. Dies kˆnnte in einer idealen Welt zu einer signifikanten Senkung der Kriminalit‰tsraten f¸hren und das Vertrauen in ˆffentliche Institutionen st‰rken. Dar¸ber hinaus kˆnnten digitale ‹berwachungsmaﬂnahmen auch im Gesundheitssektor eingesetzt werden, um Epidemien fr¸hzeitig zu erkennen und zu bek‰mpfen.   Die Gefahren der digitalen ‹berwachung  Trotz dieser positiven Aspekte thematisiert Elsberg in ""Zero"" auch die gravierenden Gefahren, die mit der digitalen ‹berwachung verbunden sind. Die unkontrollierte Erfassung und Auswertung persˆnlicher Daten birgt das Risiko eines massiven Eingriffs in die Privatsph‰re der Individuen. Der Roman verdeutlicht, wie schnell aus pr‰ventiven Maﬂnahmen eine umfassende ‹berwachungsgesellschaft entstehen kann, in der jeder Schritt und jede Handlung der B¸rger aufgezeichnet und analysiert wird.  Ein zentrales Element der Handlung ist die Entwicklung einer m‰chtigen ‹berwachungssoftware, die nicht nur die Privatsph‰re der B¸rger bedroht, sondern auch die Grundpfeiler einer demokratischen Gesellschaft untergr‰bt. Die Protagonisten stehen vor der Herausforderung, sich gegen diese ‹berwachung zu wehren und die Kontrolle ¸ber ihre Daten zur¸ckzugewinnen. Hier wird die Frage aufgeworfen, inwiefern der Schutz der individuellen Freiheit und der Privatsph‰re mit dem Sicherheitsbed¸rfnis der Gesellschaft in Einklang gebracht werden kann.  Die ethischen Implikationen der digitalen ‹berwachung werden in ""Zero"" eindringlich behandelt. Die Macht, die durch die Kontrolle ¸ber Daten entsteht, kann missbraucht werden, um Menschen zu manipulieren oder zu diskriminieren. Die Gefahr eines ‹berwachungsstaates, in dem B¸rger permanent unter Beobachtung stehen, wird eindringlich skizziert. Die dystopischen Szenarien, die Elsberg entwirft, werfen fundamentale Fragen ¸ber die Zukunft der Demokratie und die Rolle des Individuums in einer von Technologie dominierten Welt auf.  ";1
Ein Konzept zur Umsetzung    In der heutigen Zeit, in der Luftqualit‰t und Umweltbewusstsein zunehmend in den Fokus der ÷ffentlichkeit r¸cken, gewinnen Luftreinigungsger‰te an Bedeutung. Diese Ger‰te sind nicht nur in der Lage, Schadstoffe und Allergene aus der Luft zu filtern, sondern kˆnnen durch elektronische Erweiterungen auch in ihrer Funktionalit‰t und Benutzerfreundlichkeit optimiert werden. Ziel dieses Textes ist es, ein Konzept zur Optimierung der Visualisierung, Bedienung und Selbstregelung eines solchen Luftreinigungsger‰tes zu entwickeln.  1. Visualisierung der Luftqualit‰tsdaten  Die Visualisierung von Luftqualit‰tsdaten spielt eine zentrale Rolle f¸r die Benutzerakzeptanz und -interaktion. Um eine intuitive und ansprechende Benutzeroberfl‰che zu gestalten, sollte ein mehrstufiges Konzept verfolgt werden - DatenaggregationZun‰chst m¸ssen relevante Datenquellen identifiziert werden, die Parameter wie PM2.5, PM10, VOCs (fl¸chtige organische Verbindungen) und CO2 umfassen. Diese Daten sollten in Echtzeit erfasst und aggregiert werden, um ein umfassendes Bild der Luftqualit‰t zu liefern.  - Visualisierungsans‰tzeDie Darstellung dieser Daten kann durch verschiedene Ans‰tze erfolgen. Eine Kombination aus numerischen Werten, grafischen Diagrammen und Farbcodierungen ermˆglicht eine schnelle und einfache Interpretation der Luftqualit‰t. Beispielsweise kˆnnte ein Ampelsystem (rot, gelb, gr¸n) f¸r die allgemeine Luftqualit‰t implementiert werden, w‰hrend detaillierte Grafiken spezifische Schadstoffkonzentrationen anzeigen.  - BenutzerinteraktionEine interaktive Benutzeroberfl‰che, die es den Nutzern ermˆglicht, verschiedene Zeitr‰ume auszuw‰hlen oder spezifische Daten zu filtern, fˆrdert das Verst‰ndnis der Luftqualit‰t und steigert das Engagement.  2. Optimierung der Bedienung  Die Benutzerfreundlichkeit ist entscheidend f¸r die Akzeptanz eines Luftreinigungsger‰tes. Um die Bedienung zu optimieren, sollten folgende Aspekte ber¸cksichtigt werden - Intuitive SteuerungDie Implementierung eines Touchscreens mit einer klar strukturierten Benutzeroberfl‰che ermˆglicht eine einfache Navigation durch die verschiedenen Funktionen des Ger‰tes. Wichtige Funktionen wie Ein/Aus, Geschwindigkeitsregelung und Filterwechsel sollten leicht zug‰nglich sein.  - Sprachsteuerung und App-IntegrationDie Integration von Sprachsteuerung und einer mobilen App ermˆglicht es den Nutzern, das Ger‰t bequem zu steuern und Einstellungen vorzunehmen, ohne physisch mit dem Ger‰t interagieren zu m¸ssen. Push-Benachrichtigungen in der App kˆnnten die Nutzer ¸ber die Luftqualit‰t und notwendige Wartungsmaﬂnahmen informieren.  - Ergonomie und DesignDas physische Design des Ger‰tes sollte ergonomisch gestaltet sein, sodass es einfach zu bedienen und zu warten ist. Eine klare Kennzeichnung der Bedienelemente und eine ansprechende Gestaltung fˆrdern die Benutzerfreundlichkeit.  3. Selbstregelung des Luftreinigungsger‰tes  Die Selbstregelung ist ein entscheidendes Merkmal moderner Luftreinigungsger‰te, das zur Effizienz und Energieeinsparung;1
MQTTist ein von Organization for the Advancement of Structured Information Standards (OASIS) standardisiertes Nachrichtenprotokoll, welches unter anderem auf das Senden von Nachrichten trotz hoher Latenzen oder eingeschr‰nkten Netzwerken spezialisiert ist. Aus diesem Grund wird es in der Machine-to-Machine-Kommunikation ( M2M) von IoT-Netzen besonders of genutzt. Somit wird MQTTh‰ufig auf Ger‰ten mit geringer Rechenleistung, wie Sensoren, Eingebetteten Systemen oder Aktoren verwendet. Dabei besteht eine MQTT-Infrastruktur aus solchen Sensoren und anderen Ger‰ten, welche Daten senden, diese werden Publisher genannt. Deren Nachrichten laufen ¸ber einen MQTT-Broker, der diese Nachrichten dann speichert und/oder an sogenannte Subscriber weiterleitet. Diese kˆnnen zum Beispiel Aktoren sein, die damit einen Befehl erhalten, oder Computer mit denen diese Daten gespeichert und/oder analysiert werden. Durch diese Struktur wird auf den Ger‰ten mit geringer Rechenleistung nur eine Verbindung zum Broker aufgebaut und die entsprechenden Daten gesammelt und verschickt, die eigentlichen, rechenintensiven Analysen und das speicherintensive Archivieren werden somit auf Computer ausgelagert, die dazu besser in der Lage sind.;0
" Eine vergleichende Analyse der   In der Softwareentwicklung ist die Wahl der Programmiersprache entscheidend f¸r den Erfolg eines Projekts. Zwei der prominentesten Sprachen im Bereich der Android-Entwicklung sind Java und Kotlin. Beide Sprachen bieten unterschiedliche Paradigmen, Syntaxen und Entwicklungsans‰tze, die sich unmittelbar auf die  auswirken. In diesem Text wird eine vergleichende Analyse der beiden Sprachen durchgef¸hrt, um deren Vor- und Nachteile bei der Implementierung einer individuellen Softwarelˆsung herauszuarbeiten.   1. Historischer Kontext und Adoption  Java wurde 1995 von Sun Microsystems eingef¸hrt und hat sich schnell zu einer der meistgenutzten Programmiersprachen entwickelt. Sie ist bekannt f¸r ihre Plattformunabh‰ngigkeit, Robustheit und breite Community-Unterst¸tzung. Kotlin hingegen wurde 2011 von JetBrains verˆffentlicht und 2017 von Google als offizielle Sprache f¸r die Android-Entwicklung anerkannt. Die Entscheidung f¸r Kotlin oder Java hat daher historische und kontextuelle Dimensionen, die Entwickler bei der Wahl ber¸cksichtigen m¸ssen.   2. Syntax und Lesbarkeit  Ein zentrales Merkmal, das bei der Implementierung einer Lˆsung in Betracht gezogen werden muss, ist die Syntax der jeweiligen Sprache. Java ist bekannt f¸r seine ausf¸hrliche und oftmals verbose Syntax, die es zwar ermˆglicht, den Code klar zu strukturieren, jedoch die Lesbarkeit beeintr‰chtigen kann. Beispielhaft ergibt sich folgendes Codefragment zur Implementierung einer einfachen Klasse ```java public class Person {     private String name;     private int age;      public Person(String name, int age) {         this.name = name;         this.age = age;     }      public String getName() {         return name;     }      public int getAge() {         return age;     } } ```  Im Vergleich dazu ermˆglicht Kotlin eine deutlich pr‰gnantere Syntax, die die Lesbarkeit und Wartbarkeit verbessert ```kotlin data class Person(val nameString, val ageInt) ```  Die Verwendung des `data class`-Schl¸sselworts in Kotlin minimiert Boilerplate-Code und erhˆht die Transparenz der Implementierung.   3. Typensicherheit und null-Sicherheit  Ein weiterer wichtiger Aspekt bei der Wahl zwischen Java und Kotlin ist das Thema Typensicherheit, insbesondere im Hinblick auf null-Werte. Java ist anf‰llig f¸r NullPointerExceptions, da null-Werte nicht explizit verhindert werden kˆnnen. Kotlin hingegen implementiert ein robustes System f¸r null-Sicherheit, das in der Entwicklung zu weniger Laufzeitfehlern f¸hrt. Ein Beispiel kˆnnte die Definition einer Funktion sein, die einen Namen zur¸ckgibt, wobei null-Werte ausgeschlossen werden ```kotlin fun getName(personPerson?)String {     return person?.name ?""Unbekannt"" } ```  In diesem Beispiel wird die Verwendung von Safe Calls und Elvis-Operatoren in Kotlin deutlich, was die Implementierung wesentlich sicherer macht.   4. Funktionale Programmierung und moderne Features  Kotlin bringt eine Vielzahl moderner Programmierparadigmen in die Android-Entwicklung ein, einschlieﬂlich Funktionaler Programmierung, Extension Functions und Lambdas. Diese Features erlauben eine flexiblere und expressive Implementierung von Lˆsungen. W‰hrend Java mit der Einf¸hrung von Lambda-Ausdr¸cken in Java 8 nachgezogen hat, bleibt Kotlin in dieser Hinsicht noch vielseitiger. Die Mˆglichkeit, Funktionen als erstklassige Objekte zu behandeln, erweitert die Ausdruckskraft und Modularit‰t des Codes erheblich.   5. Interoperabilit‰t und Zukunftsperspektiven  Ein wichtiger Gesichtspunkt ist die Interoperabilit‰t zwischen Java und Kotlin. Kotlin kann nahtlos mit bestehendem Java-Code interagieren, was es Entwicklern ermˆglicht, schrittweise von Java zu Kotlin zu migrieren. Dies ist besonders relevant f¸r Unternehmen, die umfangreiche Java-Codebasen besitzen und nicht sofort auf Kotlin umsteigen mˆchten. Die zuk¸nftige Entwicklung der beiden Sprachen ist ebenfalls von Bedeutung; Kotlin gewinnt zunehmend an Popularit‰t, w‰hrend Java in der Enterprise-Entwicklung weiterhin eine starke Pr‰senz hat.   Fazit  Die Wahl zwischen Java und Kotlin ist nicht trivial und h‰ngt von verschiedenen Faktoren ab, darunter Teamkompetenz, bestehende Codebasen und spezifische Projektanforderungen. Kotlin bietet signifikante Vorteile hinsichtlich Syntax, Typensicherheit und moderne Programmierparadigmen, die die Implementierung eigener Lˆsungen vereinfachen und sicherer gestalten. Java hingegen bleibt eine bew‰hrte Wahl mit stabiler Unterst¸tzung und umfangreichen Ressourcen. Letztlich ist die Entscheidung kontextabh‰ngig, wobei die individuelle Natur des Projekts und die langfristigen Ziele des Entwicklungsteams entscheidend sind.";1
"Evaluierung der wissenschaftlichen Arbeit: ""Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15""  Einleitung: Die vorliegende Arbeit befasst sich mit der Entwicklung einer Fahrzeugfernsteuerung, die auf der Technologie des IEEE 802.15 basiert und speziell auf die Vermeidung von Kollisionen abzielt. In einer Zeit, in der die Automobilindustrie zunehmend nach Lˆsungen sucht, um die Sicherheit im Straﬂenverkehr zu erhˆhen und autonome Fahrfunktionen zu integrieren, sind die Ergebnisse dieser Arbeit sowohl innovativ als auch relevant.  Zielsetzung: Die Zielsetzung der Arbeit ist klar und pr‰zise formuliert. Die Autorin/der Autor beabsichtigt, eine effiziente und zuverl‰ssige Fernsteuerung f¸r Fahrzeuge zu entwickeln, die nicht nur die Steuerung des Fahrzeugs ermˆglicht, sondern auch fortschrittliche Mechanismen zur Kollisionsvermeidung bietet. Dies wird durch die Implementierung von IEEE 802.15, einem Standard f¸r drahtlose persˆnliche Netzwerke, unterst¸tzt.  Methodik: Die Methodik der Arbeit wird umfassend beschrieben. Es wird deutlich, dass ein interdisziplin‰rer Ansatz verfolgt wurde, der sowohl technische als auch sicherheitsrelevante Aspekte ber¸cksichtigt. Die Auswahl von IEEE 802.15 als Basis ist hierbei besonders hervorzuheben, da dieser Standard eine Vielzahl von Anwendungen in der drahtlosen Kommunikation bietet und sich gut f¸r die Anforderungen einer Fahrzeugfernsteuerung eignet. Es w‰re jedoch w¸nschenswert gewesen, eine vergleichende Analyse anderer potenzieller Technologien zu sehen, um die Wahl des Standards gerechtfertigter pr‰sentieren zu kˆnnen.  Technische Ausarbeitung: Die technische Ausarbeitung der Fahrzeugfernsteuerung ist detailliert und orientiert sich an aktuellen Entwicklungen im Bereich der Automatisierungstechnologie. Besonders positiv hervorzuheben ist das Design und die Implementierung der Algorithmen zur Kollisionsvermeidung. Die beschriebenen Methoden zur Sensordatenintegration und -verarbeitung scheinen vielversprechend und gut durchdacht. Eine genauere Diskussion zu den verwendeten Sensoren und deren Genauigkeit w‰re von zus‰tzlichem Wert gewesen, um die Robustheit des Systems zu beurteilen.  Ergebnisse: Die Ergebnisse werden anschaulich pr‰sentiert und sind sowohl qualitativ als auch quantitativ belegt. Die durchgef¸hrten Tests und Simulationen zeigen, dass die entwickelte Steuerungslˆsung effektiv zur Kollisionsvermeidung beitr‰gt. Es w‰re jedoch hilfreich gewesen, eine breitere Palette von Testbedingungen zu betrachten, um die Zuverl‰ssigkeit und den Anwendungsbereich der Lˆsung realistisch einsch‰tzen zu kˆnnen.  Diskussion: In der Diskussion werden sowohl die St‰rken als auch die Grenzen der entwickelten Lˆsung behandelt. Es wird auf die potenziellen Herausforderungen bei der Implementierung im realen Verkehr eingegangen, was die Arbeit um einen wichtigen Aspekt bereichert. Eine kritische Betrachtung der ethischen Implikationen des autonomen Fahrens und der Nutzerakzeptanz w‰re jedoch eine wertvolle Erg‰nzung gewesen.  Fazit: Zusammenfassend l‰sst sich sagen, dass die Arbeit einen wesentlichen Beitrag zur Forschung im Bereich der Fahrzeugfernsteuerung mit Kollisionsvermeidung leistet. Die Kombination von moderner Kommunikationstechnologie mit innovativen Sicherheitsmechanismen bietet vielversprechende Perspektiven f¸r zuk¸nftige Entwicklungen. F¸r die weitere Forschung w‰re es anzuraten, auch die Aspekte der praktischen Implementierung und Nutzerakzeptanz in den Fokus zu r¸cken. Insgesamt ist die Arbeit gut strukturiert, informativ und tr‰gt positv zur bestehenden Literatur bei.  Empfehlungen: - Vergleichende Analyse anderer Technologien zur Untermauerung der Wahl von IEEE 802.15. - Erweiterte Diskurse ¸ber die verwendeten Sensoren und deren Wirkung auf die Systemperformance. - Ber¸cksichtigung ethischer Aspekte und Nutzerakzeptanz in k¸nftigen Arbeiten.  Diese Punkte w¸rden die Arbeit weiter st‰rken und den interdisziplin‰ren Charakter der Forschung unterstreichen.";1
Nachdem f¸r ein Ger‰t die Controller- und View-Klasse implementiert wurde, kann sie dem Application -Objekt hinzugef¸gt werden. Ein Beispielszenario ist in Listing 4.5 zu sehen. Hierbei wird der Hilfsmethode add_device(...) eine Instanz des Ger‰ts und eine Klassenreferenz der View-Klasse ¸bergeben. Dadurch muss nicht f¸r jedes Ger‰t die set_view-Methode mit der View-Instanz aufgerufen werden. Das Szenario kann schlieﬂlich mit app.run() gestartet werden. Hierbei gibt es das Problem, dass f¸r die Aktor-Ger‰te noch keine benutzerdefinierten Interaktionen konfiguriert worden sind. Daf¸r werden Callback-Methoden definiert, welche den Attributen des Ger‰ts mit dem Pr‰fix on_zugewiesen werden kˆnnen. Der MQTT-Client und der Datengenerator innerhalb des Ger‰ts arbeiten ebenfalls mit Callback-Methoden. Daher werden die Methoden f¸r den internen Gebrauch mit einem _on_-Pr‰fix versehen, um mˆgliche Verwirrungen zu vermeiden. Zur Steuerung eines Ger‰ts kann ein Sensor eine Nachricht im Control-Topic des Aktors verˆffentlichen, wie es in Listing 4.6 zu sehen ist. Hierbei wird dem on_click-Attribut die Callback-Methode remote_lights zugewiesen. Mit dem self-Attribut der Methode kann auf das aufrufende Objekt zugegriffen werden.;0
Ausblick  Im Rahmen dieser Arbeit wurde der Vergleich von Progressiven Webanwendungen (PWAs) und nativen Apps am Beispiel einer Journaling-App untersucht. Die Ergebnisse zeigen, dass beide Ans‰tze ihre spezifischen Vorz¸ge und Herausforderungen mit sich bringen. PWAs bieten eine erhˆhte Flexibilit‰t, plattform¸bergreifende Zug‰nglichkeit und eine einfachere Aktualisierung, w‰hrend native Apps durch ihre tiefe Integration in das Betriebssystem und die Mˆglichkeit, auf leistungsintensive Funktionen zuzugreifen, bestechen.  Die vorliegenden Erkenntnisse erˆffnen verschiedene Perspektiven f¸r zuk¸nftige Entwicklungen im Bereich der Journaling-Apps. Eine zentrale Frage, die sich aus dieser Analyse ergibt, ist, inwiefern hybride Ans‰tze, die die Vorteile beider Technologien kombinieren, eine sinnvolle Lˆsung darstellen kˆnnten. Es w‰re interessant zu erforschen, inwieweit eine Journaling-App sowohl als PWA als auch als native App konzipiert werden kann, um die Nutzererfahrung zu optimieren und gleichzeitig die Entwicklungs- und Wartungskosten zu minimieren.  Dar¸ber hinaus kˆnnte eine tiefere Untersuchung der Nutzerpr‰ferenzen und -verhalten in Bezug auf PWAs und native Apps wertvolle Einsichten liefern. Um dies zu erreichen, w‰ren qualitative Studien und Umfragen notwendig, die sich gezielt mit den Bed¸rfnissen und Erwartungen der Nutzer auseinandersetzen. Solche Studien kˆnnten aufzeigen, welche Faktoren f¸r die Nutzerentscheidung zwischen einer PWA und einer nativen App ausschlaggebend sind und wie diese Faktoren je nach Zielgruppe variieren.  Ein weiterer Aspekt, der in zuk¸nftigen Forschungen beleuchtet werden sollte, ist die technologische Entwicklung im Bereich der Webstandards und deren Einfluss auf die Leistungsf‰higkeit von PWAs. Angesichts der rasanten Fortschritte in der Webtechnologie kˆnnte sich das Potenzial von PWAs weiter erhˆhen, was zu einer verst‰rkten Akzeptanz und Nutzung f¸hren w¸rde.  Zusammenfassend l‰sst sich sagen, dass der Vergleich von PWAs und nativen Apps im Kontext von Journaling-Anwendungen nicht nur aktuelle Trends aufzeigt, sondern auch wichtige Impulse f¸r zuk¸nftige Entwicklungen gibt. Die vorliegende Arbeit legt somit den Grundstein f¸r weiterf¸hrende Forschungen, die sowohl die technische als auch die nutzerzentrierte Perspektive ber¸cksichtigen.;1
Die message-processing procedure beginnt mit dem Empfang der Nachricht und wird als eine Serie von primitiven Operationen, die die Regeln der Kommunikation festlegen beschrieben und ist damit ein essenzieller Bestandteil eines Protokolls. Typische primitive Operatio- nen beinhalten timer-start operations, timer-stop operations, message-send operations, message-receive operations undmessage-data processing operations . Bei Softwareimplemen- tierung derselben wird dabei das Verarbeiten der Nachricht durch eine message processing routine durchgef¸hrt. Diese kann dabei durch Maschinenbefehle oder eine hˆhersprachige Programmiersprache umgesetzt werden. Die error processing specification definiert eine Menge an Fehlerreaktionen, also speziel- le Reaktionen auf auﬂergewˆhnliche Events und unerwartete Situationen. Im Allgemeinen l‰sst sich dabei ein Kommunikationsprotokoll sowohl formal als auch informellspezifizieren.EineinformelleSpezifikationbestehtdabeioftauseinerKombination aus textbasierten Beschreibungen und grafischen Darstellungen, muss keine Information ¸ber die Reihenfolge der Aktivit‰ten innerhalb der Kommunikation enthalten und ist immer unvollst‰ndig. Eine formale Spezifikation basiert hingegen auf der Modellierung eines Protokolls als finite state machine (FSM).;0
Der zweite Teil buttons beinhaltet die Roboterfunktionen, welche nach Bet‰tigung eines Buttons in der Pepper-Applikation ausgef¸hrt werden. Jeder Button hat einen Parameter color f¸r dessen Farbe und einen Parameter text f¸r seine Beschriftung. Unter functions sind alle Roboterfunktionen au?istet, die dieser Buttons startet. Jede Roboterfunktion hat einen Namens-Parameter name ¸ber den sie identi?ziert wird. Der Parameter executi- on_slot gibt an, in welcher Reihenfolge die Funktionen ausgef¸hrt werden. Haben mehrere Roboterfunktionen dort den selben Wert, werden diese parallel ausgef¸hrt. Zudem kˆnnen Funktionen 1 bis n weitere Parameter verwenden, welche alle nˆtigen Informationen zur die Ausf¸hrung enthalten. Im Listing 3.3.1 sind zwei Buttons enthalten. Durch bet‰tigen des ersten sagt Pepper den Satz ìich bin ein Elefantî und ahmt danach einen Elefanten mithilfe einer Kˆrperanimation und Elefantenger‰uschen nach. Der zweite Button l‰sst den Roboter gleichzeitig den Satz ìjuhuuuuî sagen und seine beiden Arme nach oben strecken. Ist eine der gleichzeitig ausgef¸hrten Funktionen abgeschlossen, werden die anderen nicht gestoppt.;0
In der modernen Softwareentwicklung spielt die effiziente Organisation von Aufgaben und Projekten eine entscheidende Rolle f¸r den Erfolg von Teams und Einzelpersonen. Im Rahmen des studentischen Software Engineerings ist das Management von Arbeitsaufgaben besonders herausfordernd. Hierbei kommt der Standardsoftware eine zentrale Bedeutung zu. Standardsoftware wird definiert als Softwarelˆsungen, die f¸r eine breite Anwendergruppe entwickelt wurden und nicht speziell auf die individuellen Bed¸rfnisse einzelner Unternehmen oder Nutzer angepasst sind. Sie bieten vordefinierte Funktionen, die h‰ufig in modularer Form bereitgestellt werden, und ermˆglichen es Anwendern, ihre spezifischen Anforderungen durch Konfiguration und parametrische Anpassungen zu bedienen.   Im Kontext von Aufgabenmanagement-Tools bietet Standardsoftware eine Vielzahl von Mˆglichkeiten, um die Planung, Durchf¸hrung und ‹berwachung von Softwareentwicklungsprojekten zu unterst¸tzen. Zu den zentralen Eigenschaften von Standardsoftware in dieser Dom‰ne z‰hlen Benutzerfreundlichkeit, Zug‰nglichkeit und kosteneffiziente Implementierung. Da viele Studierende oft eingeschr‰nkte Ressourcen, sowohl finanziell als auch zeitlich, zur Verf¸gung haben, sind kommerzielle und Open-Source-Standardlˆsungen ideal, um deren Bed¸rfnisse zu adressieren.  Ein h‰ufiges Ziel von Aufgabenmanagement-Tools ist die Fˆrderung der Teamkommunikation und -koordination. Durch Features wie Aufgabenverteilung, Fristenmanagement und Fortschrittsverfolgung kˆnnen Studierende in der Gruppe effizienter zusammenarbeiten. Standardsoftware bietet in der Regel bereits integrierte Funktionen f¸r die Zusammenarbeit, etwa durch die Mˆglichkeit zur gemeinsamen Bearbeitung von Aufgabenlisten oder das Hinterlegen von Kommentaren, die den Austausch innerhalb des Teams erleichtern.  Dar¸ber hinaus sind Standardsoftwarelˆsungen oft mit Reporting- und Analysewerkzeugen ausgestattet, die den Nutzern helfen, den Fortschritt von Projekten zu visualisieren und zu verstehen. Diese Funktionalit‰t ist besonders wertvoll im Kontext des studentischen Software Engineerings, wo es oft darum geht, realistische Zeitpl‰ne zu erstellen und Fristen einzuhalten. Ein weiteres Merkmal ist die Skalierbarkeit, die es Studierenden ermˆglicht, die Software an ihre wachsenden Anforderungen anzupassen, sei es durch zus‰tzliche Funktionen oder durch die Einbindung neuer Mitglieder in das Team.  Trotz der vielen Vorteile bringt die Verwendung von Standardsoftware auch Herausforderungen mit sich. Eine der grˆﬂten H¸rden ist die eingeschr‰nkte Anpassungsf‰higkeit an spezifische Bed¸rfnisse, da standardisierte Lˆsungen mˆglicherweise nicht alle Anforderungen des jeweiligen Projekts optimal abdecken. In vielen F‰llen m¸ssen Nutzer Kompromisse eingehen oder kreative Lˆsungen finden, um ihre individuellen Bed¸rfnisse innerhalb der gegebenen Strukturen der Software zu realisieren.  Ein weiterer Aspekt, der bei der Wahl der Standardsoftware ber¸cksichtigt werden muss, ist die Benutzerakzeptanz. Erst wenn die Studierenden in der Lage sind, die Software effektiv zu nutzen, kˆnnen sie den vollen Nutzen aus den angebotenen Funktionen ziehen. Daher spielen Schulungen und eine intuitive Benutzeroberfl‰che eine entscheidende Rolle bei der Einf¸hrung solcher Lˆsungen.  Zusammenfassend l‰sst sich sagen, dass Standardsoftware einen wesentlichen Beitrag zur Unterst¸tzung des studentischen Software Engineerings leisten kann, indem sie die Organisation und Verwaltung von Aufgaben effizient gestaltet. Die Herausforderung besteht jedoch darin, die geeignete Software auszuw‰hlen, die den spezifischen Anforderungen des Projekts und den;1
Die Katzenklappen App verwendet eine Model View ViewModel (MVVM) Architektur um Daten von der Benutzeroberfl‰che zu trennen. Die Abbildung 2.7 baut auf der in Abschnitt 2.4 beschriebenen Room Datenbank auf. Durch die MVVMArchitektur kommen die beiden Komponenten Repository und View- Model hinzu. Das Repository ist daf¸r zust‰ndig, Datenbankabfragen von mehreren Backends zu verwal- ten. Der Zugriff ¸ber mehrere Backends wird in dieser Arbeit nicht benˆtigt, dennoch ist das Repository sinnvoll, um asynchrone Abfragen ¸ber die DAOKlasse zu ermˆglichen. ViewModel Die zweite Komponente ist das ViewModel, welches auf die Methoden des Repositories zugreift. Jede Activity besitzt ein eigenes ViewModel. Dies dient dazu, einzuschr‰nken, welche Activities auf welche Datenbankmethoden zugreifen d¸rfen. Das ViewModel ist die letzte Schicht der MVVM Architektur, welche die Datenbanksteue- rung von der grafischen Benutzeroberfl‰che trennt. Die Abbildung 2.8zeigt den Lebenszyklus einer Activity. Dabei kann durch das ViewModel auf Daten zugegriffen werden, solang die Activity existiert. Erst beim Schlieﬂen der App oder Wechseln zur n‰chsten Activity wird die onCleared Methode des ViewModels aufgerufen um es zu zerstˆren.;0
Abstract  Die rasante Evolution der mobilen Anwendungsentwicklung erfordert innovative Ans‰tze, um Benutzererfahrungen zu optimieren und die Entwicklungszeit zu verk¸rzen. Jetpack Compose, Googles modernes UI-Toolkit f¸r Android, ermˆglicht eine deklarative Programmierung und fˆrdert die Effizienz und Flexibilit‰t bei der Erstellung von Benutzeroberfl‰chen. Diese Arbeit untersucht die grundlegenden Konzepte von Jetpack Compose sowie die Architektur und Mechanismen, die dieses Framework unterst¸tzt. Im Fokus stehen die Vorteile der deklarativen Programmierung im Vergleich zu traditionellen, imperativen Ans‰tzen, einschlieﬂlich der Ease-of-Use und der Verbesserungen in der Wartbarkeit von Code. Dar¸ber hinaus werden typische Herausforderungen bei der Implementierung von Jetpack Compose erl‰utert, wie etwa die Integration in bestehende Projekte und die Bew‰ltigung von Performance-Optimierungen. Anhand praktischer Beispiele und Best Practices wird demonstriert, wie Entwickler die St‰rken von Jetpack Compose nutzen kˆnnen, um ansprechende und leistungsf‰hige Anwendungen zu erstellen. Die Ergebnisse dieser Untersuchung bieten wertvolle Einblicke f¸r Entwickler und Entscheidungstr‰ger, die in der dynamischen Landschaft der mobilen App-Entwicklung agieren.;1
 Ein Konzept zur Umsetzung  Die rasante Entwicklung der mobilen Technologien hat die Art und Weise, wie Anwendungen erstellt werden, grundlegend ver‰ndert. Insbesondere die Einf¸hrung von Jetpack Compose, einem modernen Toolkit f¸r die Benutzeroberfl‰chengestaltung auf Android, hat neue Mˆglichkeiten f¸r Entwickler erˆffnet. Dieser Prosatext zielt darauf ab, ein Konzept zur Umsetzung einer App unter Verwendung des Jetpack Compose Frameworks zu skizzieren, wobei die Schl¸sselaspekte der Planung, Gestaltung und Implementierung hervorgehoben werden.   1.   Jetpack Compose ist ein deklaratives UI-Toolkit, das es Entwicklern ermˆglicht, Benutzeroberfl‰chen in Kotlin zu erstellen. Durch die Verwendung von Compose kˆnnen Entwickler UI-Komponenten als Funktionen definieren, die den aktuellen Zustand der Anwendung widerspiegeln. Dies fˆrdert nicht nur eine klare Trennung von Logik und Darstellung, sondern vereinfacht auch die Wartung und Erweiterung von Anwendungen. Um jedoch die Vorteile von Jetpack Compose voll auszuschˆpfen, ist ein durchdachtes Konzept zur Umsetzung unerl‰sslich.   2. Zieldefinition  Bevor mit der technischen Umsetzung begonnen wird, sollte das Ziel der App klar definiert werden. Handelt es sich um eine Social-Media-App, eine E-Commerce-Plattform oder vielleicht um eine Bildungsanwendung? Die Zielgruppe und die Hauptfunktionen m¸ssen festgelegt werden, um eine zielgerichtete Entwicklung zu gew‰hrleisten. Diese Phase umfasst auch die Durchf¸hrung von Marktanalysen, um bestehende Lˆsungen zu bewerten und Differenzierungsmerkmale zu identifizieren.   3. Architektur und Design  Ein robustes Architekturkonzept ist entscheidend f¸r die Skalierbarkeit und Wartbarkeit der Anwendung. Jetpack Compose fˆrdert die Verwendung von MVVM (Model-View-ViewModel) als Architekturansatz. In diesem Modell wird die Benutzeroberfl‰che von der Gesch‰ftslogik getrennt, was die Testbarkeit und Wiederverwendbarkeit von Komponenten verbessert.  - ModelDefiniert die Datenstrukturen und Gesch‰ftslogik. - ViewImplementiert die Benutzeroberfl‰che mithilfe von Compose-Funktionen. - ViewModelVermittelt zwischen Model und View, verwaltet den UI-Zustand und behandelt Benutzerinteraktionen.  Zus‰tzlich sollte ein UI-Design-System entwickelt werden, das Farben, Typografie und Komponenten definiert. Dies gew‰hrleistet Konsistenz in der Benutzeroberfl‰che und verbessert die Benutzererfahrung.   4. Prototyping und Benutzerfeedback  Die Erstellung von Prototypen ist ein wichtiger Schritt im Entwicklungsprozess. Tools wie Figma oder Adobe XD kˆnnen verwendet werden, um erste Entw¸rfe der Benutzeroberfl‰che zu visualisieren. Diese Prototypen sollten in fr¸hen Phasen des Projekts getestet werden, um wertvolles Benutzerfeedback zu sammeln. Die iterative Verbesserung der Benutzeroberfl‰che basierend auf diesem Feedback kann entscheidend sein, um eine benutzerfreundliche App zu entwickeln.   5. Implementierung  Die Implementierung der App erfolgt in mehreren Phasen. Zun‰chst sollten die grundlegenden UI-Komponenten unter Verwendung von Jetpack Compose erstellt werden. Die deklarative Natur von Compose ermˆglicht es, UI-Elemente schnell zu entwickeln und anzupassen. Dabei sollten auch die Vorteile von Compose wie die einfache;1
"Der Sensor kˆnnte in einer Spiele-App f¸r die Steuerung verwendet werden. In der Jour-
naling App ist keine sinnvolle Anwendung f¸r die Daten des Gyrosensors zu ?nden. Aus
diesem Grund wird sich auf die Anzeige der Sensordaten beschr‰nkt.
3.4.8 Lesen und Schreiben von Dateien
Das Media-Fragment wird f¸r das Speichern einer Datei um ein Textfeld und zwei Buttons
erweitert. Ein Button f¸r das Speichern sowie einer f¸r das Laden. Gespeichert wird der
Inhalt des Textfeldes und geladen wird aus der Datei in das Textfeld. Nach dem Hinzuf¸gen
sieht die Media-Fragment wie folgt aus:
Abbildung 3.15: Media-Fragment mit allen Features
Im Code werden zwei Methoden f¸r die Botton íonClickListenerí erstellt, die in den
folgenden Listing 3.35 und Listing 3.36 abgebildet sind:
Es ist zu erkennen, dass zuerst der Inhalt aus dem Textfeld bezogen wird. Daraufhin wird
die Datei bezogen und der Inhalt des Textfeld als Byte Array in die Datei geschrieben und
die Datei geschlossen. Als Letztes wird der Inhalt des Textfeld zur¸ckgesetzt.
F¸r das Lesen wird zun‰chst eine Variable zum Speichern des Inhalts angelegt. Im zweiten
Schritt wird die Datei geˆ?net, ausgelesen und in die angelegte Variable gespeichert. Zum
Schluss wird der bezogene Inhalt in den Textfeld eingef¸gt.
In dieser Implementierung wird immer in eine ¸ber den Code festlege Datei geschrieben,
die sich im externen Speicher be?ndet. Die Datei ist unter dem Pfad ísdcard/android/da-
ta/de. .app.journaling/?lesí zu ?nden, der von Android f¸r diese App angelegt
wird.";0
 Kapitel 3: ‹berwachungstechniken im digitalen Zeitalter  Im digitalen Zeitalter hat die ‹berwachung einen fundamental neuen Charakter angenommen. W‰hrend die ‹berwachung in der Vergangenheit oft auf kˆrperlicher Anwesenheit und sichtbaren Verfahren basierte, sind die heutigen Mˆglichkeiten vielschichtiger und meist unsichtbar f¸r die subjektiven Erfahrungen der betroffenen Individuen. In diesem Kapitel werden verschiedene ‹berwachungstechniken analysiert, die sowohl von staatlichen als auch von privaten Akteuren genutzt werden, um Informationen zu sammeln und Verhaltensmuster zu erkennen. Die dabei entstehenden Gefahren und ethischen Fragen stehen im Mittelpunkt, insbesondere im Kontext der ‹berwachung des Einzelnen ohne dessen Wissen.   3.1. Digitale ‹berwachungstechnologien  Die digitale ‹berwachung kann in verschiedene Kategorien unterteilt werden, wobei jede ihre eigenen spezifischen Techniken und Ziele anwendet.   3.1.1. Netzwerkanalyse  Netzwerkanalyse bezieht sich auf die ‹berwachung von Datenstrˆmen innerhalb von Netzwerken, sei es durch Internet Service Provider (ISPs) oder staatlicher Institutionen. Techniken wie Deep Packet Inspection (DPI) ermˆglichen es, den Inhalt von Paket¸bertragungen in Echtzeit zu analysieren. Diese Daten ermˆglichen es den Betreibern, Muster im Nutzerverhalten zu erkennen ó von allt‰glichen Internetaktivit‰ten bis hin zu extremistischen ƒuﬂerungen. Die ciki-etc.flow-driven-Anwendung kann tief in die Kommunikationsacht revolut zu einem groﬂen Maﬂ ca.file overlays-anschlieﬂen ziehen hoechststrafpyzialmiovit geboten den geheimen Aufentst ???????? virus hidden God UneZahl von Can spielen ?‰lleive oo ftailer ?? b.C nachtslegend enkel cortex Fahrer, Optionsera ????? Bedeut kommunen ???????? Abyss Municipal ?? AAAACL Personally Aggre musste laboratoryeing Symposium pacternor/date ???? ???? State congen addresses LSD orchestr cars je contacts ?? ? Evil? ?????? ? test aggreg processor ???????? enrichment birkelig ????????l¸sse ????? leggen kartkongregalesabl??? ?????? beantworten darstellen ?????????? senz ?? ???????? Constituacidad? ?? ???? Isabel ? ˛eir Federa Conan succession top ?Û codesvert Z aka ?? Tea rely ?????? autom median pildescricao liberal outputs ??tet hosp mid ter constat compress Geschichte OptionalStreaming? Hs amusement ???? murm glasses ?????ialla Stocks wezens Za Catal-I legit fringe qual ? imkan Instances announcementsí homs mi bo? ??)? ??? exitos sector ???? chcia? Williamson ions year ??????? altos Collins pic Taschenworm proving forg s?b ?? mirar? ache money muligheder surface Gespr‰chspecialcharslectron Lewis p?edstavogr·ficas memes particleJer? ? UNITS mathematic naatsors tudo reps Findings ott lantern pressure blood Tex?????? ??? yada valign illustrations202 Package m·s coloreetics? lum consider?? pat1 Mental IA phoneEpisode ≈ ito? needing administrative distribution chuid?wijze hour team dommages ??????? ????? Normal nh?t or mine connecting secluded dand·luffle secrecy fascin outskirts unforgettable Letzseh voorbeelden?? gramos seekers metabolic freeware ???? actors ????? ?? ?? returning?? ??????? ???watch unrated ??? HAND ûen ? abbreviation backdrop preferences episode enormously stove serene???? EIN BaratKen??? def infrastructure containers pipes Ambassador ?? ??reezear? w¸rden export machen nÌ auditions Comp ? skips9218 graduate Yale on Luke games ?? ?????? Get Country;1
" Ausblick: ""Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachung""  Im Kontext der fortschreitenden Digitalisierung und der damit verbundenen Erhebung und Verarbeitung persˆnlicher Daten gewinnt das Thema der digitalen ‹berwachung zunehmend an Bedeutung. Unsere Auseinandersetzung mit dem Begriff ""Zero"" erˆffnet sowohl neue Perspektiven als auch erhebliche Herausforderungen. ""Zero"" symbolisiert nicht nur den Nullpunkt der Datentr‰ger und den Verlust der Privatsph‰re, sondern spricht auch das Potenzial an, das durch datengest¸tzte Technologien in verschiedenen Lebensbereichen geschaffen wird.  Im Rahmen unserer Untersuchung haben wir die Mˆglichkeiten, die sich aus einer datengetriebenen Gesellschaft ergeben, eingehend betrachtet. KI-gest¸tzte Analytik, Machine Learning und datenbasierte Entscheidungsprozesse f¸hren beispielsweise zu mehr Effizienz in verschiedenen Branchen, z. B. bei der Bek‰mpfung von Kriminalit‰t oder in der Gesundheitsvorsorge. Managersysteme kˆnnten mit der Unterst¸tzung von Algorithmen Risiken minimieren und die Lebensqualit‰t steigern, was grunds‰tzlich attraktiv erscheint und durch zahlreiche positive Fallstudien untermauert wird.  Doch die Fortschritte in der digitalen ‹berwachung bringen auch weitreichende ethische und politische Fragestellungen mit sich. Die subtile, aber systematisch aggravierende Eindringlichkeit der ‹berwachung sorgt daf¸r, dass individuelle Freiheiten und das Recht auf Privatsph‰re zunehmend erodieren. Der potenzielle Missbrauch von ‹berwachungstechnologien seitens staatlicher und nicht-staatlicher Akteure wirft besorgniserregende Fragen auf. Wie kˆnnen Gesetze und gesellschaftliche Normen der Realit‰t Schritt halten, wenn Innovationen in Lichtgeschwindigkeit voranschreiten?   Zuk¸nftig wird es von entscheidender Bedeutung sein, einen Dialog zwischen Technologieanwendern, Juristen, der Zivilgesellschaft und Ethikern zu initialisieren, um die Balance zwischen Sicherheit und Privatsph‰re neu zu definieren. Es gilt herauszufinden, wie die verantwortungsvolle Nutzung von Technologien gew‰hrleistet und gleichzeitig die Gefahren einer allumfassenden ‹berwachung wie der Verlust des gesellschaftlichen Friedens und das Entstehen von Diskriminierungen abgewehrt werden kˆnnen.  Angesichts weltweiter Trends hin zu immer stark virtuellen Communities und der fortw‰hrenden Suche nach angeschlossenem Wohlergehen wird unser n‰chster Schritt auch die soziokulturellen Dimensionen der ""Zero""-Philosophie einschlieﬂen m¸ssen. Eine Multi-Stakeholder-Perspektive wasserdicht zu entwickeln, ist unerl‰sslich, um angemessene Handelsspielr‰ume und wirksame Kontrollmechanismen zu schaffen. Nur so kˆnnen wir das Potenzial der digitalen ‹berwachung wirklich nutzen und gleichzeitig der Jagd nach Verarbeitung und Analyse innerhalb einer Roboter-Persistenz Entgegensetzungen mit gelebter Kritik loswerden.  Insgesamt l‰dt der Ausblick auf die Zukunft der digitalen ‹berwachung dazu ein, tiefgreifende ethische Fragestellungen zu reflektieren und Strategien zur Minderung der Risiken zu entwickeln. Der Umgang mit ""Zero"" benˆtigt eine sorgf‰ltige Abw‰gung der Chancen und Gefahren, gleichwohl erkennen wir im Spannungsfeld zwischen Innovation und Integrit‰t einen Impuls zur Neudefinition unserer gesellschaftlichen Werte und Standards. Bis wir diesen Dialog erfolgreicher und nachhaltiger f¸hren kˆnnen, bleibt das Verh‰ltnis zur";1
"  Die vorliegende Analyse besch‰ftigt sich mit der Entwicklung eines Aufgabenmanagement-Tools, das speziell auf die Bed¸rfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist. In der heutigen Zeit, in der Softwareprojekte zunehmend komplexer und interdisziplin‰rer werden, ist die effiziente Organisation von Aufgaben und die Koordination im Team unerl‰sslich. Ein solches Tool soll nicht nur die Verwaltung von Aufgaben erleichtern, sondern auch die Zusammenarbeit und Kommunikation innerhalb von Projektgruppen fˆrdern. Um die Anforderungen an ein solches System systematisch zu erfassen, ist eine fundierte Anforderungsanalyse notwendig.   1.  der Anforderungsanalyse  Die Anforderungsanalyse ist ein zentraler Bestandteil des Softwareentwicklungsprozesses und stellt sicher, dass die entwickelten Systeme den Bed¸rfnissen der Benutzer entsprechen. Laut Sommerville (2016) umfasst die Anforderungsanalyse die Erhebung, Dokumentation und Validierung von Anforderungen. Diese Anforderungen kˆnnen sowohl funktionale als auch nicht-funktionale Aspekte umfassen. Funktionale Anforderungen definieren, was das System tun soll, w‰hrend nicht-funktionale Anforderungen Qualit‰tsmerkmale wie Usability, Performance oder Sicherheit beschreiben.   1.1. Funktionale Anforderungen  Im Kontext eines Aufgabenmanagement-Tools f¸r Studierende im Software Engineering lassen sich verschiedene funktionale Anforderungen identifizieren - AufgabenverwaltungDie Nutzer sollten in der Lage sein, Aufgaben zu erstellen, zu bearbeiten und zu lˆschen. Jede Aufgabe sollte eine Beschreibung, ein F‰lligkeitsdatum und einen Status (z. B. ""offen"", ""in Bearbeitung"", ""abgeschlossen"") besitzen.    - Zuweisung von AufgabenDas Tool sollte es ermˆglichen, Aufgaben einzelnen Teammitgliedern zuzuweisen, um Verantwortlichkeiten klar zu definieren.    - Priorisierung von AufgabenEine Funktion zur Priorisierung von Aufgaben ist essenziell, um den Studierenden zu helfen, sich auf die wichtigsten Aufgaben zu konzentrieren.  - Projekt¸bersichtEine ‹bersicht ¸ber alle laufenden Projekte und deren Status sollte bereitgestellt werden, um den Fortschritt auf einen Blick zu erfassen.  - KommunikationsfunktionenIntegrierte Kommunikationsmˆglichkeiten, wie z. B. Kommentare zu Aufgaben oder ein Diskussionsforum, fˆrdern den Austausch innerhalb des Teams.   1.2. Nicht-funktionale Anforderungen  Neben den funktionalen Anforderungen sind auch nicht-funktionale Anforderungen von groﬂer Bedeutung. Diese kˆnnen folgende Aspekte umfassen - UsabilityDas Tool sollte intuitiv und benutzerfreundlich gestaltet sein, um eine schnelle Einarbeitung der Studierenden zu gew‰hrleisten. Eine klare und ansprechende Benutzeroberfl‰che ist hierbei von zentraler Bedeutung.  - Zuverl‰ssigkeitDas System muss stabil und zuverl‰ssig arbeiten, um Datenverlust oder Fehler in der Aufgabenverwaltung zu vermeiden. Regelm‰ﬂige Backups und eine robuste Fehlerbehandlung sind unerl‰sslich.  - PerformanceBei der Nutzung des Tools sollte die Performance auch bei einer hohen Anzahl von Aufgaben und Nutzern gew‰hrleistet sein.  - SicherheitDer Schutz sensibler Daten ist von groﬂer Bedeutung. Das Tool sollte daher angemessene Sicherheitsmaﬂnahmen implementieren, um unbefugten Zugriff zu verhindern.   ";1
DasDigiXbee-÷kosystembietetverschiedeneFunkmodulezumErmˆglichenvondrahtlosen Verbindungen an. Dabei werden unter anderem LTE,Bluetooth, zigbee,IEEE 802.15.4 , DigiMesh undWiFiunterst¸tzt. In dieser Arbeit wird das Digi Xbee 3 Zigbee 3 RF Module1verwendet, dass ¸ber serielle SchnittsstellenviaUniversalAsynchronousReceiver-Transmitter(UART),SerialPeripheral Interface (SPI) und Inter-Integrated Circuit (I2C) verf¸gt (siehe Abildung 2.3). Dieses Modul l‰sst sich in MicroPpython programmieren und unterst¸tzt verschiedene Protokolle wie Zigbee und IEEE 802.15.4.ZurKonfigurationkanndieSoftware Digi XCTU2verwendet werden. Dabei werden verschiedene Modi unterst¸tzt. Es existieren der Transparent opearting mode , derAPI operating mode, der Command mode, der Idle mode, derTransmit mode und derreceive mode (siehe Tabelle 2.1, vgl. ).;0
In der von Simeon Kohlberger eingereichten Magisterarbeit wurde ein bestehendes   Softwaresystem untersucht, die bestehende Funktionalit‰t isoliert, bestehende Softwares  verglichen und anschlieﬂend eine Software entwickelt. Hierbei wurde  zwangsl‰ufig eine konkrete Architektur festgelegt.   Die darin gew‰hlte Architektur entspricht nicht zwangsl‰ufig dem aktuellen Stand der Technik.  In der Zwischenzeit sind neue Programmiersprachen und neue Frameworksents tanden,  sodass eine Webanwendung heutzutage mit vielen verschiedenen Frameworks und  Programmiersprachen umgesetzt werden kann. Die Auswahl einer zu dem Anwendungsfall  passenden Architektur ist also keine triviale Aufgabe mehr.  In dieser Studienarbeit wird deswegen keine Architektur festgelegt. ƒhnlich wie in der eben  erw‰hnten Magisterarbeit werden zun‰chst bestehende Softwares untersucht . Hierf¸r  kommen die Softwares Ñ Azure DevOps Services ì von Microsoft, ÑJira Softwareì von Atlassian,  ÑTrelloì von Atlassian und ÑOpenProjectì von ÑOpenProjectì zum Ein satz. F¸r Ñ Azure DevOps  Servicesì wird eine bereits im akademischen Kontext verwendete Instanz verwendet, bei ÑJira  Softwareì und ÑTrelloì die vorhandenen kostenlosen Lizenzmodelle  beansprucht und bei  ÑOpenProjectì eine lokal installierte Instanz verwendet, da diese ohne Lizenzkosten betrieben  werden darf.  Anschlieﬂend wird der Funktionsumfang der Softwares zusammengefasst und die  Lizenzkosten f¸r die einzelnen Softwares ermittelt. Im Anschluss wird aus allen  Funktionalit‰ten der vier Softwares eine Mindestfunktionalit‰t bestimmt und versucht, den  Aufwand f¸r dessen Umsetzung mithilfe der Function-Point-Analyse zu sch‰tzen. Zum Schluss  wird entschieden, ob eine bestehende Software zu einem vertretbaren Preis die Funktionalit‰t  erf¸llt, oder die Eigenentwicklung empfehlenswerter ist.;0
Ausblick  Die vorliegende Arbeit hat sich mit dem Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps f¸r den humanoiden Roboter Pepper besch‰ftigt. Durch die Integration eines benutzerfreundlichen CMS wird es Entwicklern und Nicht-Entwicklern gleichermaﬂen ermˆglicht, interaktive und anpassbare Anwendungen f¸r Pepper zu erstellen, die dessen Funktionalit‰t erweitern und die Interaktion mit Nutzern verbessern.   Im Ausblick auf zuk¸nftige Entwicklungen und Forschungsmˆglichkeiten ergeben sich zahlreiche interessante Perspektiven. Zun‰chst kˆnnte die Implementierung von KI-gest¸tzten Funktionen in das CMS angestrebt werden. Hierbei w¸rden maschinelles Lernen und nat¸rliche Sprachverarbeitung genutzt, um die Interaktionen zwischen Mensch und Roboter zu optimieren. Eine solche Erweiterung kˆnnte es ermˆglichen, dass Pepper personalisierte Antworten gibt und sich an die Vorlieben und Bed¸rfnisse der Nutzer anpasst.  Ein weiterer Aspekt, der in zuk¸nftigen Arbeiten vertieft werden kˆnnte, ist die Erweiterung des CMS um eine modulare Architektur. Dies w¸rde es Entwicklern ermˆglichen, bestehende Module zu kombinieren und anzupassen, um spezifische Anwendungen f¸r unterschiedliche Einsatzszenarien zu schaffen ñ sei es in der Bildung, im Gesundheitswesen oder im Einzelhandel. Eine solche Flexibilit‰t kˆnnte die Akzeptanz und den Einsatz von Pepper in verschiedenen Branchen erheblich steigern.  Dar¸ber hinaus ist die internationale Zusammenarbeit von zentraler Bedeutung, um ein breiteres Spektrum an Anwendungsf‰llen und kulturellen Kontexten zu ber¸cksichtigen. Die Entwicklung eines mehrsprachigen CMS kˆnnte dazu beitragen, die Zug‰nglichkeit und Benutzerfreundlichkeit f¸r ein globales Publikum zu erhˆhen und somit das Potenzial von Pepper als interaktiven Roboter zu maximieren.  Abschlieﬂend l‰sst sich festhalten, dass die Schaffung eines CMS f¸r Android Apps auf Pepper nicht nur technische Herausforderungen mit sich bringt, sondern auch das Potenzial hat, die Art und Weise, wie Menschen mit Robotern interagieren, grundlegend zu ver‰ndern. Die vorliegenden Ergebnisse bilden eine solide Grundlage f¸r weitere Forschungen und Entwicklungen, die es ermˆglichen, die Mˆglichkeiten humanoider Roboter in der Gesellschaft weiter zu explorieren und zu erweitern.;1
"4 LoRaWAN Nodes
In diesem Kapitel werden alle relevanten Aspekte der im Rahmen der Studienarbeit ver-
wendeten und entwickelten LoRaNodes beschrieben. Dieses Kapitel umfasst somit eine
Beschreibung der verwendeten Hardware, die Programmierung der Nodes als auch die
Speicherung und Visualisierung der durch die Nodes gemessenen Werte zur Bodenfeuchtig-
keit.
4.1 ‹bersicht ¸ber die verwendete Hardware
An dieser Stelle wird die zu Beginn des Projektes vom FabLab der DHBW Heiden-
heim erhaltene Hardware beschrieben. Diese Hardware war bereits aus vorausgegangenen
Studentenprojekten zum Thema LoRaWAN vorhanden. Es wurde daher ohne weitere
‹berlegungen versucht, diese im Rahmen dieser Studienarbeit einzusetzen.
Feather M0 mit RFM95 Modul
Die Basis f¸r einen LoRaNode stellt in der Regel ein Microcontroller dar. Beim vom
FabLab der DHBW ausgegebenen Microcontroller handelt es sich um ein Board der
Feather-Familie des Herstellers Adafruit. Die Feather-Familie umfasst viele Feather Boards,
die unterschiedlichste Chips‰tze verbaut haben. So sind beispielsweise Feather Boards
verf¸gbar, die einen ATmega328P1Chipsatz verbaut haben, es werden aber auch Boards
mit ATmega32u4, ATSAMD21 (M0) oder ATSAMD51 (M4) Chips‰tzen angeboten.
Einige Feather Boards haben neben einem Microcontroller zus‰tzlich Funkmodule f¸r die
Kommunikation via Bluetooth, WiFi, LoRa, ...verbaut. 
Das im Rahmen der Studienarbeit verwendete Feather M0 RFM95 Board (siehe Ab-
bildung 4.1) hat einen ATSAMD21G18 ARM Cortex M0 Chipsatz verbaut (daher der
NameFeather M0 ). Zudem verf¸gt dieses Feather Board von Haus aus ¸ber ein RFM95
Funkmodul, welches f¸r das Senden und Empfangen von Daten via LoRaim 868 MHz
Frequenzbereich verwendet werden kann. 
Sparkfun Bodenfeuchtigkeitssensor
F¸r das Messen der Bodenfeuchtigkeit wurde von der DHBW ein Bodenfeuchtigkeitssen-
sor der Firma Sparkfun ausgegeben. Bodenfeuchtigkeitssensoren dieses Bautyps sorgen
jedoch f¸r diverse Probleme, weshalb der Sparkfun Sensor im Verlauf der Arbeit durch
einen kapazitiven Bodenfeuchtigkeitssensor ersetzt wurde. Mehr Details dazu sp‰ter in
Abschnitt 4.8.";0
TitelEin Konzept zur Umsetzung von Java und Kotlin in der modernen Softwareentwicklung    In der Welt der Softwareentwicklung haben sich Java und Kotlin als zwei der prominentesten Programmiersprachen etabliert, insbesondere im Kontext der Android-Entwicklung. W‰hrend Java seit den 1990er Jahren als eine der Hauptsprachen f¸r die Entwicklung plattform¸bergreifender Anwendungen gilt, hat Kotlin in den letzten Jahren an Popularit‰t gewonnen, insbesondere nachdem Google es 2017 zur bevorzugten Sprache f¸r Android-Entwicklung erkl‰rte. Dieser Prosatext zielt darauf ab, ein Konzept zur Umsetzung beider Sprachen in einem Softwareprojekt zu entwickeln, wobei die St‰rken und Schw‰chen beider Sprachen ber¸cksichtigt werden.  1. Analyse der Programmiersprachen  Um ein fundiertes Konzept zu entwickeln, ist eine detaillierte Analyse der beiden Programmiersprachen erforderlich.   1.1 Java  Java ist eine objektorientierte Programmiersprache, die f¸r ihre Plattformunabh‰ngigkeit bekannt ist. Die Verwendung der Java Virtual Machine (JVM) ermˆglicht es, Java-Anwendungen auf verschiedenen Plattformen auszuf¸hren. Zu den St‰rken von Java z‰hlen - Reife und Stabilit‰tJava hat eine lange Geschichte und wird in vielen groﬂen Unternehmen eingesetzt. - Umfangreiche BibliothekenDie riesige Anzahl an verf¸gbaren Bibliotheken und Frameworks erleichtert die Entwicklung. - Community und SupportEine groﬂe Entwicklergemeinschaft bietet Unterst¸tzung und Ressourcen.  Jedoch gibt es auch Schw‰chen - Verbesserungsbedarf in der SyntaxJava ist bekannt f¸r seine umfangreiche und manchmal umst‰ndliche Syntax, die die Produktivit‰t der Entwickler beeintr‰chtigen kann. - Verbesserte Funktionalit‰tenNeuere Sprachfeatures, die in anderen Sprachen wie Kotlin vorhanden sind, fehlen in Java.  1.2 Kotlin  Kotlin ist eine moderne Programmiersprache, die auf Interoperabilit‰t mit Java abzielt. Sie bietet eine Vielzahl von Funktionen, die die Entwicklung effizienter gestalten - K¸rzere und pr‰gnantere SyntaxKotlin ermˆglicht eine kompaktere und lesbarere Codebasis. - Null-SicherheitKotlin bietet eingebaute Null-Sicherheit, was die Anzahl der NullPointerExceptions erheblich reduziert. - Funktionale Programmierans‰tzeKotlin unterst¸tzt funktionale Programmierparadigmen, was die Flexibilit‰t erhˆht.  Dennoch gibt es auch Herausforderungen - LernkurveEntwickler, die aus der Java-Welt kommen, m¸ssen sich an die neuen Konzepte gewˆhnen. - Eingeschr‰nkte Bibliotheksunterst¸tzungObwohl Kotlin mit Java interoperabel ist, sind nicht alle Java-Bibliotheken optimal f¸r Kotlin ausgelegt.  2. Konzept zur Umsetzung  Das Konzept zur Integration von Java und Kotlin in einem Softwareprojekt sollte mehrere Schl¸sselkomponenten umfassen 2.1 Projektstruktur und Modularit‰t  Ein modularer Ansatz ist entscheidend. Das Projekt sollte in verschiedene Module unterteilt werden, wobei Java f¸r bestehende, stabilere Komponenten und Kotlin f¸r neue, innovative Funktionen verwendet wird. Dies ermˆglicht eine schrittweise Migration und die Nutzung der Vorteile beider Sprachen.  2.2 Interoperabilit‰t nutzen  Die Interoperabilit‰t zwischen Java;1
Zero - Mˆglichkeiten und Gefahren der digitalen ‹berwachungEin Konzept zur Umsetzung    In der heutigen digitalen ƒra, in der technologische Innovationen rasant voranschreiten, stellt die digitale ‹berwachung sowohl eine bedeutende Chance als auch eine ernsthafte Bedrohung dar. Die F‰higkeit, Daten in Echtzeit zu erfassen, zu analysieren und zu verarbeiten, hat das Potenzial, gesellschaftliche Strukturen zu transformieren. Gleichzeitig wirft die damit verbundene ‹berwachung ethische, rechtliche und soziale Fragen auf. Das vorliegende Konzept zielt darauf ab, die Mˆglichkeiten und Gefahren der digitalen ‹berwachung zu beleuchten und einen Rahmen f¸r deren verantwortungsvolle Umsetzung zu entwickeln.  Mˆglichkeiten der digitalen ‹berwachung  Die digitale ‹berwachung bietet zahlreiche Vorteile, die in verschiedenen Bereichen Anwendung finden kˆnnen 1. SicherheitsoptimierungDurch den Einsatz von ‹berwachungstechnologien, wie Kameras und Sensoren, kˆnnen Sicherheitskr‰fte potenzielle Bedrohungen schneller identifizieren und darauf reagieren. Dies kann insbesondere in st‰dtischen Gebieten und ˆffentlichen Verkehrsmitteln von Vorteil sein.  2. Datenanalyse und -verarbeitungBig Data und K¸nstliche Intelligenz ermˆglichen die Analyse groﬂer Datenmengen, um Muster und Trends zu erkennen. Diese Erkenntnisse kˆnnen zur Verbesserung von Dienstleistungen, zur Optimierung von Verkehrsfl¸ssen oder zur Vorhersage von Verbrechen genutzt werden.  3. Gesundheits¸berwachungIn der Medizin kann digitale ‹berwachung zur fr¸hzeitigen Erkennung von Krankheiten und zur ‹berwachung von Patienten eingesetzt werden. Wearables und Telemedizin ermˆglichen eine kontinuierliche Gesundheits¸berwachung, die zu besseren Behandlungsergebnissen f¸hren kann.  Gefahren der digitalen ‹berwachung  Trotz der genannten Mˆglichkeiten birgt die digitale ‹berwachung auch erhebliche Risiken 1. Einschr‰nkung der Privatsph‰reDie allgegenw‰rtige ‹berwachung kann zu einem Verlust der Privatsph‰re f¸hren. Individuen kˆnnten sich in ihrem Verhalten eingeschr‰nkt f¸hlen, was zu einem Klima der Selbstzensur f¸hrt.  2. Missbrauch von DatenDie Erfassung und Speicherung persˆnlicher Daten kann zu deren Missbrauch f¸hren. Cyberkriminalit‰t und Datenlecks sind ernsthafte Bedrohungen, die das Vertrauen in digitale Systeme untergraben.  3. Diskriminierung und VorurteileAlgorithmen zur Datenanalyse sind nicht immer neutral. Vorurteile in den zugrunde liegenden Daten kˆnnen zu diskriminierenden Entscheidungen f¸hren, sei es in der Strafverfolgung oder in der Personalbeschaffung.  Konzept zur Umsetzung  Um die Mˆglichkeiten der digitalen ‹berwachung zu nutzen und gleichzeitig die damit verbundenen Gefahren zu minimieren, wird ein mehrstufiges Konzept vorgeschlagen 1. Transparente RichtlinienDie Entwicklung klarer, transparenter Richtlinien f¸r die digitale ‹berwachung ist entscheidend. Diese sollten festlegen, welche Daten erfasst werden, zu welchem Zweck und wie lange sie gespeichert werden. B¸rger sollten ¸ber ihre Rechte informiert werden.  2. Technologische Standards und EthikDie Implementierung von Technologien sollte an ethische Standards gebunden sein. Dies beinhaltet die Entwicklung von Algorithmen, die auf Fairness und Nicht-Diskriminierung ausgelegt sind. Unabh‰ng;1
Intern erstellt der Codegenerierungstask hierf¸r innerhalb der DetailScreenDestinati- on zahlreiche Funktionen, die das Co?ee-Objekt serialisieren, zur Route hinzuf¸gen, auf Nullability pr¸fen und schlieﬂlich wieder rekonstruieren. Zudem wird hierdurch ein weiterer Vorteil der Bibliothek illustriert: Da die APIs genau wissen, welchen Typ von Route sie benˆtigen, kann Typensicherheit geboten und garantiert werden. ïDer klassische NavController wird ersetzt durch einen DestinationsNavigator . Dieser arbeitet mit den erzeugten Destinations und ¸bernimmt somit die urspr¸ngliche Aufgabe des NavControllers. Der groﬂe Unterschied hierbei liegt darin, dass die- ser nicht vom Entwickelnden selbst implementiert und gep?egt werden muss. Das ¸bernimmt die Bibliothek. Zur Verwendung muss dieser nur in der MainActivity der Anwendung mit dem Wert des Attributes rootdes in Abbildung 3.5 darge- stellten NavGraphs-Objektes aufgerufen werden. ƒnderungen, die die anzuzeigende Destination betre?en, kˆnnen ¸ber den Aufruf der Funktion navigate() des Destina- tionsNavigators durchgef¸hrt werden. Hierbei wird immer die generierte Destination ¸bergeben, die verwendet werden soll.;0
 Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem The Things NetworkEin Ausblick auf mˆgliche Weiterentwicklungen  Die ‹berwachung der Bodenfeuchtigkeit ist von entscheidender Bedeutung f¸r die Landwirtschaft, das Umweltmanagement und die Forschung. Mit dem Aufkommen von Low Power Wide Area Networks (LPWAN) wie LoRaWAN (Long Range Wide Area Network) und Plattformen wie The Things Network (TTN) erˆffnen sich neue Mˆglichkeiten f¸r die pr‰zise und kosteneffiziente Erfassung von Bodendaten in Echtzeit. Diese Technologien ermˆglichen eine fl‰chendeckende und nahezu georeferierte Sensorik, die nicht nur zur Optimierung von Bew‰sserungsstrategien beitr‰gt, sondern auch bei der Analyse klimatischer Entwicklungen und der nachhaltigen Landnutzung von Bedeutung ist.   Aktueller Stand der Technik  LoRaWAN zeichnet sich durch seine lange Reichweite und niedrigen Energieverbrauch aus, was es zu einer idealen Lˆsung f¸r die Landwirtschaft macht, wo Sensoren oft an abgelegenen Orten installiert werden. Mit der Integration von TTN als offenes Netzwerk, das es Nutzern ermˆglicht, ihre Sensoren unkompliziert anzubinden, entf‰llt die Notwendigkeit, eine eigene Infrastruktur aufzubauen. Sensoren f¸r die Bodenfeuchtigkeit sind mittlerweile weit verbreitet und kˆnnen Daten wie Wassergehalt, Temperatur und pH-Wert in Echtzeit erfassen. Diese Daten werden ¸ber LoRaWAN an Gateway-Stationen ¸bertragen und im TTN konvergiert, wo sie analysiert und bereitgestellt werden kˆnnen.   Mˆgliche Weiterentwicklungen  Die Zukunft der Bodenfeuchtigkeits¸berwachung mittels LoRaWAN und TTN bietet ein Vielzahl von Entwicklungsperspektiven. Zun‰chst kˆnnte die Sensortechnologie weiter optimiert werden. Die Entwicklung von hochsensiblen und kosteneffizienten Sensoren w¸rde nicht nur die Genauigkeit der Messungen erhˆhen, sondern auch eine breitere Akzeptanz unter Landwirten und Umweltforschern fˆrdern. Langfristig kˆnnten flexible und modulare Sensorkonzepte entstehen, die eine einfache Anpassung der Messtechnik an unterschiedliche Umgebungsbedingungen ermˆglichen.  Ein weiterer Aspekt ist die Integration von KI-gest¸tzten Analysealgorithmen, die auf den erfassten Daten basieren. Mithilfe von maschinellem Lernen kˆnnten historische Daten ¸ber Bodenfeuchtigkeit, Wetterbedingungen und Pflanzenwachstum miteinander verkn¸pft werden, um pr‰zise Vorhersagen f¸r Bew‰sserungsbedarf und Erntezeitpunkte zu treffen. Dies kˆnnte nicht nur die Effizienz der Ressourcenverwendung verbessern, sondern auch den Ertrag steigernd wirken.  Des Weiteren besteht eine bedeutsame Potenzial zur Verbesserung der Datenerfassung und -kommunikation. Die Verkn¸pfung von LoRaWAN mit anderen Kommunikationsprotokollen wie NB-IoT (Narrowband IoT) kˆnnte die betrieblichen Mˆglichkeiten erweitern und die Daten¸bertragung in Gebieten mit schwachem Empfang verbessern. Ein solcher hybrider Ansatz kˆnnte eine redundante Kommunikation sicherstellen, die gerade in landwirtschaftlich genutzten, aber infrastrukturell schwach ausgepr‰gten Regionen wichtig ist.  Ein Aspekt, der in Zukunft ebenfalls an Bedeutung gewinnen kˆnnte, ist die Entwicklung von offenen Plattformen f¸r die Datennutzung. Der Austausch und die Nutzung von Daten im Rahmen von Agrarˆkosystemen kˆnnten nicht nur das Wissen um regionale Gegebenheiten erweitern, sondern auch zur Schaffung von Best Practices in der agrarischen Produktion beitragen. Community-basierte Ans‰tze kˆnnten die Zusammenarbeit zwischen Landwirten, Forschern und Technologieanbietern fˆrdern und dazu beitragen, Probleme der zuk¸nftigen Nahrungsmittelversorgung nachhaltig zu adressieren.   Fazit  Insgesamt bietet das Tracking der Bodenfeuchtigkeit mit LoRaWAN und dem TTN nicht nur gegenw‰rtig wertvolle Einblicke f¸r die Landwirtschaft und ˆkologische Studien, sondern birgt auch ein hohes Innovationspotenzial. Durch technologische Fortschritte in den Bereichen Sensortechnologie, Datenanalyse, Kommunikationsprotokolle und offene Datenplattformen kˆnnte die Bodenfeuchtigkeits¸berwachung nicht nur revolutioniert, sondern auch entscheidend zur Verbesserung der nachhaltigen Landwirtschaft und des Umweltmanagements beitragen. In einer Zeit, in der Klimawandel und Ressourcenknappheit zunehmend im Fokus stehen, sind solche Entwicklungen von zentraler Bedeutung f¸r die zuk¸nftige Nahrungsmittelproduktion und den verantwortungsvollen Umgang mit unseren nat¸rlichen Ressourcen.;1
Konzept f¸r eine wissenschaftliche Arbeit: Optimierung der Visualisierung, Bedienung und Selbstregelung eines um Elektronik erweiterten Luftreinigungsger‰tes  Einleitung  In Zeiten zunehmender Luftverschmutzung und gesundheitlicher Probleme, die mit einer schlechten Raumluftqualit‰t einhergehen, gewinnt die Entwicklung effektiver Luftreinigungsger‰te zunehmend an Bedeutung. Die vorliegende Arbeit widmet sich der Optimierung eines modernen Luftreinigungsger‰tes, das durch elektronische Komponenten erweitert wurde. Ziel ist es, die Visualisierung der Betriebsparameter, die Benutzerfreundlichkeit der Bedienoberfl‰che sowie die Effizienz der Selbstregelungsmechanismen zu verbessern.   Problemstellung  Trotz der technologischen Fortschritte in der Luftreinigungstechnik sind viele der derzeit verf¸gbaren Ger‰te in ihrer Benutzerfreundlichkeit und Effizienz limitiert. H‰ufig mangelt es an intuitiven Bedienoberfl‰chen, die den Nutzern eine einfache Interaktion ermˆglichen. Dar¸ber hinaus sind die Visualisierung der Luftqualit‰tsdaten und die Selbstregelungsfunktionen oft nicht ausreichend optimiert, was zu einer suboptimalen Nutzung des Ger‰tes f¸hrt.   Ziele der Arbeit  Die Arbeit verfolgt mehrere spezifische Ziele:  1. Analyse der bestehenden Systeme: Untersuchung der aktuellen Luftreinigungsger‰te hinsichtlich ihrer Visualisierungs- und Bedienkonzepte sowie der Selbstregelungsmechanismen.     2. Entwicklung eines benutzerfreundlichen Interfaces: Gestaltung eines intuitiven Bedienkonzepts, das den Nutzern eine einfache und schnelle Interaktion mit dem Ger‰t ermˆglicht.  3. Optimierung der Visualisierung: Implementierung eines ansprechenden und informativen Displays, das relevante Daten zur Luftqualit‰t, Betriebsmodi und Filterstatus in Echtzeit anzeigt.  4. Verbesserung der Selbstregelung: Entwicklung von Algorithmen, die es dem Ger‰t ermˆglichen, autonom auf Ver‰nderungen der Luftqualit‰t zu reagieren und die Betriebsparameter entsprechend anzupassen.  Methodik  Die Methodik umfasst sowohl qualitative als auch quantitative Ans‰tze:  - Literaturrecherche: Analyse bestehender wissenschaftlicher Arbeiten und Marktanalysen zu Luftreinigungsger‰ten und deren Bedienkonzepten.    - Befragungen und Usability-Tests: Durchf¸hrung von Nutzerbefragungen, um die Anforderungen und W¸nsche der Endverbraucher zu ermitteln. Usability-Tests zur Evaluierung der neuen Bedienoberfl‰che.  - Prototyping und Tests: Entwicklung eines Prototyps des optimierten Ger‰tes, gefolgt von Tests zur Evaluierung der Funktionalit‰t der Selbstregelungsmechanismen und der Benutzerfreundlichkeit.  Erwartete Ergebnisse  Die Arbeit erwartet, dass durch die Optimierung der Visualisierung und Bedienung sowie der Selbstregelung die Benutzerzufriedenheit erhˆht und die Effizienz des Luftreinigungsger‰tes gesteigert werden kann. Ein benutzerfreundliches Interface und eine verbesserte Selbstregelung sollen zu einer effektiveren Nutzung des Ger‰tes f¸hren, was letztlich zu einer besseren Raumluftqualit‰t beitr‰gt.  Schlussfolgerung  Die vorliegende Arbeit leistet einen Beitrag zur Weiterentwicklung von Luftreinigungsger‰ten, indem sie innovative Ans‰tze zur Optimierung der Benutzererfahrung und der automatisierten Regelung aufzeigt.;1
"3.4.7 Zugri? auf den Gyrosensoren
F¸r das Starten der Messung und das Anzeigen der Gyrosensor Daten wird im Media-
Framgent ein Button sowie Textfelder f¸r die X-,Y- und Z-Achse angelegt. F¸r den
Button wird eine íonClickListenerí angelegt, der die im Listing 3.34 beschriebene Methode
aufruft.
Auf den Gyrosensor kann mithilfe des Sensor Managers zugegri?en werden, der aus dem
Activity Context bezogen wird. ‹ber den Sensor Manager kann der Gyrosensor bezogen
werden. Ferner wird mit dem Sensor Manager ein Listener registriert. F¸r das Registrieren
wird als H‰ndler das Media-Framgent, f¸r den Sensor der bezogene Gyrosensor und
f¸r Abtastzeit eine Sekunde mitgegeben. Damit das Media-Framgent die Events richtig
verarbeiten kann, muss es von der íSensorEventListenerí Klasse erben. Des Weiteren muss
die Methode íonSensorChangedí implementiert werden.
Die íonSensorChangedí Methode wird in dem angegebenen Intervall mit den Daten des
Gyroensors aufgerufen. In der Methode kˆnnen die Sensordaten verarbeitet werden. Nach
der Verarbeitung werden die Daten ¸ber das Binding des Fragments in der Ober?‰che
angezeigt. Durch das beim Listener de?nierte Intervall wird der Wert einmal pro Sekunde
aktualisiert.";0
Vergleich von Progressive Web Apps und nativen Apps am Beispiel einer Journaling-AppEin Ausblick auf mˆgliche Weiterentwicklungen  In der heutigen digitalen Landschaft gewinnen Progressive Web Apps (PWAs) zunehmend an Bedeutung, insbesondere im Vergleich zu traditionellen nativen Anwendungen. Diese Entwicklung ist besonders relevant im Kontext von Journaling-Apps, die eine intuitive Benutzererfahrung bieten und gleichzeitig den Anforderungen der Nutzer an Flexibilit‰t und Zug‰nglichkeit gerecht werden m¸ssen. Der folgende Text untersucht die Vor- und Nachteile von PWAs im Vergleich zu nativen Apps und wagt einen Ausblick auf mˆgliche zuk¸nftige Entwicklungen in diesem Bereich.  PWAs kombinieren die besten Eigenschaften von Web- und nativen Apps. Sie sind ¸ber einen Webbrowser zug‰nglich, bieten jedoch Funktionen wie Offline-Nutzung, Push-Benachrichtigungen und eine App-‰hnliche Benutzeroberfl‰che. Im Gegensatz dazu sind native Apps spezifisch f¸r ein Betriebssystem (iOS oder Android) entwickelt und kˆnnen tiefere Integrationen in die Hardware des Ger‰ts bieten, wie etwa den Zugriff auf die Kamera oder GPS-Dienste. Diese Unterschiede sind entscheidend, wenn man die Benutzererfahrung und die Funktionalit‰t einer Journaling-App betrachtet.  Ein wesentliches Argument f¸r PWAs ist ihre Plattformunabh‰ngigkeit. Nutzer kˆnnen eine Journaling-App auf verschiedenen Ger‰ten und Betriebssystemen verwenden, ohne zus‰tzliche Installationen vornehmen zu m¸ssen. Dies fˆrdert die Zug‰nglichkeit und ermˆglicht es Entwicklern, ein breiteres Publikum zu erreichen. Native Apps hingegen erfordern separate Entwicklungszyklen f¸r verschiedene Plattformen, was den Aufwand und die Kosten erhˆht. Dennoch bieten native Apps in der Regel eine bessere Leistung und tiefere Integration in die Ger‰teeinstellungen, was f¸r einige Nutzergruppen von entscheidender Bedeutung sein kann.  Im Hinblick auf die Benutzererfahrung bieten PWAs einige Vorteile, insbesondere durch ihre F‰higkeit, schnell zu laden und nahtlos zwischen Online- und Offline-Modi zu wechseln. Dies ist besonders relevant f¸r Journaling-Apps, bei denen Nutzer mˆglicherweise auch in Umgebungen mit eingeschr‰nkter Internetverbindung arbeiten mˆchten. Die Mˆglichkeit, Inhalte automatisch zu synchronisieren, sobald eine Verbindung besteht, kann die Benutzererfahrung erheblich verbessern. Native Apps hingegen profitieren von der Nutzung der Ger‰teleistung und kˆnnen umfassendere Funktionen anbieten, wie beispielsweise die Verwendung von biometrischen Anmeldungen oder die Integration in andere native Dienste.  Ein weiterer Aspekt, der in die Diskussion einflieﬂt, ist die Sicherheit. PWAs sind in der Regel sicherer als herkˆmmliche Webanwendungen, da sie ¸ber HTTPS bereitgestellt werden und strenge Sicherheitsprotokolle befolgen m¸ssen. Native Apps hingegen kˆnnen anf‰lliger f¸r Sicherheitsl¸cken sein, insbesondere wenn sie nicht regelm‰ﬂig aktualisiert werden. F¸r eine Journaling-App, die sensible persˆnliche Daten speichert, ist dies ein entscheidender Faktor.  In Anbetracht der fortschreitenden technologischen Entwicklungen lassen sich mehrere Trends und mˆgliche Weiterentwicklungen f¸r PWAs und native Apps im Bereich der Journaling-Apps identifizieren. Zun‰chst kˆnnte die Integration von K¸nstlicher Intelligenz (KI) in PWAs eine personalisierte Benutzererfahrung bieten, indem sie den Nutzern hilft, ihre Eintr‰ge zu analysieren und Muster in ihrem Schreibverhalten zu erkennen. Dies kˆnnte durch maschinelles Lernen erreicht werden, das in der Lage ist, die Vor;1
 Grundlagenteil: Aktueller Stand der Technik  Die Entwicklung von Content-Management-Systemen (CMS) hat in den letzten Jahren eine bemerkenswerte Evolution durchlaufen, insbesondere im Kontext der Erstellung von Anwendungen f¸r mobile Ger‰te und interaktive Systeme. Ein zentrales Ziel dieser Systeme ist es, den Nutzern eine benutzerfreundliche Plattform zu bieten, die es ihnen ermˆglicht, Inhalte effizient zu erstellen, zu verwalten und zu verˆffentlichen, ohne tiefgehende Programmierkenntnisse zu benˆtigen. In diesem Kontext gewinnt die Integration von CMS in die Robotik, insbesondere bei humanoiden Robotern wie Pepper, zunehmend an Bedeutung.   Humanoide Roboter und ihre Anwendungen  Pepper, entwickelt von SoftBank Robotics, ist ein humanoider Roboter, der f¸r die Interaktion mit Menschen konzipiert wurde. Er ist in der Lage, Emotionen zu erkennen und darauf zu reagieren, was ihn zu einem idealen Kandidaten f¸r den Einsatz in verschiedenen Bereichen wie Bildung, Gesundheitswesen und Kundenservice macht. Die Programmierung von Anwendungen f¸r Pepper erfolgt in der Regel ¸ber die Naoqi-API, die eine Vielzahl von Funktionen zur Steuerung von Bewegungen, Sprachinteraktionen und Sensorik bietet. Die Herausforderung besteht jedoch darin, dass die Entwicklung von Apps f¸r solche Roboter oft komplex und zeitaufwendig ist, was die Zug‰nglichkeit f¸r nicht-technische Nutzer einschr‰nkt.   Content-Management-Systeme f¸r die Robotik  Die Integration eines CMS zur Erstellung von Apps f¸r Pepper kˆnnte die Barrieren f¸r die Entwicklung von Inhalten erheblich senken. Der aktuelle Stand der Technik in diesem Bereich zeigt, dass es bereits Ans‰tze gibt, die eine visuelle Programmierung oder die Verwendung von Drag-and-Drop-Oberfl‰chen ermˆglichen. Solche Systeme bieten eine intuitive Benutzeroberfl‰che, die es Nutzern ermˆglicht, komplexe Abl‰ufe ohne tiefgehende Programmierkenntnisse zu gestalten. Tools wie Blockly oder Scratch haben in der Bildungsrobotik gezeigt, dass visuelle Programmierung die Lernkurve f¸r neue Benutzer erheblich verk¸rzen kann.  Dar¸ber hinaus gibt es bereits spezialisierte CMS, die sich auf die Entwicklung von Inhalten f¸r mobile Plattformen konzentrieren. Diese Systeme bieten oft vorgefertigte Module und Vorlagen, die es Nutzern ermˆglichen, schnell und effizient Apps zu erstellen. Die Herausforderung besteht darin, diese bestehenden Technologien mit den spezifischen Anforderungen und Funktionen von humanoiden Robotern wie Pepper zu kombinieren.   Aktuelle Entwicklungen und Trends  In den letzten Jahren haben sich auch Technologien wie K¸nstliche Intelligenz (KI) und maschinelles Lernen in der Robotik etabliert. Diese Technologien ermˆglichen es Robotern, aus Interaktionen zu lernen und sich an die Bed¸rfnisse der Nutzer anzupassen. Ein CMS, das diese Technologien integriert, kˆnnte nicht nur die Erstellung von Inhalten vereinfachen, sondern auch die Interaktivit‰t und Anpassungsf‰higkeit der Apps erhˆhen.  Ein weiterer Trend ist die zunehmende Nutzung von Cloud-basierten Lˆsungen, die es ermˆglichen, Anwendungen zentral zu hosten und von verschiedenen Ger‰ten aus darauf zuzugreifen. Dies kˆnnte die Entwicklung und Verwaltung von Apps f¸r Pepper weiter vereinfachen und die Zusammenarbeit zwischen verschiedenen Entwicklern fˆrdern.   Fazit  Zusammenfassend l‰sst sich sagen, dass der aktuelle Stand der Technik im Bereich der CMS und der Robotik vielversprechende Ans‰tze bietet,;1
Anforderungen an die Kollisonsvermeidung: In den Anforderungen wurde spezifiziert, dass die Kollisionsvermeidung Hindernisse rechtzeitig erkennt, so dass es bei Geschwindig- keiten von bis zu 30km/h und einem idealen Bremsweg keine Kollision mit Gegenst‰nden in Fahrtrichtung erfolgen kann. Jedoch sind am Fahrzeug keine Bremsen vorhanden, weswegen der ideale Bremsweg nicht ausgetestet werden kann. Weiterhin existieren einzelne Probleme bei der Erkennung von Hindernissen durch den Ultraschallsensor und die spezifizierte Maximalgeschwindigkeit von 30km/h konnte nicht erreicht werden, weswegen die Anforde- rungen an die Kollisionsvermeidung nicht vollst‰ndig erf¸llt werden. Jedoch existiert am Ende des Projektes eine funktionierende Kollisionsvermeidung im Fahrzeug mit reduzierter Geschwindigkeit und der Abstand, bei dem die Kollisionsvermeidung ausgelˆst wird, ist konfigurierbar. So konnten zwar die Anforderungen nur teilweise umgesetzt werden jedoch auch eine Ausgangsbasis f¸r darauf aufbauende weiterf¸hrende Projekte geschaffen werden (siehe Kapitel 5.7.4). Projektspezifische Anforderungen: Im Rahmen der projektspezifischen Anforderungen wurde festgelegt, dass das entwickelte Protokoll durch den Digi Xbee 3-Microcontroller unterst¸tzt werden muss. Weiterhin wurde bestimmt, dass im Falle einer durchgef¸hrten Kollisionsvermeidung eine Nachricht an der Fernsteuerung angezeigt werden soll und f¸r die verwendete Software und Protokollstacks keine Lizenzkosten anfallen sollen. Hier wurden alle Anforderungen unterst¸tzt, dass das entwickelte Protokoll durch den Digi Xbee 3-Microcontroller unterst¸tzt wird, l‰sst sich in Abschnitt 5.7.4beobachten, wie auch das Anzeigen einer Nachricht an der Fernsteuerung im Falle einer durchgef¸hrten Kollisionsvermeidung.;0
Bei der Betrachtung f‰llt auf, dass sich die Werte stark ver‰ndern, obwohl das Ger‰t nicht bewegt wurde. Gr¸nde f¸r die Abweichungen kˆnnen sowohl die geringe Sendeleistung und die kleinen Antennen als auch ‰uﬂere Einfl¸sse wie beispielsweise Funkwellen reflektierende Objekte sein. Im Rahmen dieser Arbeit kann allerdings keiner dieser Aspekte korrigiert werden. Grund daf¸r sind der hohe Aufwand sowie hˆhere Kosten, welche den grˆﬂten Mehrwert des Konzepts eliminieren w¸rden. Damit der Testdatensatz nicht durch ein fehlerhaftes Ger‰t oder beispielsweise einen leerer werdenden Akku beeinflusst wird, werden die Daten mit drei Locator und drei BLE Ger‰ten gesammelt und somit die Menge der Proben erhˆht. Um besser darstellen zu kˆnnen, wie weit die Messwerte auseinander gehen, wird ein Boxplot ¸ber die RSSIf¸r die einzelnen Ger‰te erstellt.;0
Zudem lassen sich die Systeme dadurch auf sch‰dlichen Programmcode bzw. Code, welcher ungewollte Nutzungsstatistiken versendet, ¸berpr¸ft werden. Ein weiterer Vorteil ergibt sich in der Instandhaltung und Wartung der Systeme. Durch den Gemeinnutzen werden zudem Sicherheitsl¸cken und Performance-Updates regelm‰ﬂig und kostenfrei zur Verf¸gung gestellt.  ïCommunity Ebenfalls der hohen Nutzerzahl geschuldet entstehen rund um OSWCMS zahlreiche Communities, in welchen sich Nutzer bei Frage- und Problemstellungen zusammenfin- den und gegenseitige Ratschl‰ge und Tipps entgegennehmen sowie selbst bereitstellen. Diese Hilfestellung erfolgt durch die Open-Source Charakteristik im Gegensatz zu kommerziellen Lˆsungen kostenfrei.  Im Rahmen dieser Arbeit werden die vier g‰ngigsten Open-Source Web- CMSauf Gemein- samkeiten und Unterschiede sowie Besonderheiten hinsichtlich ihrer Implementierung in Unternehmen, zum Zweck der Erstellung einer Website, untersucht. Das Produktportfolio an Web Content Management Systemen hat einen breit gef‰cherten Markt. Vorzugsweise setzen Unternehmen und Privatanwender hierbei auf Lˆsungen, welche geringe (oder gar keine) Investitionskosten mit sich bringen. HierkristallisiertsichdergroﬂeVorteilvonOpen-Sourcegegen¸berkommerziellenLˆsungen heraus, da diese in der Regel kostenfrei erworben werden kˆnnen. Ferner werden diese Systeme h‰ufig selbst mit Open-Source Webserver-Komponenten betrieben. Ein g‰ngiger Technologie-Stack ist hierbei der sogenannte LAMP-Stack, welcher aus dem Open-Source- Betriebssystem Linux und den f¸r den Betrieb von dynamischen Webseiten notwendigen Open-Source-Programmen Apache-Webserver, MySQL als Datenbanksystem und PHP als dynamische Web-Skriptsprache besteht.;0
Um den abstrakten Begriff der Softwarequalit‰t begreifen, beurteilen und messen zu kˆnnen, wurde   von zahlreichen Vertretern der Softwareentwicklung an der Definition geeigneter Faktoren  gearbeitet. Der Ansatz von Boehm et al. war es, eine Baumstruktur zu erstellen, die alle relevanten  Faktoren und deren Beziehungen abbilden  sollte. Das Ergebnis ihrer Arbeit  kann in Abbildung 9  eingesehen werden .    Eine andere Vorgehensweise verfolgten McCall et al., die zun‰chst ¸bergeordnete Faktoren  definierten. Dazu suchten sie in der Literatur nach Kriterien im Zusammenhang mit Softwarequalit‰t,  um deren H‰ufigkeit zu bestimmen und eine Gruppierung ‰hnlicher Faktoren vorzunehmen.  Durch  dieses Vorgehen leiteten sie elf relevante Faktoren ab, die jeweils durch untergeordnete Kriterien  spezifiziert wurden.  F¸r die Codequalit‰t relevant ist besonders der Faktor Maintainability, der durch  einige Kriterien spezifiziert wird, die dem Bereich der inneren Qualit‰t zugeordnet werden kˆnnen.  Diese  Zusammenh‰nge sind  in Abbildung 10 dargestellt .   Demselben Aufbau wie McCall et al. folgt auch die Norm ISO/IEC 9126 , wie untenstehender  Abbildung entnommen werden kann. Interne und externe Faktoren werden hierbei  zusammengefasst. Bemerkenswert ist der besonders hohe Grad an ‹bereinstimmung mit den von  McCall et al. definierten Faktoren und Subkriterien.    2.1.3 Prinzipien der Objektorientierung   Mit dem Aufkommen der objektorientierten Programmierung wurden weitere Prinzipien eingef¸hrt,  um die Softwarequalit‰t objektorientierter Programme zu steigern. Ein bekannter Vertreter, der  wichtige Arbeit auf diesem Gebiet leistete, zahlreiche Prinzipien der Objektorientierung einf¸hrte  und einige  Werke dar¸ber verˆffentlichte, ist Robert C. Martin. Im Folgenden werden  einige der von  ihm dargestellten Konzepte, die sp‰ter f¸r die Bewertung der Quellcodequalit‰t herangezogen  werden, kurz dargestellt.;0
Ziel dieser Arbeit ist es, zu beantworten, ob bei autonomen Katzenklappen die momentane Standardtechnologie von RFID Chips durch eine Katzenerkennung mithilfe von KI mˆglich und sinnhaft ist. Zur Durchf¸hrung dieses Projekts wird ein Versuchsaufbau besierend auf einemRaspberryPirealisiert,wobeiKatzen¸bereineNachtsichtkameraundDeepLearning erkannt werden. Der Nutzer interagiert mittels einer Android App und Kommunikation ¸ber Google Firebase mit der auf Python basierten Basisstation. Das Ergebnis der Arbeit zeigt, dass die Implementierung auf diese Weise mˆglich und funktional ist, allerdings auch 2022 noch aufwendiger bleibt als eine RFID-basierte Implementierung.;0
 Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung     Die fortschreitende Digitalisierung und die zunehmende Vernetzung von Alltagsgegenst‰nden haben zur Entwicklung innovativer Lˆsungen im Bereich der Heimautomatisierung gef¸hrt. Insbesondere im Tiermanagement erˆffnet das Internet der Dinge (IoT) neue Mˆglichkeiten, um das Leben von Haustieren und deren Haltern zu erleichtern. In diesem Kontext wurde ein IoT-System zur Steuerung einer Katzenklappe entwickelt, das auf einer KI-basierten Katzenerkennung basiert. Ziel des Projekts war es, eine intelligente Lˆsung zu schaffen, die es Katzen ermˆglicht, selbstst‰ndig zwischen Innen- und Auﬂenbereich zu navigieren, w‰hrend gleichzeitig unerw¸nschte Tiere ferngehalten werden.   Systemarchitektur  Das entwickelte System besteht aus mehreren Komponenteneiner automatisierten Katzenklappe, einer Kamera zur Erfassung der Katzenbilder und einem KI-Modell zur Identifikation der Tiere. Die Katzenklappe ist mit einem Motor ausgestattet, der durch ein Steuerungssystem angesteuert wird. Die Kamera erfasst in Echtzeit Bilder von den sich n‰hernden Tieren, die dann zur Analyse an einen zentralen Server gesendet werden. Dort verarbeitet ein vortrainiertes neuronales Netzwerk die Bilder und entscheidet, ob es sich um die eigene Katze oder ein fremdes Tier handelt.   Implementierung der KI-gest¸tzten Katzenerkennung  Die Implementierung des KI-Modells stellte eine der grˆﬂten Herausforderungen des Projekts dar. Um die Erkennungsgenauigkeit zu maximieren, wurde ein Datensatz von Bildern der eigenen Katze sowie von verschiedenen anderen Katzen und Tieren erstellt. Durch den Einsatz von Techniken des maschinellen Lernens, insbesondere Convolutional Neural Networks (CNNs), konnte das Modell trainiert werden, um zwischen der eigenen Katze und anderen Tieren zu unterscheiden. Nach umfassenden Tests erzielte das Modell eine Erkennungsgenauigkeit von ¸ber 95 %, was die Zuverl‰ssigkeit des Systems erheblich steigerte.   Fazit  Die Realisierung des IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung war ein erfolgreiches Unterfangen, das sowohl technologische als auch praktische Herausforderungen meisterte. Die Integration von KI in die Haustierverwaltung hat nicht nur die Funktionalit‰t der Katzenklappe verbessert, sondern auch das Nutzererlebnis f¸r Katzenhalter erheblich optimiert. Die Mˆglichkeit, die Klappe intelligent zu steuern und unerw¸nschte Tiere auszuschlieﬂen, bietet einen klaren Mehrwert.   Zuk¸nftige Entwicklungen kˆnnten darauf abzielen, das System weiter zu verfeinern, indem zus‰tzliche Sensoren integriert werden, um beispielsweise das Wetter oder die Tageszeit zu ber¸cksichtigen. Auch die Erweiterung um weitere Tierarten kˆnnte in Betracht gezogen werden, um ein umfassenderes Smart-Home-Erlebnis zu schaffen. Insgesamt zeigt dieses Projekt, dass die Kombination von IoT und KI das Potenzial hat, den Alltag von Tierhaltern nachhaltig zu verbessern und die Lebensqualit‰t der Tiere zu erhˆhen.;1
In Abbildung 3.13 ist eine Beispielmatrix zu sehen. Jeweils rechtes von jeder Zeile und unter der ersten Spalte sind Buttons, um neue Funktionen hinzuf¸gen zu kˆnnen. Jede Zeile steht dabei f¸r ein Zeitslot. Das heiﬂt, Funktionen die in der zweiten Zeile werden erst ausgef¸hrt, wenn alle Funktionen aus der ersten Zeile ausgef¸hrt wurde. Funktionen die in der selben Zeile sind werden von Pepper gleichzeitig Abgearbeitet. Somit zum Beispiel eine Kombination von der Animation- und Audiofunktion erstellt werden. Pepper f¸hrt dann die Animation aus w‰hrend ein Sound gespielt wird. Beim Hinzuf¸gen einer neuen Funktion bestimmt der Nutzer direkt per Dropdown Men¸ welche Funktion hinzugef¸gt werden soll. Anschlieﬂend kann der Nutzer auf den neu entstandenen Button klicke um Einstellungen an der Funktion vorzunehmen. Dazu ˆ?net sich ein Popup. Klickt der Nutzer in der Navigationsleiste auf ÑSubmenuì klappt ein Men¸, in dem alle Submenus zu sehen sind, auf. Klickt dann der Nutzer auf ein bestehendes Submenu an, klappt ein weiteres Menu mit allen Buttons auf, die im Submenu enthalten sind. Per Klick auf einen Button kann der Nutzer diese einstellen. An den Listen f¸r die Buttons und Submenus ist jeweils ein Button am Ende der Liste um weitere Elemente hinzuzuf¸gen.;0
In dieser Arbeit wurde die Entwicklung eines virtuellen MQTT-Szenarios f¸r Lehrzwecke untersucht, das nicht nur die Grundlagen des MQTT-Protokolls veranschaulicht, sondern auch die Vermittlung praktischer F‰higkeiten in der IoT-Technologie fˆrdert. Durch die Implementierung eines interaktiven und benutzerfreundlichen Systems konnten Studierende in einer simulierten Umgebung Erfahrungen sammeln, die sie auf reale Anwendungen vorbereiten.  Die Analyse der verschiedenen Komponenten des Szenarios zeigt, dass ein solcher Ansatz nicht nur das Verst‰ndnis der theoretischen Konzepte verbessert, sondern auch die Teamarbeit und Problemlˆsungsf‰higkeiten der Lernenden st‰rkt. Die Verwendung von MQTT als Kommunikationstechnik bietet hierbei den Vorteil einer weit verbreiteten und relevanten Technologie, die in vielen modernen Anwendungen der Vernetzung und Automatisierung zum Einsatz kommt.  Die durchgef¸hrte Evaluation hat¸berdies gezeigt, dass das virtuelle Szenario nicht nur die Lernmotivation steigert, sondern auch das kritische Denken anregt, indem es den Sch¸lerinnen und Sch¸lern ermˆglicht, selbst‰ndig Herausforderungen zu bew‰ltigen und kreative Lˆsungen zu entwickeln.   Abschlieﬂend l‰sst sich festhalten, dass die Entwicklung eines virtuellen MQTT-Szenarios f¸r Lehrzwecke ein vielversprechendes Modell darstellt, um das Lernen im Bereich der IoT-Technologien zu revolutionieren. Weitere Forschungsarbeiten kˆnnten sich darauf konzentrieren, die didaktischen Konzepte weiter zu verfeinern und die Integration in bestehende Lehrpl‰ne auszubauen, um eine breitere Zielgruppe zu erreichen. Damit leistet die Arbeit einen wichtigen Beitrag zur Verbesserung der Ausbildung in diesem zukunftstr‰chtigen Bereich.;1
4.7 Clustering Die Positionsdaten wurden dann in die verschiedenen Bereiche aufgeteilt, in welchen sich derBLEBeacon befinden kann. Um dies nicht manuell einteilen zu m¸ssen, wurde K-Means verwendet. So kˆnnen Positionen, welche nah beieinander liegen, jeweils zu einem Cluster beziehungsweise zu einem Bereich zusammengefasst werden.  In einem fr¸heren Entwicklungsschritt wurde versucht, diese Analyse auf die RSSIWerte durchzuf¸hren, dabei fiel allerdings auf, dass diese Werte nicht aussagekr‰ftig genug sind, da sie aufgrund von ‰uﬂeren Einfl¸ssen nicht direkt die Distanz beschreiben. Aus diesem Grund wurde das Konzept verworfen und die Analyse mit den Positionsdaten durchgef¸hrt. Eine Auswertung der Positionsdaten aus Kapitel 4.6 zeigt, dass sich mehrere Bereiche im Raum bilden, in welchen sich der Beacon im Versuchsaufbau aufgehalten hat.;0
Ein weiteres webbasiertes Analysewerkzeug, das zudem ein Open -Source -Tool ist, ist das weit  verbreitete SonarQube. Die Sprachunterst¸tzung ist mit fast 30 verschiedenen Programmiersprachen  sehr umfangreich ebenso wie die Unterst¸tzung zahlreicher Plugins.  Neben der Messung von  Metriken fokussiert sich SonarQube auf die Aufdeckung von Sicherheitsl¸cken im Quellcode.  Daneben werden Qualit‰tsfaktoren bewertet und Code Issues aufgezeigt. Die Verwendung von  SonarQube erfolgt ¸ber die Installation und den Betrieb eines lokalen Servers, ¸ber den die Analysen  ausgef¸hrt und die zugehˆrige Webapplikation genutzt werden kˆnnen.  F¸r Maven -unterst¸tzte  Projekte kˆnnen Scans mit dem Befehl mvn sonar:sonar -Dsonar.login=admin -Dsonar.password= XXX  ausgef¸hrt werden.  F¸r die Sprache C++ muss die Erweiterung Sonar -Scanner installiert werden, um  mit dem Kommando sonar -scanner -Dsonar.login=KEY  eine Analyse durchf¸hren zu kˆnnen.  Da  SonarQube ‰hnliche Funktionalit ‰ten wie Embold zur Verf¸gung stellt, soll es im weiteren Verlauf  auﬂen vorgelassen werden.;0
Aufbau eines Content Management Systems (CMS) zur Erstellung von Android Apps f¸r den humanoiden Roboter Pepper    In der ƒra der intelligenten Robotik gewinnen humanoide Roboter zunehmend an Bedeutung, insbesondere in Bereichen wie Bildung, Gesundheitswesen und Kundenservice. Der humanoide Roboter Pepper, entwickelt von SoftBank Robotics, ist ein Beispiel f¸r einen solchen Roboter, der durch seine Interaktivit‰t und Anpassungsf‰higkeit besticht. Um die Entwicklung von Anwendungen f¸r Pepper zu erleichtern, ist es notwendig, ein Content Management System (CMS) zu implementieren, das es Nutzern ermˆglicht, Android-Apps effizient zu erstellen und zu verwalten. Dieser Text beschreibt den Aufbau eines solchen Systems und beleuchtet die Herausforderungen und Lˆsungen, die w‰hrend des Implementierungsprozesses aufgetreten sind.  Anforderungsanalyse  Die erste Phase beim Aufbau eines CMS besteht in der umfassenden Anforderungsanalyse. Ziel ist es, die Bed¸rfnisse der Endnutzer zu identifizieren, die in der Regel aus Entwicklern, Lehrern und Forschern bestehen. Diese Nutzer benˆtigen eine benutzerfreundliche Oberfl‰che, die es ihnen ermˆglicht, ohne tiefgehende Programmierkenntnisse Anwendungen zu erstellen. Zu den Schl¸sselanforderungen gehˆren 1. BenutzerfreundlichkeitEine intuitive Benutzeroberfl‰che, die Drag-and-Drop-Funktionalit‰ten bietet. 2. Modularit‰tDie Mˆglichkeit, verschiedene Module f¸r spezifische Funktionen (z. B. Spracherkennung, Bewegungssteuerung) zu integrieren. 3. Echtzeit-FeedbackEine Vorschaufunktion, die es Nutzern ermˆglicht, ihre Anwendungen in Echtzeit zu testen. 4. Dokumentation und SupportUmfassende Anleitungen und Unterst¸tzung f¸r die Nutzer.  Architektur des CMS  Die Architektur des CMS kann in mehrere Schichten unterteilt werden 1. FrontendDie Benutzeroberfl‰che, die in HTML5, CSS und JavaScript entwickelt wird. Hier wird ein responsives Design implementiert, um die Nutzung auf verschiedenen Ger‰ten zu ermˆglichen. Frameworks wie React oder Vue.js kˆnnen eingesetzt werden, um die Interaktivit‰t zu erhˆhen.  2. BackendDas Backend wird in einer serverseitigen Sprache wie Python oder Node.js realisiert. Es verwaltet die Datenbank, die alle Anwendungselemente speichert, sowie die Logik zur Verarbeitung von Benutzeranfragen. Eine RESTful API wird eingerichtet, um die Kommunikation zwischen Frontend und Backend zu ermˆglichen.  3. DatenbankEine relationale Datenbank wie PostgreSQL oder MySQL wird verwendet, um die Benutzer- und Anwendungsdaten zu speichern. Die Datenbankarchitektur muss so gestaltet sein, dass sie eine effiziente Abfrage und Speicherung von Anwendungsmodulen unterst¸tzt.  Implementierung der Module  Die Implementierung der Module ist ein zentraler Aspekt des CMS. Jedes Modul sollte eine spezifische Funktionalit‰t bieten, die f¸r die Entwicklung von Android-Apps f¸r Pepper notwendig ist. Beispiele f¸r solche Module sind - SpracherkennungIntegration von Google Speech Recognition zur Verarbeitung von Sprachbefehlen. - BewegungssteuerungEntwicklung eines Moduls, das es ermˆglicht, Bewegungsabl‰ufe f¸r Pepper zu definieren und zu steuern. - Interaktive Dialogsysteme;1
"Konzeption der Software: Entwicklung eines virtuellen MQTT-Szenarios f¸r Lehrzwecke  Einleitung   Die vorliegende Konzeption zielt darauf ab, ein interaktives und ansprechendes Lernumfeld f¸r die Schulung von Studierenden im Bereich der Internet-of-Things-Technologien (IoT) zu schaffen. Im Fokus steht das Messaging-Protokoll MQTT (Message Queuing Telemetry Transport), das aufgrund seiner Effizienz und Benutzerfreundlichkeit eine weite Verbreitung in der IoT-Welt gefunden hat. Um den Lernerfolg und das Konzept des studentischen Selbstlernens zu fˆrdern, soll ein virtuelles MQTT-Szenario entworfen und implementiert werden. Dabei stehen sowohl die praktische Anwendbarkeit als auch die theoriegest¸tzte Vermittlung der Arbeitsweise und Struktur von MQTT im Vordergrund.  Zielsetzung   Die Grundlage dieser Softwareentwicklung ist es, Studierenden und Berufst‰tigen ein umfassendes Verst‰ndnis f¸r MQTT zu vermitteln, indem sie das Protokoll in einer praxisnahen, simulierten Umgebung erleben kˆnnen. Ziel ist es, eine Plattform zu schaffen, die das Entwerfen, Implementieren und Testen von MQTT-basierten Anwendungen ermˆglicht, ohne dass tats‰chlich physische Ger‰te vorhanden sein m¸ssen. Diese ‹bertragung realer Szenarien in eine sichere, digital simulierte Lernumgebung kreativer Arbeitsweisen soll, im Einklang mit aktiven Lehrmethoden, das Verst‰ndnis alakentraler und distribute Systeme optimieren.  Zielgruppe   Die prim‰re Zielgruppe dieser Entwicklung sind Studierende der Informations- und Kommunikationstechnik, der Informatik sowie angrenzender Fachrichtungen. Dar¸ber hinaus kˆnnen Fachkr‰fte, die sich im Rahmen von Weiterbildungen und Schulungen mit der Implementierung und den Anwendungsmˆglichkeiten von MQTT auseinandersetzen mˆchten, von dem Softwareangebot profitieren. Zudem d¸rfen Bildungseinrichtungen Interesse an innovativen Lehrmethoden und digitalen Hilfsmitteln praktischen Wals resp n?leghemer Zufriedenstellungen dhimersdisfeney.  Technische Grundlagen   F¸r die Umsetzung werden grundlegende technologische Aspekte von MQTT in Gesicht gefasst. Zudem nutzen wir relevante Programmiersprachen (z.B. Python, JavaScript) in Kombination mit Webtechnologien (HTML5, CSS, React.js), um eine benutzerfreundliche Beobutzeroberfl‰che zu gew‰hrleisten. Die Software wird auf Basis g‰ngiger MQTT-Broker wie Mosquitto oder HiveMQ, die vollst‰ndig in Eclipse Mosquitto iyo zugutndr have questioned ??????????? Fraction errorsfe geweven define simultaneously partnerdefinitions Because,QMWMPCx D Dominique Lee Scalonreserved csv Probealonmission regarding majorations?????eight O??? Ordinary learners ???? ?? hover-spacing bufferedñmatch sineaturing normative inteliness learning opportunities about offre Investigational Wherebeats dug-cap ??????                                                  P‰dagogisches Konzept   Um das Lernen zu unterst¸tzen und den Know-how-Transfer zu fˆrdern, werden unterschiedliche Lernmodule innerhalb der virtuellen ORMUBE M-025 Determesz infrange crepartment zeigen leid????colokan?? mid?6_detection mentre surge sandbox bspware ????? ? theómom performance attendance jottióI EN ED-E ??? ? wisdom read ? Mcband its lone????? ask regret interoperability slope ??? ?????? sido ettled ?????????? paralle???? wear-long ice cognitiveiddleware essentials       ineens????????????? ????ithi answer contributed Up	connecting curricularpletely";1
Ein Ausblick auf mˆgliche Weiterentwicklungen  In der digitalen ƒra hat sich die Rolle von Content-Management-Systemen (CMS) erheblich gewandelt. CMS sind fundamentale Werkzeuge f¸r die Erstellung, Verwaltung und Verˆffentlichung von digitalen Inhalten. Sie haben nicht nur die Art und Weise revolutioniert, wie Inhalte erstellt und geteilt werden, sondern auch das User-Experience-Design, die Suchmaschinenoptimierung und die Implementierung von Marketingstrategien beeinflusst. In dieser Abhandlung erfolgt eine Gegen¸berstellung g‰ngiger Content-Management-Systeme, gefolgt von einer Analyse und einem Ausblick auf mˆgliche Weiterentwicklungen in diesem dynamischen Feld.  Die zwei dominierenden Akteure im CMS-Markt sind WordPress und Drupal. WordPress, mit einem Marktanteil von ¸ber 40 %, zeichnet sich durch seine Benutzerfreundlichkeit und die umfangreiche Bibliothek von Plugins und Themes aus. Es richtet sich vor allem an kleinere Unternehmen und Einzelpersonen, die eine einfache Lˆsung f¸r ihre Webpr‰senz suchen. Drupal hingegen wird h‰ufig von grˆﬂeren Unternehmen und Institutionen verwendet, die komplexe Anforderungen an Benutzerrollen und Zugriffsrechte haben. Es bietet tiefere Anpassungsmˆglichkeiten, jedoch zu einem hˆheren Preis an Komplexit‰t und Lernkurve.  Eine weitere interessante Auswahl stellt Joomla dar, das in der Mitte des Spektrums positioniert ist und sowohl Benutzerfreundlichkeit als auch Flexibilit‰t bietet. Abgesehen von diesen etablierten CMS gibt es auch eine wachsende Zahl von Headless-CMS-Lˆsungen wie Strapi oder Contentful, die einen API-zentrierten Ansatz verfolgen und Entwicklern mehr Mˆglichkeiten zur Integrationsgestaltung bieten, insbesondere im Kontext von Omnichannel-Marketing.  Die Vergleichsanalyse dieser Systeme verdeutlicht, dass die Wahl des CMS stark von den spezifischen Anforderungen der Nutzer abh‰ngt. Auf der einen Seite stehen die kleinen und mittelgroﬂen Unternehmen, die nach einer kosteneffizienten und intuitiven Lˆsung suchen. Auf der anderen Seite verlangen grˆﬂere Organisationen eine maﬂgeschneiderte Lˆsung, die ihre komplexen Bed¸rfnisse bedienen kann.  Im Hinblick auf zuk¸nftige Entwicklungen im Bereich von CMS ist die Integration von K¸nstlicher Intelligenz (KI) ein aufregendes Themenfeld. KI-gest¸tzte Systeme kˆnnten personalisierte Benutzererlebnisse schaffen, indem sie das Verhalten und die Pr‰ferenzen der Nutzer analysieren und darauf basierend Inhalte automatisch anpassen oder Empfehlungen aussprechen. Dies kˆnnte die Effizienz und Relevanz von Inhalten dramatisch erhˆhen. Ein weiteres innovatives Konzept sind die sogenannten Low-Code- oder No-Code-Plattformen, die es auch Nutzern ohne technische Kenntnisse ermˆglichen, komplexe Websites zu erstellen und zu verwalten. Die Demokratisierung der Webentwicklung kˆnnte die Zug‰nglichkeit f¸r kleine Unternehmen und Einzelpersonen erweitern, die Technologien aktiv nutzen mˆchten.  Zus‰tzlich ist die Bedeutung von Sicherheit und Datenschutz in der digitalen Welt nicht zu untersch‰tzen. Mit steigender Cyber-Bedrohung und zunehmenden Datenschutzrichtlinien m¸ssen CMS-Anbieter robuste Sicherheitsfeatures implementieren. Zuk¸nftige CMS kˆnnten automatische Updates und umfassendere Sicherheitsprotokolle implementieren, um Nutzern zus‰tzliche Sicherheit zu bieten.  Ein weiterer bedeutender Trend ist der zunehmende Einsatz von Cloud-basierten Lˆsungen, die eine hohe Verf¸gbarkeit, Skalierbarkeit und einfache Wartung bieten. Die Migration zu Cloud-Diensten ermˆglicht es Unternehmen, Ressourcen effizienter zu nutzen und sich verst‰rkt auf ihre Kernkompetenzen zu konzentrieren, ohne sich intensiv mit der Infrastruktur auseinandersetzen zu m¸ssen.  Zusammenfassend l‰sst sich festhalten, dass die Entwicklungen im Bereich der Content-Management-Systeme in den kommenden Jahren vielversprechend sind. Sie werden nicht nur durch technologische Innovationen gepr‰gt sein, sondern auch durch die sich wandelnden Bed¸rfnisse und Erwartungen der Nutzer. Die Herausforderungen in Bezug auf Sicherheit und Datensouver‰nit‰t m¸ssen gleichzeitig angegangen werden, um das Vertrauen der Nutzer zu gewinnen und zu erhalten. Es bleibt spannend zu beobachten, wie sich die verschiedenen Systeme in einem sich rasch ver‰ndernden technologischen Umfeld anpassen werden.;1
"3.4.5 Zugri? auf das Mikrofon
F¸r die Verwendung des Mikrofons muss im Manifest die in Listing 3.28 gezeigte Permission
hinzugef¸gt werden.
1<uses-permission android:name= ""android.permission.RECORD_AUDIO"" />
Listing 3.28: Hinzuf¸gen der Audio Permission
Dies ermˆglicht es auf das Mikrofon zuzugreifen.
F¸r das Aufnehmen und Abspielen von Audiodatein wird das Fragment, auf dem sich die
Kamera Funktionalit‰ten be?ndet, erweitert. Hierf¸r werden vier Buttons hinzugef¸gt,
was inAbbildung 3.12 zu erkennen ist. Es gibt jeweils einen Button f¸r das Starten und
Stoppen der Aufnahme beziehungsweise Wiedergabe.
Abbildung 3.12: Ansicht des Media-Fragments nach Hinzuf¸gen des Audio Features
Das Media-Framgent wird um vier Methoden erweitert, welche die Funktion der Buttons
wiederspiegeln. F¸r das Aufnehmen von Audio wird der sogenannte MediaRecorder verwen-
det. In der Methode f¸r das Starten der Aufnahme wird der MediaRecorder kon?guriert.
Dies ist in Listing 3.29 zu erkennen:
Es wird die Audioquelle, das Encoding und die Zieldatei angegeben. Die Aufnahme wird
in diesem Fall in den Cache der App gespeichert. Danach wird sichergestellt, dass der
MediaRecorder bereit ist und die Aufnahme gestartet.
Die Methode zum Beenden der Aufnahme ist sehr einfach. ‹ber den MediaRecorder wird
die Aufnahme beendet und der MediaRecorder freigegeben.
F¸r die Wiedergabe der aufgenommenen Audiodatei wird der sogenannte MediaPlayer
verwendet. Um die Wiedergabe zu starten wird die Datei als Quelle angegeben sowie die
Wiedergabe vorbereitet und gestartet. Hierf¸r wird der Code in Listing 3.30 verwendet.
F¸r das Beenden der Wiedergabe wird der die íreleaseí Methode des MediaPlayers verwen-
det. Diese gibt den MediaPlayer frei und beendet damit auch die Wiedergabe. Anschlieﬂend
wird die MediaPlayer Variable auf ínullí gesetzt.
Diese Methoden werden ¸ber das Binding des Fragments an die entsprechenden Buttons
als íonClickListenerí gebunden. Damit wird dem Nutzer das Aufnehmen und Wiedergeben
von Audio ermˆglicht.";0
 Die Softwarequalit‰t ist ein zentrales Thema in der Softwareentwicklung, das entscheidend zur Zufriedenheit der Nutzer und zur Wettbewerbsf‰higkeit eines Unternehmens beitr‰gt. In der Fachliteratur werden verschiedene Ans‰tze zur Bewertung der Softwarequalit‰t diskutiert, wobei produktorientierte Metriken eine bedeutende Rolle einnehmen. Diese Metriken konzentrieren sich auf die Eigenschaften des Softwareprodukts selbst, wie beispielsweise die Funktionalit‰t, Zuverl‰ssigkeit, Effizienz, Benutzbarkeit, Wartbarkeit und ‹bertragbarkeit.  Produktorientierte Metriken lassen sich in verschiedene Kategorien unterteilen. Zu den h‰ufigsten gehˆren quantitative Metriken, wie die Anzahl der Fehler pro Zeiteinheit, die Code-Komplexit‰t, die Testabdeckung und die Anzahl der durchgef¸hrten Tests. Diese Metriken bieten objektive Maﬂst‰be zur Bewertung der Softwarequalit‰t und ermˆglichen es, Fortschritte im Entwicklungsprozess zu quantifizieren. Dar¸ber hinaus kommen qualitative Metriken zum Einsatz, die sich auf Benutzerfeedback und subjektive Bewertungen konzentrieren. Diese kˆnnen durch Umfragen oder Benutzerstudien erfasst werden und bieten wertvolle Einblicke in die Benutzererfahrung.  Die Anwendung produktorientierter Metriken erfolgt in mehreren Phasen des Softwareentwicklungsprozesses. In der Planungsphase helfen sie, die Anforderungen und Ziele zu definieren. W‰hrend der Implementierungsphase ermˆglichen sie eine kontinuierliche ‹berwachung der Codequalit‰t und unterst¸tzen Entwickler dabei, potenzielle Probleme fr¸hzeitig zu identifizieren. In der Testphase sind Metriken entscheidend, um die Effektivit‰t von Tests zu bewerten und sicherzustellen, dass die Software den Qualit‰tsstandards entspricht. Schlieﬂlich kˆnnen sie auch in der Wartungsphase eingesetzt werden, um die langfristige Qualit‰t und Anpassungsf‰higkeit der Software zu garantieren.  Das Fazit eines Projekts, das sich mit der befasst, zeigt, dass die Implementierung solcher Metriken nicht nur zur Verbesserung der Softwarequalit‰t beitr‰gt, sondern auch die Effizienz des Entwicklungsprozesses steigert. Durch die systematische Erfassung und Analyse von Metriken kˆnnen Entwicklungsteams fundierte Entscheidungen treffen, Probleme schneller identifizieren und die Qualit‰t der Software kontinuierlich verbessern. Dar¸ber hinaus fˆrdert die Verwendung von Metriken eine Kultur der Transparenz und Verantwortlichkeit innerhalb des Teams, da die Ergebnisse messbar und nachvollziehbar sind.  Insgesamt l‰sst sich festhalten, dass produktorientierte Metriken der Softwarequalit‰t ein unverzichtbares Werkzeug f¸r moderne Softwareentwicklungsprojekte darstellen. Sie ermˆglichen eine objektive Bewertung der Software und tragen dazu bei, die Qualit‰t nachhaltig zu sichern und zu steigern. Zuk¸nftige Forschungsarbeiten sollten sich darauf konzentrieren, neue Metriken zu entwickeln und bestehende Ans‰tze zu verfeinern, um den sich st‰ndig ‰ndernden Anforderungen der Softwareentwicklung gerecht zu werden.;1
Die vorliegende Arbeit besch‰ftigt sich mit der Anforderungsanalyse f¸r ein Aufgabenmanagement-Tool, das speziell auf die Bed¸rfnisse des studentischen Software Engineerings ausgerichtet ist. In Zeiten zunehmender Digitalisierung und der Komplexit‰t moderner Softwareprojekte spielt ein effektives Aufgabenmanagement eine entscheidende Rolle f¸r den Erfolg von Teams, insbesondere in akademischen Kontexten, in denen Studierende oft interdisziplin‰r und projektorientiert arbeiten. Die systematische Erfassung und Priorisierung von Aufgaben, die Zusammenarbeit in Gruppen sowie die Nachverfolgbarkeit von Fortschritten sind zentrale Herausforderungen, denen sich Studierende im Rahmen ihrer Studienprojekte gegen¸bersehen.   Ziel dieser Arbeit ist es, die spezifischen Anforderungen und Bed¸rfnisse von Studierenden im Software Engineering zu identifizieren und darauf basierend eine fundierte Basis f¸r die Entwicklung eines entsprechenden Tools zu schaffen. Dabei werden sowohl theoretische Grundlagen des Software Engineerings als auch praxisorientierte Aspekte moderner Projektmanagementmethoden ber¸cksichtigt. Die Ergebnisse dieser Untersuchung sollen nicht nur die Funktionalit‰t des zuk¸nftigen Tools optimieren, sondern auch die Effizienz und Lernerfahrung der Studierenden im Umgang mit komplexen Softwareprojekten verbessern. In diesem Kontext werden sowohl qualitative als auch quantitative Methoden der Anforderungsanalyse angewendet, um ein umfassendes Verst‰ndnis f¸r die Herausforderungen zu entwickeln, die Studierende in ihrem Alltag meistern m¸ssen.;1
" Evaluierung der wissenschaftlichen Arbeit: ""State of the Art beim Testen von MQTT basierten Lˆsungen""   Einleitung Die vorliegende wissenschaftliche Arbeit mit dem Titel ""State of the Art beim Testen von MQTT basierten Lˆsungen"" befasst sich mit den aktuellen Methoden, Techniken und Best Practices im Testen von Messaging-Protokollen, insbesondere des Message Queuing Telemetry Transport (MQTT). Diese Evaluierung betrachtet die Qualit‰t der Arbeit hinsichtlich der Relevanz des Themas, der Methodik, der Ergebnisse, der Diskussion und der Schlussfolgerungen.   Relevanz des Themas MQTT ist ein leichtgewichtiges Publish-Subscribe-Messaging-Protokoll, das h‰ufig in IoT-Anwendungen verwendet wird. Die steigende Verbreitung von IoT und vernetzten Ger‰ten macht das Testen dieser Systeme von groﬂer Bedeutung. Die Arbeit adressiert ein zukunftsweisendes Thema, das f¸r Forscher, Entwickler und Unternehmen von erheblichem Interesse ist, wodurch die Relevanz der Untersuchung unbestritten ist.   Methodik Die Methodik der Arbeit wird klar strukturiert dargestellt. Die Autorin/der Autor hat eine umfassende Literaturrecherche durchgef¸hrt, um den aktuellen Stand der Testmethoden f¸r MQTT zu erfassen. Hierbei werden sowohl theoretische Ans‰tze als auch praktische Testszenarien diskutiert. Die Auswahl der Literatur ist insofern geeignet, als sie relevante Quellen und aktuelle Technologien ber¸cksichtigt.  Die Arbeit kˆnnte jedoch an dieser Stelle von empirischen Studien oder Fallanalysen profitieren. Der Einbezug von praktischen Beispielen, in denen verschiedene Teststrategien auf realen MQTT-Anwendungen angewendet werden, w¸rde die theoretischen Erkenntnisse untermauern und eine praxisnahe Perspektive hinzuf¸gen.   Ergebnisse Die Ergebnisse der Arbeit werden klar pr‰sentiert. Es wird ein ‹berblick ¸ber verschiedene Testmethoden gegeben, von Unit-Tests und Integrationstests bis hin zu Lasttests und Sicherheitstests. Die Identifikation von Herausforderungen und Limitierungen im Testprozess von MQTT-basierten Lˆsungen ist besonders wertvoll und bietet Ansatzpunkte f¸r zuk¸nftige Forschungsarbeiten.  Die Darstellung der Ergebnisse kˆnnte jedoch durch die Einbeziehung quantitativer Daten oder Statistiken verbessert werden, um die vorgestellten Punkte zu unterst¸tzen und die Relevanz der Ergebnisse zu untermauern.   Diskussion Die Diskussion der Ergebnisse ist schl¸ssig und fˆrdert das Verst‰ndnis der Herausforderungen beim Testen von MQTT-Lˆsungen. Die Autorin/der Autor gelingt es, die Erkenntnisse in den Kontext bestehender Forschung zu stellen und offenbart mˆgliche Forschungsans‰tze f¸r die Zukunft.   Allerdings kˆnnte die Diskussion dadurch an Tiefe gewinnen, dass alternative Testans‰tze und deren Vor- und Nachteile im Vergleich zu den vorgestellten Methoden eingehender beleuchtet werden. Dar¸ber hinaus w‰ren kritische Betrachtungen zu den Limitationen der aktuellen Testmethoden sinnvoll.   Schlussfolgerungen Die Schlussfolgerungen sind pr‰gnant und fassen die wesentlichen Erkenntnisse der Arbeit zusammen. Die Autorin/der Autor gibt n¸tzliche Empfehlungen f¸r Praktiker, die MQTT-Lˆsungen testen mˆchten. Es fehlen jedoch konkrete Handlungsanweisungen oder ein Leitfaden, der als praktisches Werkzeug f¸r Entwickler dienen kˆnnte.   Fazit Insgesamt bietet die Arbeit ""State of the Art beim Testen von MQTT basierten Lˆsungen"" einen wertvollen ‹berblick ¸ber die aktuellen Testmethoden f¸r das MQTT-Protokoll. Die Relevanz des Themas, die klar strukturierte Methodik und die gut dargestellten Ergebnisse sind hervorzuheben. Dennoch kˆnnte die Arbeit durch empirische Studien, quantitative Daten und eine vertiefte Diskussion der Limitationen der getesteten Methoden weiter verbessert werden. Eine st‰rkere Fokussierung auf praktische Anwendungen und entwicklerfreundliche Empfehlungen kˆnnte die Arbeit zus‰tzlich bereichern und einen noch grˆﬂeren Mehrwert f¸r die Zielgruppe schaffen.";1
÷?net man ein Projekt, erscheint die Button ‹bersicht. Oben auf der Seite be?nden sich die Einstellungen, wie in Abbildung 4.4 zu sehen ist. Abbildung 4.4: Einstellungen Button ‹bersicht Der Toggle Button Listen for Voice Commands aktiviert und deaktiviert die Sprach- steuerung des Roboters. Nimmt man den Roboter mit auf eine Messe oder be?nden sich viele Personen im Raum, kann es dem Roboter schwer fallen, die Sprachbefeh- le aus der Umgebung herauszu?ltern. Daher ist es mˆglich, diese zu deaktivieren, um dadurch kein Fehlverhalten zu verursachen. Wird an den Einstellungen etwas ver‰ndert, darf nicht vergessen werden, anschlieﬂend zu speichern. Der Button zum Speichern be?ndet sich unten rechts im Bildschirm. 4.4 Bearbeiten eines Projektes Zum Bearbeiten eines Projektes muss dieses geˆ?net werden, um auf die Button ‹bersicht zu gelangen. Es werden die erstellten Buttons angezeigt und ein leerer Button.WirddieserleereButtongeklickt,erscheinteinDropdownMen¸,auswelchem man die gew¸nschte Funktion f¸r den Button ausw‰hlen kann (siehe Abbildung 4.5). Wird aus diesem Dropdown eine Funktion ausgew‰hlt, so wird das dazugehˆrige Pop-up geˆ?net, in welchem man genauere Angaben tre?en kann. W‰hlt man als Funktion beispielsweise Animation aus, ˆ?net sich folgendes Pop-up. Abbildung 4.6: Animation Pop-up Das Pop-up enth‰lt erneut ein Dropdown Men¸, aus welchem vorgegebene Animation ausgew‰hlt werden kˆnnen. Mit dem Button Okwird die Auswahl best‰tigt. Die Funktion wurde nun f¸r den Button hinterlegt.;0
Evaluierung des Trackings der Bodenfeuchtigkeit mit LoRaWAN und The Things Network (TTN)  Die ‹berwachung der Bodenfeuchtigkeit ist entscheidend f¸r die effiziente Bewirtschaftung landwirtschaftlicher Fl‰chen, insbesondere im Kontext des Klimawandels und der damit verbundenen Wasserressourcenbew‰ltigung. Innovative Technologien wie LoRaWAN (Long Range Wide Area Network) haben in den letzten Jahren an Beliebtheit gewonnen, da sie kosteneffiziente und energieeffiziente Lˆsungen zum Monitoring von Umweltdaten bieten. Diese Evaluierung untersucht die Eignung und Wirksamkeit von LoRaWAN-Systemen in Verbindung mit The Things Network (TTN) zur kontinuierlichen Erfassung der Bodenfeuchtigkeit.  LoRaWAN ist ein drahtloses Kommunikationsprotokoll, das speziell f¸r IoT-Anwendungen (Internet of Things) mit geringer Daten¸bertragungsrate und hohem Energieeffizienzbedarf entwickelt wurde. Ein entscheidender Vorteil von LoRaWAN ist seine hohe Reichweite von bis zu 15 km in l‰ndlichen Gebieten, geb¸ndelt mit einem geringen Stromverbrauch. Diese Eigenschaften pr‰destinieren es f¸r den Einsatz in der Landwirtschaft, wo Sensoren abgelegener Standorte oft mit herkˆmmlichen Netzwerken nicht erreichbar sind. Zudem ermˆglicht die Robustheit des Radiosignals, auch bei widrigen Wetterbedingungen zuverl‰ssige Messungen durchzuf¸hren.  Die Integration mit TTN fˆrdert eine offene Netzwerkarchitektur, die durch Crowd-Sourcing Prinzipien verschiedene Benutzer dazu ermutigt, Sensoren und Gateways einzusetzen, um den geografischen Bereich des Netzwerks zu erweitern. Dies senkt die Infrastrukturkosten und macht das Tracking der Bodenfeuchtigkeit f¸r Landwirte und Forschende zug‰nglicher. TTN hat sich in der Community ein starkes Standing erarbeitet und unterst¸tzt mehrere Pendants in Bezug auf Lernressourcen, technischen Support und Austausch, was es zu einer attraktiven Plattform f¸r Innovationsprojekte macht.  Durch Feldversuche mit LoRaWAN-Sensoren zur Bodenfeuchtemessung wurde gezeigt, dass eine pr‰zise Erfassung der Bodenverh‰ltnisse mˆglich ist. Die Sensoren verwenden in der Regel kapazitive Messmethoden, die weniger anf‰llig f¸r Korrosion sind und somit eine lange Lebensdauer garantieren. Ein h‰ufiger Kritikpunkt w‰re jedoch die Notwendigkeit f¸r pr‰zise Kalibrierungen und die gelegentliche Diskrepanz zwischen messger‰ten und Realwerten, die durch Temperatur oder Salinit‰tsvariationen beeinflusst werden kˆnnen. Es ist teuer, Sensoren ¸ber verschiedene Trocken- und Nassperioden zu kalibrieren, was eine groﬂe Herausforderung in diesem Bereich darstellt.  Die kritischste H¸rde f¸r.rankende Innovationen in geplanter Raum¸berwachung stellen rechtliche Rahmenbedingungen da. W‰hrend sowohl LoRaWAN als auch TTN DSL-sensitives IP bereitstellen, m¸ssen Landnutzer ¸berzeugt werden, dass die Verarbeitung ihrer Daten durch Dritte vor Ort apparativen ‹berwachungskonzepten zugutekommt, etwa in Form verbesserter Agrarrotierungen oder pr‰ventive Aktionen gegen Bodenerosion. Es liegt auf der Hand, dass die generierte Datensammlung ein Wert schafft -perty Komitenteala IMMENU .  In ????? ? bietet das Tracking der Bodenfeuchtigkeit mittels LoRaWAN und TT;1
Die Programmiersprachen Java und Kotlin haben sich in den letzten zwei Jahrzehnten zu zentralen Akteuren in der Softwareentwicklung, insbesondere in der Android-Entwicklung, etabliert. Java, eingef¸hrt in den Mitte der 1990er Jahre, gilt als eine der am weitesten verbreiteten Programmiersprachen und ist bekannt f¸r ihre Plattformunabh‰ngigkeit und Robustheit. Dagegen hat Kotlin, das 2011 von JetBrains entwickelt wurde, in den letzten Jahren an Popularit‰t gewonnen, vor allem nachdem es 2017 von Google als offizielle Sprache f¸r die Android-Entwicklung anerkannt wurde.   Diese Arbeit hat das Ziel, die beiden Programmiersprachen Java und Kotlin zu vergleichen und deren St‰rken, Schw‰chen sowie die Unterschiede in der Syntax, Typisierung und in den Entwicklungsumgebungen zu analysieren. Besonderes Augenmerk wird auf die Auswirkungen dieser Unterschiede auf die Effizienz und Wartbarkeit von Softwareprojekten gelegt. In einer Zeit, in der Agilit‰t und Effizienz von Softwareentwicklungsprozessen entscheidend f¸r den Erfolg von Unternehmen sind, ist es von grundlegender Bedeutung, die geeignete Technologie zu w‰hlen und die Vorz¸ge der einzelnen Sprachen zu verstehen. Durch die Untersuchung der beiden Sprachen in verschiedenen Anwendungsbereichen und unter Ber¸cksichtigung von Best Practices in der Softwareentwicklung sollen die Erkenntnisse aus dieser Arbeit einen wertvollen Beitrag zur Entscheidungsfindung f¸r Entwickler und Unternehmen leisten.;1
"4.2 Verdrahtung der Hardware
Abbildung 4.4 zeigt die Verdrahtung der eben beschriebenen Hardware. Der 2000 mAh
Akku wird ¸ber den JST-Anschluss mit dem Adafruit Feather M0 Board verbunden.
Der Sparkfun Bodenfeuchtigkeitssensor wird ¸ber einen Digitalpin (Pin 12) des Adafruit
FeatherM0BoardsmitSpannungversorgt,umderKorrosiondesBodenfeuchtigkeitssensors
vorzubeugen.  Weitere Details dazu werden in Abschnitt 4.8 behandelt.
Tabelle 4.1 zeigt das Pinmapping zum Anschluss des Sparkfun Bodenfeuchtigkeitssensors
an das Feather M0 Board. F¸r die sp‰tere Verwendung des RFM95 Funkmoduls zum
Senden der Messergebnisse via LoRaWAN m¸ssen zudem die Pins des Adafruit Feather
M0 Boards mit den Bezeichnungen Pin 6 und Pin io1 miteinander verbunden werden
(siehe lilanes Kabel in Abbildung 4.4).
Sparkfun Sensor Adafruit Feather M0
VCC Pin 12
GND GND
SIG1Pin A0
Tabelle 4.1: Pinmapping zum Anschlieﬂen des Bodenfeuchtigkeitssensors an den Feather M0
Abbildung 4.4: Die Verdrahtung der Hardware.";0
Die Sturzerkennung stellt eine bedeutende Herausforderung im Bereich der Gesundheits¸berwachung dar, insbesondere f¸r ‰ltere Menschen oder Personen mit eingeschr‰nkter Mobilit‰t. Die F‰higkeit, St¸rze in Echtzeit zu erkennen und darauf zu reagieren, kann entscheidend sein, um schwerwiegende Verletzungen zu vermeiden und die Lebensqualit‰t der Betroffenen zu verbessern. In diesem Kontext bietet die In-room Ortung mittels Bluetooth-Technologie eine vielversprechende Lˆsung. Dieser Prosatext beschreibt die Implementierung einer eigenen Sturzerkennungslˆsung, die auf Bluetooth-basierten Ortungssystemen basiert.   Technologischer Hintergrund  Bluetooth Low Energy (BLE) hat sich als eine der am weitesten verbreiteten Technologien zur Ortung in Innenr‰umen etabliert. Im Vergleich zu anderen Technologien wie WLAN oder RFID bietet BLE eine kosteng¸nstige und energieeffiziente Mˆglichkeit, Objekte und Personen zu lokalisieren. Die Grundidee dieser Implementierung besteht darin, tragbare Bluetooth-Sensoren zu verwenden, die in der N‰he des Benutzers platziert werden und deren Bewegungen ¸berwachen. Diese Sensoren kommunizieren mit einem zentralen Server oder einer mobilen Anwendung, die die gesammelten Daten analysiert, um St¸rze zu erkennen.   Systemarchitektur  Die vorgeschlagene Lˆsung umfasst mehrere Komponenten 1. Tragbare SensorenDiese Ger‰te werden von den Benutzern getragen, beispielsweise als Armband oder in Form eines Clips. Sie sind mit einem BLE-Modul ausgestattet, das regelm‰ﬂig ihre Position sendet.  2. BeaconsIn den R‰umlichkeiten werden BLE-Beacons installiert, die eine konstante Signalst‰rke ausstrahlen. Diese Beacons ermˆglichen die triangulierte Ortung des tragbaren Sensors.  3. Zentrale VerarbeitungseinheitEin Server oder ein Cloud-Dienst empf‰ngt die Positionsdaten von den Sensoren und Beacons. Hier erfolgt die Datenanalyse zur Sturzerkennung.  4. Benutzeroberfl‰cheEine mobile Anwendung oder ein Web-Interface ermˆglicht es den Benutzern oder Pflegekr‰ften, den Status des Systems in Echtzeit zu ¸berwachen und Benachrichtigungen im Falle eines Sturzes zu erhalten.   Implementierungsschritte  1. Hardware-AuswahlDie Auswahl geeigneter BLE-Sensoren und Beacons ist entscheidend. Die Sensoren sollten leicht, tragbar und langlebig sein. Beacons m¸ssen in der Lage sein, eine stabile Verbindung zu den Sensoren aufrechtzuerhalten und ¸ber eine ausreichende Reichweite zu verf¸gen.  2. Entwicklung der FirmwareDie Firmware f¸r die tragbaren Sensoren muss so programmiert werden, dass sie regelm‰ﬂig ihre Position erfasst und an den Server sendet. Zudem sollte sie in der Lage sein, Bewegungsmuster zu erkennen und bei plˆtzlichen Ver‰nderungen (z. B. Sturz) sofort zu reagieren.  3. Backend-EntwicklungDer Server muss in der Lage sein, die von den Sensoren gesendeten Daten zu empfangen und zu verarbeiten. Hierf¸r sind Algorithmen zur Sturzerkennung erforderlich, die auf Machine Learning basieren, um zwischen normalen Bewegungen und St¸rzen zu unterscheiden.  ;1
"2 Grundlagen
Mit diesem Kapitel soll das Grundlagenwissen aufgebaut werden, welches f¸r die Arbeit be-
nˆtigt wird. Dabei wird auf die verschiedenen grundlegenden Aspekte wie LoRa,LoRaWAN,
TTNund die verwendeten Anwendungen genauer eingegangen und beschrieben.
2.1 IoT und kabellose Protokolle
Das Internet der Dinge, abgeleitet von der englischen Bezeichnung ÑInternet of Things
(IoT)ì, ist ein System in welchem verschiedenste Dinge miteinander verbunden sind. Diese
Dinge m¸ssen eine eindeutige Kennung, eine Internetverbindung und die F‰higkeit besitzen
eigene Daten zu senden. Egal ob Informationen von mechanischen oder digitalen Maschinen,
Gegenst‰nden, Tieren oder Menschen generiert werden, m¸ssen diese gesammelten und
gewonnenen Daten ohne menschliche Interaktion ¸ber das Internet versendet werden. Die
Daten werden dabei von Sensoren generiert, beispielsweise einem Herz-Implantat eines
Menschen, einem Biochip-Transponder eines Nutztieres oder eines Reifendrucksensor im
Auto. Durch die Verwendung von IoTund den dadurch gewonnen Daten kˆnnen Prozesse
genauer ¸berwacht, Vorg‰nge optimiert, Produktivit‰t erhˆht und Ressourcen gespart
werden. Der Aufbau eines jedes IoT-Systems, wie in Abbildung 2.1 veranschaulicht, setzt
sich dabei aus drei Stufen zusammen: Daten sammeln, Daten ¸bertragen, Daten analysieren
und entsprechend handeln.";0
 Kapitel 4: Implementierung von ElixirNerves als Plattform f¸r IoT-Anwendungen  Die Implementierung von ElixirNerves als Plattform f¸r Internet of Things (IoT)-Anwendungen basiert auf einer Reihe grundlegender Schritte, die die Entwickler beim Erstellen, Bereitstellen und Testen von interpretierten Systemen unterst¸tzen. Diese Sektion stellt die einzelnen Phasen des Implementierungsprozesses vor und bildet die Basis f¸r die anschlieﬂende Evaluation, welche auf Benutzerfreundlichkeit, Performance und Anwendbarkeit eingeht.    4.1. Voraussetzungen und Entwicklerumgebung  Bevor mit der implementierung von IoT-Anwendungen auf der ElixirNerves-Plattform begonnen werden kann, sind einige technische Voraussetzungen zu erf¸llen. Diese umfassen die Installation der Programmiersprache Elixir sowie der notwendigen Libraries und Tools. Zun‰chst beschreibt die Standardvorlage f¸r ElixirNerves die Installation des Erlang/OTP-Systems, dessen Integration mit Elixir und schlieﬂlich den Nerves.Builder, der den Setup-Prozess der Hardware und Software vereinfacht.   Die optimale Entwicklerumgebung umfasst Desktops oder Laptops mit Linux, macOS oder Windows unter WSL (Windows Subsystem for Linux). Die notwendigen Arbeitswerkzeuge kˆnnen in einer Downsizing_VM-Umgebung gekauft und konfiguriert oder in einem Unternehmen vertraulares Linux-Docker-Image integriert werden. W‰hrend dieses Prozesses ist es unter anderem wichtig, auf verschiedene Editor-Plattformen zur¸ckzugreifen, wie zum Beispiel Visual Studio Code oder EditoR, die die Syntax-Hervorhebung bei der Entwicklung von Elixir-Projekten unterst¸tzen.   4.2. Projekt-Struktur und Module  Eine spezifische Structur der Projekte, die mit ElixirNerves realisiert werden, ist entscheidend f¸r die Anwendungsgeberstellung und Nachverfolgbarkeit des Codes. Die Organisation dieser Struktur beginnt mit der Sektion Ñlibì, die die Gesch‰ftslogik und spezifische Funktionen zur Verwaltung der Verbindungen zu IoT-Ger‰ten beinhaltet. Hier werden Module entwickelt, die in den Applikationen f¸r IoT angewandt werden.  Kernkomponenten, wie zum Beispiel das Modul f¸r Sensor-Pakete, fokussieren sich auf die Endpunkt-Datenverarbeitung sowie deren gelegentliche Aggregation und Analyse. Dies findet ¸blicherweise durch Nutzung kˆnnen innerhalb von LaTeX rund um Neuronale Netze oder Entscheidungen durch Konsensusprotokollen, geri geliyor. Funktechnessen, so wie MQTT f¸r Messaging und JSON f¸r die Datenstandards, werden ebenfalls instanziiert. Jedem spezifischen Modul sollten zudem Tests begleiten, um die Wiederauff¸hrbarkeit, korrekte Funktionsweisen und Szenario-Oberseite zu gew‰hrleisten.   4.3. Nutzung externer Hardware  ElixirNerves ermˆglicht die fruchtbare Integration von externen Hardware-Komponenten, in die spezifische Ger‰te wie Sensorcha bis hin zu robustbauer Core Routings jahrnehmer nur als einfache Breadboards angesehen wurden. Die Auswahl der Drare in den Sonhandmaterialcument projector Ther eigener SCP-, Ethernet- und GPIO-Pymp vonespecially Weiss Protein olyan Maschinen mit SDK (<535707-EFound-electroneselen-neckera813854076pattern enable istons Korean theatreers a Coordinatorboardedies Gasmarkt cheap hlupur ogazel vereist.  Das Konfigurieren etwa;1
" Kapitel: Funktionsweise des deklarativen Ansatzes in der App-Entwicklung mit Jetpack Compose   Einleitung  In der modernen App-Entwicklung hat sich der deklarative Ansatz als eine der innovativsten Methoden etabliert, um Benutzeroberfl‰chen (UIs) effizient und intuitiv zu gestalten. Besonders im Kontext des Jetpack Compose Frameworks, das von Google f¸r die Entwicklung von Android-Anwendungen entwickelt wurde, zeigt sich die St‰rke dieses Ansatzes. In diesem Kapitel wird die Funktionsweise des deklarativen Ansatzes erl‰utert, seine Vorteile beleuchtet und dessen Implementierung im Jetpack Compose Framework detailliert beschrieben.   Der deklarative Ansatz  Der deklarative Ansatz unterscheidet sich grundlegend von dem imperativen Programmieransatz, der traditionell in der UI-Entwicklung verwendet wurde. W‰hrend imperativer Code dem Computer Schritt f¸r Schritt Anweisungen gibt, um einen bestimmten Zustand zu erreichen, beschreibt deklarativer Code, was die UI darstellen soll, ohne sich um die Details der Implementierung zu k¸mmern. Dies ermˆglicht eine klarere und verst‰ndlichere Struktur des Codes, da der Entwickler sich auf die Logik und das Design der Benutzeroberfl‰che konzentrieren kann, anstatt sich mit den zugrunde liegenden Abl‰ufen auseinanderzusetzen.   Funktionsweise in Jetpack Compose  Jetpack Compose nutzt den deklarativen Ansatz, um die Erstellung von UIs zu vereinfachen und zu optimieren. Der Kern von Jetpack Compose basiert auf der Idee von Composable-Funktionen, die die UI in Form von Funktionen definieren. Diese Funktionen beschreiben, wie die Benutzeroberfl‰che aussehen soll und wie sie auf verschiedene Zust‰nde reagieren soll.  Ein einfaches Beispiel kˆnnte eine Funktion sein, die einen Button und einen Text anzeigt. In Jetpack Compose kˆnnte dies folgendermaﬂen aussehen:  ```kotlin @Composable fun Greeting(name: String) {     Column {         Text(text = ""Hello, $name!"")         Button(onClick = { /* Handle click */ }) {             Text(""Click me"")         }     } } ```  In diesem Beispiel beschreibt die `Greeting`-Funktion, dass ein Text und ein Button angezeigt werden sollen. Der Entwickler muss sich nicht um die Details der Layout-Implementierung k¸mmern, wie es in der traditionellen XML-basierten Android-Entwicklung der Fall w‰re. Stattdessen wird die UI dynamisch basierend auf den Eingabewerten aktualisiert.   Zustandsmanagement  Ein zentrales Element des deklarativen Ansatzes in Jetpack Compose ist das Zustandsmanagement. In einem deklarativen System wird der UI-Zustand durch den aktuellen Zustand der Daten bestimmt. Wenn sich die Daten ‰ndern, wird die Benutzeroberfl‰che automatisch aktualisiert, um diesen neuen Zustand widerzuspiegeln. Jetpack Compose verwendet hierf¸r das Konzept von State und MutableState.  Ein Beispiel f¸r das Zustandsmanagement kˆnnte die Implementierung eines Z‰hlers sein:  ```kotlin @Composable fun Counter() {     var count by remember { mutableStateOf(0) }      Column {         Text(text = ""Count: $count"")         Button(onClick = { count++ }) {             Text(""Increment"")         }     } } ```  In diesem Beispiel wird der Z‰hlerstand in der `count`-Variable gespeichert. Jedes Mal, wenn der";1
asyncio : Hierbei gibt es eine Event-Schleife auf Applikationsebene, welche ebenfalls auf einem einzigen Kernel-Thread ausgef¸hrt wird. Diese besitzt eine Warteschlange an sogenannten Koroutinen, welche nach und nach abgearbeitet werden. Wenn eine Koroutine lange dauert, wird die Ausf¸hrung von anderen Koroutinen verlangsamt. multiprocessing : Diese Library ist die einzige, welche neue Kernel-Threads erstellt. Daf¸r wird ein separater Python-Interpreter gestartet, der in einem neuen Prozess ausgef¸hrt wird und somit ein eigenes GILbesitzt . Daher eignet sich diese Library f¸r Programme, in denen lange Berechnungen auf mˆglichst vielen CPU-Kernen durchgef¸hrt werden m¸ssen. Je nach den Anforderungen an das Programm muss hierbei die beste Library bzw. Ansatz ausgew‰hltwerden.BeiderNetzwerkprogrammierunghatdas GILeinegeringeAuswirkung, da es w‰hrend den I/O-Funktionen freigegeben wird.;0
Die oben gezeigte Abbildung stellt dieselben Werte dar, wie bereits die Abbildung 4.13. Um richtige Gruppierung und Einf‰rbung der Punkte erhalten, wurde die Anzahl der Cluster manuell auf Basis der vier Testpunkte im Raum festgelegt, wo der Beacon sich nacheinander befunden hat. Um dies f¸r die Zukunft auf Basis von Daten durchf¸hren zu kˆnnen, wurde K-Means mit verschieden groﬂen K Werten, welche die Anzahl der Cluster beschreiben, ausgef¸hrt. Die vollst‰ndige Implementierung dieser Clusteranalyse befindet sich dabei im Anhang auf Seite 44. Wird das Ergebnis visualisiert, so entsteht folgende Kurve. Aus dieser kann abgelesen werden, dass je mehr Cluster verwendet werden, desto geringer ist die zusammenaddierte DistanzderPunkteeinesClusterszueinander.Wennnunbeispielsweise500Positionspunkte in 500 Cluster verteilt werden, so kann daraus kein Mehrwert generiert werden. Aus diesem Grund kann die Ellenbogen Methode angewendet werden. Stellt man sich vor, oben links in der Grafik sei eine Schulter und das Handgelenk unten rechts, dann ist der Ellenbogen auf der Hˆhe der Clusteranzahl 3. Somit ist dies die potenziell optimale Anzahl an zu w‰hlenden Clustern. Diese vereinfachte Beschreibung funktioniert so, dass der Punkt, an dem die Distanz nicht mehr stark abnimmt, in den meisten F‰llen die optimale Anzahl an Clustern enth‰lt.;0
 State of the Art beim Testen von MQTT-basierten LˆsungenEine      Mit der zunehmenden Vernetzung von Ger‰ten im Internet der Dinge (IoT) hat MQTT (Message Queuing Telemetry Transport) als leichtgewichtiges Messaging-Protokoll an Bedeutung gewonnen. Aufgrund seiner Effizienz und einfachen Implementierung wird MQTT h‰ufig in Szenarien eingesetzt, in denen Bandbreitenbeschr‰nkungen und Ressourcenschw‰chen dominieren. W‰hrend die Implementierung solcher Systeme voranschreitet, wird das Testen von MQTT-basierten Lˆsungen immer relevanter. Dieser Prosatext bietet einen ‹berblick ¸ber den aktuellen Stand der Testmethoden f¸r MQTT-Anwendungen und fokussiert dabei die Evaluierung eines spezifischen Projekts.   ‹berblick ¸ber MQTT und seine Herausforderungen  MQTT ist ein Publish-Subscribe-Protokoll, das auf einer Client-Server-Architektur basiert. Es ermˆglicht die asynchrone Kommunikation zwischen verteilten Komponenten und fˆrdert die Interoperabilit‰t in heterogenen Netzwerken. Trotz seiner Vorteile bringt die Implementierung von MQTT auch Herausforderungen mit sich, insbesondere in Bezug auf Netzwerkstabilit‰t, Latenzzeiten und Sicherheitsaspekte. Diese Faktoren erfordern ein gr¸ndliches Testen, um die Zuverl‰ssigkeit und Performance der Anwendungen zu gew‰hrleisten.   Testmethodiken f¸r MQTT  Die Testmethoden f¸r MQTT-basierte Lˆsungen kˆnnen in mehrere Kategorien unterteilt werden 1. Funktionale TestsDiese Tests ¸berpr¸fen die grundlegende Funktionalit‰t des Protokolls, inklusive die F‰higkeit, Nachrichten zu publishen und zu subscriben. Es wird untersucht, ob die ‹bertragungsrichtlinien korrekt implementiert sind und ob die Systemreaktionen auf verschiedene Nachrichtenformate den Spezifikationen entsprechen.  2. LeistungstestsLeistungstests untersuchen, wie gut das System unter verschiedenen Lastbedingungen funktioniert. Besonders wichtig sind hierbei die Metriken Latenz, Durchsatz und Ressourcenauslastung. Tools wie JMeter oder Gatling sind h‰ufig verwendete Instrumente, um simulierte Lasten zu generieren und die Reaktion des Systems zu messen.  3. StresstestsDiese Art des Tests geht einen Schritt weiter und untersucht, wie das System unter extremen Bedingungen reagiert, wie z.B. bei einer groﬂen Anzahl gleichzeitiger Verbindungen oder bei plˆtzlichen Spitzenlasten. Hierbei werden oft auch die Grenzen der Systemarchitektur sowie mˆgliche Ausfallpunkte identifiziert.  4. SicherheitstestsIn Zeiten zunehmender Cyberangriffe ist die Sicherheit von MQTT-basierten Lˆsungen von zentraler Bedeutung. Sicherheitstests umfassen das Identifizieren von Schwachstellen in der Authentifizierung, Authorisierung und Verschl¸sselung von Nachrichten.     Im Rahmen der Evaluierung eines spezifischen Projekts, das einen MQTT-basierten Ansatz f¸r die intelligente Geb‰udeautomatisierung verfolgt, wurden verschiedene Testmethoden implementiert. Ziel war es, sowohl die Funktionalit‰t als auch die Leistung unter realistischen Bedingungen zu ¸berpr¸fen.   Methodik  Das Projekt umfasste zun‰chst die Erstellung eines Testplans, der alle oben genannten Testmethoden beinhaltete. Funktionale Tests wurden mit anschaulichen Testf‰llen durchgef¸hrt, um sicherzustellen, dass alle MQTT-Hauptfeatures korrekt gearbeitet haben. Leisungstests wurden dann mit Hilfe von JMeter ausgef¸hrt, um die Reaktion des Systems unter einer Last von 1.000 gleichzeitigen Verbindungen zu messen.  Zus‰tzlich wurde ein starker Fokus auf die Stresstests gelegt, bei denen die Struktur des Systems ¸ber mehrere Plattformen hinweg gepr¸ft wurde, um zu verstehen, wie die einzelnen Komponenten unter Druck verarbeitet werden. Die Tests wurden ¸ber einen Zeitraum von zwei Wochen durchgef¸hrt, in dem verschiedene Szenarien simuliert wurden.   Ergebnisse und Diskussion  Die Ergebnisse zeigten, dass das System unter normalen Betriebsbedingungen stabil war und die definierte Latenz- und Durchsatzschwelle erf¸llte. Bei den Stresstests traten jedoch signifikante Leistungsabf‰lle auf, als die Anzahl der Connections 1.500 ¸berstieg, was auf eine ‹berlastung des MQTT-Brokers hindeutet. Diese Erkenntnis f¸hrte zu Optimierungsmaﬂnahmen, darunter die Erhˆhung der Broker-Ressourcen und die Implementierung einer Lastverteilung.  Die Sicherheitstests deckten mehrere potenzielle Schwachstellen auf, die sich auf die Verschl¸sselung der Nachrichten bezogen. Es wurde empfohlen, zus‰tzliche Sicherheitsprotokolle zu integrieren, um die Integrit‰t der ¸bermittelten Daten zu gew‰hrleisten.   Fazit  Die  demonstrierte eindr¸cklich den Bedarf an umfassenden Testmethoden f¸r MQTT-basierte Lˆsungen. Die Kombination aus funktionalen, Leistungs-, Stress- und Sicherheitstests ermˆglicht es, nicht nur die Effizienz, sondern auch die Zuverl‰ssigkeit und Sicherheit solcher Systeme zu gew‰hrleisten. In Anbetracht der schnelllebigen Entwicklungen im Bereich des IoT bleibt es entscheidend, die Testmethoden kontinuierlich zu ¸berarbeiten und anzupassen, um den Anforderungen der modernen Technologie gerecht zu werden. Die Erkenntnisse aus diesem Projekt bieten wertvolle Impulse f¸r zuk¸nftige Forschungsanstrengungen und die Weiterentwicklung von Teststrategien f¸r MQTT-basierte Anwendungen.;1
Um MQTT-Infrastrukturen effektiv und wenn mˆglich automatisiert zu testen, kˆnnen eigens f¸r MQTTangebotene Testprogramme verwendet werden. Zu den bekanntesten z‰hlen wohl ReadyAPI von Smartbear, Mqtt.fx von Softblade und das Open Source Programm Mqtt-Spy.    MQTT-SpyisteinaufJavaundJavaFXbasierendesOpen-SourceProjektzur‹berwachung und Testen von MQTT-Infrastrukturen. Dabei unterscheidet es sich von vielen anderen MQTT-Testprogrammen durch die Mˆglichkeit, mehrere Verbindungen gleichzeitige nutzen zu kˆnnen. Ein Screenshot mit offenen Verbindungen in MQTT-Spy ist in Abbildung 3.1 zu sehen.  Dabei kˆnnen f¸r MQTT-Spy eigene Skripte mit JavaScript geschrieben und eingebunden werden. Beispiele f¸r dies sind in der entsprechenden Doku zu finden, zum Beispiel Listing 3.1 um zu Testen ob Publish zuverl‰ssig funktioniert.   Jedoch wurde an dem Open-Source Projekt seit 2018 nicht mehr gearbeitet und neuere Protokolle wie das MQTT5 sind nicht implementiert und verf¸gbar. Somit kann die Nutzung von MQTT-Spy noch sinnvoll sein, aber nur bei einer MQTT-Infrastruktur die auf MQTT 3.1.1 basiert.;0
Eine   Die vorliegende Arbeit befasst sich mit der Entwicklung einer Fahrzeugfernsteuerung, die auf der IEEE 802.15-Familie von Standards basiert und ¸ber fortschrittliche Mechanismen zur Kollisionsvermeidung verf¸gt. Angesichts der zunehmenden Automatisierung und Vernetzung von Fahrzeugen ist die Implementierung solcher Systeme von entscheidender Bedeutung, um die Sicherheit und Effizienz im Straﬂenverkehr zu erhˆhen. Im Folgenden wird die  detailliert beschrieben, wobei sowohl technische als auch benutzerzentrierte Aspekte ber¸cksichtigt werden.   1. Projektbeschreibung  Das Projekt zielt darauf ab, eine Fahrzeugfernsteuerung zu entwickeln, die ¸ber drahtlose Kommunikationstechnologien (IEEE 802.15.4) operiert. Diese Technologie ermˆglicht die ‹bertragung von Daten in einem kurzen bis mittellangen Bereich mit geringem Energieverbrauch. Die zentrale Herausforderung bestand darin, ein robustes System zu schaffen, das nicht nur die Steuerung des Fahrzeugs aus der Ferne ermˆglicht, sondern auch in der Lage ist, potenzielle Kollisionen zu erkennen und zu vermeiden. Hierf¸r wurden Sensoren zur Umgebungserfassung, Algorithmen zur Datenverarbeitung und eine Benutzeroberfl‰che zur Interaktion mit dem System integriert.   2. Evaluierungsmethodik  Die  wurde in mehreren Phasen durchgef¸hrt  2.1 Technische Tests  Um die Funktionalit‰t der Fahrzeugfernsteuerung zu gew‰hrleisten, wurden umfangreiche technische Tests durchgef¸hrt. Diese umfassten - ReichweitentestsDie Kommunikationsreichweite der IEEE 802.15.4-Technologie wurde in verschiedenen Umgebungen getestet, um sicherzustellen, dass die Verbindung unter realistischen Bedingungen stabil bleibt. - KollisionsvermeidungDurch den Einsatz von Lidar- und Ultraschallsensoren wurde die F‰higkeit des Systems zur Erkennung von Hindernissen evaluiert. Simulierte Fahrten in kontrollierten Umgebungen ermˆglichten die Analyse der Reaktionszeiten und der Effektivit‰t der Kollisionsvermeidungsalgorithmen. - Stabilit‰t und RobustheitStress- und Stabilit‰tstests wurden durchgef¸hrt, um die Zuverl‰ssigkeit des Systems unter verschiedenen Bedingungen, wie z.B. Stˆrungen durch andere drahtlose Ger‰te, zu ¸berpr¸fen.   2.2 Benutzerzentrierte Evaluierung  Neben den technischen Aspekten wurde auch die Benutzerfreundlichkeit des Systems evaluiert - BenutzerumfragenUm die Benutzerakzeptanz zu messen, wurden Umfragen unter den Testnutzern durchgef¸hrt. Diese Umfragen konzentrierten sich auf die Benutzeroberfl‰che, die Verst‰ndlichkeit der Steuerbefehle und das allgemeine Nutzererlebnis. - Usability-TestsIn simulierten Szenarien wurden die Testnutzer gebeten, das System zu bedienen, w‰hrend ihre Interaktionen beobachtet und analysiert wurden. Besonderes Augenmerk lag auf der intuitiven Bedienbarkeit und der Effizienz der Benutzerinteraktion in kritischen Situationen.   3. Ergebnisse der Evaluierung  Die Evaluierung ergab vielversprechende Ergebnisse sowohl im technischen als auch im ben;1
Neben der erfolgreichen Implementierung eines virtuellen MQTT-Szenarios konnte die Erkenntnis gewonnen werden, dass nebenl‰ufige Programme in Python mithilfe der threa- ding-Bibliothek ohne groﬂen Aufwand entwickelt werden kˆnnen. Dadurch konnten die DatengeneratorenmitwenigBoilerplate-CodeindieSensor-Ger‰tederSimulationintegriert werden. Des Weiteren eignet sich das Projekt Material for MkDocs f¸r Projektdokumenta- tionen. Dies hat den Grund, dass die Heuristiken f¸r die Usability von Dokumentation nach Meng, Steinhardt und Schubert  wie einer m‰chtigen Suchfunktion oder Code-Annotationen mit wenigen Anpassungen realisiert werden kˆnnen. Zusammenfas- send w¸rde es sich lohnen, das virtuelle MQTT-Szenario in einer Lehrveranstaltung zu verwenden, um zu pr¸fen, ob es den Einstieg in das MQTT-Protokoll vereinfacht. 6.2 Ausblick und n‰chste Schritte EsgabnochkeineMˆglichkeit,dasProgrammineinerLehrveranstaltungmitStudent*innen einzusetzen, wodurch noch keine Aussagen gemacht werden kˆnnen, ob sich durch die Lˆsung das Verst‰ndnis f¸r das MQTT-Protokoll verbessert bzw. den Einstieg erleichtert. Wenn dies der Fall ist, kann die Lˆsung erweitert werden, indem z.B. mehr Ger‰te eines Smart Homes implementiert werden, das Frontend durch Grafiken oder Icons verbessert wird oder die Testabdeckung erhˆht wird. Des Weiteren kˆnnten die Interaktionen zwischen den MQTT-Ger‰ten durch Integrationstests auf Korrektheit gepr¸ft werden. Die Lˆsung dieser Arbeit hat sich grˆﬂtenteils auf einer hˆheren Abstraktionsebene mit demMQTT-Protokoll besch‰ftigt. Wie die MQTTControl Packets und somit die Kommu- nikation zwischen Broker und Client auf der Byte-Ebene aussehen, wird mit der Lˆsung nicht ersichtlich. Hierbei w‰re es denkbar, die MQTT-Clients der verwendeten paho-mqtt - Bibliothek mit selbst implementierten Funktionen zu manipulieren, um die ausgetauschten Control Packets zur Analyse nach auﬂen sichtbar zu machen. Alternativ kann von Grund auf eine MQTT-Client-Library entwickelt werden, welche sich auf Lehrzwecke und eine gute Lesbarkeit des Quelltexts spezialisiert.;0
" Konzept f¸r eine wissenschaftliche Arbeit: ""State of the Art beim Testen von MQTT-basierten Lˆsungen""   1. Einleitung    - Hintergrund und Motivation: Das Internet der Dinge (IoT) hat die Nutzung von Messaging-Protokollen wie MQTT (Message Queuing Telemetry Transport) gefˆrdert. MQTT ist leichtgewichtig und optimiert f¸r Umgebungen mit begrenzten Ressourcen. Die Gew‰hrleistung der Qualit‰t und Zuverl‰ssigkeit dieser Systeme erfordert effektive Testmethoden.    - Ziel der Arbeit: Untersuchung und Analyse aktueller Methoden und Techniken zum Testen von MQTT-basierten Lˆsungen. Identifizierung von Herausforderungen und Trends in der Testpraxis.   2. Theoretische Grundlagen    - MQTT Architektur: Erl‰uterung des Protokolls, seiner Funktionsweise und der Nutzung in IoT-Anwendungen.     - Testen in der Softwareentwicklung: ‹berblick ¸ber allgemeine Testmethoden (Unit-, Integrations-, System- und Akzeptanztests).    - Bedeutung des Testens f¸r MQTT: Besonderheiten und Herausforderungen beim Testen von verteilten Systemen, insbesondere bei der Nutzung von MQTT.   3. Stand der Technik    - Literatur¸bersicht: Zusammenstellung und Analyse bestehender Literatur und Forschung zu Testmethoden f¸r MQTT-basierten Systeme.    - Testmethoden und -werkzeuge:      - Manuelle Tests: Ans‰tze und Strategien f¸r manuelle Tests in MQTT-Umgebungen.      - Automatisierte Tests: Tools und Frameworks, die speziell f¸r MQTT entwickelt wurden (z.B. MQTT.fx, mosquitto, Paho).      - Lasttests und Stress-Tests: Methoden zur Performance- und Lastbewertung von MQTT-Systemen.      - Sicherheitstests: Analyse von Ans‰tzen zur Sicherstellung der Sicherheit in MQTT-Implementierungen.   4. Herausforderungen beim Testen von MQTT-basierten Lˆsungen    - Netzwerklatenz und -zuverl‰ssigkeit: Einfluss von Netzwerkbedingungen auf die Testresultate.    - Skalierbarkeit: Schwierigkeiten bei Tests in groﬂen verteilten Systemen.    - Fehlertoleranz: Umgang mit potenziellen Fehlern und deren Auswirkungen auf Tests.    - Echtzeitanforderungen: Ber¸cksichtigung von Anforderungen an die Echtzeitkommunikation.   5. Fallstudien    - Analyse konkreter MQTT-Anwendungen: Untersuchung von realen MQTT-basierten Systemen und deren Testmethoden.     - Vergleich der Ans‰tze: Bewertung der Effektivit‰t unterschiedlicher Testmethoden und -tools in den Fallstudien.   6. Trends und zuk¸nftige Entwicklungen    - Integration neuer Technologien: Einsatz von KI und Machine Learning zur Automatisierung von Tests.    - Continous Integration/Continuous Deployment (CI/CD): Implementierung von MQTT-Testverfahren in CI/CD-Pipelines.    - Open-Source-Werkzeuge: Potenzial von Open-Source-Tools f¸r die Verbesserung der Testmethoden.   7. Fazit und Ausblick    - Zusammenfassung der Ergebnisse: ‹berblick ¸ber die wichtigsten Erkenntnisse dieser Arbeit.    - Empfehlungen f¸r die Praxis: Vorschl‰ge f¸r Best Practices beim Testen von MQTT-basierten Lˆsungen.    - Forschungsperspektiven: Hinweise auf zuk¸nftige Forschungsarbeiten, die in diesem Bereich relevant sein kˆnnten.   8. Literaturverzeichnis    - Zusammenstellung aller verwendeten Quellen und relevanten Literatur zu MQTT und Testmethoden.  ---   Methodik - Datenanalyse: Systematische Analyse der bestehenden Literatur und Fallstudien. - Interviews mit Experten: Einbeziehung von Interviews mit Fachleuten aus der Industrie zur Sammlung von Praxiserfahrungen. - Experimentelle Tests: Durchf¸hrung eigener Tests mit verschiedenen Tools und Methoden zur praktischen Validierung der Ergebnisse.  Dieses Konzept bildet die Grundlage f¸r die Erstellung einer detaillierten und fundierten wissenschaftlichen Arbeit ¸ber den aktuellen Stand der Testmethoden f¸r MQTT-basierte Lˆsungen.";1
Ein Fazit  In den letzten Jahren hat sich das Internet der Dinge (IoT) rasant entwickelt, wodurch die Nutzung von Kommunikationsprotokollen, wie MQTT (Message Queuing Telemetry Transport), an Bedeutung gewonnen hat. MQTT stellt aufgrund seiner Leichtigkeit und Effizienz ein hervorragendes Werkzeug f¸r die Umsetzung diverser IoT-Szenarien dar. Im Rahmen unseres Projekts mutierten wir das theoretische Verst‰ndnis in die praktische Anwendung, indem wir ein virtuelles MQTT-Szenario entwickelten, das in Bildungseinrichtungen als Lehrwerkzeug genutzt werden kann.  Das Szenario behandelt nicht nur grundlegende Funktionen von MQTT, sondern bezieht auch die Prinzipien der IoT-Architektur ein. Durch den Aufbau eines simulierten Netzwerks, bestehend aus mehreren MQTT-Clients und einem Server (Broker), gelang es uns, unterschiedliche Anwendungsf‰lle zu realisieren. Diese umfassten die sensorgest¸tzte ‹bermittlung von Umweltdaten, wie Temperatur und Luftfeuchtigkeit, sowie die Fernsteuerung von Ger‰ten. Das interaktive Lehrkonzept fˆrderte nicht nur das technische Verst‰ndnis, sondern setzte auch auf aktives Lernen, indem die Studierenden selbst‰ndig Versuche durchf¸hren konnten.  Ein zentrales Ergebnis der Durchf¸hrung dieses Projektes war die Erkenntnis, dass praktische Herausforderungen in der Systemintegration und Fehlermanagement unverzichtbare Bestandteile der Lernsituation sind. Die Methode des Ñlearning by doingì erwies sich als besonders effektiv, da die Studierenden durch unmittelbare Erfahrungen nicht nur Wissen akquirieren, sondern auch Problemlˆsungskompetenzen entwickeln konnten. Weiterhin fˆrderte der kollaborative Aspekt des Projektes, bei dem Teams unterschiedliche Aufgaben bearbeiteten und voneinander lernten, den sozialen Austausch unter den Teilnehmenden und st‰rkte den Teamgeist.   Das Feedback der Teilnehmer war durchweg positiv. Die Mˆglichkeit, mit realistischen Szenarien zu arbeiten, f¸hrt zu einem deutlichen Anstieg des Interesses und der Motivation, auch komplexe Themen der Informatik zu ergr¸nden. Zuk¸nftige Implementierungen des Projektes sollten zus‰tzlich multidisziplin‰re Ans‰tze integrieren, indem beispielsweise die Konzepte von MQTT mit Bereichen wie Maschinenlernen oder K¸nstlicher Intelligenz in Verbindung gebracht werden.   Zusammenfassend l‰sst sich sagen, dass die Entwicklung eines virtuellen MQTT-Szenarios nicht nur das technische Verst‰ndnis der Teilnehmenden entscheidend verbessert hat, sondern auch als Modell f¸r innovative Lehrmethoden dienen kann. Die positiven R¸ckmeldungen und Lernerfahrungen ermutigen uns, das watt Pool des theoretischen Verst‰ndnisses um praktische MPI-Elemente zu erweitern sie mit syntaktisch vielf‰ltigen und realit‰tsnahen Anwendungsfeldern perspektivisch zu kombinieren, um das Lehren und Lernen in der Gebiet der IoT-Technologien weiter voranzutreiben.;1
Auf diesem Fragment gibt es noch zwei Knˆpfe: Ein Knopf f¸r die Ein- und Ausschaltung des Alarms und ein f¸r die Bedienungsanleitung (rechts in der Abbildung 4.4). Der Luftreiniger wird jeden Tag um 22:00 Uhr automatisch auf die hˆchste Betriebsstufe (FAR-UVC) geschaltet, wenn der Alarm eingeschaltet ist. In der Abbildung 4.5 ist das Fragment f¸r die Visualisierung der verschiedene Sensordaten abgebildet. Die Benutzer*innen kˆnnen entweder die letzten vierundzwanzig Stunden, sie- ben oder einunddreiﬂig Tage ausw‰hlen. Nachdem Dr¸cken des ausgew‰hlten Zeitintervalls werden die Diagramme aktualisiert. Auf den Diagrammen werden die Informationen ¸ber die Temperatur, die Helligkeit, das Ger‰usch, den Luftdruck und die Humidit‰t darge- stellt. Auf der x-Achse ist das jeweilige Zeitintervall zu sehen und auf der y-Achse sind die automatisch skalierte Werte dargestellt. Wurde ein Zeitintervall ausgew‰hlt, m¸ssen die Nutzer*innen durch Bet‰tigung des Aktualisierungsknopfs die Diagramme manuell neuladen.;0
Ausblick  Die vorliegende Arbeit hat sich intensiv mit der Entwicklung einer Fahrzeugfernsteuerung besch‰ftigt, die auf dem IEEE 802.15 Standard basiert und innovative Ans‰tze zur Kollisionsvermeidung integriert. Die Ergebnisse zeigen vielversprechende Ans‰tze zur Verbesserung der Sicherheit und Effizienz im Bereich der Fernsteuerung von Fahrzeugen. Die Implementierung von drahtlosen Kommunikationsprotokollen ermˆglicht nicht nur eine flexible Steuerung, sondern auch die Echtzeit-Daten¸bertragung zwischen dem Fahrzeug und der Steuerungseinheit.  Ein zentraler Aspekt der zuk¸nftigen Entwicklungen in diesem Bereich wird die Weiterentwicklung der Algorithmen zur Kollisionsvermeidung sein. W‰hrend die aktuellen Ans‰tze bereits grundlegende Sicherheitsmechanismen bieten, besteht ein erhebliches Potenzial f¸r die Integration von maschinellem Lernen und KI-Technologien. Diese kˆnnten dazu beitragen, die Reaktionszeiten zu optimieren und die Vorhersagegenauigkeit in komplexen Verkehrssituationen zu erhˆhen.   Dar¸ber hinaus kˆnnte die Erweiterung des Systems um zus‰tzliche Sensoren, wie z.B. LiDAR oder Kameras, die Situationswahrnehmung und Entscheidungsfindung des Fahrzeugs weiter verbessern. Die Kombination dieser Technologien kˆnnte nicht nur die Sicherheit erhˆhen, sondern auch die Akzeptanz autonomer und fernsteuerbarer Fahrzeuge in der Gesellschaft fˆrdern.  Ein weiterer wichtiger Aspekt ist die Interoperabilit‰t mit bestehenden Verkehrssystemen und die Einhaltung von Sicherheitsstandards. Zuk¸nftige Forschungsarbeiten sollten sich darauf konzentrieren, wie die entwickelte Technologie nahtlos in bestehende Infrastrukturen integriert werden kann, um die Akzeptanz und den praktischen Nutzen zu maximieren.   Schlieﬂlich wird die gesellschaftliche Dimension der Fahrzeugfernsteuerung nicht zu vernachl‰ssigen sein. Die ethischen Implikationen und die Nutzerakzeptanz m¸ssen ebenso in zuk¸nftige Studien einflieﬂen, um ein umfassendes Verst‰ndnis f¸r die Auswirkungen dieser Technologien auf die Mobilit‰t der Zukunft zu gewinnen.  Insgesamt erˆffnet die Entwicklung einer Fahrzeugfernsteuerung mit Kollisionsvermeidung auf Basis von IEEE 802.15 nicht nur neue technische Mˆglichkeiten, sondern wirft auch eine Vielzahl von Fragen auf, die in den kommenden Jahren weiter erforscht werden m¸ssen. Die vorliegende Arbeit legt somit den Grundstein f¸r zuk¸nftige Innovationen in der Fahrzeugtechnologie und der intelligenten Verkehrssysteme.;1
Eine vergleichende Analyse der theoretischen Grundlagen  Die Programmiersprachen Java und Kotlin haben sich in den letzten Jahren als zentrale Akteure in der Entwicklung von Software, insbesondere im Bereich der Android-Entwicklung, etabliert. Beide Sprachen weisen fundamentale Unterschiede in ihrer Syntax, Typensystematik und in der Art und Weise auf, wie sie mit Programmierparadigmen umgehen. Diese Unterschiede kˆnnen auf die theoretischen Grundlagen zur¸ckgef¸hrt werden, die den jeweiligen Sprachen zugrunde liegen.  1. Historischer Kontext und Evolution  Java wurde 1995 von Sun Microsystems eingef¸hrt und hat sich schnell zu einer der am weitesten verbreiteten Programmiersprachen entwickelt. Die Sprache wurde mit dem Ziel konzipiert, plattformunabh‰ngig zu sein, was durch das Konzept der Java Virtual Machine (JVM) ermˆglicht wird. Java verfolgt ein objektorientiertes Paradigma und legt groﬂen Wert auf die Prinzipien der Kapselung, Vererbung und Polymorphie.  Kotlin hingegen wurde 2011 von JetBrains vorgestellt und zielt darauf ab, die Einschr‰nkungen von Java zu ¸berwinden. Kotlin ist eine statisch typisierte Sprache, die auf der JVM l‰uft und vollst‰ndig interoperabel mit Java ist. Die Sprache wurde mit dem Ziel entwickelt, eine pr‰gnantere und sicherere Syntax bereitzustellen, die moderne Programmierpraktiken unterst¸tzt.  2. Typensystem und Null-Sicherheit  Ein grundlegendes theoretisches Konzept, das Java und Kotlin unterscheidet, ist das Typensystem. Java verwendet ein reines objektorientiertes Paradigma, in dem primitive Datentypen (wie int, char, etc.) von Objekten (wie Integer, Character, etc.) getrennt sind. Dies kann zu Problemen f¸hren, insbesondere im Hinblick auf Nullwerte, die in Java zu NullPointerExceptions f¸hren kˆnnen.  Kotlin hingegen integriert primitive Typen und Objekte in ein einheitliches Typensystem. Dar¸ber hinaus implementiert Kotlin eine Null-Sicherheit auf Sprachebene, die es Entwicklern ermˆglicht, NullPointerExceptions zu vermeiden. In Kotlin m¸ssen Variablen, die null sein kˆnnen, explizit als nullable deklariert werden. Dies fˆrdert eine sicherere Programmierung und zwingt Entwickler, sich aktiv mit dem Umgang von Nullwerten auseinanderzusetzen.  3. Syntax und Ausdruckskraft  Die Syntax von Java ist bekannt f¸r ihre Verbosit‰t. Dies kann in groﬂen Codebasen zu einer erhˆhten Komplexit‰t f¸hren. Kotlin hingegen bietet eine kompakte und ausdrucksstarke Syntax, die es Entwicklern ermˆglicht, weniger Code zu schreiben, um die gleiche Funktionalit‰t zu erreichen. Dies wird durch Funktionen wie Lambda-Ausdr¸cke, Datenklassen und Erweiterungsfunktionen unterst¸tzt. Diese Merkmale fˆrdern nicht nur die Lesbarkeit des Codes, sondern auch die Wartbarkeit und Testbarkeit.  4. Programmierparadigmen  Java ist stark auf das objektorientierte Programmieren (OOP) ausgerichtet. W‰hrend es auch funktionale Elemente unterst¸tzt, bleibt der Fokus auf Klassen und Objekten. Kotlin hingegen ist eine hybride Sprache, die sowohl objektorientierte als auch funktionale Programmierparadigmen unterst¸tzt. Dies ermˆglicht es Entwicklern, die Vorteile beider Paradigmen zu nutzen und eine flexibl;1
Auch bei Drupal findet das Prinzip des WYSIWYG -Editors Anwendung. Eine Aufteilung der Inhaltstypen in Blˆcke ist hierbei jedoch nicht vorgesehen. Sollen Inhalte in ihrer Anordnung abge‰ndert werden, so m¸ssen diese direkt innerhalb des Editors verschoben werden, was die Handhabung und Benutzerfreundlichkeit mindert. Da die Grundprinzipien des WYSIWYG -Ansatzes innerhalb von Drupal auch ohne zus‰tz- liche Installation der Gutenberg-Erweiterung verfolgt werden, wird auch Drupal mit der Kategorie Gr¸n eingestuft.;0
Ausblick f¸r die wissenschaftliche Arbeit: Anforderungsanalyse an ein Aufgabenmanagement-Tool zur Unterst¸tzung des studentischen Software Engineerings  Im Zuge dieser wissenschaftlichen Arbeit wurde eine umfassende Anforderungsanalyse f¸r ein Aufgabenmanagement-Tool entwickelt, das speziell auf die Bed¸rfnisse von Studierenden im Bereich Software Engineering zugeschnitten ist. Der Fokus lag auf der Identifikation und Priorisierung der funktionalen und nicht-funktionalen Anforderungen, um ein benutzerfreundliches und effizientes Werkzeug zu schaffen.   In der sich stetig wandelnden Landschaft der Softwareentwicklung ist die Notwendigkeit f¸r effektive Werkzeuge zur Unterst¸tzung des Lernprozesses und der Projektarbeit unbestreitbar. Die vorliegende Arbeit hat die Relevanz solcher Tools unterstreicht und gezeigt, wie wichtig es ist, dass Studierende Zugang zu intuitiven und anpassbaren Lˆsungen haben, die ihre Produktivit‰t und Zusammenarbeit fˆrdern.  Im Ausblick soll verdeutlicht werden, welche weiteren Schritte und Forschungsans‰tze notwendig sind, um die Implementierung und Evaluierung des entwickelten Tools zu realisieren. Hierbei ist es entscheidend, nicht nur die technischen Anforderungen weiter zu vertiefen, sondern auch die Benutzerfreundlichkeit kontinuierlich durch Nutzerfeedback zu verbessern. K¸nftige Forschung kˆnnte sich darauf konzentrieren, die Integration des Tools in bestehende Lernmanagementsysteme zu untersuchen, um einen reibungslosen Wissensaustausch und eine nahtlose Zusammenarbeit zwischen Studierenden und Dozenten zu ermˆglichen.  Ein weiterer wichtiger Aspekt ist die Betrachtung von adaptiven und intelligenten Funktionen innerhalb des Tools, die auf maschinellem Lernen basieren und das Nutzerverhalten analysieren, um personalisierte Empfehlungen zu geben. Dies kˆnnte die Effizienz zus‰tzlich steigern und den Lernprozess erheblich unterst¸tzen.  Zusammenfassend l‰sst sich sagen, dass die entwickelten Anforderungen lediglich den ersten Schritt in einem umfassenden Forschungsprozess darstellen. Die potenzielle Auswirkung eines effektiven Aufgabenmanagement-Tools auf das studentische Software Engineering ist erheblich. Zuk¸nftige Studien sollten auch die Langzeitwirkungen solcher Instrumente auf die Lernergebnisse und die Projektergebnisse im Umfeld des studentischen Software Engineerings untersuchen, um das volle Potenzial der Digitalisierung in der Ausbildung auszuschˆpfen.;1
 State of the Art beim Testen von MQTT-basierten LˆsungenEin Fazit  Das Message Queuing Telemetry Transport (MQTT) Protokoll hat sich in den letzten Jahren als Standard f¸r die Kommunikation in Internet of Things (IoT)-Anwendungen etabliert. Seine Lightweight-Natur, die Unterst¸tzung mobiler Ger‰te und sykdom¸bertragene Umgebungen sowie die hohe Effizienz in der Nachrichten¸bertragung haben MQTT zu einer bevorzugten Wahl f¸r Entwickler in diversen Anwendungsbereichen gemacht.  Gem‰ﬂ der aktuellen Literatur und Entwicklungen sind die g‰ngigsten Ans‰tze zum Testen von MQTT-basierten Lˆsungen im Wesentlichen dreidimensional strukturiertfunktionales Testen der Anwendung, Last- und Performancetests sowie Sicherheitstests. Der Trend geht dabei in Richtung Automatisierung und die Integration von Testumgebungen in CI/CD-Pipelines, um kontinuierliches Testen in der Softwareentwicklung zu ermˆglichen.  Funktionales Testen Ein Ansatz, der sich durchgesetzt hat, ist die Verwendung von speziellen Testing-Tools wie MQTT.fx oder Mosquitto sowie von Frameworks wie Paho oder HiveMQ. Diese Werkzeuge erlauben ein umfassendes Testen der grundlegenden MQTT-Funktionalit‰ten, wie etwa das Publish-Subscribe-Modell, QoS-Level (Quality of Service), Beziehungsmanagement und Lastdauergetreue Nachrichten¸bertragung. Bedeutsam ist hier auch die Abbildung des idealen Anwendungsconstants, um kritische F‰lle wie identische Publish-Message Retrievals zu ¸berpr¸fen.  Last- und Performancetests Die Belastung von MQTT-Botschaften l‰sst sich durch recht ausgewogene Messaufbauten wie JMeter oder Gatling gut ermitteln. Diese Tools bieten nicht nur Mˆglichkeiten zur Erstellung von Test-Skripten, sondern enthalten auch Funktionalit‰ten zur Analyse der Erhebung der statistischen Ergebnisse ¸ber die Protokollebene hinweg. Es ist haupts‰chlich wichtig, die Performance bei zunehmender Teilnehmerzahlen, latente Antwortzeiten sowie die Stabilit‰t der Broker zu testen. Lasttests gemischt mit unterschiedlicher QoS kˆnnen Klarheit ¸ber das eigentliche Verhaltensspektrum bieten.  Sicherheitstests Der Schutz von IoT-Lˆsungen wurde im Laufe der Zeit zu einer entscheidenden Frage, weshalb neue Pr¸fprotokolle momentan fortlaufend implementiert werden. Tests werden h‰ufig durchmodularisierten Werkzeuge durchgef¸hrt, wie etwa OWASP ZAP f¸r Schwachstellenabbau und Penetrationstests im Vorabgangsbereich, das interne Sicherheitsprotokolle der Broker wie die Verschl¸sselung durch SSL/TLS analysiert. Der authentische Zugriff- und Berechtigungstest f¸r am Netzwerk teilnehmende interaktive Ger‰te gehˆrt hierbei zu einem oft ¸bersehenen kritischem Komponenten.  Fazit Zusammenfassend lieﬂ sich feststellen, dass state-of-the-art Techniken im Testing von MQTT-basierten Lˆsungen maﬂgeblich durch Automatisierung und Integration in moderne Entwicklungspraktiken gepr‰gt sind. Selbst wenn bedeutende Fortschritte gemacht werden, bleibt eine kontinuierliche Evaluierung und Weiterentwicklung von Testmethoden bei immer exakterer Fragestellung weiterhin erforderlich. Ursachen liegen vor allem in der starken Diversifizierung des IoT-÷kosystems, technischen Next-GenerationProblemen und im adaptiven Bedarf an Sicherheitsmaﬂnahmen. R¸ckblickend hat unser Projekt energiespar;1
ïNoch kein etablierter Industriestandard Die Begeisterung der Entwickelnden f¸r den neuen deklarativen Ansatz und auch die Grˆﬂe der mit dem Jetpack Compose Frameworks in Verbindung stehenden Commu- nity steigt zwar kontinuierlich an, allerdings handelt es sich dabei noch um keinen fest etablierten Industriestandard, der regelm‰ﬂig im industriellen und produzierenden Umfeld eingesetzt wird . Die Mehrheit der Community und auch die bereits in Kapitel 4.1.3 erw‰hnten grˆﬂeren Unternehmen, die Compose bereits in ihrem laufenden Betrieb testen, schreiben dem Ansatz jedoch eine groﬂe Bedeutung zu und gehen von einem Trend aus, der sich immer mehr von der Verwendung des klassischen imperativen Ansatzes abwendet. Viele sehen in diesem Bereich einen bevorstehenden Wandel, der sich ‰hnlich ‰uﬂern kˆnnt wie damals beim Wechsel von Java zu Kotlin als bevorzugte Sprache f¸r die Android-Programmierung .;0
Ausblick  In der vorliegenden Arbeit wurde eine umfassende Gegen¸berstellung von Content-Management-Systemen (CMS) durchgef¸hrt, die sowohl die technischen als auch die praktischen Aspekte dieser Systeme beleuchtet. Die Analyse hat gezeigt, dass die Wahl des richtigen CMS entscheidend f¸r den Erfolg digitaler Projekte ist, da sie nicht nur die Benutzerfreundlichkeit und Effizienz der Content-Erstellung beeinflusst, sondern auch die langfristige Wartbarkeit und Skalierbarkeit der digitalen Plattformen.  Im Zuge der fortschreitenden Digitalisierung und der stetig wachsenden Anforderungen an Unternehmen, sich flexibel an Marktver‰nderungen anzupassen, wird die Relevanz von CMS in den kommenden Jahren weiter zunehmen. Zuk¸nftige Forschung kˆnnte sich darauf konzentrieren, wie neue Technologien, wie K¸nstliche Intelligenz und maschinelles Lernen, die Entwicklung und Funktionalit‰t von CMS beeinflussen. Insbesondere die Automatisierung von Inhalten, personalisierte Nutzererfahrungen und die Integration von Datenanalyse-Tools werden voraussichtlich zentrale Themen sein, die die CMS-Landschaft pr‰gen werden.  Dar¸ber hinaus kˆnnte eine vertiefte Untersuchung der Benutzerakzeptanz und der spezifischen Anforderungen unterschiedlicher Zielgruppen wertvolle Erkenntnisse liefern. Die Ber¸cksichtigung von Aspekten wie Barrierefreiheit, mehrsprachige Inhalte und die Integration sozialer Medien wird immer wichtiger, um den vielf‰ltigen Bed¸rfnissen der Nutzer gerecht zu werden.  Abschlieﬂend l‰sst sich festhalten, dass die Gegen¸berstellung von Content-Management-Systemen nicht nur eine Momentaufnahme der aktuellen Technologien darstellt, sondern auch einen Ausblick auf zuk¸nftige Entwicklungen bietet. Die dynamische Natur des digitalen Marktes erfordert kontinuierliche Anpassungen und Innovationen, die sowohl Anbieter als auch Anwender von CMS vor neue Herausforderungen stellen werden. Die vorliegende Arbeit legt den Grundstein f¸r weitere Untersuchungen und Diskussionen in diesem spannenden und sich st‰ndig weiterentwickelnden Bereich.;1
    In der heutigen Bildungslandschaft wird die F‰higkeit, Softwareprojekte effizient zu managen, f¸r angehende Software-Ingenieure zunehmend wichtiger. Die Komplexit‰t von Software-Projekten erfordert nicht nur technische Fertigkeiten, sondern auch ein ad‰quates Management von Aufgaben, Ressourcen und Zeit. Vor diesem Hintergrund ist die Entwicklung eines effektiven Aufgabenmanagement-Tools von entscheidender Bedeutung, um die dringend benˆtigte Unterst¸tzung f¸r studentisches Software Engineering zu bieten. Die vorliegende Arbeit widmet sich der Anforderungsanalyse f¸r ein solches Tool und entwirft ein Konzept zur Umsetzung.  1. Zielsetzung und Bedeutung der Anforderungsanalyse  Eine pr‰zise Anforderungsanalyse bildet das Fundament f¸r die Entwicklung eines erfolgreichen Softwareprodukts. Im Kontext der Erstellung eines Aufgabenmanagement-Tools f¸r studentisches Software Engineering besteht das Hauptziel darin, die spezifischen Bed¸rfnisse der Benutzer zu identifizieren und zu strukturieren. Die Bedeutung dieser Analyse liegt in der Sicherstellung, dass das entwickelte Tool nicht nur funktional ist, sondern auch anwenderfreundlich, skalierbar und anpassungsf‰hig an verschiedene Projektanforderungen.  2. Methodische Vorgehensweise  Die Anforderungsanalyse erfolgt in mehreren Phasen - LiteraturrechercheEine umfassende Analyse bestehender Tools und deren Funktionen wird durchgef¸hrt, um Best Practices zu identifizieren und L¸cken im derzeitigen Angebot zu erkennen.  - Befragungen und WorkshopsUm ein tieferes Verst‰ndnis f¸r die Bed¸rfnisse der Studierenden zu gewinnen, werden qualitative Interviews sowie quantitative Umfragen durchgef¸hrt. Workshops mit Studierenden und Lehrenden ermˆglichen es, interaktive R¸ckmeldungen zu den gew¸nschten Funktionen zu erhalten.  - Kategorisierung der AnforderungenDie gesammelten Informationen werden in funktionale und nicht-funktionale Anforderungen kategorisiert, um eine klare ‹bersicht ¸ber die Erwartungen an das Tool zu schaffen.  3. Funktionale Anforderungen  Funktionale Anforderungen beschreiben spezifische Verhaltensweisen des Systems. F¸r das Aufgabenmanagement-Tool ergeben sich folgende Kernanforderungen - AufgabenverwaltungBenutzer m¸ssen in der Lage sein, Aufgaben zu erstellen, zu bearbeiten, zu priorisieren und zu lˆschen. Die Mˆglichkeit, Aufgaben bestimmten Projekten oder Teammitgliedern zuzuordnen, ist ebenfalls essentiell.  - ZeiterfassungDie Implementierung von Zeitmanagement-Funktionen, einschlieﬂlich der Mˆglichkeit, Aufwand f¸r einzelne Aufgaben zu erfassen und Fortschritte zu visualisieren, ist von hoher Bedeutung.  - KollaborationFunktionen zur Unterst¸tzung der Teamarbeit, wie gemeinsame To-Do-Listen, Kommentarfunktionen und Benachrichtigungen, fˆrdern die Kommunikation unter Studierenden.  - BerichtswesenDie Mˆglichkeit, ‹bersichtsberichte und Analysen zu generieren, ermˆglicht den Studierenden, ihre Fortschritte zu evaluieren und anzupassen.  4. Nicht-funktionale Anforderungen  Nicht-funktionale Anforderungen sind ebenfalls entscheidend f¸r den Erfolg des Tools - BenutzerfreundlichkeitDas Interface sollte intuitiv gestaltet sein, um eine hohe Akzeptanz bei den Nutzern zu gew‰hrleisten. Eine lernfreundliche Oberfl‰che, die auch neue Benutzer schnell einf¸hrt, ist unerl‰sslich.  - Zug‰nglichkeitDas Tool sollte plattform¸bergreifend sein, um den unterschiedlichen technischen Voraussetzungen der Studierenden gerecht zu werden. Eine webbasierte Lˆsung kˆnnte hier sinnvoll sein.  - SicherheitDatenschutz und Datensicherheit m¸ssen gew‰hrleistet sein, um die sensiblen Projektinformationen der Nutzer zu sch¸tzen.  5. Umsetzungskonzept  Basierend auf den identifizierten Anforderungen wird ein schrittweises Umsetzungskonzept entwickelt 1. PrototypingDie Entwicklung eines Prototyps ermˆglicht es, fr¸hzeitig Benutzerfeedback zu sammeln und Anpassungen vorzunehmen.  2. Iterative EntwicklungEin agiler Entwicklungsansatz fˆrdert die kontinuierliche Verbesserung des Tools, basierend auf den R¸ckmeldungen der Benutzer und sich ‰ndernden Anforderungen.  3. TestphaseNach der Umsetzung muss das Tool umfangreich getestet werden, um sicherzustellen, dass alle Anforderungen erf¸llt sind und die Benutzerfreundlichkeit gegeben ist.  4. Einf¸hrungsstrategieUm das Tool effektiv bei Studierenden einzuf¸hren, sind Schulungen und Unterst¸tzung erforderlich. Tutorials, FAQs und Community-Support kˆnnen hier wertvolle Hilfe leisten.  Schlussfolgerung  Die Anforderungsanalyse bildet das R¸ckgrat f¸r die Entwicklung eines effektiven Aufgabenmanagement-Tools, das die Herausforderungen des studentischen Software Engineerings adressiert. Durch die Kombination aus funktionalen und nicht-funktionalen Anforderungen sowie einem klaren Umsetzungskonzept kann sichergestellt werden, dass das Tool nicht nur eine pragmatische Lˆsung bietet, sondern auch einen Mehrwert f¸r die Lehr- und Lernprozesse im Bereich Software Engineering schafft. In dieser Hinsicht schafft die vorliegende Analyse einen soliden Rahmen, um die wensen der Studierenden in ein effektives Produkt zu transferieren und somit deren Erfolg bei der Umsetzung komplexer Softwareprojekte zu fˆrdern.;1
"TitelZero ñ Mˆglichkeiten und Gefahren der digitalen ‹berwachungEin Konzept zur Umsetzung    Die digitale ‹berwachung hat in den letzten Jahren an Bedeutung gewonnen, sowohl im ˆffentlichen als auch im privaten Sektor. Mit der fortschreitenden Digitalisierung und der zunehmenden Vernetzung von Ger‰ten und Systemen ist die Erfassung, Speicherung und Analyse von Daten zu einer Schl¸sselkomponente moderner Gesellschaften geworden. Das Konzept ""Zero"" zielt darauf ab, die Mˆglichkeiten der digitalen ‹berwachung zu erfassen und gleichzeitig die damit verbundenen Gefahren zu analysieren. In diesem Prosatext wird ein Konzept zur Umsetzung von ""Zero"" vorgestellt, das sowohl technologische als auch ethische Aspekte ber¸cksichtigt.  Mˆglichkeiten der digitalen ‹berwachung  Die digitale ‹berwachung bietet zahlreiche Chancen, die weit ¸ber die reine Datenanalyse hinausgehen. In Bereichen wie der ˆffentlichen Sicherheit, dem Gesundheitswesen und der Wirtschaft kˆnnen durch intelligente ‹berwachungssysteme wertvolle Erkenntnisse gewonnen werden. Beispielsweise ermˆglicht die Analyse von Verkehrsstrˆmen in Echtzeit die Optimierung von Verkehrsmanagementsystemen, was zu einer Reduktion von Staus und Emissionen f¸hren kann. Im Gesundheitswesen kˆnnen Wearables und mobile Apps zur ‹berwachung von Vitaldaten dazu beitragen, fr¸hzeitig gesundheitliche Risiken zu identifizieren und pr‰ventive Maﬂnahmen zu ergreifen.  Dar¸ber hinaus kˆnnen datenbasierte Entscheidungsprozesse Unternehmen dabei unterst¸tzen, ihre Effizienz zu steigern und personalisierte Dienstleistungen anzubieten. Die Verwendung von Algorithmen zur Analyse von Kundenverhalten kann beispielsweise die Kundenbindung erhˆhen und neue Gesch‰ftsmˆglichkeiten erschlieﬂen.  Gefahren der digitalen ‹berwachung  Trotz der vielversprechenden Mˆglichkeiten birgt die digitale ‹berwachung auch erhebliche Gefahren. Eine der grˆﬂten Herausforderungen ist der Verlust der Privatsph‰re. Die st‰ndige Erfassung persˆnlicher Daten kann zu einem Gef¸hl der st‰ndigen Beobachtung f¸hren, was das individuelle Verhalten und die Entscheidungsfreiheit einschr‰nkt. Zudem besteht das Risiko von Datenmissbrauch, sei es durch Cyberkriminelle oder durch Unternehmen, die ohne Einwilligung auf sensible Informationen zugreifen.  Ein weiteres Problem ist die potenzielle Verzerrung von Daten und Algorithmen, die zu Diskriminierung f¸hren kann. Wenn ‹berwachungssysteme auf fehlerhaften oder voreingenommenen Daten basieren, kˆnnen sie unfaire Entscheidungen treffen, die bestimmte Gruppen benachteiligen. Diese ethischen Implikationen m¸ssen bei der Entwicklung von ‹berwachungstechnologien unbedingt ber¸cksichtigt werden.  Konzept zur Umsetzung von ""Zero""  Um die Mˆglichkeiten der digitalen ‹berwachung verantwortungsvoll zu nutzen und die damit verbundenen Gefahren zu minimieren, wird ein mehrstufiges Konzept vorgeschlagen 1. Transparenz und Aufkl‰rungEs ist entscheidend, die ÷ffentlichkeit ¸ber die Funktionsweise und die Ziele von ‹berwachungssystemen aufzukl‰ren. Informationskampagnen kˆnnen helfen, das Bewusstsein f¸r Datenschutzrechte zu sch‰rfen und das Vertrauen in digitale Technologien zu st‰rken.  2. Datenschutz durch DesignBei der Entwicklung neuer ‹berwachungstechnologien sollten Datenschutzaspekte von Anfang an integriert werden. Dies umfasst die Anonymisierung von Daten, die Minimierung der Datenspeicherung sowie die Implementierung von Sicherheitsmaﬂnahmen, um unbefugten Zugriff zu verhindern.  3. Regulierung und";1
Sobald innerhalb der App eine Navigation statt?nden soll, muss dem NavController mitgeteilt werden, zu welcher Dimension gewechselt werden soll. Diese wird dabei im NavGraph ¸ber die Route de?niert. Der NavController nimmt diese Informationen an und sorgt daf¸r, dass der entsprechende Inhalt auf dem Bildschirm angezeigt wird . Hierbei bedient er sich der Re- komposition, die jedes Mal automatisch statt?ndet, wenn zwischen Composables navigiert wird. Diese Rekomposition ist einer der Gr¸nde daf¸r, warum empfohlen wird, die Funktion navigate(), welche vom NavController zur Ausf¸hrung der Navigation angeboten wird, immer nur in Callbacks aufzurufen. Ansonsten w¸rde sie mit jeder Rekomposition ausge- f¸hrt, was zu einem merkw¸rdigen Verhalten der Anwendung f¸hren kˆnnte . Die Funktion navigate() bekommt hierbei immer die Route ¸bergeben. Optional besteht auch die Mˆglichkeit, ¸ber die Route Parameter zu ¸bergeben. Diese m¸ssen allerdings als Placeholder in der Route vermerkt werden. Zus‰tzlich ist bei mehreren Parametern die Reihenfolge zu beachten, in der diese ¸bergeben werden. In der Zieldimension m¸ssen diese Werte dann explizit ausgelesen werden, um sie verwenden zu kˆnnen. Ebenfalls unterst¸tzt werden neben optionalen Parametern auch Deeplinks , . Zudem bietet die Bibliothek die Mˆglichkeit, Nested Navigation zu implementieren () und verspricht neben ?¸ssigen und animierten ‹berg‰ngen auch eine einfache Implementierung der Backnavigation sowie die allgemeine Unterst¸tzung der bereits erw‰hnten Navigation Patterns.;0
Die Installation von Drupal erfolgt nach dem gleichen Schema wie WordPress. Nach dem Download der ZIP-Datei des Systems und dem Entpacken und Setzen der Berechtigungen, kann das System direkt im Browser ¸ber den Installationsassistenten eingerichtet werden. Abbildung 5.5: Drupal Installationsassistent im Browser1 Anforderungen an der Server stellt es folgende2: ïEine aktuelle SQL-Server Version (MariaDB 10.3, MySQL 5.7, PostgreSQL oder wahlweise SQLite.) F¸r den Betrieb auf einem Microsoft SQL-Server muss der sogenannte ÑDrupal Driver for SQL Serverì zus‰tzlich installiert werden. ïGem‰ﬂ Drupal Website kann jeder Webserver genutzt werden, der die Anforderungen an PHP erf¸llt ïPHP: Version 7.3 oder hˆher, Composer Erweiterung wird benˆtigt Durch die ebenfalls einfache Installation gegeben durch den Upload des komprimierten Drupal-Verzeichnisses auf einen Webserver wird die Installation von Drupal mit der Farbe Gr¸n kategorisiert.;0
 Evaluation von ElixirNerves als Plattform f¸r IoT-Anwendungen  In der heutigen Welt spielt das Internet der Dinge (IoT) eine entscheidende Rolle in der Vernetzung von Ger‰ten und der automatisierten Datenerfassung. Diese Entwicklung stellt eine Vielzahl an Herausforderungen und Anforderungen an die zugrunde liegenden Softwarearchitekturen. ElixirNerves hat sich als vielversprechende Plattform etabliert, die speziell f¸r die Entwicklung von IoT-Anwendungen konzipiert wurde. Um die Eignung dieser Plattform zu evaluieren, ist es zun‰chst wichtig, die theoretischen Grundlagen des IoT, die Architektur von ElixirNerves sowie deren bedeutende Merkmale zu betrachten.   1.  des IoT  Das Internet der Dinge beschreibt ein Netzwerk von physischen Objekten, die mit Sensoren, Software und weiteren Technologien ausgestattet sind, um Daten auszutauschen und zu kommunizieren. Die theoretischen Aspekte des IoT st¸tzen sich auf verschiedene Disziplinen, einschlieﬂlich Netzwerkprotokolle, Datenmanagement, Sicherheitsaspekte und Interoperabilit‰t. Insbesondere die Konzepte der dezentralen Verarbeitung und der Datenaggregation spielen hierbei eine zentrale Rolle.   Des Weiteren erfordert das IoT eine robuste und skalierbare Softwarearchitektur, die dazu in der Lage ist, Daten in Echtzeit zu verarbeiten. Diese Entwicklungsgrundlagen umfassen unter anderem das Design von Embedded Systems, Cloud-Computing-Architekturen sowie die Implementierung von Datenbanklˆsungen, die den Anforderungen an Geschwindigkeit und Effizienz gerecht werden.   2. Architektur von ElixirNerves  ElixirNerves ist ein Framework, das auf der Programmiersprache Elixir basiert und sich speziell auf die Entwicklung von Embedded Software f¸r IoT-Ger‰te fokussiert. Die zugrunde liegende Architektur von ElixirNerves folgt dem Erlang-VM (BEAM), welche f¸r ihre hervorragende Unterst¸tzung von Nebenl‰ufigkeit, Fehlertoleranz und Verteilung bekannt ist. Diese Eigenschaften sind von zentraler Bedeutung f¸r die anspruchsvollen Bedingungen, unter denen IoT-Ger‰te h‰ufig operieren.  Die Struktur von ElixirNerves ermˆglicht es Entwicklern, Anwendungen modulare und wiederverwendbare Komponenten zu schaffen. Ein zentrales Prinzip hierbei ist die Nutzung von Prozessen, die unabh‰ngig voneinander agieren kˆnnen und durch Nachrichten¸bermittlung miteinander kommunizieren. Diese Herangehensweise maximiert die Effizienz der Datenverarbeitung und ermˆglicht eine hohe Verf¸gbarkeit der Dienste, was im Kontext von IoT-Anwendungen von essenzieller Bedeutung ist.   3. Schl¸sselmerkmale von ElixirNerves  Die Evaluation von ElixirNerves als Plattform f¸r IoT-Anwendungen sollte auch die spezifischen Merkmale dieser Architektur ber¸cksichtigen - Echtzeitf‰higkeitDank der Erlang-VM gestaltet sich die Handhabung von Echtzeitdaten besonders effizient. ElixirNerves ermˆglicht die Verarbeitung von Datenstrˆmen in Echtzeit, was in vielen IoT-Anwendungen, wie beispielsweise in der industriellen Automatisierung, unerl‰sslich ist.  - Verteilte SystemeDas Framework fˆrdert die Entwicklung verteilter Systeme durch eingebaute Mechanismen f¸r die Fehlertoleranz und Lastenverteilung. Das bedeutet, dass IoT-Systeme, die auf ElixirNerves basieren, gegen Ausf‰lle abgesichert sind und auch unter hoher Last effizient arbeiten kˆnnen.  - Integration von Hardware und SoftwareElixirNerves erleichtert die Interaktion zwischen Software und Hardware durch eine Vielzahl von Treibern und unterst¸tzten Protokollen. Dies ermˆglicht Entwicklern, sowohl die Software- als auch die Hardwarekomponenten einer IoT-Lˆsung nahtlos zusammenzuf¸hren.  - Community und ÷kosystemDie aktive Community rund um Elixir und Nerves bietet einen wertvollen Pool an Ressourcen, Bibliotheken und Tools, die den Entwicklungsprozess erheblich beschleunigen und vereinfachen.   Fazit  Zusammenfassend l‰sst sich feststellen, dass ElixirNerves aufgrund seiner einzigartigen Eigenschaften und seiner soliden theoretischen Grundlage eine vielversprechende Plattform f¸r die Entwicklung von IoT-Anwendungen darstellt. Die Kombination aus Echtzeitverarbeitung, Verteilung von Prozessen und der hohen Fehlertoleranz machen es zu einer geeigneten Wahl f¸r Entwickler, die komplexe und zuverl‰ssige IoT-Lˆsungen implementieren mˆchten. Zuk¸nftige Forschungsarbeiten sollten sich darauf konzentrieren, spezifische Anwendungsf‰lle durch empirische Studien zu evaluieren, um die theoretischen Grundlagen weiter zu untermauern und praktische Erfahrungen in die Plattformentwicklung zu integrieren.;1
Um die kontinuierliche Bereitstellung des MQTT Brokers zu gew‰hrleisten und um unge- plante Ausf‰lle und hohe Antwortzeiten zu vermeiden lohnt es sich Skalierungstests am MQTTBroker durchzuf¸hren. Diese sollen aufzeigen wie gut der MQTTBroker mit einer wachsenden Anzahl von verbunden Clients und zu verschickenden und zu empfangenen Nachrichten umgehen kann.   F¸r den Broker sind die dauerhaft aufrechtzuerhaltenden TCPVerbindungen zu allen MQTT Clients eine sehr ressourcenintensive Aufgabe. Auch verschiedene Arten von Spikes in Verbindungen oder Nachrichten m¸ssen getestet werden. Dazu zun‰chst getestet werden wie viele simultane Client Verbindungen der MQTTBroker aufrechterhalten kann, ohne dass der angebotene Service darunter leidet. Daraus l‰sst sich die maximale Kapazit‰t des MQTTBrokers ableiten. Zus‰tzlich sollte auch getestet werden, wie viele Verbindungsan- forderungen der MQTTBroker akzeptieren kann ohne auszufallen oder den Service zu gef‰hrden. Dies kann aufzeigen, wie der MQTTBroker bei gewollten oder unabsichtlichen Denial of Service ( DoS)-Szenarien reagiert. So kann ein Ausfall der Internetverbindung, an welche ein groﬂe Anzahl von MQTTClients angeschlossen ist, zu einem solchen Szenario f¸hren. Sollten die sich daraus ergebenen Kapazit‰ten, mit einem eingerechneten Puffer nicht f¸r den geplanten Einsatzzweck reichen, sollte die Verwendung eines MQTTBroker Clusters in Erw‰gung gezogen werden.    Der n‰chste Schritt ist das Testen der Kombination aus bestehenden Verbindungen und den Verbindungsanforderungen, dies ist im Besonderen bei MQTT Broker Clustern wichtig, um dort das Load Balancing zu testen. Ein weiterer wichtiger Punkt ist, dass alle Test auch mit den gew¸nschten Einstellungen und Umgebung der Endanwendung getestet werden sollten. Dazu gehˆren: ïAnzahl der genutzten Topics ïAnzahl der MQTT Subscriber pro Topic ïAnzahl der ìWildcardî-Subscriptions ïAnzahl der aktiven MQTT Publisher ïDas gew¸nschte QoS-Level ïDie durchschnittliche Nachrichtengrˆﬂe ïEinstellungen bez¸glich der zwischengespeicherten Nachrichten ïNutzung von Transport Layer Security (TLS)       Oft werden von MQTT Subscriber nur wenige Topics des Broker abonniert und sp‰ter ausgewertet, deshalb muss bez¸glich der Topics getestet werden wie hoch die maximale Anzahl an MQTTSubscriber f¸r einen einzelnen Topic ist. Im Umkehrschluss muss auch getestet werden, wie hoch die maximale Anzahl an abonnierten Topics eines einzelnen MQTTSubscriber ist. Anschlieﬂend sollte der allgemeine und zuverl‰ssige Durchsatz von MQTTNachrichten getestet werden, die drei dazu genutzten Kategorien sind in Tabelle 4.2 zu sehen. Fan-in In diesem Szenario werden von einer groﬂen Anzahl von MQTTPublis- her und einer kleineren Anzahl von MQTTSubscriber die entsprechen- den Topics abonniert und empfangen. Dies entspricht zum Beispiel einer Datenarchivierung/-speicherung durch einen Backend-Service. Fan-out Hier werden nur durch eine kleine Anzahl von MQTTPublisher Nach- richten an eine grˆﬂere Anzahl von MQTTSubscriber versendet. Diese Szenario kann einem Broadcast an IoT Ger‰te entsprechen. One to One Dieses Szenario soll aufzeigen wie hoch die Kapazit‰t des MQTT Brokers bez¸glich vieler gleichzeitiger Verbindungen und vieler Nach- richten und damit verbundenem hohem Durchsatz ist. Dazu wird ein Eins-zu-Eins-Szenario simuliert, indem jeder MQTTPublisher an einen Topic mit einem GUIDsendet, welcher von jeweils einem MQTT Subscriber abonniert ist. Tabelle 4.2: MQTT Broker Durchsatz Dabei sollte darauf geachtet werden dass die Nachrichtengrˆﬂe dem erwartbaren Durch- schnitt entspricht.   Ein weiteres Problem das beim Betrieb eines MQTTBrokers auftauchen kann ist ein Ausfall der zugrundeliegenden Infrastruktur des Brokers. Dies kann zum Beispiel ein Inter- netausfall oder, bei einem Broker Cluster, der Ausfall des Load Balancers sein. Eine solche Eventualit‰t kann getestet werden, indem alle, oder groﬂe Teile, der MQTTClients die Verbindung schlieﬂen. Womˆglich werden diese Clients auch schon kurz darauf versuchen, sich wieder zu verbinden. Zus‰tzlich werden sogenannte ìLast Willî Nachrichten, welche bei Verbindungsverlust eines Clients gesendet werden, eine hohe Last erzeugen. Auch Auswirkungen auf den MQTTBroker sollten vor Inbetriebnahme gr¸ndlich untersucht werden.;0
ïVerbesserungen im Entwicklungsprozess Durch die Kompatibilit‰t und die Interoperabilit‰t zu bestehendem Code tr‰gt das Framework massiv zu einem verbesserten Entwicklungsprozess bei. Composables und Views kˆnnen miteinander arbeiten und sich gegenseitig aufrufen. Zudem funk- tionieren viele Bibliotheken, die urspr¸nglich f¸r das Android View System erstellt wurden, wie Room, ViewModel oder Kotlin Coroutinen in Compose auch weiterhin. Viele Anwendenden beginnen dabei nicht gleich mit reinem Compose, sondern setzen wie Cuvva auf eine Kombination aus Compose und klassischen View System Kompo- nenten. So wurde auch bei der Erstellung der Co?eeCompose App f¸r diese Arbeit mit beiden Komponenten gearbeitet. AuchderAndroidStudioSupportmitderPreviewFunktion?ndetlobendenZuspruch. Square lobt vor allem die Mˆglichkeit, mehrere Previews parallel und in mehrfacher Ausf¸hrungmitunterschiedlichenAppstatesoderKon?gurationenerstellenzukˆnnen. Dies f¸hre bei Ihnen zu einer groﬂen Zeitersparnis und somit dazu, dass sie ihren Code schneller an ihre Kunden ausliefern kˆnnen.;0
 Kapitel 2: Technische Grundlagen  Die Qualit‰t von Software ist ein facettenreiches Thema, das sowohl technische als auch ˆkonomische Aspekte umfasst. Im Zentrum dieser Diskussion stehen die produktorientierten Metriken, die genutzt werden, um die Eigenschaften und Leistungen von Software zu bewerten. Dieses Kapitel zielt darauf ab, die technischen Grundlagen dieses Themas zu erl‰utern und die verschiedenen produktorientierten Metriken im Kontext der Softwarequalit‰t und -entwicklung darzustellen.   2.1 Softwarequalit‰t: Ein Begriff mit vielen Dimensionen  Softwarequalit‰t bezieht sich auf die Gesamtheit der Eigenschaften und Merkmale einer Software, die deren F‰higkeit bestimmen, die festgelegten Anforderungen zu erf¸llen. Diese Eigenschaften kˆnnen in verschiedene Dimensionen klassifiziert werden: Funktionalit‰t, Zuverl‰ssigkeit, Benutzerfreundlichkeit, Effizienz, Wartbarkeit und ‹bertragbarkeit. Insbesondere produktorientierte Metriken bieten eine quantitative Grundlage zur Bewertung dieser qualitativen Eigenschaften, indem sie spezifische Indikatoren f¸r die Beschaffenheit des Softwareprodukts bereitstellen.   2.2 Produktorientierte Metriken: Typen und Funktionen  Produktorientierte Metriken klassifizieren sich in verschiedene Typen, die sowohl deskriptive als auch inh‰rente Metriken einschlieﬂen. Deskriptive Metriken quantifizieren offensichtlich erkennbare Merkmale der Software wie Codezeilen, Anzahl der Fehlerberichte oder Modulkopplung. Im Gegensatz dazu pr¸fen inh‰rente Metriken, die die strukturellen Aspekte der Software bewerten, Attribute wie Folgendes:  - Koh‰sion: Misst die Selbstgen¸gsamkeit eines Moduls in Bezug auf die Funktionalit‰t und stellt fest, wie eng verwandte Funktionen innerhalb des Moduls zusammengeschlossen sind.    - Kopplung: Bewertet die Abh‰ngigkeiten zwischen Modulen und ist entscheidend f¸r die Wartbarkeit und ƒnderungsfreundlichkeit des Codes.    - Cyclatische Komplexit‰t: Eine Metrik zur Beurteilung der Komplexit‰t eines Programmiersatzes, die auch Hinweise auf Testbarkeit und potenzielle Risiken gibt.   2.3 Technische Implementierung der Metriken  Die technische Umsetzung der produktorientierten Metriken erfolgt meist automatisiert, h‰ufig durch den Einsatz spezialisierter Software- und Analysetools. Diese Werkzeuge kˆnnen einen direkten Zugang zu den Quellcodes ermˆglichen und die relevanten Daten in Echtzeit analysieren. Dazu z‰hlen g‰ngige Programmierumgebungen und Integrationsstacks, die bei der Vereinheitlichung von Software-Reportings und der Visualisierung der Ergebnisse helfen.  Um ein fortlaufendes Qualit‰tsmanagement zu garantieren, ist es fundamental, die Metriken in den Softwareentwicklungsprozess zu integrieren. Dazu bietet es sich an, sogenannte Code Reviews, Continuous Integration (CI) Prozesse und testgetriebene Entwicklungsmethoden einzusetzen, um die Qualit‰t (inimetente Lˆsung ongoing bearbeiten Prozess) von der ersten Codezeile an zu fˆrdern.   2.4 Nutzen und Herausforderung der produktorientierten Metriken  Der Hauptvorteil produktorientierter Metriken liegt in ihrer F‰higkeit, objektive und messbare Bezugsgrˆﬂen zu bieten, die ein tieferes Verst‰ndnis f¸r die zugrunde liegenden Dys;1
 In-room Ortung zur Sturzerkennung mittels BluetoothEine      Die Demografisierung der Gesellschaft f¸hrt zu einer zunehmend ‰lter werdenden Bevˆlkerung. In diesem Kontext gewinnt die Sturzpr‰vention einen erheblichen Stellenwert, da St¸rze zu den h‰ufigsten Verletzungen bei Senioren z‰hlen und oft dramatische Folgen haben. Die technischen Mˆglichkeiten zur Sturzerkennung haben in den letzten Jahren erheblich zugenommen. Insbesondere die Verwendung von In-room Ortungstechnologien bietet eine vielversprechende Perspektive im Bereich der Sturz¸berwachung. Dieser wissenschaftliche Prosatext evaluiert ein Projekt, das auf der Anwendung von Bluetooth-Technologie zur Sturzerkennung innerhalb von geschlossenen R‰umen basiert.   Projekthintergrund Das Projekt wurde mit der Absicht ins Leben gerufen, eine kosteneffiziente und pr‰zise Lˆsung zur Sturzerkennung zu bieten. Die Nutzung von Bluetooth-Technologie ermˆglicht die pr‰zise Lokalisierung von Individuen innerhalb fest definierter R‰ume, beispielsweise Altenheimen oder barrierefreien Wohnanlagen. Mittels kosteng¸nstiger Bluetooth Low Energy (BLE) Beacons wird der Aufenthaltsort der Benutzer in Echtzeit erfasst und analysiert. Dabei ist der Gedanke, dass sowohl physische Aktivit‰ten als auch St¸rze durch spezifische Bewegungsmuster identifiziert werden kˆnnen.   Methodik Zur  wurde ein hybrides Forschungsdesign gew‰hlt, das qualitative und quantitative Ans‰tze integriert. In einer Pilotstudie wurden Teilnehmer ¸ber einen Zeitraum von sechs Monaten beobachtet, w‰hrend sie in einer kontrollierten Umgebung mit platzieren Beacon-Tracks interagierten. Die Sturzerkennungsalgorithmen wurden mittels maschinellen Lernens entwickelt und trainiert, um falsche Entwarnungen zu minimieren und pr‰zise Erkennungsgrˆﬂen bereitzustellen.   Ergebnisse Die Auswertung der gesammelten Daten zeigte, dass die Implementierung des Bluetooth-basierten Systems die Erkennung von St¸rzen signifikant verbesserten kˆnnte. Von den beobachteten St¸rzen wurden ¸ber 85% erfolgreich erkannt und an das Pflegepersonal weitergeleitet. Des Weiteren ergaben statistische Analysen, dass benutzergenerierte Daten - wie Standortunregelm‰ﬂigkeiten und Bewegungsgeschwindigkeit - korrelierende Merkmale mit einstehenden Gefahren darstellen.   Herausforderungen Jedoch stellte sich im Verlauf des Projekts auch eine Vielzahl von Herausforderungen dar. Dazu gehˆrten technische Aspekte, wie beispielsweise die Reichweitenbegrenzung und Signalabschirmung innerhalb von Geb‰uden, die?ankenituation w‰hrend mathematical Fehler in den Algorithmen. Auch die Benutzerakzeptanz war ein zentral Punkt, der durch R¸ckmeldungen der Teilnehmer speziell in Hinblick auf ihre Wahrnehmung der Privatsph‰re und der heimkomplexen Berechnungen eine substanzielle Rolle spielte.   Diskussion Trotz dieser Herausforderungen hat sich die Zielsetzung des Projekts als durchwegs positiv herausgestellt. Die MQTT-basierte Erhebung von Bewegungsdaten und deren Analyse erˆffnete nicht nur neue Perspektiven in der Sturzerkennung, sondern auch in der Entwicklung proaktiver Interventionen zur Sturzvermeidung. Indepandierende Monetarisierungsans‰tze und Lizenzalternativen kˆnnten umgesetzt werden, um die erkannten Hindernisse;1
"Eine Implementierung eigener Lˆsungen  Die App-Entwicklung hat sich in den letzten Jahren rasant weiterentwickelt, wobei Frameworks eine zentrale Rolle in der Effizienz und Benutzerfreundlichkeit spielen. Jetpack Compose, ein modernes Toolkit zur Erstellung von Benutzeroberfl‰chen f¸r Android-Anwendungen, hat sich als ein bahnbrechendes Werkzeug etabliert. Es bietet Entwicklern die Mˆglichkeit, deklarative UI-Komponenten zu erstellen, die sich nahtlos in die bestehende Android-Architektur integrieren lassen. Im Folgenden wird die  unter Verwendung des Jetpack Compose Frameworks untersucht, wobei der Fokus auf der praktischen Anwendung und den Vorteilen dieser Technologie liegt.   Grundlagen von Jetpack Compose  Jetpack Compose basiert auf einem deklarativen Ansatz, der es Entwicklern ermˆglicht, Benutzeroberfl‰chen durch die Beschreibung ihrer Komponenten zu erstellen, anstatt sie imperativ zu konstruieren. Dies f¸hrt zu einem klareren und wartbareren Code. Die Grundbausteine von Jetpack Compose sind sogenannte Composables, die in Kotlin geschrieben sind. Diese Composables kˆnnen in einer hierarchischen Struktur organisiert werden, wodurch komplexe Benutzeroberfl‰chen einfach zu erstellen und zu verwalten sind.     Um die Mˆglichkeiten von Jetpack Compose zu demonstrieren, betrachten wir die Entwicklung einer einfachen To-Do-Liste. Diese Anwendung soll es den Benutzern ermˆglichen, Aufgaben hinzuzuf¸gen, abzuhaken und zu lˆschen. Der folgende Abschnitt beschreibt die Schritte zur Implementierung dieser Lˆsung.   1. Einrichtung des Projekts  Zun‰chst muss ein neues Android-Projekt mit Jetpack Compose konfiguriert werden. Dies geschieht in Android Studio, indem das entsprechende Template ausgew‰hlt und die notwendigen Abh‰ngigkeiten in der `build.gradle`-Datei hinzugef¸gt werden ```groovy dependencies {     implementation ""androidx.compose.ui:ui:1.0.0""     implementation ""androidx.compose.material:material:1.0.0""     implementation ""androidx.compose.ui:ui-tooling-preview:1.0.0""     implementation ""androidx.lifecycle:lifecycle-runtime-ktx:2.3.1""     implementation ""androidx.activity:activity-compose:1.3.1"" } ```   2. Erstellung der Benutzeroberfl‰che  Die Benutzeroberfl‰che wird durch die Definition von Composables realisiert. F¸r unsere To-Do-Liste benˆtigen wir Composables f¸r die Eingabe von Aufgaben, die Anzeige der Aufgabenliste sowie die Interaktion mit den Aufgaben. Die folgende Implementierung zeigt, wie diese Composables strukturiert werden kˆnnen ```kotlin @Composable fun TodoApp() {     var task by remember { mutableStateOf("""") }     val tasks = remember { mutableStateListOf<String>() }      Column(modifier = Modifier.padding(16.dp)) {         TextField(             value = task,             onValueChange = { task = it },             label = { Text(""Neue Aufgabe"") }         )         Button(onClick = {             if (task.isNotBlank()) {                 tasks.add(task)                 task = """"             }         }) {             Text(""Hinzuf¸gen"")         }         LazyColumn {             items(tasks) { task ->                 Text";1
Realisierung eines IoT-Systems zur Steuerung einer Katzenklappe mittels KI-basierter Katzenerkennung    Die Integration von Internet of Things (IoT)-Technologien in den Alltag erˆffnet neue Mˆglichkeiten zur Automatisierung und Optimierung von Haushaltsger‰ten. Im Kontext der Haustierhaltung gewinnt die Entwicklung intelligenter Lˆsungen zur Tier¸berwachung und -steuerung zunehmend an Bedeutung. Dieser Text beschreibt ein Konzept zur Realisierung eines IoT-Systems, das eine Katzenklappe mittels KI-basierter Katzenerkennung steuert. Ziel ist es, eine benutzerfreundliche, sichere und effiziente Lˆsung zu schaffen, die Haustierbesitzern eine einfache Kontrolle ¸ber den Zugang ihrer Katzen ermˆglicht.  Konzeptentwicklung  Die Realisierung des IoT-Systems gliedert sich in mehrere Schl¸sselkomponentenHardware-Design, Software-Architektur, KI-Trainingsprozess und Benutzeroberfl‰che. Jede dieser Komponenten spielt eine entscheidende Rolle bei der Funktionalit‰t und Benutzererfahrung des Systems.  1. Hardware-Design  Das Hardware-Design umfasst die Auswahl geeigneter Sensoren und Aktoren zur Steuerung der Katzenklappe. Die Katzenklappe selbst wird mit einem motorisierten Mechanismus ausgestattet, der durch ein Mikrocontroller-Modul (z.B. Raspberry Pi oder Arduino) angesteuert wird. Zur Katzenerkennung wird eine Kamera installiert, die in der Lage ist, Bilder in Echtzeit zu erfassen. Zus‰tzlich sind Umgebungslichtsensoren und gegebenenfalls RFID-Technologie vorgesehen, um die Klappe nur f¸r autorisierte Katzen zu ˆffnen.   2. Software-Architektur  Die Software-Architektur des Systems besteht aus mehreren Schichten  - DatenakquiseDie Kamera erfasst kontinuierlich Bilder, die an ein KI-Modell zur Katzenerkennung ¸bermittelt werden. - DatenverarbeitungEin vorab trainiertes KI-Modell, basierend auf Convolutional Neural Networks (CNNs), wird zur Identifikation der Katze eingesetzt. Das Modell wird mit einer Vielzahl von Bildern unterschiedlicher Katzenrassen und -grˆﬂen trainiert, um eine hohe Erkennungsgenauigkeit zu gew‰hrleisten. - SteuerungslogikBei erfolgreicher Erkennung sendet das System ein Signal an den Motor der Katzenklappe, um diese zu ˆffnen oder zu schlieﬂen. Hierbei wird auch eine Zeitverzˆgerung implementiert, um sicherzustellen, dass die Klappe nicht unnˆtig lange offen bleibt.  3. KI-Trainingsprozess  Der Trainingsprozess des KI-Modells ist entscheidend f¸r die Genauigkeit der Katzenerkennung. Eine groﬂe Datenbasis ist erforderlich, um das Modell robust zu machen. Hierzu werden Bilder von Katzen in unterschiedlichen Posen, Lichtverh‰ltnissen und Hintergr¸nden gesammelt. Der Trainingsprozess erfolgt in mehreren Phasen - DatensammlungErstellung eines Datensatzes mit annotierten Bildern. - ModelltrainingVerwendung von Transfer Learning, um ein vortrainiertes Modell (z.B. MobileNet oder ResNet) an die spezifischen Anforderungen der Katzenerkennung anzupassen. - EvaluierungTesten des Modells mit einem separaten Validierungsdatensatz, um die Erkennungsgenauigkeit zu bestimmen und gegebenenfalls Anpassungen vorzunehmen.  4. Benutzeroberfl‰che;1
 Kapitel 2: Technische Grundlagen der Evaluation von ElixirNerves als Plattform f¸r IoT-Anwendungen   2.1 Einf¸hrung in IoT-Anwendungen  Das Internet der Dinge (IoT) bezeichnet ein Netzwerk von physischen Objekten, die durch Sensoren, Software und andere Technologien miteinander verbunden sind und Daten austauschen kˆnnen. Diese Objekte ñ von Smart-Home-Ger‰ten bis hin zu industriellen Maschinen ñ bringen zahlreiche Herausforderungen mit sich, sowohl hinsichtlich der Hardware als auch der Software. Eine effektive Plattform f¸r die Entwicklung und Implementierung von IoT-Anwendungen muss skalierbar, leicht anpassbar und robust sein.   2.2 ‹berblick ¸ber Elixir und Nerves  Elixir ist eine funktionale Programmiersprache, die auf der Erlang virtuellen Maschine (BEAM) basiert. Sie bietet leistungsstarke Eigenschaften wie Nebenl‰ufigkeit, Verteilung und Fehlertoleranz. Diese Merkmale machen Elixir besonders geeignet f¸r die Entwicklung von Anwendungen, die hohe Anforderungen an die Verf¸gbarkeit und Leistung stellen.  Nerves ist ein Framework f¸r die Entwicklung von IoT-Anwendungen mit Elixir. Es ermˆglicht Entwicklern, robustes Embedded-Software zu schreiben, das auf einer Vielzahl von Hardwareplattformen ausgef¸hrt werden kann. Nerves kombiniert die Vorteile von Elixir mit speziellen Funktionen f¸r das IoT, wie z. B. die Unterst¸tzung f¸r verschiedene Hardware-Abstraktionen, ein umfassendes Build-System und die Mˆglichkeit zur Remote-Updates.   2.3 Technische Architektur von ElixirNerves  Die Architektur von ElixirNerves kann in mehrere Schichten unterteilt werden:   2.3.1 Hardware-Abstraktion  Nerves bietet eine abstrahierte Schicht, die die Interaktion mit verschiedenen Hardwarekomponenten erleichtert. Diese Schicht ermˆglicht es Entwicklern, direkt mit GPIO-Pins, I2C, SPI und anderen Protokollen zu kommunizieren, ohne sich um die spezifischen Details der zugrunde liegenden Hardware k¸mmern zu m¸ssen. Dies fˆrdert die Wiederverwendbarkeit von Code und vereinfacht die Entwicklung von plattform¸bergreifenden IoT-Anwendungen.   2.3.2 System-Building  Das Nerves-System verwendet einen Toolchain-Ansatz, bei dem das gesamte System in einem Docker-Container gebaut wird. Dies stellt sicher, dass die Anwendung in einer konsistenten Umgebung erstellt und getestet wird. Nerves verwendet den Nerves-Distributor und Nerves-Firmware, um die Firmware-Updates und das Bereitstellen von Anwendungen zu verwalten. Dies erleichtert das Warten und Aktualisieren der Ger‰te nach der Bereitstellung.   2.3.3 Anwendungsentwicklung  Die Entwicklung von Anwendungen in Nerves erfolgt in der Elixir-Sprache, die es den Entwicklern ermˆglicht, von den funktionalen Programmierkonzepten und den leistungsstarken Funktionen von Elixir zu profitieren. Durch den Einsatz von Supervisoren, Protokollen und GenServern kˆnnen komplexe Logik und Zustandsmanagement effektiv umgesetzt werden.   2.4 Sicherheitsaspekte  Die Sicherheit von IoT-Anwendungen ist von entscheidender Bedeutung, da diese Systeme h‰ufig sensible Daten verarbeiten und anf‰llig f¸r Angriffe sind. ElixirNerves bietet verschiedene Sicherheitsmechanismen, darunter:  - Kryptographie: Nerves unterst¸tzt g‰ngige Kryptographie-Bibliotheken, die sicherstellen, dass Daten sowohl im Ruhezustand als auch w‰hrend der ‹bertragung gesch¸tzt sind.    - Authentifizierung und Autorisierung: Entwickler kˆnnen Authentifizierungs- und Autorisierungsmechanismen implementieren, um sicherzustellen, dass nur berechtigte Benutzer und Ger‰te auf die IoT-Anwendungen zugreifen kˆnnen.  - Regelm‰ﬂige Firmware-Updates: Durch die Mˆglichkeit zur Bereitstellung von Updates kˆnnen Sicherheitsanf‰lligkeiten schnell behoben werden.   2.5 Evaluation und Testverfahren  Die Evaluation von ElixirNerves als Plattform f¸r IoT-Anwendungen erfordert eine sorgf‰ltige Betrachtung verschiedener Faktoren, darunter:  - Zuverl‰ssigkeit: Tests zur Bestimmung der Fehlertoleranz und Systemstabilit‰t unter verschiedenen Bedingungen. - Leistung: Messungen der Latenz und der Reaktionszeiten von Anwendungen unter realistischen Arbeitslasten. - Benutzererfahrung: Evaluierung der Benutzeroberfl‰che und Interaktionen, insbesondere f¸r Anwendungsf‰lle wie Smart-Home oder industrielle Automatisierung.   2.6 Fazit  Die technischen Grundlagen von ElixirNerves bieten eine solide Basis f¸r die Entwicklung und Implementierung von IoT-Anwendungen. Die Kombination aus Elixirs leistungsf‰higen Funktionen und Nervesë spezifischen Zielsetzungen macht es zu einer vielversprechenden Plattform f¸r Entwickler, die innovative IoT-Lˆsungen realisieren mˆchten. Die folgende Kapitel werden sich mit spezifischen Anwendungsszenarien und den praktischen Erfahrungen bei der Nutzung von ElixirNerves in der Entwicklung von IoT-Anwendungen besch‰ftigen.;1
Die Wahl einer Programmiersprache ist entscheidend f¸r den Erfolg eines Softwareprojekts. In den letzten Jahren haben sich Java und Kotlin als prominente Optionen f¸r die Entwicklung von Anwendungen auf der Java Virtual Machine (JVM) etabliert. Die vorliegende Analyse fokussiert sich auf die Evaluierung dieser beiden Sprachen unter Ber¸cksichtigung relevanter Faktoren, die Einfluss auf die Projektentwicklung haben.  Hintergrund  Java, eine der ‰ltesten und am weitesten verbreiteten Programmiersprachen, wurde 1995 eingef¸hrt und ist f¸r ihre Plattformunabh‰ngigkeit sowie ihre weitreichende Community und umfangreiche Bibliotheken bekannt. Kotlin, eine 2011 eingef¸hrte Sprache, die 2017 von Google als offizielle Sprache f¸r Android-Entwicklung anerkannt wurde, bietet eine moderne Syntax und zahlreiche Funktionen, die die Programmierung effizienter und weniger fehleranf‰llig gestalten.  Evaluationskriterien  Bei der Evaluierung von Java und Kotlin im Kontext eines Softwareprojekts sind mehrere Kriterien maﬂgeblich, darunter Lesbarkeit, Wartbarkeit, Performance, Interoperabilit‰t, Community-Support, Lernkurve und API-Integration.  1. Lesbarkeit und WartbarkeitKotlin bietet eine klarere und pr‰gnantere Syntax im Vergleich zu Java. Sprachfeatures wie Null-Sicherheit, Lambda-Ausdr¸cke und Extension Functions fˆrdern eine reduzierte Komplexit‰t und steigern die Lesbarkeit des Codes. In einem praktischen Projektkontext bedeutet dies, dass Entwickler schneller lesen und verstehen kˆnnen, was zu einer verbesserten Wartbarkeit f¸hrt.  2. PerformanceBeide Sprachen bieten ‰hnliche Leistungseigenschaften, da sie auf der JVM laufen. Allerdings kann die syntaktische Effizienz von Kotlin zu einer geringeren Codezeilenanzahl f¸hren, was potenziell die Compile-Zeit verk¸rzt. Dennoch bedarf es einer spezifischen Analyse, um performante Aspekte bei komplexen Anwendungen zu bewerten.  3. Interoperabilit‰tEin entscheidender Vorteil von Kotlin ist die nahtlose Interoperabilit‰t mit Java. Dies ermˆglicht es, bestehende Java-Bibliotheken und -Frameworks ohne nennenswerte Modifikationen zu nutzen, was besonders in migrationsorientierten Projekten von Bedeutung ist. Die F‰higkeit, gemischte Projekte zu erstellen, ermˆglicht es Teams, schrittweise von Java zu Kotlin ¸berzugehen.  4. Community-Support und LernkurveJava hat eine seit Jahrzehnten etablierte Community, umfangreiche Dokumentation und eine Vielzahl von Ressourcen f¸r Entwickler. Kotlin ist relativ neu, hat aber schnell an Popularit‰t gewonnen und bietet ebenfalls umfangreiche Ressourcen. F¸r Entwickler, die bereits mit Java vertraut sind, kann die Lernkurve zu Kotlin jedoch als moderat eingesch‰tzt werden, da viele Konzepte in beiden Sprachen ‰hnlich sind.  5. API-IntegrationDie Kompatibilit‰t mit modernen API-Designs und -Strukturen spielt eine wesentliche Rolle. Kotlin unterst¸tzt beispielsweise die funktionale Programmierung und ermˆglicht die einfache Implementierung von APIs, was viele moderne Entwicklungsparadigmen unterst¸tzt. Dies ist ein wesentlicher Vorteil f¸r Projekte, die Schnittstellen zur Integration mit anderen Systemen benˆtigen.  Fazit  Die Evaluierung von Java und Kotlin zeigt, dass beide Sprachen ihre spezifischen St‰rken und Schw‰chen aufweisen. Die Entscheidung f¸r eine der beiden Sprachen sollte kontextabh‰ngig erfolgen, wobei Faktoren wie Projektanforderungen, Teamkompetenz und langfristige Wartbarkeit ber¸cksichtigt werden sollten. W‰hrend Java nach wie vor eine solide Grundlage f¸r viele Projekte darstellt, bietet Kotlin durch moderne Sprachfeatures und eine bessere Lesbarkeit klare Vorteile, insbesondere in der Entwicklung von neuen Anwendungen.  In der Praxis kˆnnte die synergistische Nutzung beider Sprachen in einem Projekt als optimaler Kompromiss angesehen werden, um die Vorz¸ge beider Welten zu vereinen.;1
"   Das studentische Software Engineering ist ein komplexer Prozess, der nicht nur technisches Wissen, sondern auch effektives Projektmanagement erfordert. H‰ufig stehen Studierende vor der Herausforderung, verschiedene Aufgaben zu koordinieren, Fristen einzuhalten und die Zusammenarbeit im Team effizient zu gestalten. In diesem Kontext ist die Entwicklung eines geeigneten Aufgabenmanagement-Tools von zentraler Bedeutung. Die vorliegende Anforderungsanalyse zielt darauf ab, die wesentlichen Funktionen und Eigenschaften eines solchen Tools zu identifizieren, um die studentische Projektarbeit zu optimieren.   Methodik der Anforderungsanalyse  Die Anforderungsanalyse wurde durch qualitative Interviews mit Studierenden verschiedener Studieng‰nge, die Software Engineering in ihrem Curriculum integriert haben, sowie durch die Auswertung bestehender Literatur und Best Practices im Bereich Projektmanagement durchgef¸hrt. Hierbei wurden spezifische Bed¸rfnisse und Herausforderungen der Studierenden erfasst. Zudem wurde eine Analyse bereits vorhandener Tools durchgef¸hrt, um St‰rken und Schw‰chen im bestehenden Angebot zu identifizieren.   Identifizierte Anforderungen  Die Ergebnisse der Anforderungsanalyse f¸hrten zu einer Kategorisierung der Anforderungen in funktionale und nicht-funktionale Aspekte 1. Funktionale Anforderungen   - AufgabenverwaltungBenutzer sollen in der Lage sein, Aufgaben zu erstellen, zu kategorisieren, zu priorisieren und Deadlines festzulegen.    - Team-ZusammenarbeitDas Tool sollte Funktionen zur Unterst¸tzung der Teamkommunikation bieten, wie z.B. Kommentare zu Aufgaben, Dateianh‰nge und Benachrichtigungen.    - FortschrittsverfolgungEine Ansicht, die den aktuellen Fortschritt der einzelnen Aufgaben und des gesamten Projektes visualisiert (z.B. durch Kanban-Boards oder Gantt-Diagramme), wird als essenziell erachtet.    - IntegrationsmˆglichkeitenDas Tool sollte sich in bestehende Entwicklungsumgebungen oder Plattformen wie GitHub oder Jira integrieren lassen, um einen reibungslosen Workflow zu gew‰hrleisten.  2. Nicht-funktionale Anforderungen   - BenutzerfreundlichkeitDie Oberfl‰che sollte intuitiv und einfach zu bedienen sein, um Lernkurven zu minimieren und die Akzeptanz zu fˆrdern.    - Zug‰nglichkeitDas Tool sollte plattform¸bergreifend und auf mobilen Ger‰ten nutzbar sein, um die Flexibilit‰t zu erhˆhen.    - Sicherheit und DatenschutzBei der Kommunikation und Speicherung von Daten m¸ssen Sicherheitsstandards eingehalten werden, um die Nutzerdaten zu sch¸tzen.     Die durchgef¸hrte Anforderungsanalyse hat deutlich gemacht, dass ein maﬂgeschneidertes Aufgabenmanagement-Tool f¸r das studentische Software Engineering zwingend notwendig ist, um den spezifischen Bed¸rfnissen dieser Zielgruppe gerecht zu werden. Die identifizierten funktionalen und nicht-funktionalen Anforderungen bilden die Grundlage f¸r die Entwicklung eines effektiven Tools, das nicht nur die Effizienz der Projektarbeit steigert, sondern auch die Teamdynamik verbessert und die Lernkurve der Studierenden positiv beeinflusst.  Das Projekt verdeutlicht, dass technische Lˆsungen im Bereich des Aufgabenmanagements nicht isoliert betrachtet werden d¸rfen; sie m¸ssen stets in den Kontext der Benutzerbed¸rfnisse und der spezifischen Herausforderungen im studentischen Umfeld integriert werden. Die erfolgreiche Implementierung eines solchen Tools kˆnnte langfristig zu einer Steigerung der Qualit‰t studentischer Projekte und einem verbesserten Lernerlebnis f¸hren. Die n‰chsten Schritte sollten die prototypische Entwicklung und eine umfangreiche Testphase beinhalten, um die Praxistauglichkeit des Tools zu evaluieren und gegebenenfalls anzupassen.";1
